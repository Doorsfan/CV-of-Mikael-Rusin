paragdim; Olika sätt att hantera data.

imperativ paragdim; Algoritmisk, använder kombination av Algoritmer att modifiera datan och pekar till minnespunkter i datan // While loop with addition based on Declared variables
Procedual paragdim; Creates a Proceduer of interacting with the data (A function to manipulate the data) // while loop in a function that you just add a Value to

Declarative Paragdim; 2 olika subklasser; 
Functional paragdim; Performs a mathematical function on the data put in , returns a immutable value (New value can be derived from new Function call) //for example, recursive math function on Data
Logic Paragdim; You feed the Function a problem to have it solve it for you. (Like finding peoples nationalities in a Register, etc) //Like searching a Registrer or a Database

Object-oriented paragdim; Object Oriented Programming structure //Functioncalls to Class based structures and manipulating data there of

Errors; Compile-Time Error //Syntax Errors//, Runtime Error //Runtime Errors, occurs at actual Runtime//, Logic Error //Bug in Functionality//

Abstraction //Abstract the problem to make it fesible to apply to General Situations//;
//Can use basic proceduers, or can use Abstract Formulas to increase performance/hide interactivity//

//Can have Placeholder names to fill in later on in the program, regardless of original origin of Data//

Data Abstraction; //You make an abstract medium between the User and the program to interact with the data without modifying the actual code//

//Data abstraction also involves Privacy or Access levels of said data, if you wish to make it purely abstract, you do not show the Data in it's pure form//
//An easy way to do this, is to have private Constructors and variables for your Class functions//

//In Java, Arrays have a Defined length and must be refered to by their indexes to manipulate the data of the Specific storage point//
//Having an abstraction that allows for userdefined datatypes, allows you to modify values and assign values by Class functions, without changing Code//

Encapsulation; //A class is a Bundling of data/Methods, a package is bundle of Classes (Each package contains a unique set of Classes)//
//A bundle of classes can be gathered into a Compilation unit, which can be compiled seperately from other Compilation units/by itself//

Inheritance; //Allows you to Further Specialize an Object by inheriting base-line features and modifying them for that specific Sub-type alone//

Polymorphism; //Creating Generic types of code that can apply to different (ideally) all types.//

Ad hoc Polymorphism (a.k.a Apparent polymorphism) // The type must be known and the amount of types usable with said code is finite//

Universal Polymorphism //The type can be unknown to begin with, but still usable with the Code//
^^^^^^ 2 Sub Classes; parametric Polymorphism and inclusion Polymorphism

Overloading a Method; //When a Function name Overloaded it is Shared with another Function in a Class ; Note: Does not include Function Definitions - Must have different number and/or type of parameters//

Overloading a Operator; //Allows an operator to do different operations, based on context. Such as Concatenating STR's, or addition etc.//

Coercion Polymorphism; // Ad hoc Polymorphism, when a type is converted by implicit method (i.e, not Explicitly declared) //

Inclusion Polymorphism; // By virtue of Sharing type with the Parent class, a function that is Inclusive Poylmorphism, works by virtue of inheriting Type//
//Let's you write Abstract parameters that can be passed on, with virtue of inherited type, such as a wide array of Subtype Object Classes, that all work with the function, because they are all inheriting from Object class//

Parametric Polymorphism; // Can use completely abstract parameters, by defining type upon need of calling the function parameter//
// In Java, Lists are instansicated with defined types, that defines what types the List holds. //
//Lists is a form of a Interface, that allows further implications other than an Array. Lists are also Ordered//
//Functons for Lists include ; iteration in bipedal directions, replacement of specific interger indexes and Searching in said List, etc//

//4 pillar of Object-oriented Paragdim ; Abstraction, Encapsulation, inheritance and Polymorphism.//

Packages in Java, can be imported much like Modules in Python. Importing also exists in java.

//packages import from defined Directories, which are defined in the package import command//

//Every project in Java, should be defined to part of a package, typically reversed of your company name, example; Google.com would be package com.Google;//

Importing; //To use a explicit class from a package, we simply type the whole import path ; import com.jdojo.intro.Account; for example//
//If We wish to use ALL of the associated classes, from a package, we must end with a *, import com.jdojo.util.*;//

//You must specify one package name, when you are importing ; using an abstract important name such as com.*.*; IS INVALID//

Commenting; // The 2 //'s is what defines when a Comment is enclosed. A comment needs not be enclosing //'s if it's on several lines, but on singular, it does//

Example;

// This is a Single line comment//

//This
//is
//a
//Multi Line
//Comment

Class declaration; //There are 3 types of Class declarations//
#1 // 
class
<name> {}
//

#2 //
class
        <name> {

}
//

#3 //
class <name>{
}
//

//There are 4 parts to a Class;
Field declerations
Initializers; Static and instance initalizers
Constructors
method declarations
//

Method structure;
<<MethodReturnType>> <<MethodName>> (<<arguments>>) {
        //Body of the method goes here
}

Declaring an Array; // int[] num, is a int Array that is called num//

Classes; Classes must have a Main function, as in, // void main(String[] name) {
}
// For example. Void implies the type it returns (void is Null, None, etc.), main is that it's the main function, and in the ()'s, there are the arguments.

Saving Java Files // If you save a Class that is declared Public, the file name must be formed as ; <Class name>.java//
//If a class is not public, the source can be saved as anything//

Simple name and Fully qualified name;
//A Simple name is the name of the class, regardless. If a Class belongs to no package, it's Simple name is the same as it's fully qualified Name.//
//The Fully qualified name, of the class, is it's package directory path + the name Class. As stated above, if it belongs to no package, it's simply the Class name.//

Compiling;
//Java compiles every class in a Seperate class File//

Running Java programs;
//You can run Java programs by either having it compiled into a Java file, or run it by using the Command prompt//
//Java runs your class from the directory of which you have defined the Class path in > Control panel > System > advanced tab > Environmental variables//

//You can also run a Java program from within, by using the -cp/-classpath option in coding, accompanied by a full path declaration.//
//Keep in mind, you go to Directory with a normal path declaration, then you followed with the full qualified Package name//

//Tutorial Covers Netbeans IDE, Java//

Identifiers (Variables);
//CAN: start with a letter, use a-z or A-Z, use 0-9, start with underscore or a $, at least 1 of length, letters and underscores//
//CANNOT: start with a number, have a space, have a + sign, have a hypen or - sign (hypen is -)//

Keywords;
//Identifiers cannot be Keywords, they are reserved words. An identifier can't be named Null, False, True either.
Keywords in Java, are;
abstract
assert
boolean
break
byte
case
catch
char
class
const
continue
default
do
double
else
enum
extends
final
finally
float
for
goto
if
implements
import
instanceof
int
interface
long
native
new
package
private
protected
public
return
short
static
strictfp
super
switch
synchronized
this
throw
throws
transient
try
void
volatile
while
//

Variable;
//A variable has 3 components; Memory location, type of data and name//
//A null varibale, points to no point in the Memory, and takes no space

Types of Data;
//Primitive and Reference Data type//
//There are 8 primitive types ; Booleans and Numbers.//

//The hierarchy is as follows ; 
        Primitive Data Type
    v---------        ---------v
  boolean                   Numeric type
                               v
                               v
                               v
                        v------ ------v
                    Integral              v
                       v             Floating-Point type
                       v             v                  v
                       v             v                  v
                       v             Float             Double
                       v
              v------v----v----v----v
             Byte   short int  long char


//Thus the 8 types of primitive Data, are ; Boolean, byte, short, int, long, char, float, double//


Int Type;
//The Int type is a 32 bit data type. It takes 32 bits of memory to store.//
//Integrals can be expressed in ; decimal number, octal number, hexadecimal, Binary number//

//if a integral starts with a 0, it's considered a Octal. (Example: 021 is 17 in Octal)//

//Hexadecimal starts with an 0x or 0X, followed by the up to 15 format.//

//Binary starts with 0b or 0B.//

//The int type has a range of -2^31 to 2^31-1.//

Long Type;
//When an int is supported by an l or a L, it's a long type.//
//Has a range of -2^63 to 2^63-1

//The conversion between Long to Int, is not allowed. Though, a int may be converted to Long.//

Byte type;
//A byte is a integer between -128 and 127.//
//Uses 8 bit of Memory allocation//

//Used when there is a lot of small numbers pending//

//To declare a byte, you must declare it by ; byte <variable name> = <int <= 127> or <variable name> = (byte)<integer variable <= 127>//

Short Type;
//a 16 bit type of Data, it has a number range of 2^-15 to 2^15-1//

//A Byte can always be assigned to a Short, the rest requires explicit type casting//

Char type;
//A char type is a 16 bit type of Data, can never be negative//
//Has a range of 0 to 65535//
//A char is defined by being 1 length, a character, and encapsulated by 's, instead of "'s, which creates a String.//

//A char, can also be expressed as a Character Escape Sequence.//
#1; '\n' A linefeed
#2; '\r' A carriage return
#3; '\f' A form feed
#4; '\b' A backspace
#5; '\t' A tab
#6; '\\' A backslash
#7; '\"' A doublequote
#8; '\'' A single quote

Booleans;
//stored in one Byte//

Float point data types;
//There are two Floating point data types//
//Float and double//
//using floating point representations is slower, and less accurate. But, can handle a larger range, with the same memory allocation as a fixed number//

//A float point, is a 32 bit data type. It is known as a Single precision floating point.//
//The range of a float point is 1.4 x 10^-14 and 3.4 x 10^38, it can be positive or negative.//

//All real numbers that end with f or F, are called Float Literals. It can be expressed two formats;
Decimal number format
Scientific notation
//

//Float points are defined to be representatives of 3 states, a positive infinity, a NaN (not a number) and a negative infinity.//
//In scientific notation, the power of the number, i.e the ^X, X is represented by a XF, where X can be -, +, no notation, small letter or large letter.//
//The X can be a range from 0, up until the point of the Power represented.//

//Floating points are inheritly not accurate.//

Double data Format
//Double Data is a far greater range of Floating point numbers. It spans from 4.9 x 10^-324 to 1.7 x 10^308//
//A Double does not need a notification of d or D. It is optional//

//All other interger types, can be converted to Double, without explicit cast.//

Underscore in Intergrals;
//You are allowed to put Underscore inside of a Integral definition, be that Binary, hexadecimal or Octal.//

Converting to Binary;
//You can convert to binary, by using the following Formula;

ORIGINAL NUMBER/2 = RESULT. If there is a remainder (i.e, it's not even Division), it is a 1, otherwise it's a 0.

RESULT/2 = RESULT. Rinse and repeat, until you have reached that result is 1 and that you have divided it.

EXAMPLE;

32/2 = 16, remainder = 0
16/2 = 8, remainder = 0
8/2 = 4, remainder = 0
4/2 = 2, remainder = 0
2/2 = 1, remainder = 0
1/2 = 0, remainder = 1

INVERT THE LINE-UP ; You get 100000, which is 32 in binary.

//Since a Binary number is stored in a 8 byte number, it adds 4 0's to the front, regardless of if it reached that height or not, due to 8 bit format.//
//The minus representation of a Binary number, is every bit flipped, + 1//

//The Bit to the most left, of a binary number, denotes where it is a positive (0) or a negative (1)//

Rounding;

//There are four ways to round. Towards 0, towards nearest, towards positive infinity, towards negative infinity.//

//In terms of floating Rounding, you have a 2 point precision (unclear if there is higher), where it rounds for thoose in mind, with the specific Rounding in mind.//

//TOWARDS ZERO ; It will round towards 0.

//TOWARDS POSITIVE INFINITY ; It will attempt to round to the highest positive infinite, i.e, 1.01249 for instance, becomes 10.00//

//TOWARDS NEGATIVE INFINITY ; It will attempt to round to the highest negative infinite, i.e, 1.01249 for instance, becomes 1.00//

//TOWARDS NEAREST ; It will attempt to round to the nearest. In case of a tie, it will round to the Even number.//

Exceptions regarding Floating Points;

INVALID OPERATIONS;
//Division by Zero
//Square root of a negative number
//Dividing Zero by Zero, or infinity by infinity
//Multiplication of zero and infinity
//Any operation of a singaling NaN
//Subtracting infinity from infinity
//When a NaN is compared to a > or a <

OVERFLOW EXCEPTION;
//If the number you are trying to assign to a format is too large for that Format.//

UNDERFLOW EXCEPTION;
//If the number you are trying to assign to a format, is too small for that format.//

INEXCACT EXCEPTION;
//When a Floating number is divided by a floating number larger than itself, or the process is inexact.//

OPERATORS;
//There are a number of Operators and they way they interact is different.//
//There is the usual ones, +, -, unary +(signifying +), unary -(signifying -), *, /, %//

//There is the Non-common ones; ++ (increment), -- (decrement)//

//There is compound ones; +=, -=, /=, %=, *=//

+ OPERATOR;
//If one is double, both become double.//
//If one is float, both become floats.//
//If one is long, both become long.//
//If none of the above hold true, all get converted to Int if not already int.//

//Int cannot be converted implicitly to Byte, it has to be done explicitly.//
//UNLESS THEY ARE COMPILETIME CONSTANTS; Then it is done Implicitly already. AS IN, IF THEY DO NOT CHANGE IMPLICITLY DURING THE OPERATION, THEY CAN IMPLICITLY CONVERT TO BYTE, ASSUMING IT'S IN RANGE//

//The same rules for +, goes for -, as does *.//

//All of the rules so far, also applies to Division.//

//There are two forms of Division, interger division and Floating Point division.//

//The first, is whole numbers, and discards floating points. Only occurs when both are int.//

//The second, occurs when there is a Floating point involved, where the floating point is shown, and converts the entire argument to floating point, if one is floating.//

//If the resulting division is an other type than the explicit stated variable, it cannot assign to the explicitly stated variable without explicit conversion.//


//When dividing by Zero, if it is Floating division, depending on the dominant nominator of division (i.e what is being divided), it resorts to Negative infinity or Positive infinity.//

//A negative/Positive infinity can be Double and Float.//

Integral Modulo;
//Modulo by int 0 is a Runtime error.//

//Whatever is getting modulod upon, defines the resulting numbers notation ; i.e, if -6 % 5, the result is -1//

Floating Modulo;

//The operation never results in an Error, if the Right hand is a FLOATING POINT 0. And the result becomes NaN//

//If either is NaN, the result is NaN.//
//NaN can be Double, Float etc.//

//If the number being modulod upon, is infinity, the result is NaN.//

//If none of the Above rule applies, it executes as per normal.//
//If the % is larger than the number being modulod upon, the result is simply the original number being modulod upon.//

Unary + and Unary -;
//If a number is assigned a unary + or a unary - and it is less than a integral, it is converted to a Integral.//

String Addition;
//If a += is used with a string on the left hand, it directly converts that to a Str value.//

Increment (++);
//There are two ways Increment works, post-fix and pre-fix.//

//if the pre-fix is assigned, the increment occurs first. If it's a post-fix, it comes afterwards.//

//For example; 
// int i = 100//
// int j = 50//

// j = i++ + 15; j gets assigned with 115 and i becomes 101.//

// If we instead, write, j = ++i + 15; j gets assigned with 116 and i becomes 101.//

//int i = 15;
// i = i++; i still remains as 15, it would have been assigned 16 if it was i = ++i;//

//If there is a post increment or decrement, it is done AFTER a set of operations has been completed.
//if it is pre increment or decrement, it is done BEFORE any set of operation has been completed.

//An increment or Decrement, returns a value, not a variable.//
//The increment and Decrement, must be performed on a Variable, not a constant.//

STRING CONCATENATION;
//If the right side of an operation is string, in a contacination context, then the rest is converted to being String, regardless of Type and Value.//

//If it is infinity, it is replaced by - or + INFINITY.//
//If it's a float with a scientific notation, the notation part is removed and the original value is represented as a String.//

//Even if the value is Null, the str value becomes "Null" in a str format.//

//If two values are both arethmetic operations, they execute as per normal, and then get represented as a String value.//
//If either value is String, that specific context, gets considered to be a String Conatation.//

//You can put '"'s in Strings by adding them by the virtue of \ followed by a "\. //

Equality Operator;
//If you have two =='s, making the "Equality" comparison, you cannot mix two different types//
//You can also chain them, in a series, albeit this only works for things that are still of the same type.//

//If it's a reference to a variable, it defaults to False, lest they point to the same object in the memory.//

//If either of the variables happens to be a NaN, it defaults to False.//

//To see if something is a NaN value AND it is a float or double, you can call the function that checks it, which is the name of the Type, with a Capital start letter.//

EXAMPLE;

b = Double/Float.isNaN(<variable name>)

//This assigns a True if it's a NaN, and a False if it is not.//

//The equality operator, checks against where the data is allocated in memory. Which means, that if you compare 2 strings, that are exactly the same, but different allocations
//it says it's False. This only applies to Strings.

//To compare Strings, one must use the function of ; variable name = <first str name>.equals(<second str name>) //

Inequality operator;
//If something is not equal to another, it returns True. Otherwise, it's False.
//Works as per usual on numbers. Does not work as per usual for Strings.
//If either is NaN, it defauls to True.
//Floating point numbers, double or float, inheritly return false on equality checks against themselves, and only return true if it's a inequality check against itself, it only levels a True if
//it's being compared to a NaN.//


Greater Than operator (>);
//A Greater Than operator only works on primitive type numbers.
//If either is NaN, it automatically defaults to False.

//Can assign function values to variables

Greater Than or Equal to Operator(>=);
//Can only be used on primitive data types.
//If either is NaN, it automates to False.

Less Than Operator (<);
//Same rule as above.

Less Than or Equal to Operator (<=);
//Same rule as above.

BOOLEAN LOGIC OPERATORS;

Logical Not Operator (!);
//Inverses the boolean state of what it's put before. (Still has to be assigned to a variable)

Logical Short Circuit AND operator (&&);
//An And statement, does not evluate the right part if the left part is False.
//Returns False if Left part is False, or Right part is False.

Logical AND operator (&);
//Same as Short Circuit AND operator, except it still evaluates the Right hand part, even if Left is False.

Logical Short Circuit Or (||);
//An Or statement that breaks if left statement is True.

Logical Or Operator (|);
//An Or statement that checks both parts, even if one is False.

Logical XOR operator (^);
//An XOR statement that checks to see if the two Booleans are different.
//If one is true, and the other is False, it returns True.
//If both are True or both are False, it returns False.

Compound Boolean Logic Operators (Compound of operators above);
//You can write op instead of a Compound operators.
//There are 3 compound operators, in the Boolean Logic field.

// &=, which is equal to <variable1> = <variable2> & <variable3> (a logical And check)
// |=, which is equal to <variable1> = <variable2> | <variable3> (a logical Or check)
// ^=, which is equal to <variable1> = <variable2> ^ <variable3> (a logical XOR check)

Ternary Operator (? :);

<Boolean Expression> ? <true-expression> : <false-expression>

//if the boolean expression is True, it evaluates the true expression, if it's False, it evaluates the False.

Example;

int num1 = 50
int num2 = 25

int minNum = (num1 < num2 ? num1 : num2);

//minNum becomes num2, because it evaluated as False.



Hierachy Order of Operators;

1: ++ pre or post increment
    -- pre or post decrement
    unary +/- (notifying + or minus)
    ~ bitwise complement
    ! Logical Not
    (type) Explicit Cast

2; *, /, %

3; +, - (normal + and minus)
   + string concatenation

4; << Left Shift
   >> signed right shift
   >>> unsigned right shift

5; < Less Than
   <= Less Than or Equal to
   > greater than
   >= greater than or equal to
   instanceof (type comparison)

6; == Equal in Value
   != Not equal to

7; & bitwise and
   & Logical And

8; ^ bitwise XOR
   ^ Logical XOR

9; | bitwise Or
   | Logical Or

10; && logical short circuit And

11; || logical short circuit Or

12; ?; ternary

13; = assignment
    +=, -=, *=, /=, %=, <<=, >>=, >>>=, &=, |=, ^= Compound assignment


STATEMENTS;

//There are three different types of Statements. 
//Declaration Statements
//Expression Statement
//Control flow Statement

//Declaration statement is pretty obvious, it's the statement of which declares things.

//Expression statement is a statement that expresses Data and follows with a ;.

//There are four categories that apply to this sort of declaration;

//Increment and decrement expressions.

//Assignment Expressions

//Object Creation expression.

//Method invocation expression.

Control Flow Statements;
//If and For statements are examples of Control Flow Statements.

Block statements;
//Blocks are local environments, in which variables can be defined and used within that Block.//

//In case of nested block statements, the hierarchy of accesibility, is that the inner ones have right to the outer ones, but the outer ones do not have
//right to the inner ones.

//Which means that you can privatize information or hide information in nested code blocks ; or just isolate variables by code blocks.

//Note; Since Inner Blocks account for Outer blocks being local environment, you cannot define variables with the same name, that are used in both places.



If Else statements;

//In Java, an If and Else statement, can only hold 1 statement after the check, unless they are within a block.//

//Ternary statements can be used as arguments for functions, where as of If Else statements cannot.
//Ternary works much like an If else statement ; Except, that a ternary operator can handle simpler operations, where of If Else can handle code blocks for decisionmaking.

Switch Statements;

//Switch statements work on a basis of cases, if a Case is found to match the check, it will proceed to ignore the checks past that point and simply execute; Unless there is a break statement.
//Using a break statement in a Switch statement, completely interuppts the Switch process and forces the program to move onwards.

//The range of the data format, must be within the parameter of whatever argument is fed to the Switch statement. If a statement that is outside of the range is fed to the Switch Statement,
//it causes a compile-time error.

//Labels of cases in Switch statements, cannot be repeats.


//All variable names must be known at Compile-time to prevent a compile-time error for Switch statements.
//Variables are evaluated at runtime, thus, it throws an error if it's a Variable that has been defined pre the Switch statement, as it is not known to the Switch statement.

//Thus, cases in Switch statements, may not be variable names, they need to be known at Compile-time.


FOR LOOPS;

//A For loop consists of 4 parts.

//Initialization

//Condition-Expression

//Statement

//Expression-list

//A For loop can consist of several statements that it iterates for, and what the operations for said thing is.

//for (initialization; condition-expression ; expression-list)
    Statement


// You initialize with what you wish to iterate on, which you can re-set the value of, albeit you cannot redeclare it whilst it is in the scope of the Loop.
//(You cannot redefine a int i to be a Float i, whilst working on i, in the loop. But you can reset the value of i, or change it, whilst in the loop.)

//For example, a for loop with two int variables, would look like the following;

//for(int i = 10, j = 20; ; ); This is a for loop, that iterates on i and j, two interger primtive data types.

//For loops can also be used to cause other operations, such as printing etc.

//If there is no condition in the for loop, it will need a break statement to break the loop at a relevant point.
//The condition expression must evaluate to True or False, and if it is not declared, it is automatically assumed to be True - Which causes a infinite loop, outside of using break statements.


//The Expression list part is optional, and varies in how you can express it; Ranging from very compact, to unconstructively large.

//Nested loops work as in Python, except you can have greater control due to Expression statement and the condition check is larger in variety.//

FOR EACH LOOPS;
//There is a specialized form of a For loop, that is called a For each loop.
//A For each loop defines a type, in an array or a collection, and it is iterates and operates upon specifically, in that Collection/Array.

//They generally look like this; 

for(Type element : a_collection_or_an_array){
  //Code that executes once for every variable that accounts for being as relevant according to the For each loop expression.
}
//

WHILE LOOPS;
//While loops execute for as long as their conditional expression is true.
// The looks of a While loop can slightly vary, depending on the intrecate details of doing is.
// A while loop breaks when the condition is no longer true, or a break statement is hit due to being on a relevant designated point.

Generally, it looks as follows;

Initialization
while (condition-expression) {
      Statement
      Expression-list
}



DO WHILE LOOPS;
//A Do While loop is like a While loop, except it executes the given proceduer, regardless of conditional check, at least once.//
//A Do While loop looks as follows;

do {
      //Code goes here
}
while(conditional-expression);
//

Break Statements;
//There are two forms of Break statements. A non-labeled one, and a labeled one.

//A non-labeled one, is as per usual, a normal break statement.


LABELS;
//Blocks can have label names, simply by declaration of the label name before the block.

ExampleLabelName:

//Break statements, can use these, to break that specified loop, assuming it's associated to it.
//If you try to use a Break statement with a label name, that is not the associated code block, a Compile-time error occurs.


CONTINUE STATEMENTS;

//Continue statements, can only be used in For loops, while loops and do while loops.

//There are two forms of Continue statements.
//Unlabeled ones and labeled ones.

//Where a Continue statement goes, depends on what kind of a loop it is.

//In a for loop, it goes to the update statement.

//In a while or do while loop, it goes to the Boolean expression instantly.

//If a Continue statement is triggered, it skips everything that is past that Continue statement, and goes to the Update statement or the Boolean expression, depending on what loop it is.

//If a Continue has a label, it refers to a specific block of code or loop with said label, and can be used in for example Nested loops.



EMPTY STATEMENTS;

//A couple of ;'s by themselves, is considered an empty statement.
//These are useful, when creating For loops, that require a statement, but at the same time already do what they should, in of themselves.

//An empty statement, can follow a already excisting statement; for example; 
// int i = 10;;
// This is actually a declaration of i being a int, followed by a empty statement.
//Empty statements are not allowed as part of a simple if else structure, if it is on top of an already existing statement, cause of only 1 statement before the else in terms of a simply if and else.



CLASSES AND OBJECTS;

//Generally Classes are defined according to this form;

<<modifiers>> class <<class name>> {
        //Body of the Class, goes here

        <<modifiers>> <<data type>> <<field name>> = <<initial value>>;
}

//Modifiers for a class is optional.

//Usually, when naming a class, the absolute first word, is lower-case, whilst the following is Capitalized, respectively.

//There are two different kind of variables in a Class, in Java.
//One is a instance variable, these can be defined with just a name and a value.

//The other, is a class variable, that must be defined with Static before it's name.

//To invoke a class, you call upon it's constructor.

//If you have not defined a constructor in your class, a default one is assigned for you. The default one, accepts no arguments.

//One way to declare a reference to a class instance, which you have instanciated, is by the following;

<class Name> <variable name> = new <class Name>;

//Every class, is a seperate reference type.

The Null Value;

//Null is an Empty value, that can be assigned to hold the value of variables.
//But variables, can never be named Null.

//Null is not a reserved keyword, it is the literal representation of the null reference type. (It's basically the literal representation of Nothing.)

//NOTE; Null and primitive number types, are not comptabile. Which means, that you cannot assign null to a Number type.
//You cannot make comparisons or relational operators, that are inheritly working on primitive number types, if you are doing it against Null.



Instance Variables and Class variables;

//To access class variable, you do like in Python. (class_name.class_variable_name)

//To access a instance variable, it is the same as Python as well. (instance_name.instance_variable_name)

//When a class or instance variable lacks a defined number, one is ascribed to it, which defaults to 0 (respective format for different types, if contains decimals, they will be there)
//If it is a string value, the default string value assigned to it is Null.

//If it is a boolean, it is set to False.


//If refering to a class variable that is part of a Package, you have to refer the package first, and make sure that the access level of the Class is such that you can access the Data from where you are trying.
//An example of this would be to have a public class and to access the variable, you need to do as following, if part of a package;

<package name>.cls.<name of class> <instance of class name>

//There are only two levels of access declarations in terms of Classes in Java.

//The first, is No declaration, which leaves it at Package level access, which requires that the class you are trying to access, has to be part of the same package as the one that is trying to access it.

//The second, is Public Access declaration ; Which leaves the Class as Public, and every class in the application can access it.

//A second way to access Class variables or attributes, is to import them, from it's package.

//If a Class is already in the same package, you can simply refer to it by it's simple name, but if it consists of another Package, or you don't have the acess, you can for instance import variables, classes, etc. 
//from said package that you are trying to reach.

IMPORTING;

//There are two types of importing that you can do;

//Single-type import declaration

and

//Import on-demand declaration.


SINGLE-TYPE IMPORT DECLARATION;
//If you use a Single type import declaration, you can use the Simple name of the class of which you imported.

//The compiler will replace the times that you name the class, with the full path of the Imported class that shares the percieved simple name of the class.

//As in, if you import a Human class from a Package, the compiler will replace your Human references, with the full path of the Package Class reference.


Import-On-Demand declaration;
//To import everything from the specified package (not all of it's sub packages, but only it's main package), you write;

import <<package name>>.*;

//To import a sub package of the main package, you need to refer to the name and further specify it ; An example would be,

import <<package name>>.<sub package name>.*;

Import Search Order;
//When you import a Class, the compilator will search in the follow order, for the simplified name of the class you are refering to,

//If a type has a nested type, it will search through thoose first.

//The Current Compilation Unit

//Single-type import declarations

//Types declared in the same package

//Import-on-demand declarations

//Note; You cannot import two classes that go by the same simplified names. The compiler gets confused, and it is prohibited to do this.

//There are two ways to use conflicts of simplified names.

//The first, which is a compromise, is to first use a simplified name, and later on use the whole qualified path name.

//The second, is to always use fully qualified names and complement with Commenting.

//When the compiler searches for where the Simplified import name stems from, it ALWAYS prioritizes Single-type prioritization

//If the package already excists in the Local environment, as in that it is specified, then it will automatically ignore import commands, regardless of Specification.

//It is generally smarter to just use the fully qualified name and path, to import things.

STATIC-IMPORT DECLARATION;
//You can declare Java to Import all the static members of a class, by simply putting static before the package name. an example;

import static <<package.name>>.<<type name>>.<<static member name>>; //This is a single static import

import static <<package.name>>.<<type name>>.*; //This is a on demand declaration

//The advatange of importing other classes and type names, especially static ones, is that it can allow your code to be easier to read and easier to understand.

//Albeit, it is still worth it to use full length path directory imports, just to be certain of that conflicts do not occur.

//Same rules of predesence apply to import-on-demand declarations as Static-import declarations

//If you import a static method from a Class, and it's simplified name already exists in the Class environment, the class environment takes priority above the imported one.
//(Basically just even more reason to do a fully qualified import)

//There usually is not much of a reason to import static variables from other classes, as it can cause Bugs and complicate simple matters such as functioncalls and simplifications of names.


Methods of Classes;
//methods of classes usually follow the format of;

<<modifiers>> <<return type>> <<method name>> (<<parameters list>>) <<throws clause>> {
        //method body goes here
}

//Every method contains a unique set of variables to be called upon. Duplicates are not allowed.

//Modifiers, return type and parameter names are not part of said thing, all that matters is what Arguments the method takes.

//When a Function has it's return type defined as Void, it does not return any value.

//Return can also function as a way of ending a method, instead of actually getting a Value back.

//If a Method throws exceptions or if it throws one on a expected place, it does not require a Return.

//Local Variables (only available to Methods) are not like instance/class attributes, they do not get a default value, they need to be initialized explicitly

//If a Local variable is attempted to be used before initialized, it will cause a Compiler Error.

//Local variables can be declared anywhere, but they must be declared before they are being used.

//When a Class Variable and a Local variable are in the same scope, Local Variables take higher priority.

//Make different names of calling, for clarity of Code purposes.

//When a Method is non-static, it is a instance method that is used for explicitly modifying behaviour of specific objects or the likes.
//Static methods, are class methods and used to define the behaviour of the Class overall.

//Class method (static) can only refer to Class Variables (static ones), whilst a instance method can call both local and Static ones.

//Because otherwise crashes can occur due to pre-mature referal, before initialization has occured into the actual memory.

//Invoking a instance method and Class method is done differently.

This is usually how you invoke a method;

<<instance reference>>.<<instance method name>>(<<actual parameters>>)

//When calling a instance method from a class, you must have instanciated the object first.

//This is done by the following;

<<class name>> <<function nickname>> = new <<class name>>();

//Afterwards, you can call the instance function per normal proceduer, with;

<<function nickname>>.<<function name>>();

//To invoke a Class method, you can either create a instnace of it, or reference the Class method directly.

<<class name>>.<<function name>>();

OR

<<class name>> <<function nickname>> = new <<class name>>();

//Main methods in Methods, are used for entry points of initializing methods, and the JVM (java compiler) has no idea how to initialize instance methods,
//There of, why it needs to have static methods that allows for it to create a Class instance, along with the defaulted groundworks of the function for it
//to have something to work with. (The return type being void, the string array etc.)

//Only one main function is needed, in terms of starting the application and running the class in the JVM.

Keyword; THIS

//This is a self reference tool that refers to the specific instances values ; Thus, it only works in instance methods (i.e, non static)
//You can forego using the this.<variable name> usage, by simply using the full qualified name.

//the this reference is a very good tool to distinguish different variables from each other, and sometimes is the only way to allow access to instance variables.
//Otherwise, you can just use different variable names.

//the this word, can be useful for when a instance is hiding it's name by fact of overlapping arguments names and instance variable names.

Instance Variable initialization Context: 

Instance variable initialization Instance Yes Yes Yes
Class variable initialization Class No No Yes
Instance initializer Instance Yes Yes Yes
Class initializer
(Also called static initializer)
Class No No Yes
Constructor Instance Yes Yes Yes
Instance method
(Also called non-static method)
Instance Yes Yes Yes
Class method
(Also called static method)
Class No No Yes

//The Following is allowed and not allowed for different concepts;
                                   Can use This/  can use instance variable / can use class variable

instance variable initialization (instance);  Yes, yes, yes
class variable initialization (class); No, No, yes
Instance Initializer (instance); yes, Yes, yes

Class initializer (class); No, No, Yes
Constructor (instance); yes, yes, yes

Instance method(instance); Yes, yes, yes
Class method(Class); No, No, yes

//A variable cannot be called this, and it cannot be assigned a value.

//a instance method can be invoked with the notation of this.<function name>

Class Protection Levels;

//There are 4 levels of which a Class field/method can have in terms of protection levels;

//private ; Only within the same class
//package-level ; in the same package (default if no security defined)
//protected ; same package or descendant in any package
//public ; Everywhere

//Conventionally, declare security before instance or class instanziation.

//Regardless of protection level, the data is always accesible inside of the Class.

//Trying to access a unavailable security level leads to a Compiler Error in form of Access level

//Access is only defined directly, you can still access them indirectly or through a function that has "channeled" access into the said Class.

//Outside of things being public, if things are of another pAckage, you can only gain access to them by virtue of functions or importing

//Both the Class and the Class member needs to be accessible, to ensure that the data can be reached.

//Class members should be declared private and channeled through moderated functions that have relevant access levels.

//If a Class is only using it's members internally, you can declare them all as private.
//If there is a channeled need, make a medium between private by the virtue of moderated functions.

//Another advantage of Private variables, is that it allows very precise changes and defined changes, within the class ; No need to change everything that uses parts of it, through public means.

Parameter passing;

//There are two types of data in java;
//A primitive data type and a reference data type.

//A primtive data type is simply stored in a direct manner.
//reference data types are handled as Objects.

//Java bases itself on references which are allocated in data memory.


Constructors;

A constructor is usually as follows;

<<Modifiers>> <<Constructor Name>>(<<parameters list>>) throws <<Exceptions list>> {
          //Body goes here.
}


//A constructor does not allow for a return type to be defined.

//Constructors are used to initialize new instances of a Objects.

//Even if a Object is initialized and not kept bound to a reference ; it still executes the code of the Objects constructor.

//Constructors in a class, if they have the same name, become overloaded ; And must have differences in their ordering, number of parameters or types of parameters.

//When you call a Constructor with parameters, the number of parameters, ordering and type of parameters must all match in accordance to the Constructor.

//You should use this, when defining specific objects attributes in terms of initilization or modification.


Calling a Constructor from Another Constructor;

//A constructor cannot call itself, as it becomes recursive. It folds in on itself.

//You can call another constructor, with the keyword of this, in a class.

//You can only call the first statement of a constructor, when it is calling a function in on itself. 
//Doing otherwise, is a compilation error.

//You usually make several overloaded functions, if a object is to be able to be initialized in different manners.

//A constructor cannot have a return expression in it's Constructor. Albeit, it can be in the Body.

//Constructors can have the standard range of protection levels;
//Public , private, package (default with nothing), protected.

//constructors can be private, regardless of the status of the class.
//This creates the availability to have a very specific control of your code, to allow when certain objects are accessed and how they are accessed.

//This can also cause you to have a singelton pattern. Where only one instance of an object, may be created and returned.

//Another factor to private constructors, can be to prevent Inheritance. 
//If the class is completely made private and only returnable by private means, they cannot be passed on to cause inheritance.

//A keyword to call a Protected function, in a inherited hierarchy - is super()//
//super() implies that you call upon a constructor of a parent class
//This cannot be done, before a parent class's object has been created.

DEFAULT CONSTRUCTORS;
//Top level classes (Classes that are not inner classes), inheritly cannot be declared to be protected or private.
//They can only be public or package access level.

//Inner classes, can have all the 4 levels of protection ; Protected, Private, Public, Package default

//If you do not define a constructor for a class, it defines a default one, for you.

//It also adds a super() by default, to call the no args argument of the parent class.

//If the class does not yield a constructor, it adds a default one that reflects the security level of said Top class.

//This works the same for Inner classes ; If inner classes do not yield any constructor, it will be assigned one that yields the same security level as the top one.

INSTANCE Initalization;
//An instance initializer, is a block of code, that inheritly does not have a name, but has access to the variables by referal with this.

//Instance Initializers come before Constructors ; And you can have as many Instance initializers as you wish.

//These instance initializers, cannot have a Return statement.
//It cannot throw exceptions, unless all of the ones it is trying to throw, is already defined in all of the respective constructors throw lists.

//Instance Initializers can be static. If they are, they occur in predecence before other instance initializations. 
//They occur in alphabetical order, when it comes to initialization. 
//These cannot have a return statement and they cannot throw checked exceptions.


THE Final KEYWORD;
//The main function of the Final keyword, is that the construct which is associated with Final, can not have it's original value modified or replaced.

//Beyond this, Final can be used in three different contexts.

//A variable declaration.
//a class declaration.
//a method declaration.

//If a class is defined as Final, it cannot be extended, or have subclasses.
//If a method is defined as final, it cannot be hidden or overwritten, in the subclasses of the class that contains the method.

//A variable that is assigned final, but not with a value, is considered a Blank final variable ; that can later have it's value assigned, but after it's been assigned, you cannot modify it.

//You can still, however, read it.

//Blank statements can be initialized as Final, tho, there can only be one instance of such.


//A class variable can be blank or blank final.

//A static final variable, is considered a constant.

//if a Class variable is set to be Final, that _specific_ variable, is final. Not the actual class variable overall.

//you can optimize, by replacing factors in the program with pre-determined wordings that you initialize compile time, to not have to initialize everything on Run-time.

//An example, would be;

public class Constants {
      public static final <variable type> <variable name> = <variable value>;
}

//Everything past that point, will replace Constants.<variable name>, when it is found in the program.
//Do note, this causes the variable to be static final, which means that while it may increase performance if it nevers needs to be changed,
//it might cause need to rework everything, because you stated it to be final static.


VARAGS METHOD;

//These methods can have an arbitrary amount of arguments to perform operations on.
//They are usually writen as follows;

<security level> <static or dynamic or default to Nothing> <type> <name>(<type>... <variable name>)

//They might only have one argument of the type that is variable length.
//That specific var length argument, must be last in the list of arguments for the method.

//An example of a var length method, is as follows.

public class MathUtil4 {
    public static int max(int...num) {
        int max = Integer.MIN_VALUE;
        for(int i = 0; i < num.length; i++) {
            if (num[i] > max) {
                max = num[i];
            }
        }
        return max;
    }
}

//As you can see, this is basically an array that has N amount of numbers accessible, where N is the supplied number for the int...num part.
//Basically, you iterate through the array with the numbers, according to the iterating in a range of what number you are accessing and assigning it for the specific purpose.
//In this specific situation, it is searching for the max value of an interger, when supplied.

//the int...num part is optional. If the only argument is int...num, it would be okay to call it with 0 arguments, because it defines int to be the minimum of int by default.
//If it is a more specified argument than the int...num argument, it would be needed to actually supply it.

//Further more, there must always be a incorporated form of at least 2 arguments being handeled, in this case the default is already put to Interger.MIN-VALUE and the int...num argument is optional.
//Thus, it can return max. If you would want anything else, you would need to provide the argument.

//When Vargas methods are overloaded, Java will resort to trying to find a standard method first - it uses Vargas methods as a last resort.
//If the overloading leaves it ambigious, a compiler error is raised, with a message of it being ambigious.

//You can replace a main method initializer with a Vargas method and have it be Valid.


GENERIC CLASSES;
//Generic Classes are Classes that can operate on objects of unknown type.

//They are written as follows;

public class Wrapper<T>  {
      //Code for the Wrapper class goes here
}

//if a type is not defined, it uses a type known as Raw Type.

//Primitive types are not allowed to be used for generic classes.
//Generic Classes can have more than 1 parameter.

//To declare a Generic instance of a class, you do the following;

<name of Class><parameter type1, parameter type2, etc.> <variable name>;

//At times, you do not need to omit actual types, because the Compiler can usually tell what type the argument you are feeding it, actually is.

//A standard way of interacting with privatized arguments or modified arguments in any sense, is as follows;

public class <class name><<parameter type>> { //The 2 <<'s in this context, means that you actually have to encase the type in <>
    private <parameter type> <empty placeholder variable name>

    public <class name>(<parameter type>){
            this.<empty placeholder variable name> = <empty placeholder variable name>;

    }

    public <empty placeholder variable name> get() {
            return <empty placeholder variable name>;
    }

    public void set(<parameter type> <empty placeholder variable name>) {
            this.<empty placeholder variable name> = <empty placeholder variable name>;

    }
}

THE OBJECT AND OBJECT CLASSES;
//In java, all Classes are object classes that extend the Object class.

//You can assign almost anything to an empty declared obj variable.

//You can only declare a excisting class instance to be a instnace of the inherit Object function by explicit cast.

//In case you are uncertain of the nature of two objects, as in, if one is actually an instance of the other, you can use the instanceof command.

//it works as follows;

if (<example1 of declared object> instanceof <example2 of second declared object>){
      <variable name> = (<example2)example1;
}

//The object class has 9 methods, which of there are two categories for.
//The first, is a category that is default defined to be Final.

//The ones that this applies to, is;
getClass()
notify()
notifyAll()
wait()

//The second category, are not declared as final.

toString()
equals()
hashCode()
clone()
finalize()


//Following is a list of the inherit functions to Objects.

                           req written Code:          Customizable:

public String toString()        No                         Yes

//public String toString() returns a String representation of the Object. Mainly used for debug.

public boolean equals(Object obj)    No                    Yes

//public boolean equals(Object obj) is used to compare two objects for equality.

public int hashCode()                No                   Yes

//public int hashCode() returns a hashcode (an integer) of an object.

protected Object clone() throws CloneNotSupportedException       Yes        Yes

//protected Object clone() throws CloneNotSupportedException is used for making copies of an object.

protected void finalize() throws Throwable        Yes        Yes

//protected void finalize() it is called by the garbage collector before an object is destroyed

public final Class getClass()        No                  No

//public final Class getClass() returns a reference to the Class object

public final void notify()           No                  No

//public final void notify() notifies one thread in the wait queue of the object

public final void notifyAll()        No                  No

//public final void notifyAll() notifies all threads in the wait queue of the object

public final void wait()             No                  No

//public final void wait() Makes a thread wait in wait queue of the object with or without a timeout.

public final void wait(long timeout) throws InterruptedException           No                No

//public final void wait(long timeout) throws InterruptedException is the same as public final void wait, except with a long timeout

public final void wait(long timeout, int nanos) throws InterruptedException              No             No

//public final void wait(long timeout, int nanos) throws InterupptedException is the same as above, except with a measurement of nano seconds.


//An example of getClass in action.

Cat c = new Cat(); //We instanciate a object of the Cat class

Class catClass = c.getClass();

//Since the Class class is generic, we can re-write the getClass, as follows;

Class<Cat> catClass = c.getClass();

//You can get names of classes by the following examples;

String <variable name> = <class name>.getName(); //This is the full name variant
String <variable name> = <class name>.getSimpleName(); // This is to get the simple variant.


COMPUTING HASH CODE ON A OBJECT;
//Three things revolve around a Hash ; A piece of information, An algorithm and a integer value.

//Hashing is used to store Data and retrieve it fast out of designated buckets.

//By having a good hash function, you can with high speed know which container is holding your information.
//Thus, skipping the process of iterating through the entire container of information.

//Rules to follow, if you override the inherit hashCode() function that is inherit to objects;

This is assuming two object references, x and y.

//If x.equals(y) == True, both x and y must have the same hashcodes.

//If they have the same hash code, they do not have to be x.equal(y) == True

//If the hashCode() is called multiple times, the value must always return the same.

//if equals() or hashCode() is overwritten for your Object class, you need to have both hashCode() and equals() overwritten.

//The same variables for equals() should apply to hashCode() as well, if you are intending to use the Hash value.

//if a class is mutable (changeable), you should not have it as a basis of hashCode(), due to it being able to change the return hash value.

//Guidelines on how to Hash;

Start with a prime number. (For example, 37)

if type == byte, short, int and char;
    code = (int)value;

if type == long;
    code = (int)(value ^ (value >>>32));

if type == Float;
    code = Float.floatToIntBits(value)

if type == Double;
    long longBits = Double.doubleToLongBits(value);
    code = (int)(longBits ^ (longBits >>>32));

if type == boolean;
    code = (value ? 1 : 0)

if type == reference type or null;
    code = (ref == null ? 0: ref.hashCode())

Use another prime number for the next part (arbitrary which one, but we will keep using the same one);
hash = hash * <prime number> + code;

Do this for all the relevant instance variables that you want to include in the hashing.

return hash;

//Following, is an example of how to do the Hashing. NOTE; SINCE WE OVERRIDE THE HASHCODE FUNCTION, WE NEED TO DEFINE A NEW EQUALS METHOD

package com.jdojo.object;

public class Book {

    private String title;
    private String author;
    private int pageCount;
    private boolean hardCover;
    private double price;
    /* Other code goes here */
    /* Must implement the equals() method too. */
    public int hashCode() {
        int hash = 37;
        int code = 0;

        // Use title

        code = (title == null ? 0 : title.hashCode());
        hash = hash * 59 + code;

        // Use author
        code = (author == null ? 0 : author.hashCode());
        hash = hash * 59 + code;

        // Use pageCount
        code = pageCount;
        hash = hash * 59 + code;

        // Use hardCover
        code = (hardCover ? 1 : 0);
        hash = hash * 59 + code;

        // Use price
        long priceBits = Double.doubleToLongBits(price);
        code = (int)(priceBits ^ (priceBits >>>32));
        hash = hash * 59 + code;

        return hash;
    }
}

COMPARING FOR EQUALITY;

//The base of equality checks in java is made on reference. If two references are seen as the same, then they are deemed to be the same.

//What follows, is an example of how to re-implement the hashCode() function and the equals() function.

package com.jdojo.object;

public class SmartPoint {
      private int x;
      private int y;

      public SmartPoint(int x, int y){
          this.x = x;
          this.y = y;
      }

      /* implementing the equals function again */
      public boolean equals(Object otherObject) {
          if (this == otherObject) {
              return True;
          }

          if (otherObject == null) {
              return False;
          }

          if (this.getClass() != otherObject.getClass()) {
              return False;
          }

          SmartPoint otherPoint = (SmartPoint)otherObject;

          boolean isSamePoint = (this.x == otherPoint.x && this.y == otherPoint.y);

          return isSamePoint;
      }

      /*implement the hashCode() function again */

      public int hashCode() {
          return (this.x + this.y);
      }
}

//Pointers for equals() function;
//it should return True
//It must be symmetrical (x.equals(y) should return true and y.equals(x) should do the same)
//if x and y return true, so must Z
//it should be consistent
//An object should never equal to Null
//if x.equals(y) returns true, the x.hashCode() and y.hashCode() must return the same value.

//If you are comparing String values, you need to further modify the equals function;

first, define a arbitrary class for assigning the name of the reference object to be compared;

public <class name>(String name) {
      this.name = name;
}

secondly;

Do the same as the is equal to, above, except, instead we define a new name and compare the values of the String, character by character, use the following;

<class name> <second variable> = (<class name>)otherObject;

boolean <variable name> = (this.name == null? <second variable>.name == null :this.name.equals(<second variable>.name));

return isSameName;

//Since we redefined equals, we need to reassert the hashCode() function, and since it's a string comparison with a name variable, this is the final product we use for the hashCode()

public int hashCode(){
      return (this.name == null? 0 : this.name.hashCode());


STRING REPRESENTATION OF AN OBJECT;

//When you print a object, you get the following format;

<<fully qualified class name>>@<<hash code of the object in hexadecimal>>

//There is a toString() function, that works on the premise of converting things to String, even Objects.
//It is defined by default to all Objects.

//This can be used for Debugging in different ways ; for example, if you are working in a 2d Co-ordinate system, you can make a toString() function that returns the X and Y of the object.
//This can be done by the following;

public class Point {
      private int x;
      private int y;

      public Point(int x, int y){
              this.x = x
              this.y = y

      }

      public String toString(){
              String str = "(" + x + ", " + y + ")";
              return str;
      }
}

//It is called automatically in different situations, for example;

//When you make a System.out.print() call
//A string concatination expression involving a reference of an object

//You can't call on a function that holds a null reference, as it causes a runtime exception.

Cloning Objects;

//To clone an object, you must re-implement the clone function first.
//The original syntax for cloning, is as follows;

protected Object clone() throws CloneNotSupportedException

//It is protected, so you need to re-declare it in your class, to public, to be able to use it.

//When you clone objects, you need to cast it explicitly, in the reference assignment, as follows;

<class name> <variable name> = new <class name>;
<class name> clone = (<class name>)<variable name>.clone();

//To access a higher up method or class (Can be overwritten class or method or hidden), you need to use the keyword super.

//An example of this, follows;

<my class> <variable name> = <variable>;
try {
          <variable name> = (<my class>)super.clone();
}
catch (CloneNotSupportedException e) {
          e.printStackTrace();
}

return obj;

//This accesses the clone function from Object superclass and uses it to try and clone the designated object.

//it returns a reference to the object that has been cloned.

//What follows, is a class declaration with an interface implementation of being able to clone things.
//Without this declaration, you will get a runtime error for running clone()

public class <class name> implements Cloneable {
      //code goes here
}

//When you override methods, you have the option to opt out of having throwing exceptions.

//What follows, is a demonstration of how to implement the clone method;

package com.jdojo.object;

public class DoubleHolder implements Cloneable {
      
      private double value;

      public DoubleHolder(double, value){
              this.value = value;
      }

      public void setValue(double value){
              this.value = value;
      }

      public double getValue(double value){
              return this.value;
      }

      public DoubleHolder clone(){
              Object copy = null; (previous to Java 5, you would do something like DoubleHolder here as well, instead of Object copy, just cause of casting occurs later in, pre Java 5)
              try{
                       //First we call the Clone method of the Object class, by using Super.
                       //Which copies the object.

                       copy = (DoubleHolder) super.clone();
              }
              catch (CloneNotSupportedException e) {
                      e.printStackTrace(); //this is for printing the error, in case one happens.
                      //We trace the error and then print it.
              }
              return (DoubleHolder)copy; (Earlier than Java 5, you just return a Copy, instead of doing the casting here and have to explicitly cast the returned copy, afterwards)
      }
}

//IN JAVA 5 AND LATER, YOU CAN SKIP THE EXPLICIT CASTING OF CLONING, USING THE MODIFICATION ABOVE.

//This follows the standard proceduer of using the key set of 3 functions ; One that sets the value, one that gets it, and one that acts as a Container for the value.
//This is a common practice and is generally good for controlling flow of information and handling of interactivity of Objects in a controlled manner.

//To illustrate how the Clone function works, here is the following example;

DoubleHolder <variable name> = new DoubleHolder(100.00); //We instanciate a object and create a referance to it
DoubleHolder <variable name> = (DoubleHolder) <variable name>.clone(); //Remember to explicitily cast to the class of which you are using. It is done by the () casting.

//To further illustrate the point, here is an example of how cloning something works in practice.

public class CloningTest{
      public static void main(String[] args) {
          DoubleHolder dh = new DoubleHolder(100.00); //Once more, variable name of dh could be called anything
          //we instanciate an object and make a reference to it

          //Clone dh by use of explicit casting and assign the clone to some fitting Clone name, in this case, dhClone
          DoubleHolder dhClone = (DoubleHolder)dh.clone();

          //Run some simple prints of the values
          System.out.println("original:" + dh.getValue());
          System.out.println("clone :" + dhClone.getValue());

          //Change the values for the upcoming second print
          dh.setValue(200.00)
          dhClone.setValue(400.00)

          //Print the second round of values
          System.out.println("After mod Original: " + dh.getValue());
          System.out.println("Clone :" + dhClone.getValue());

      }
}

//it is clear, that since we overrode the cloning function, it became quite straight forward to clone it and modify values through a solid structure.

//With the latest version of the implemented clone function, an example is as follows;

DoubleHolder dh = new DoubleHolder(100.00);
DoubleHolder dhClone = dh.clone();// Clone dh, no cast is needed when you use the updated format of casting in the overwritten version of the clone function.

//An object can be held in another object, creating the effect of having a Container Object.
//The original clone() function only has the ability to allow shallow cloning (i.e, it copies references, not actual objects)

//Which means that you end up with 1 object, when you clone a Container object, that has 2 references operating to the same point, instead of 2 seperate objects.

//To actually create a clone, that results in 2 distinct yet identical objects, you need to perform what is called a Deep Clone.

//A Deep Clone can be hard to make, as it depends on if all of the containing members allow for cloning ; if they do not, you are left with shallow cloning.

//In case of that there are immutable references involved, it is fine to have Shallow copying, as it does not matter ; Immutable objects or variables can have as many
//references to it as it wishes, it matters not ; Because it is immutable, it can't be changed anyway.

//If you have mutable references, tho, you have to copy every single one of thoose, to actually create a deep copy. 
//Sometimes, compound objects may consist of some immutable, some mutable ; Then you just take the mutable ones and deep copy thoose, whilst you shallow copy the immutable ones.

//To perform a Deep copy, you first need to perform a shallow copy of everything. After that, you can commit the deep copy.

//What follows, is examples of how to perform shallow copies, followed by Deep copies examples.

SHALLOW COPY EXAMPLE;

package com.jdojo.object;

public class ShallowClone implements Cloneable {
          private DoubleHolder holder = new DoubleHolder(0.0);
          //The variable name can be anything, really

          public ShallowClone(double value) {
                  this.holder.setValue(value);
          }

          public void setValue(double value) {
                  this.holder.setValue(value);
          }

          public double getValue() {
                  return this.holder.getValue();
          }

          public Object clone() {
                  ShallowClone copy = null;
                  try {
                            copy = (ShallowClone)super.clone();
                  }
                  catch (CloneNotSupportedException e) {
                          e.printStackTrace();
                  }
                  return copy;
          }
}

//The difference between this one and the earlier example, is a subtle one. This one, implements one that has a reference to the same object as the original clone function.
//Which means, that both the copy of this function and the one that is copied, share values. Since they both point to the same object.
//Thus, if you change the value of one of the objects, the other one will have the same values, because it's a Shallow Copy.

//In other words, it is a Shallow copy of itself.

//What follows, is an example of how to do Deep Cloning;

package com.jdojo.object;

public class DeepClone implements Cloneable {
      private DoubleHolder holder = new DoubleHolder(0.0)
      //So far, just the same

      public DeepClone(double value){
              this.holder.setValue(value); //Again, one of the core trio.
      }

      public void setValue(double value) {
              this.holder.setValue(value) //Set the value
      }

      public void getValue(double value) {
              return this.holder.getValue() //get the value of the relevant object
      }

      public Object clone() {
              DeepClone copy = null;

              try {
                      copy = (DeepClone)super.clone();

                      //HERE COMES THE DIFFERENCE WITH A DEEP CLONE
                      copy.holder = (DoubleHolder)this.holder.clone();
                      //we basically copy the holder reference variable too

              }

              catch(CloneNotSupportedException e) {
                      e.printStackTrace();
              }

              return copy;
      }
}

//As is visible, the main difference between a shallow clone and a deep clone, is that a deep clone actually tries to copy the actual object of reference, as well

//If the object is not cloneable, you will have to either settle for a shallow clone, or you assign the value of the holder reference to something else and copy that.
//(Remember, the goal is to copy it's values; There of, we can simply assign the values to something else and copy that instead.)

//Here is an example of do just that;

copy.holder = new DoubleHolder(this.holder.getValue());

//basically, you just run the getValue method and assign the value to something else, so that you can copy that.


FINALIZING OBJECTS;

//There is a inherit Finalize method, that is run on a low priority thread process, to free memory when references to things are not held anymore.
//It doesn't do anything, when run, though. And it is not specified when it does the clean up, other than when it feels it is running low on memory.

//Thus, you can implement your own finalize methods, but it is kind of pointless, as you have no certainty of when they are run.

IMMUTABLE OBJECTS;

//A mutable variable is changeable, an immutable one is not.

//Variables have two states, internal and external. Objects may change internally, but we may not observe that, cause it is not extrenally visible to us.

//If an object is internally immutable, it is externally so, as well.

//The pros of a Immutable object, is that you can just pass the reference to other things, without fear of it changing.

//This saves both time, space and performance for the coder ; As you do not need to worry about the value changing nor do you need to copy things.

//It can, however, be highly impractical if you have something that needs to change it's values, at all.

//if a class consists of only immutable variables ; the class is considered Immutable.

//If a variable is just immutable, it's an immutable variable.

//It is a good idea to declare immutable variables to be final, cause it shows intention and it prevents inadverted changing.

//What follows, is a simple example of a mutable class;

package com.jdojo.object;

public class IntHolder{
      private int value;

      public IntHolder(int value){
          this.value = value;
      }

      public void setValue(int value){
          this.value = value;
      }

      public int getValue(){
          return value; //Since it's public you don't need to refer with this, you get away with just saying public
      }
}


//The only difference between IntHolder being a mutable and a immutable class, is the setValue method.
//If we remove that, it's an immutable method, already.

//Albeit, to be even more clear, we could just declare the private int value to be final.

//What follows, is an example of a class that is externally imutable, but interally mutable.

package com.jdojo.object;

public class IntWrapper2 {
          private final int value;
          private int halfValue = Integer.MAX_VALUE;
          //This is to indicate the original state of the halfValue, before it is changed

          public IntWrapper2(int value) {
                  this.value = value
          }

          public int getValue() {
                  return value;
          }

          public int getHalfValue() {
                  //Compute half value, if it has not been computed already

                  if (this.halfValue == integer.MAX_VALUE) {
                          this.halfValue = this.value/2;
                  }
                  return this.halfValue;
          }
}

//this leaves up with the possibility of a externally imutable object, albeit internally mutable.

//Which means, that the internal values of it may change, but the external values does not reflect this.

//A String object is internally mutable, albeit externally immutable. 

//A issue that might arise, with unintended changes in the variables ; is when you provide the instance variable directly.

//The solution to this, is to create a copy of it, and provide the copy reference. You need not hand out the original.

//What follows, is an example of a situation with a Faulty one, and a Correct one;

FAULTY ONE;

package com.jdojo.object;

public class IntHolderWrapper {
      private final IntHolder valueHolder;

      public IntHolderWrapper(int value) {
              this.valueHolder = new IntHolder(value);
      }

      public IntHolder getIntHolder() {
              return this.valueHolder; //This is what is faulty with it. We return the actual variable, instead of a reference to a copy of it.
      }

      public int getValue() {
              return this.valueHolder.getValue();
      }
}


CORRECTED ONE;

package com.jdojo.object;

public class IntHolderWrapper {
    private final IntHolder valueHolder;

    public IntHolderWrapper(int value)  {
            this.valueHolder = new IntHolder(value);
    }

    public IntHolder getIntHolder() {
            int v = this.valueHolder.getValue();
            IntHolder copy = new IntHolder(v);

            /first, we run the get value, then we assign it to a value that we return.
            /This is according to the Trio, of returning through set values functions, instead of passing the actual variables.

            return copy;
    }

    public int getValue() {
            return this.valueHolder.getValue();
    }
}

//What could have been an easy overlook, can be a devestating mistake. This is why it is so important to have a rigid structure that follows protocol,
//all the way through.

//If you do not have that, mistakes like these can occur ; flaws in the structure causes security risks and failures to have a solid foundation that is working as per intention.

//if the instance of a constructors argument is from a mutable class, you must first make a argument to store the value and then pass it on, so that it is not mutated along the way.

//Remember; Using the direct variable of a class, when you seek to have immutable sources, is a big nono.
//Use copies of values, or use immutable values.

WRAPPER CLASSES;

//All Wrapper Classes are Immutable.

//A Wrapper Class is a way to store a Primtive data type, into a format that is capable of being handeled in tandem with other Objects, as just plain primitives cannot do this, inheritly.

//All of the Primitive Types, have a co-responding Wrapper Class, that is just named by the primitive types name, except with capitalization, as follows;

byte = Byte
short = Short
int = Integer
long = Long
float = Float
double = Double
char = Character
boolean = Boolean

//Every Wrapper Class, either accepts a String Value, or it's primitive data type.
//Except for Character, it can only take a char.

//In terms of efficiency, it can be very effective to store a value of something, in a variable with the valueOf() function.

//What follows, is an example of how to do that;

<primitive type with capitalization as class name> <variable name> = <primitive type with capitalization as class name>.valueOf(<argument>)

//This allocates one instance of said argument, which can be refered to many times ; Thus, requiring less space, compared to allocating a new memory spot for each new instance of a variable.

//Numerical wrapper classes, can be used to retrieve, and store, a converted value, from one to another.

//Following, are examples of this;

<Primitive data type as Class name> <variable name1> = <primitive data type as Class name>.valueOf(<argument>)

<primitive data type name> <variable name2> = <variable name1>.<primtive data type name>Value();

Above is basically, for instance, byte b = intObj.byteValue();

//The conversion rules between the different primitive types, still count.

//You can also extract number from string values, by way of parse<insert primitive data type>()

//You can also find the bounds of numbers, by virtue of <capitalized primitive data type>.MIN_VALUE/MAX_VALUE, respectively.

//You can also find the Size of said data types, by virtue of <capitalized primitive data type>.SIZE.

//You usually place parsing string functions in a try and catch block, because if the string cannot be converted, it throws a ANumberFormatException.

WRAPPER CLASSES FOR CHARACTERS;
//There are some wrapper class functions for Characters as well.

//They are, as follows ; 

isLetter()
isDigit()
toUpperCase()
toLowerCase()
charValue() //Returns the char of which the wrapper is handling

//And of course, the valueOf() function, which is better overall, than just using plain constructors.

//The most valuable one, in terms of valueOf(), is to call it on booleans, as it returns either False or True, and can save a lot of space, if you keep it to one instance.
//In terms of valueOf, regardless of capitalization, if it simply says true, in the valueOf(), it returns Boolean.TRUE

//If it says ANYTHING but True, in any capitalized format, it will return Boolean.FALSE.

//Autoboxing/unboxing, is when the compiler autoboxes or unboxes values from Wrapper classes, automatically, when the code is compiled.

//Shorthanded defined primitive types, cannot be Null in value.

Hierachy of Function Calls in Autoboxing and Unboxing;

//When Autoboxing or unboxing a primitive type, the compiler searches first, with the type provided. It searches for this.
//if it cannot find the primitive type, it expands it, to the next level, and searches for that.

//If it cannot find that, it boxes whatever the argument is, and then searches for it.

//In the case of the relational comparison operator of ==, no unboxing or autoboxing occurs.

REFERENCE;

//When a primitive type is stored, it's object reference is stashed in the range of -128 and 127.
//If a number is higher than this, a new object is declared for that specific instance.

//Thus, you can save space with the valueOf(), assuming that the number is between -128 and 127.
//otherwise, you are going to have tons of Objects.

//Unboxing and Automatic boxing, works in collections.
//Collections are lists, where you can only store references. No primitive types are allowed in their raw form.
//To store a Primitive type, you have to autobox it first, to later on unbox it.

//Following, is an example of how such a list works;

List<Integer> list = new ArrayList<>(); //The notation of the <Integer> here, signifies that the List will only hold Integer types. 
//Which allows for unloading of workburden and helps to know what is allocated in a list.
list.add(101); //Autoboxing would work, here
int <variable name> = list.get(0); //Autounboxing works here

EXCEPTION HANDLING;
//General structure for error handling;

try {
      //do something
}
catch(first type of error){
    //Do something about the error
  
}

catch(second type of error){
  //Do something about the error
}

etc.

//Exceptions are objects with all the qualified data of the Error that occured.

//You can also throw exceptions on demand.

//When a exception is thrown, it tells of what Thread it occured on, Name, Type, Line in Code, Class

//When an exception is not caught by an catch clause, we call that a uncaught exception.

//The default Java runtime catcher is kinda wonky, you are much better off using actual try and catch clauses.

//A catch block can catch several different exceptions

//What follows, is a way to extract the Str value of an error exception, and present it to us.

package com.jdojo.exception;

public class DividedByZeroWithTryCatch {
      public static void main(String[] args) {
          int x = 10, y = 0, z;
          try {
                  z/x = y;
                  System.out.println("z = " + z);

          }
          catch(ArithmeticException e) {
                  String msg = e.getMessage();

                  System.out.println("An error has occured. The error is: " + msg);
          }

          System.out.println("At the end of the Program.");
      }
}

//This is an example of how to extract the message of an error exception and present it in a neat fashion.

//In a try block, if an exception is thrown, the exception is handeled according to the exception clause,
//to which it is then transfered out of the try and catch block.

//Assuming you have several catch, only one will be able to trigger.

//It is better to figure out a solid structure and avoid exceptions, and if you cannot, try to go after the structure
//of having only a maximum of one being thrown, after each try statement.

//This does not mean that you cannot have different types of Catch commands, just that you should not have several
//try and catch blocks lined up, as only one catch block can be executed per failed try.

//There is a hierarchy to Throwable exceptions;

Throwable -> Error -> virtual machine error - Out of Memory Error

Throwable -> Exception -> RuntimeException/IOException -> ArithmeticException

//YOU CAN DEFINE YOUR OWN EXCEPTION CLASSES

ARRAGING MULTIPLE CATCH BLOCKS;
//Object is the Superclass of all Classes in java, thus, you can assign any object to the Object class, inheritly.

//A Superclass, can always refer to another instance of a Subclass, assuming it derivates from the same Class.
//A Class can also refer to another instance of a Class, assuming the classes are the same.

//You follow suit of a Try block, with a suit of Catch blocks, in the order of which you suspect that kind of operation would 
//warrant as an error. From the most specific, to the most generic.

//if you do not do this, you recieve a compile-time error.

//If you do not define a Try and catch block, for a method that might cause a high probablity error, you need to declare in the constructor
//That it might throw a specific kind of error, that is of that higher probability.
(This might be things like I/O Errors in terms of readChar(), because you are reading the input of letters.)

//OutofMemoryErrors can only be solved by allowing increased allocated space of Memory.
//You can not write it off with a catch statement.

//You are better off improving your code and preventing error causing situations, compared to spamming try and catch statements.

//The difference between a Checked and unchecked exception, is that a checked exception is enforced by the compiler, for you to handle.
//A unchecked one, is one that you are free to handle, but not forced to.

CHECKED EXCEPTIONS;

//You can do a mix of different forms of Exception handlings.
//Some can be defined in the Throw parameters, others can be directly put in try and catch blocks.

//What follows, is the format of which methods must follow;

<<modified>> <<return type>> <<method name>> (<<params>>) throws <<List of Exceptions>> {
      //body goes here
}

//When a Throw is defined in the list of exceptions, and it is actually thrown, the application reports it and quits.
//You still need to put a relevant try and catch block, even if putting the Throw in the List of Exceptions.

//The reason you can use higher form of Catch statements, is because they are the super classes of the other exceptions,
//Which means that they can be defined as loose as they are, as they can handle all the sub categories of exceptions.

//You cannot throw checked exceptions for Static Initializers.

//If a instance variable is suspect to throwing an Error, you must define all of the following Methods in the class, to throw
//the same error ; Due to the class being able to throw the error by initialization.

//if you do not have a try and catch clause for a method or class that might throw an error, you must put it in the Throw expression
//if a instance variable throws a checked exception, you must declare a constructor for your class.
//If you do not, a default one is assigned to you.
//NOTE: Said constructor must have the try and catch command in it. Checked exceptions are forced to be handeled.


CREATING YOUR OWN EXCEPTION CLASSES;
//What follows, is the syntax for extending a class.

<<Class Modifiers>>class <<Class Name>>extends <<Superclass Name>> {
      //Body for <<class name>> goes here
}

//What follows, is syntax for how a user-defined exception class might look like

package com.jdojo.exception;

public class <class name> extends <Type of Exception> {
      public <class name>() {
           super(); //This returns the Exception with the message of null
      }

      //We call the Super class, to handle business for exceptions, as this is inheritly a inherited class from the higher hierarchy.

      public <class name>(String message) {
            super(message); //Exception with a detailed message
      }

      public <class name>(String message, Throwable cause) {
            super(message,cause); //The last two, are wrapper classes that let's you wrap an exception into another exception, with or without a Message.
      }

      public <class name>(Throwable cause) {
            super(cause); //Wrapper class for Exception class without a detailed message
      }
} 

//The syntax of throwing said error would be;

throw new <my class>('Your message goes here');

//What follows, is a list of Methods that are related to Exceptions and Exceptions handling.

Throwable getCause() //A method to return what the cause of the exception is

String getMessage() //Returns a detailed message of the Exception

StackTraceElement[] getStackTrace() //Retruns the Stack, of where all the compiled elements are. On top of it, is the Exception Object.

Throwable initCause(Throwable cause) //There are two ways to set the cause of an exception to be cause of a Exception ; By this Method or to feed an Exception to the Constructor.

void printStackTrace() //Prints the Stack trace on the normal Error Stream. Very useful for debugging.

void printStackTrace(PrintStream s) //Prints the stack trace to the specified PrintStream object

void printStackTrace(PrintWriter s) //Prints the stack trace to the specified PrintWriter object

String toString() //Returns a short description of the Exception

//You can save String values of exceptions, using a combination of StringWriter and printWriter, as follows;

packa com.jdojo.exception;

import java.io.StringWriter;
import java.io.PrintWriter;

public class StackTraceAsStringTest {
      public static void main(String[] args) {
          try {
                   m1();
          }
          catch(MyException e) {
                  String str = getStackTrace(e);

                  System.out.println(str);
          }
      }

      public static void m1() throws MyException {
          m2();
      }

      public static void m2() throws MyException {
          throw new MyException("Some Error has occured.");

      }

      public static String getStackTrace(Throwable e) {
          StringWriter strWriter = new StringWriter();
          PrintWriter printWriter = new PrintWriter(strWriter);
          e.printStackTrace(printWriter);

          String str = strWriter.toString();

          return str;
      }
}

//This is a Class on how to return the str value of an Error, so that you can save it in a File or to a Database.

THE FINALLY BLOCK;

//A try block can have one or zero finally blocks.
//If you define a Finally block, it must be following a Try block.

//A simple example of this, is

try {
      //Try do something
}

catch(Exception1 e1) {
      //Catch the Error, in case it occurs
}

finally {
      //Commit something.
}

//Finally always executes after a Try or a Catch, for the exception of 2 situations.
//The first, being that whatever Thread the process is being run on, dies 
//The second, being when the Application exits before it reaches the Finally clause.

//Usually, Finally is used for cleanup work. You run the processes you need in the try clause,
//followed by unallocating them in the Finally block.

//Another way to use Finally, is to assure that something that has many exit points, absolutely executes something after it's done.
//This is mostly the case for different methods that have statements that cause it to jump in different directions of Control.
//(Examples of this is; Break statements, Switch statements. etc.)

//In context of creating connections to Databases to deposit and withdraw things ; You use a lot of try and finally blocks, in form of
//first doing the connection in the try block and followed by cleanup in the Finally block.

//In terms of Handling Databases, the connection must always be closed again, after having been opened. No matter what occured.

//The flow of Try and Catch statements is as, when a Try fails, it is thrown to the associated Catch statement and things proceed from there.

RE-THROWING EXCEPTIONS;

//You can re-throw caught exceptions. 
//To do this, you simply need to throw it again in the try block.

//Only one catch statement can be executed per try, thus, if you wish to throw another error in a Catch, you must make a nested try catch (2 sets of Try and catch)

//If you throw a new exception, without providing the original, the data of the original one, is basically lost. (The type etc.)
//However, if you throw the new exception, with the old exception as the cause, you basically wrap the previous Exception and use it as an argument for the new exception.

//What follows, is an example of how to create said structure;

try {
      //Something that might invoke the Exception
}
catch(<Some Exception> e) {
      e.printStackTrace(); //You print the Trace of the Stack

      throw new RunTimeException(e.getMessage(), e);
      //here, we throw another exception, in the catch clause, except with the original exception provided

}

//This is a transparent throw, you will know what it is and where it is.

//You can do a "hidden" throw, as well, with it's location hidden, if you wish, it is as follows;

try {
      //Catch some Error that occurs
}
catch(<exception name lol> e){
      e.fillInStackTrace(); //We re-package the stack frames in the Exception object

      throw e; //Then we re-throw the same exception
}

//This is how you re-throw an Exception and hide the originals location

//What follows, is a whole structure of an example of a class that utilizes this;

package com.jdojo.exception;

public class ReThrowLol{
      public static void main(String[] args){
          try{
              m1()
          }

          catch(<random exception name> e) {
              e.printStackTrace();
          }

      }

      public static void m1() throws <random exception name> {
          try {
                  m2();
          }
          catch(<random exception name> e){
              e.fillInStackTrace();
              throw.e;
          }
      }

      public static void m2() throws <random exception name> {
          throw new <random exception name>("An error has totally occured!");
      }
}

AVOIDING THROWING TOO MANY EXCEPTIONS;

//Following, is a structure that allows you to utilize the way Exception hierarchy works. You take the the highest instance of a Exception,
//print with the Error message of whatever your specific Exception type was, and end up with only creating and refering to one Exception object.

//This way, you allocate less memory, and you clutter your code less.

//What follows, is the structure for said Exception handling.

public void m1() throws <exception name> {
      try {
              //Try to do something, lol
      }

      catch(Exception1 e1){
          throw new <exception name>("Msg1", e1);
      }
      catch(Exception2 e2){
          throw new <exception name>("Msg2", e1);
      }
      catch(Exception3 e3){
          throw new <exception name>("Msg3", e1);
      }

}

//This is a pretty solid structure, that allows you to keep defining specific types to throw, and it causes the said exceptions that are declared, to be sent "Upwards"
//in the structure, in terms of Exception hierarchy, cause it refers to the Supreme type of Exception, which still leaves you with 1 type of exception, albeit
//the type of exception that has occured, may be different and told of in detail.

//A truly elegant design.

ACCESSING THE STACK OF A THREAD;
//LIFO stands for Last In, First Out - Which is how the Stack handels data that is temporarily stacked there.
//(Stuff is added, and the latest Entry is also the first one to go. It's basically a pile.)

//When you call the fillInStackTrace(), you are looking at a snapshot of the state of the Thread. The state differs, based on allocated Data, of course.

//What follows, is an example of a Structure that allows you to inspect the Stack of a Thread.

package com.jdojo.exception;

public class StackFrameTest {
      public static void main(String[] args) {
           m1();
      }

      public static void m1() {
           m2();
      }

      public static void m2() {
          m3();
      }

      public static void m3() {
          //first we create a Throwable object, that will be the container for our information.
          Throwable <throw variable name> = new Throwable();


          StackTraceElement[] frames = t.getStackTrace();
          //Get the Elements of the stack trace

          printStackDetails(frames);
          //Print the information of the Stack elements.
      }

      public static void printStackDetails(StackTraceElement[] frames) {
          System.out.println("Frame count: " + frames.length);

          for (int i = 0; i < frames.length; i++) {
                  //Get the details of the Frame.
                  int frameIndex = i; //We are basically iterating through a "list", beginning from the top.
                  //0 is the top frame.

                  String filename = frames[i].getFileName();
                  String className = frames[i].getClassName();
                  String methodName = frames[i].getMethodName();

                  int lineNumber = frames[i].getLineNumber();

                  //print the frame details
                  System.out.println("Frame Index: " + frameIndex);
                  System.out.println("File name: " + fileName);
                  System.out.println("Class name: " + className);
                  System.out.println("Method name: " + methodName);

                  System.out.println("Line Number: " + lineNumber);
                  System.out.println("--------------------------");
          }
      }
}


//This can be used to create logs for debugging processes, where you know exactly on what line the issue is.

TRY-WITH-RESOURCES;
//What follows, is a Try statement that is attempting to use Resources from a SQL system.

try (AnyResource <variable name> = create the resource...) {
      // Work with the resource here. The resource will be closed automatically.
}

//You can allocate more than one resource in terms of the above statement of Try With.

//An example of this, is as follows.

try (AnyResource aRes1 = getResources1(); AnyResource aRes2 = getResources2) {
          //use aRes1 and aRes2 here
}

try (AnyResource aRes1 = getResources1()) {
          //Use aRes1 here
}

//These variables are implicitly final, and you can declare them as such, but it's redundant.

//What follows is an example of usage, when it comes to try with resources, and how it produces output.

package com.jdojo.exception;

public class SimpleTryWithResource {
      public static void main(String[] args) {
          try(MyResource mr = new MyResource(2, false)){
                  mr.use();
                  mr.use();
          }
      }
}

//This is an example, of how to use a try with resources.
//As you can see, we call the MyResource and assign it to a variable, which as a total of 2 levels, and then we use it, twice.
//What is the output? It is as follows;

Creating MyResource. Level = 2
Using MyResource level 2
Using MyResource level 1
Closing MyResource...

//Remember, that we cannot use more than the amount of levels that we have specified to have. Thus, we cannot use 3 levels, if we have 2.

//This would cause an Error, because we try to go below 0 levels.

//As such, if we intend to use more levels than we have available, or run the risk of it, we need to put it in a Try and Catch block.
//If we intend to debug, and try to find surpressed exceptions ; We can use the following;

for(Throwable t : e.getSuppressed()) {
      System.out.println(t.getMessage());
}

A MULTI-CATCH BLOCK;
//There is a way to declare a multi catch statement, that follows after a Try.
//It can be done, as follows;

try {
       //May throw 3 kinds of exceptions
}
catch(Exception1|Exception2|Exception3 e) {
      //Handle Exceptions Here
}

//Keep in mind, when having this kind of a structure, you are not allowed to have Exceptions that are related by subclassing.
//It causes a compiler error.

ASSERTIONS;

//Asserts can have two forms.
//One form, is that of;

assert booleanAssertionExpression;

//The second form, is that of;

assert booleanAssertionExpression : errorMessageExpression;

//the booleanAssertionExpression, consists of an expression that implicitly can be converted to True or False.
//The assert statement, checks wether it is true or not.

//if the assertment is true, nothing occurs. If it is False, an error is thrown.

//Following, is examples of how to write it.

int x = 10 + 15;

assert x == 25; // This is the first form of asserment

assert x == 25: "x = " + x; // Uses the second form of the assert statement and is helpful for if you want to print out the value at some point.

assert x == 25: x; // Uses the second form of the assert statement

//What follows, is a class that allows us to call Assertions on will.

java com.jdojo.assertion.AssertTest

java -ea com.jdojo.assertion.AssertTest

//This will try your assert commands in your program

//The -ea is a switch to enable assertions on runtime. They are by default de-activated.

//Assertions inheritly take up performance, thus, they are to be used only in development environments

//What follows, is different commands regarding assertions;

-enableassertions or -ea //This enables assertions, can be used with passing a number to it's constructor, to define how many assertions are to be made.

-disableassertions or -da //As above, but turns them off

-enablesystemassertions or -esa //Allows you to use assertions on System classes. Cannot be passed a level argument.

-disablesystemassertions or -dsa //Disables you to use assertions on System classes. Cannot be passed a level argument.

//What follows, is examples of using different calls on the enabling/disabling.

(no argument) //using no argument, disables or enables assertions in all user-defined classes.

packageName... //using this, enables or disables assertions in the specified package and all of it's subpackages, can also be used to enable/disable system assertions

... //using this, enables or disables assertions in the unnamed package in the current working directory

className // using this, in tandem with assertions, enables/disables assertions for a specific class. can also be used for system assertions

//Enabling all system assertions;
java -esa com.jdojo.assertion.AssertTest

//Enabling assertions in all user-defined classes
java -ea com.jdojo.assertion.AssertTest

//Enable assertions in com.jdojo package and it's sub-packages
java -ea:com.jdojo... com.jdojo.assertion.AssertTest

//Enables assertions in the unnamed package of which the current working directory is
java -ea:... com.jdojo.assertion.AssertTest

//Enables assertions in com.jdojo.assertion.AssertTest class
java -ea:com.jdojo.assertion.AssertTest com.jdojo.assertion.AssertTest

//You can use multiple da or ea statements, to make a clearer cut in where assertions are allowed.

//What follows, is an example of that;

java -ea:p1... -da:p1.p2.MyClass com.jdojo.assertion.AssertTest

//This enables assertions in p1, but disables it for p2, which is a subclass of p1.

//Once a assertion has occured, it cannot be changed. It can only be changed before the said object to be asserted has initialized.

USING ASSERTIONS;
//When you are using assertions, they should be limited to testing environments only.
//In case you need to be absolutely certain of something, you create a boundry of which the data is allowed to move within.
//Examples of this, may be that you use throw statements bound by if statements, instead, if you find a error that goes outside of the constrictments.

//An example of this, is as follows;

public void credit(double amount) {
      if (amount <= 0.0) {
          throw new IllegalArgumentException("Invalid credit amount: " + amount);
      }
      //other code
}

//This is exactly how we should do it, by defining a structure that goes around using Assertions, as they are waste of resources in an actual runtime environment.

//You can use assertions to check non public functions, and use it for things that does not disrupt functionality of actual methods. (i.e, not changing values or the likes.)

//Another example, is as follows;
private boolean validAccount() {
      boolean valid = False;

      //We can check for validity of of all the formats of code that follows, if one of them breaks, we return valid as False
      //otherwise, we change valid to True and return it with a fitting str message of what occured.
      //One could also, make a message command for each invalid one, and after all the methods have been run, you return valid, based on status.
}

STRINGS;

// "\n" means new row

//in Java, you use the .length() command to find the length of a String.

//String literals are string objects, String objects are immutable

//You can use the .equals() function with the argument of passing the object, when comparing String objects.

//If a String value already excists in the String Pool, references to a identical string value replaces the other one.

//For every single different string value, that is not identical to others already ; A new one, is created.

//by default, when you create a string object by the keyword of New, one is always created, regardless if one already exists in the String Pool or not.

//This means, that if a string value doesn't exists in the string pool, it will create a total of 2 (1 from new, 1 from the Reference)

//If there is one in the memory, and you make a reference of new, only 1 is created, by virtue of the New keyword.

//When you are simply refering to a string Object, it compares to the ones existing in the string pool.

//This means, that every instance of a string object, that is instanciated by New, makes it a unique Object.

//This means, that if you would compare a assigned string object that has associated new, to another string, it will always return False.

//When a String Object is constant, it is added to the pool, by Compiletime. (Things like final, are constants.)

//This means, that if you were to compare a String object that was not added by Compiletime, to the assigned variable, it would return False.

//However, if it is a Constant, it's already in the string pool, since it's added by compiletime, and there for, it would be true, when compared to the assigned variable.

//What follows, is a set of common functions for String Objects;

//<variable name>.charAt(<index number>) returns the letter of which is at said index number.

//Taking consideration to Capitalization and Casing, you would use the <variable name>.equals(<variable name2>) for two string Values.

//To ignore it, you would use <variable name>.equalsIgnoreCase(<variable name2>) for two string Values.

//There are three ways to check to see if a String is empty.

<variable name>.isEmpty() 

<variable name>.equals("") //Use this one, for safety against Null values

int <variable name> = <string name>.length();

//Usually, you use the second one of these, cause #1 and #3 throws a exception when you involve a vlaue of Null.

//There is also conversion between caps and all lower case, by virtue of <variable name>.toUpperCase(); / <variable name>.toLowerCase();

//You can refer to the index of the first occurence of a Letter in a string, and the last, as such;

String <variable name> = new String('Example');

int index;

index = str.indexOf("x"); //Will assign 1
index = str.indexOf('E'); //Will assign 0

index = str.lastIndexOf("pl"); //Will assign 4
//If a character is not found, both methods return -1.

//You can call the function of valueOf(<string name>) to return a string data type, of any kind of Data.
//i.e, if you call it on a string that is Null or False, it will return as "Null" or "False"

//You can do string cutting, with the function of substring(), as follows;

String string1 = "Hello".substring(1); //Will return "ello"

String string2 = "Hello".substring(2, 4); //Will return "ll" (H1, E2, L3, L4, O5)

//You can remove excess unicode characters and extra white space, from a String, by use of <string>.trim()
//Which returns a value of the string, without the unicode and without the white trail.

//Note; It only removes thoose on the outer reaches, inner reaches are not reachable by this method.

//Replacement of a String exists, by the virtue of the <variable name>.replace(<variable to be replaced1>, <variable replacer 1>)
//This returns a new object, with the specified ones, replaced.

//You can check the start and end of a string value, by the virtue of <variable name>.startsWith(<String Value>) OR <variable name>.endsWith(<String Value>)
//It always returns a Boolean value, True or False.

//Here is an example of splitting and joining strings;

String str = "LOL, LOL1, LOL2, LOL3, LOL4"

String[] parts = str.split(', ');

System.out.println(str)

for(String part : parts) {
      System.out.println(part);
}

Here, we print out the whole list, in form of "LOL, LOL1, LOL2, LOL3, LOL4"

After this, we have;

LOL
LOL1
LOL2
LOL3
LOL4

//This is because we split them by the points of ", " and print the value with seperate print commands thus, making new lines for each.

//You can also join em easily, as follows;

String str = String.join("/", "1", "2", "3", "4")
System.out.println(str);

1/2/3/4 //is what it will print

//Case statements can be called with String values.
//Usually, you have to make sure that whatever that Switch command is, is assured to not be Null and it's either converted to uppercase or lowercase.

//An example of this, follows;

package com.jdojo.string;

public class StringInSwitch {
      public static void main(String[] args) {
          operate("ON");
          operate("on");
          operate("On");
          operate("oN");
          operate("OFF");
          operate("oFf");

          operate(null);
      }

      public static void operate(String status) {
          if (status == null) {
              System.out.println("Status cannot be null.");
              return;
          }

          //have to convert to lowercase/uppercase

          status = status.toLowerCase();

          switch (status) {
               case "on":
                   case1;
                   break;
               case "off":
                   case2;
                   break;
               default:
                   default case;
                   break;
          }
      }
}

//Will print the following;

case1 //ON
case1 //on
case1 //On
case1 //oN
case2 //OFF
case2 //oFf
default case //Null

Stringbuilder and Stringbuffer;

//Stringbuilder and Stringbuffer, allows you to create strings that are mutable.

//Stringbuilder is used, when no thread safety is needed. For example, when processing a local variable in a instance method or constructor.
//otherwise, you should use StringBuffer, for thread safety.

//The StringBuilder() has 4 methods, associated to it;

StringBuilder()
StringBuilder(CharSequence seq)
StringBuilder(int capacity)
StringBuilder(String str)

//here is a few examples, of StringBuilder interaction;

//has an initial capacity of 16 characters
StringBuilder sb1 = new StringBuilder();

//create a StringBuilder from a String
Stringbuilder sb2 = new StringBuilder("Some random String of doom");

//Creates an empty StringBuilder object with the capacity of <num>
StringBuilder sb3 = new StringBuilder(<num>);

//You can increase the capacity of a StringBuilder with null objects, by way of using <variable>.setLength(<number>)
//If number is greater than the length of the variable, you set the capacity of the object to be to number.

//You can also make it so that you shorten it, by specifying a smaller number.

//There also exists the reverse() method for the StringBuilder class, which of course, reverses a String (returns a Reversed version)

//What follows, is a way of how to compare the order of String values, based on Alphabetical order

package com.jdojo.string;

import java.text.Collator;
import java.util.Locale;

public class CollatorStringComparison {
      public static void main(String[] args) {
          Locale USLocale = new Locale("en", "US");

          //create a Locale Object

          Collator c = Collator.getInstance(USLocale);
          String str1 = "cat";
          String str2 = "Dog";

          int diff = c.compare(str1, str2);

          System.out.print("Comparing using the Collator Class: ");
          print(diff, str1, str2);

          System.out.print("Comparing using the string Class");

          diff = str1.compareTo(str2);
          print(diff, str1, str2);
      }

      public static void print (int diff, String str1, String str2) {
          if (diff > 0) {
              System.out.println(str1 + " comes after " + str2 + ".");

          }

          else if (diff < 0) {
              System.out.println(str1 + " comes before " + str2);
          }

          else {
               System.out.println(str1 + " and " + str2 + " are the same.")
          }
      }
}

//This would print the following;

Comparing using Collator class: cat comes before Dog
Comparing using String class: cat comes after Dog


DATES AND TIMES;

//These exist in the java.util and java.sql packages.

//The API for dates and times, can only be extended with static classes

//When using LocalDate.now(), you have to keep in mind that this function, refers to a default Timezone.
//The LocalDate class per say, does not store Timezones ; They store dates.

//This means, that it cannot account for in what Time zone it is occuring, nor account for Clock changes.

//When you wish to set a Date, Year and Day, you can use the LocalDate.of(<year>, <month>, <day>) function.

//What follows, is a example of how to construct a class that returns current date, current time,datetime, and datetime within the Zone.
//It will also show, how to make a date from year, month of year, and day of month. 

//It is as follows;

import java.time.LocalDate;
import java.time.LocalTime;
import java.time.LocalDateTime;
import java.time.ZonedDateTime;
import static java.time.Month.JANUARY;

public class CurrentDateTime {
      public static void main(String[] args) {
          //Get current date, time and datetime
          LocalDate dateOnly = LocalDate.now();
          LocalTime timeOnly = LocalTime.now();
          LocalDateTime dateTime = LocalDateTime.now();
          ZonedDateTime dateTimeWithZone = ZonedDateTime.now();

          System.out.println("Current Date: " + dateOnly);
          System.out.println("Current Time: " + timeOnly);
          System.out.println("Current Date and Time: " + dateTime);
          System.out.println("Current Date, Time, and Zone: " + dateTimeWithZone);

          //Construct a birth date and time from date-time components
          LocalDate myBirthDate = LocalDate.of(1968, JANUARY, 12);
          LocalTime myBirthDate = LocalTime.of(7, 30);
          System.out.println("My Birth Date: " + myBirthDate);
          System.out.println("My Birth Time: " + myBirthTime);
      }
}

//From the class, we get the following results;

Current Date = <current YY/MM/DD>
Current Time = <Current time>
Current Date and Time = (Current YY/MM/DDTHH/MM/SS)
Current Date, Time and Zone: (Current YY/MM/DDTHH/MM/SS)<Time Zone difference[Time Zone]>
My birth date: 1968-01-12
My Birth Time: 07:30

//What follows, are a few classes containing functions regarding Time;

java.time (Contains LocalDate, LocalTime, LocalDateTime, ZonedDateTime, Period, Duration and Instant Classes)
java.time.chrono 
java.time.format (Contains functions for formatting and parsing dates/times)
java.time.temporal (Contains classes for accessing components of dates and times. Also contains stuff for Date-time adjusters.)
java.time.zone (Contains classes for supporting Time Zones and zone rules)

//To create a instnace of the date class, you need to use the accessing method LocalDate.of(<arguments>)
//the Local<format>(Date, date-time etc.).from(<arguments) method, is a way to extract a Date-time object from a localdatetime object.

//Local Date objects do not inheritly have a Set method, you have to actually set it through withXXX arguments, as follows;

LocalDate ld1 = LocalDate.of(2012, Month.MAY, 2) //the 2nd of May, 2012
LocalDate ld2 = ld1.withYear(2014); //ld2 is 2014, 2nd of May

//You can further distinguish the changes regarding the with arguments, by following up with them, as follows;

LocalDate ld3 = ld1.withYear(2015).withMonth(10).withDay(7); //This would present 2015-10-07

//The Local Classes have a get Method, that allows you to get whatever respective data you need out of it, as follows;

LocalDate ld = LocalDate.of(2010, 10, 5); /2010-10-05
int year = ld.getYear(); //2010
Month month = ld.getMonth(); //Month.OCTOBER
int day = ld.getDayofMonth(); //5

//The atXXX method of the LocalDate/LocalDateTime classes, allows you to modify the setting points of LocalDate objects.

//The duration class allows you to measure seconds, minutes etc.

//There is plusXXX/minusXXX methods, that allows you to subtract and add days/years/months etc.

//There is multiplication/division/negate (inverses plus to minus) functions that operate on time units

//These are as follows, for example;

Duration d = Duration.ofSeconds(200);
Duration d1 = d.multipliedBy(2); (This leaves d1 as being 400 seconds, 6 min 40 secs)

//What follows, is an example of Instants and Durations;

//we get the current instant

Instant i1 = Instant.now();

//get seconds and nanoseconds
long seconds = i1.getEpochSecond(); //We get seconds from the point of the Epoch (This is a really long time)
int nanoSeconds = i1.getNano(); //Nanoseconds

//To declare a duration of seconds, we can do as follows;

Duration d1 = Duration.ofSeconds(XXX);

//To do operations of the values on these, you have to use a .plus or .minus method, as follows;

Duration derp = d1.plus(d1); //Would result in derp being d1 + d1

//What follows, is a Flowchart that explains what each Class in the Date-Time API gives you;

Class name            Date        Time        Zone Offset        Zone Rule
LocalDate              Yes         No             No                No
LocalTime              No          Yes            No                No
LocalDateTime          Yes         Yes            No                No
OffsetTime             No          Yes            Yes               No
OffsetDateTime         Yes         Yes            Yes               No
ZonedDateTime          Yes         Yes            Yes               Yes
ZoneOffSet             No          No             Yes               No
ZoneID                 No          No             Yes               Yes

//The ZoneOffSet is the time delay between Zones and places. And example would be the UTC +1 etc.

//The following is a Class on how to handle ZoneOffSet;

public class ZoneOffSetTest {
      public static void main(String[] args) {
          ZoneOffSet zone1 = ZoneOffset.ofHours(-6) //Zone1 is a -6 hours off-set
          ZoneOffSet zone2 = ZoneOffset.ofHoursMinutes(6, 30) //Zone2 is a +6 ½ hours off-set

          ZoneOffSet zone3 = ZoneOffset.ofHoursMinutesSeconds(8, 10, 10) //zone3 is a 8 hours, 10 minutes, 10 seconds positive off-set


      }
}

//You can use the compareTo() function to see the total off-set between two time-zones
//The offset of UTC is a static Z
//Normal Offsets that do not belong to UTC, have a maximum of -18 hours and +18 hours.

//The ZoneId class follows the format of Zone rules, such as daylight savings time etc.

//What follows, is an example of how to represent data in terms of Time zones, if they are static etc;

package com.jdojo.datetime;

import java.time.LocalDateTime;
import java.time.ZoneID;
import java.time.ZoneOffSet;
import java.time.zone.ZoneOffsetTransition;
import java.time.zone.ZoneRules;
import java.util.List;

public class ZoneRulesTest {
      public static void main(String[] args) {
          LocalDateTime now = LocalDateTime.now();
          System.out.println("Current date time: " + now);

          ZoneId fixedZoneId = ZoneId.of("+06:00");
          ZoneId bdDhaka = ZoneId.of("Asia/Dhaka");
          ZoneId usChicago = ZoneId.of("America/Chicago");

          printDetails(fixedZoneId, now);
          printDetails(bdDhaka, now);
          printDetails(usChicago, now);

      }

      public static void printDetails(ZoneId, zoneId, LocalDateTime now)  {
          System.out.println("Zone ID: " + zoneId.getId());

          ZoneRules rules = zoneId.getRules();
          boolean isFixedOffset = rules.isFixedOffset();

          System.out.println("isFixedOffset(): " + isFixedOffset);

          ZoneOffset offset = rules.getOffset(now);
          System.out.println("Zone offset: " + offset);

          List<ZoneOffsetTransition> transitions = rules.getTransitions();
          System.out.println(transitions);
      }
}

//If we wrote the above Class, we would get the following Data;

Current Date Time: 2014-01-03T16:05:13.035
Zone ID: +06:00
isFixedOffset(): true
Zone offset: +06:00
[]
Zone ID: Asia/Dhaka
isFixedOffset(): false
Zone offset: +06:00
[Transition[Overlap at 1890-01-01T00:00+06:01:40 to +05:53:20], ..., Transition[Gap at
2009-06-19T23:00+06:00 to +07:00], Transition[Overlap at 2009-12-31T23:59+07:00 to +06:00]]
Zone ID: America/Chicago
isFixedOffset(): false
Zone offset: -06:00
[Transition[Overlap at 1883-11-18T12:09:24-05:50:36 to -06:00], ..., Transition[Gap at
2008-03-09T02:00-06:00 to -05:00], Transition[Overlap at 2008-11-02T02:00-05:00 to -06:00]]

//Basically, we get a set of data to how much the Offset is, the ID of the Offset (i.e, what region), if it's a fixed Offset etc.

//In regards to working with dates, you will usually get returned some form of Enum.

//These are constants that represent relevant data in the context.

//as such, is for example the Month enums that all are caps-locked, exmaple follows;

Month january = Month.JANUARY// The january reference now holds the january month

//What follows, is a class utilizing the Month enum;

package com.jdojo.datetime;

import java.time.LocalDate;
import java.time.Month;

public class MonthTest{
      public static void main(String[] args) {
          //here, we use a Month enum as a argument
          LocalDate ld1 = LocalDate.of(2012, Month.July, 1);

          Month m1 = Month.from(ld1);

          Month m2 = Month.from(2);

          Month m3 = m2.plus(1);

          Month m4 = Month.getMonth();

          int m5 = m2.getValue();

          System.out.format("%s, %s, %s, %s, %d%n", m1, m2, m3, m4, m5);
      }
}

//This will print the following; 

JULY, FEBRURARY, MARCH, JULY, 2

//When we run the GetValue, on a Month class, we get the int value of which it is in the calender, so 2 is Feburary, 1 is January etc.

//Representing week days is as follows;

LocalDate ld = LocalDate.of(2012, 5, 10);

DayOfWeek dw1 = DayOfWeek.from(ld); // Here, we extract the day of the week, which on this specific day happens to be Thursday

DayOfWeek dw2 = ld.getDayOfWeek(); //This is the same as above, except in a different ordering of writing

//You can off course add plus and minus to a reference to which is holding the value of a Week day, by the methods of plus and minus;

DayofWeek dw4 = dw2.plus(1); //This would return Friday, and if it was Sunday, it would return Monday, etc. etc.

//What follows, is how to further extract information about what is allowed operations and not, on the datetime classes;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.temporal.ChronoField;
...
LocalDateTime now = LocalDateTime.now();
System.out.println("Current date Time: " + now);
System.out.println("Year: " + now.get(ChronoField.YEAR));
System.out.println("Month: " + now.get(ChronoField.MONTH_OF_YEAR));
System.out.println("Day: " + now.get(ChronoField.DAY_OF_MONTH));
System.out.println("Hour-of-day: " + now.get(ChronoField.HOUR_OF_DAY));

System.out.println("Hour-of-AMPM: " + now.get(ChronoField.HOUR_OF_AMPM));
System.out.println("AMPM-of-day: " + now.get(ChronoField.AMPM_OF_DAY));

LocalDate today = LocalDate.now();
System.out.println("Current Date : " + today);
System.out.println("LocalDate supports year: " + today.isSupported(ChronoField.YEAR));
System.out.println("LocalDate supports hour-of-day: " + today.isSupported(ChronoField.HOUR_OF_DAY));

System.out.println("Year is supported by LocalDate: " + ChronoField.YEAR.isSupportedBy(today));
System.out.println("Hour-of-day is suppored by LocalDate: " + ChronoField.HOUR_OF_DAY.isSupportedBy(today));

//AMPM_OF_DAY can be 1 or 0, 1 means PM, 0 means AM

//We get the following output form above code;

Current Date Time: 2014-03-01T10:15:24.918 (This may differ, based on time)
Year : <current year>
Month : <current month>
Day : <current day>
Hour-of-Day : <current hour>
Hour-of-AMPM : <current hour>

AMPM-of-day: 0 or 1, depending on AM or PM

Current Date: <YYYY-MM-DD>
LocalDate supports year: true
LocalDate supports hour-of-day: false
Year is supported by LocalDate: true
Hour-of-day is supported by LocalDate: false

//Skipped majority of Time Chapter, cuz repetition of same shit.

FORMATTING DATA;
//Explains legacy Date time formats, skipped as well

REGULAR EXPRESSIONS;
//Regular Expressions is a way to sense patterns or recognize patterns based on certain criterias.

//What follows, is a code structure of how such things can be written;

package com.jdojo.regex;

public class Regexmatch {
      public static void main(String[] args) {
          String regex = ".@.";

          //This is what we will match against, with the occuring pattern to be <something before>@<something after>, albeit, keep in mind that the . is merely for normal characters, in this case.
          //it is as following;

          RegexMatch.matchIt("a@k", regex);
          RegexMatch.matchIt("webmaster@jdojo.com", regex);
          RegexMatch.matchIt("r@j", regex);
          RegexMatch.matchIt("a%N", regex);
          RegexMatch.matchIt(".@.", regex);
      }

      public static void matchIt(String str, String regex) {
          //Test for the pattern match
          if (str.matches(regex)) {
              System.out.println(str + " matches the regex " + regex);
          }
          else {
              System.out.println(str + " does not match the regex " + regex);
          }
      }
}

//The output, will be the following;

a@k matches the regex .@.
webmaster@jdojo.com does not match the regex .@.
r@j matches the regex .@.
a%N does not match the regex .@.
.@. matches the regex .@.

//The .@. did not match to the webmaster@jdojo.com, because it only matched part of the word, not the entire thing.
//If you want a proper match, you need to use a capture all, which is (.*).@.(.*)

//A very important concept in terms of regex, is metacharacters ; What follows, is a list of metacharacters;

(
)
[
]
{
}
\
^
$
|
?
*
+
.
<
>
-
=
!

//These are basically keywords, in terms of regex, and can be used in different combinations to modify searching capacities.

//Regex is a way to search String values ; The way to do this, is made by operating keywords and the combination of said keywords.

//For example, [] will match whatever letters are in there, and is written as follows, for example;

"[<letters>]@." //This will match when it finds one of the letters of letters, if one or more of the letters are to the left of the @.

//If you write the follow as an argument of regex;

"[^A-Z]" //This will find any english letter, as long as they are not uppercase.

//You can also add more ranges, to the regex argument, by simple adding on arguments, as follows;

"[a-zA-Z0-9]"; //This will search for any lowercase letter, any uppercase letter and the numbers 0 to 9.

//When you do the ^ FIRST, i.e, before all the letters, it is explicitly saying to not include thoose letters.

//For instance ; 

[^1-9]; //Would mean, do not include these Numbers in the Search.

//another example;

[abc]; //This will search for only the said letters.

[^xyz]; //A character except these.

[a-p]; //Search from a to p, only small letters

[a-cx-z]; //Search from a to c, then x to z. This means, abc and xyz

[0-9&&[4-8]]; //This is intersection of two ranges, meaning ; Within the range of 0-9, search for 4-8, thus, 4, 5, 6, 7, 8

[a-z&&[^aeiou]]; //This is subtraction of the letters range, meaning go between a to z, but exclude a, e, i, o, u

//what follows is a set of pre-defined characters;

. //A dot, means any character.

\d // same as [0-9]

\D // same as [^0-9], not a digit, in other words

\s //A whitespace character, functions the same as \t \n \x0B \f \r 

\S //A non-white space character, the same as [^\s]

\w //A word character, same as [a-zA-Z_0-9], this includes any letters, decimal digits, and underscore.

\W //a non-word character, same as [^\w]

//If you allow uppercase, lowercase, underscore and digits, you can shorten down verification of e-mail adress to be "\w@\w"

//There are three classes to java.util.regex, 

Pattern

Matcher

PatternSyntaxException

//A pattern holds the compiled form of a regular expression, it's a internalized set of data that allows for faster matching of strings.

//A Matcher, tries to match the String to the Pattern, and constitutes the actual match.

//A PatternSyntaxException reports an error, in a malformed regular expression.

THE PATTERN CLASS;

//The pattern class holds the compiled version of the Regular Expression.

//it is immutable, it can be shared and it has no public constructor.

//It has two methods;

static Pattern compile(String regex)

static Pattern compile(String regex, int flags)

//What follows, is an example of how to create a pattern;

String regex = "[a-z]@.";
//Prepare a regular expression

Pattern p = Pattern.compile(regex);
//Compile the regular expression into a Pattern object

//The second version of the pattern compile, allows you to use flags.

//What follows, is a list of different flags and what they do;

Pattern.CANON_EQ //Enables canonical equivilance. If this flag is set, two characters match only if their full canonical decomposition match.
//This means, that the two letters literally must mean the same thing.

Pattern.CASE_INSESITIVE // Enables case insensitive matching, only works for ASCII-US letters.

Pattern.COMMENTS //Permits Whitespace and Comments in a pattern. When this is set, whitespace is ignored and embedded comments starting with # are also ignored until end of line.

Pattern.DOTALL // By default, the expression does not match line terminators. When this flag is set, it matches Any character, including thoose.

Pattern.LITERAL // Enables literal parsing of the pattern. This means that the characters are treated literally, disabling the functionality of \n commands etc.

Pattern.MUTLILINE // By default, the characters ^(Beginning) and $(End), define when the matching stops. If MULTILINE is enabled, it will check to just before or just after line terminators OR
//to the end of the sequence that is being put in.

Pattern.UNICODE_CASE // When done in conjunction with the CASE_INSENSITIVE flag, it will match according to the unicode standard.

Pattern.UNICODE_CHARACTER_CLASS // enables the pre-defined characters of the Unicode to be used

Pattern.UNIX_LINES // Enables Linux lines mode. This , also, causes the \n character to be the only one to be recognized as a line terminator.

//NOTE: Conditional statements are generally not recognized in context of a Regex, when it comes to Java.

//In terms of declaring and using a Regex in Java, you declare several arguments by seperating them with |, in this context, it is not a or system.

//An example follows;

String regex = "A@\n";

Pattern p = Pattern.compile(regex, Pattern.CASE_INSENSITIVE|Pattern.DOTALL);

//When you chain | , they are called flags.
//The | in this case, is a bit or statement ; that compares the bits of said statements.
//basically, it chains together the ones that are true, and discards the ones that are false.

//This allows for much greater memory allocation, as you are basically merging the true bits and discaring the False ones.
//Which in turn, means that you can check a lot more boolean statements at the same time, whilst saving the result in a much more compact format.

//NOTE; go back and read about Bitwise operation AND Date/Time operations.

//When we try to match Strings, we use a class that is a matcher. This matcher, as is, has 4 different Classes inheritly.

//How to match, follows;

String regex = "[a-z]@.";

Pattern p = Pattern.compile(regex);

String str = "abc@yahoo.com,123@cnn.com,ksharan@jdojo.com";

Matcher m = p.matcher(str);

//The Matcher inheritly has 4 classes, that we can interact with the object through.
//They are as follows;

find()

start()

end()

group()



find();

//It is used to find a match for the input. if it succeeds, it returns True.
//Else, it's False. It begins it search at the beginning of the input.

//If the previous call to this method was succesful, it starts searching where the previous search concluded.
//Usually, you use find() in a while loop, to find what you need.

//It is overloaded, as there is another find argument, with a integer argument, that defines the offset of the position that you are searching in.

start();

//It returns the index of the last find that was concluded true. Usually used after find() finds something.

end();

//returns (the index of the last found character in the match + 1), to find the length of your match, you subtract the start() value with the end() value.

//What follows, is a continuation of previous code;

if (m.find()) {
      String foundstr = str.substring(m.start(), m.end());

      System.out.println("Found string is:" + foundStr);
}


group();

//Returns the value of the previous succesful find() method.
//It is also valid to use the .substring method with the arguments of start() and end()

//An example of usage of group();

if (m.find()) {
      String foundStr = m.group();
      System.out.println("Found text is:" + foundStr);
}


//What follows is an example of how to use said methods;

package com.jdojo.regex

import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class PatternMatcher {
      public static void main(String[] args) {
          String regex = "[abc]@.";

          String source = "cric@jdojo.com is a valid email adress."
          PatternMatcher.findPattern(regex, source);

          source = "kelly@dojo.com is invalid"
          PatternMatcher.findPattern(regex, source);

          source = "a@band@yea@u";
          PatternMatcher.findPattern(regex, source);

          source = "There is a @ sign here";
          PatternMatcher.findPattern(regex, source);
      }

      public static void findPattern(String regex, String source) {
          Pattern p = Pattern.compile(regex);

          Matcher m = p.matcher(source);

          System.out.println("n\Regex:" + regex);
          System.out.println("Text:" + source);

          boolean found = false;
          while (m.find()) {
              System.out.println("Matched Text:" + m.group() + 
              ", Start:" + m.start() + ", " + "End:" + m.end());

              found = true;
          }

          if (!found) {
              System.out.println("No match found");
          }
      }
}

//From this, we get the following output;

Regex:[abc]@.
Text:cric@jdojo.com is a valid email address
Matched Text:c@j, Start:3, End:6

Regex:[abc]@.
Text:kelly@jdojo.com is invalid
No match found

Regex:[abc]@.
Text:a@band@yea@u
Matched Text:a@b, Start:0, End:3
Matched Text:a@u, Start:9, End:12

Regex:[abc]@.
Text:There is an @ sign here
No match found

//For every enclosement in a regular expression context, you have to denote with a \ for singular chars,
//If you encase with 2 sets of [], as in [[0-9]], you have to write that as \[[0-9]\] to get it as a metacharacter
//To define it as a string literal, we must put it in another set of \'s, as follows \\[[0-9]\\]]

//QUANTIFIERS OF REGULAR EXPRESSIONS;

//There are quantifiers for Regular Expressions, that allows you to say how many times you want to do something, or doing them in a range.
//What follows, is how to do that;

* //This is a 0 or more times quantifier

+ //This is a 1 or more times quantifier

? //This is a once or not at all quantifier

{m} //This is exactly m times

{m, } //This is at least m times

{m, n} //At least m, but not more than n times

//Quantifiers, come after the specification of what you are looking at.

//So for instance, if we are looking for a word, fact is, 1 or more words, we could do as follows;

\w+@\w+

//What follows, is the operators for matching boundaries

^ //The beginning of a line
$ //The end of a line
\b // A word boundry
\B // A non-word boundry
\A // The beginning of the input
\G // the end of previous match
\Z // The end of the input but for the final terminator, if any
\z // the end of the input


//What follows, is how to practically use regular expression matchings

package com.jdojo.regex;

public class MatchBoundary {
      public static void main(String[] args){
          //prepare regular expression. use \\b to get \b inside the string literal

          String regex = "\\bapple\\b";
          String replacementStr = "orange";
          String inputStr = "I have an apple and five pineapples.";
          String newStr = inputStr.replaceAll(regex, replacementStr);

          System.out.println("Regular Expression: " + regex);
          System.out.println("Input String: " + inputStr);
          System.out.println("Replacement String: " + replacementStr);
          System.out.println("New String: " + newStr);
      }
}

//we'get the following outpot from this;

Regular Expression: \bapple\b
Input String: I have an apple and five pineapples
Replacement String: orange
New String: I have an orange and five pineapples

//There are two boundry matches;

^ (beginning of a line)

and

\A (beginning of the input)

GROUPS AND BACK REFERENCING;

//You can create groups, from characters.
//to create a group in terms of Regular expressions, you put them in parenthesis, as follows;

(<chars>)

//The accounted number for groups, is at least 0, as the original input accounts for being as a group, albeit it is not reported.

//Every group, is accounted for, by what number they are in the breakdown order.
//This can be found, as follows;

Original Group = AB(XY)

AB(XY) = Group 0

(XY) = Group 1

//groupCount() will count 1 class

Original Group = (AB)(XY)

(AB)(XY) = group 0
(AB) = group 1
(XY) = Group 2

//groupCount() will count 2 classes

Original group = ((A)((X)(Y)))

((A)((X)(Y))) = Group 0

((A)((X)(Y))) = Group 1

(A) = Group 2

((X)(Y)) = Group 3

(X) = Group 4

(Y) = Group 5

//groupCount() will count 5 classes

Original group = ABXY

ABXY = Group 0

//groupCount() will count 0 Classes

//You can "Backtrack" to older groups, with reference by virtue of their group number
//It can be done as follows;

original group = (ab)xyab

Wanted result = abxyab

Can be written as = abxy/1 
//The /1 refers to Group 1, which it automaticlaly puts there. If there is more in the reference than there is groups, it will assume it's a String literal.
//Which, then leaves it writen as abxy1

//You can sort the results of a matched reference, in terms of grouping. It can be done as follows;

//To find numbers in a text, assuming they are 10 digits long, consisting of the 3 first being Regional numbers, we could do as follows;

\b\d{10}\b //This sorts the 10 digits into a group.

\b\(\d{3})\d{7}\b //This would sort each match, as two parts, one group with the 3 first as numbers, and another group with the remaining 7.

//If we had a match object, that was related to this matched pattern, we could find the 3 first digit, by virtue of;

m.group(1)
//Which would return the group of the 3 first digits.

//We could also do m.group(0), if we just plain wanted to have everything at once.

package com.jdojo.regex;

import java.util.regex.Pattern;
import java.util.regex.Matcher;

public Class PhoneMatcher {
      public static void main(String[] args) {
          String regex = "\\b(\\d{3})\\d{7}\\b";

          Pattern p = Pattern.compile(regex);

          String source = "3342449027, 2339829, and 6152534734";

          Matcher m = p.matcher(source);

          while(m.find()) {
              String phone = m.group();
              String areaCode = m.group(1);
              System.out.println("Phone: " + phone + ", Area Code: " + areaCode);


          }
      }
}

//The output we would get, is the following;

Phone: 3342449027, Area Code: 334
Phone: 6152534734, Area Code: 615

//stylish!

//What if we want to format the phone numbers, to be so that we have (XXX) XXX-XXXX?
//This can be done, by grouping, as follows;

String regex = "\\b(\\d{3})(\\d{3})(\\d{4})\\b";

//Compile
Pattern p = Pattern.compile(regex);

String source = "3342449027, 2339829, and 6152534734";

Matcher m = p.matcher(source);

while(m.find())) {
      System.out.println("Phone: " + m.group() + ", Formatted Phone: (" + m.group(1) +") " + m.group(2) + "-" + m.group(3));
}

//This will give us the followering pattern;

Phone: 3342449027, Formatted Phone: (334) 244-9027
Phone: 6152534734, Formatted phone: (615) 253-4734

//What follows, is an example of how to backtrace with groups in terms of using Regex;

package com.jdojo.regex;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class MatchAndReplace {
      public static void main(String[] args) {
          /Prepare the String by dividing it into groups
          String regex = "\\b(\\d{3})(\\d{3})(\\d{4})\\b";
          String replacementText = "($1) $2-$3";
          String source = "3342449027, 2339829, and 6152534734";

          Pattern p = Pattern.compile(regex);

          Matcher m = p.matcher(source);

          String formattedSource = m.replaceAll(replacementText);

          System.out.println("Text: " + source);
          System.out.println("Formatted Text: " + formattedSource);
      }
}

//This will give us the output of;

Text = 3342449027, 2339829, and 6152534734
Formatted Text: (334) 244-9027, 2339829, and (615) 253-4734

//You can acheive the same result, by just using the String Class, as follows;

String regex = "\\b(\\d{3})(\\d{3})(\\d{4})\\b";
String replacementText = "($1) $2-$3";
String source = "3342449027, 2339829, and 6152534734";

String formattedSource = source.replaceAll(regex, replacementText)

//You can also assign names to groups and use them by name reference.
//You can define names for groups, as follows;

(?<groupName>pattern)

//The group name must consist of numbers and digits, a-z, A-Z, 0-9
//the group name must start with a letter.
//What follows, is a regex that uses 3 different group names.

\b(?<areaCode>\d{3})(?<prefix>\d{3})(?<lineNumber>\d{4})\b

//Since areaCode and prefix use the same pattern, we can re-write it with backtracking by using areaCode with name reference;

\b(?<areaCode\d{3})\k<areaCode>(?<lineNumber>\d{4})\b

//You can reference a group, in a replacement text, with $(groupName).
//What follows, is an example of this;

String regex = "\\b(?<areaCode>\\d{3})(?<prefix>\\d{3})(?<lineNumber>\\d{4})\\b";
String replacementText = "(${areaCode}) ${pre-fix}-${lineNumber}";

//You can still reference a group, by their number, even if they have a name.
//What follows, is the above code, except we make the call to the third group, by number, whilst keeping the others by name;

String regex = "\\b(?<areaCode>\\d{3})(?<prefix>\\d{3})(?<lineNUmber>\\d{4})\\b";
String replacementText = "(${areaCode}) $(pre-fix}-$3";

//Sometimes, it can be easier to reference them by number, if you already know their number and it's a small group.
//Otherwise, you can reference by name for clarity. It depends on the situation.

//What follows, is an example of how to use named groups in Regular expressions;

package com.jdojo.regex;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class NamedGroups {
      public static void main(String[] args) {
          String regex = "\\b(?<areaCode>\\d{3})(?<prefix>\\d{3})(?<lineNumber>\\d{4})\\b";

          //refernece the first two groups by name, the last by number

          String replacementText = "(${areaCode}) ${pre-fix}-$3";

          String source = "3342449027, 2339829, and 6152534734";

          Pattern p = Pattern.compile(regex);

          Matcher m = p.matcher(source);

          String formattedSource = m.replaceAll(replacementText);

          System.out.println("Text: " + source);
          System.out.println("Formatted Text: " + formattedSource);
      }
}

//we'd get the following from this;

Text: 3342449027, 2339829, and 6152534734
Formatted Text: (334) 244-9027, 2339829, and (615) 253-4734

//When you have found a match, you can run the Matcher.start() and Matcher.end() methods to know the match boundary for the groups.
//There are several options for these, as follows;

int start()

int start(int groupNumber)

int start(String groupName)

int end()

int end(int groupNumber)

int end(String groupName)

//The ones that take no arguments, return the start and the end of the match.

//if you put in the groupNumber, it will return for the start/end of that groups number, if you do it by groupName, it's by that groups name etc.

//What follows, is an example of how to use it;

String regex = "\\b(?<areaCode>\\d{3})(?<prefix>\\d{3})(?<linerNumber>\\d{4})\\b";

String source = "3342449027, 2339829, and 6152534734";
System.out.println("Source Text: " + source);

Pattern p = Pattern.compile(regex);

Matcher m = p.matcher(source);

while(m.find()) {
      String matchedText = m.group();
      int start1 = m.start("areaCode");
      int start2 = m.start("prefix");
      int start3 = m.start("lineNumber");

      System.out.print("Matched Text:" + matchedText);
      System.out.print(". Area code start:" + start1);
      System.out.print(", Prefix start:" + start2);
      System.out.println(", Line Number start:" + start3);
}

//We'd get the following output;

Source Text: 3342449027, 2339829, and 6152534734
Matched Text: 3342449027. Area code start:0, Prefix start:3, Line Number start:6
Matched Text: 6152534734. Area code start:25, Prefix start:28, Line Number start:31

//You can reset where the Matcher is "currently pointing to", be that the String or where it is in said string.
//it can be done by the Matcher.reset() method.

//They go as follows;

Matcher.reset() //Just starts over again, from the beginning of the input
Matcher.reset(<another input>) //Which then applies the matcher pattern to the new input

//How would we form, a regular expression, if we want to match against the following;

//be in the form of name@domain
//must start with alphanumeric characters (a-z, A-Z, 0-9)
//The name must have at least one character
//The name part, may have any character of the (a-z,A-Z, 0-9, underscore, hypen or dot)
//The dot in the domain part must contain at least one dot
//The dot in domain name must be preceded and followed by at least one alphanumerical character
//You should also be able to refer to the name and the domain parts using group numbers. This validation states,
//that you place name and domain part as groups inside the regular expression

//Group 1 is the name part, group 2 is the domain;

([a-zA-Z0-9]+[\\w\\-.]*)@([a-zA-Z0-9]+\\.[a-zA-Z0-9\\-.]+)

//The issue with this one, is that it allows 2 dots in the domain part.

Find and Replace using Regular Expression;

//There are two classes for Finding and replacing, when it comes to Regular Expressions;

Matcher appendReplacement(StringBuffer sb, String replacement)
StringBuffer appendTail(StringBuffer sb)

//Assume we have a String as follows;

"A train carrying 125 men and women was traveling at the speed of 100 miles per hour. The train fare was 75 dollars per person."

//What if we want to re-write it, as follows;

"A train carrying more than a hundred men and women was traveling at the speed of a hundred miles per hour. The train fare was less than a hundred dollars per person."

//To sort out the numbers, on word boundaries, we do the following;

String regex = "\\b\\d+\\b"; //This is our Regex

Pattern.p = Pattern.compile(regex);



String text = "A train carrying 125 men and women was traveling" + " at the speed of 100 miles per hour. The train" + " fare was 75 dolars per person.";

Matcher m = p.matcher(text);


//we have to create a StringBuffer to hold the String value to which we are to operate upon;

StringBuffer sb = new StringBuffer();

//Start a While loop to find matches;

String replacementText = "";

String matchedText = m.group();

int num = Integer.parseInt(matchedText);

if (num == 100) {
      replacementText = "a hundred";
}
else if (num < 100) {
      replacementText = "less than a hundred";
}
else {
      replacementText = "more than a hundred";
}

m.appendReplacement(sb, replacementText); //Here, we call the appendReplacement method with a Empty stringbuffer and the replacementText that we want to put in

//The appendReplacement first checks if there was an earlier match.
//If it is the first match (i.e, no earlier found) - it append the replacementText in the beginning. 
//What it appends, is from the beginning of the input to the first character of the match. //THIS COUNTS FOR FIRST MATCH

//We could call this "temp";

//"temp", is now holding "A train carrying ";
//appendReplacement then appends the argument that it was fed to replace, in this case, it was assigned more than a hundred;

//Thus, Stringbuffer, becomes "temp" + the argument;

//Stringbuffer = "A train carrying more than a hundred"

//It then moves the location for where it is to replace, to be right after where the first match was found.

//You call find() again, it will repeat the pattern, find the second number, put the starting position to where the last saved position was, and append whatever you put in

//At this point, your Stringbuffer will be;

"A train carrying more than a hundred men and women was traveling at the speed of a hundred"

//When you call find the third time, you'll have ended up with the following;

"A train carrying more than a hundred men and women was traveling at the speed of a hundred miles per hour. The train fare was less than a hundred"

//To append the last, final piece of the puzzel, you must call the function of appendTail(). 
//It can be done as followers;

m.appendTail(sb);

//Then the stringbuffer will be, a grand total, of the following;

"A train carrying more than a hundred men and women was traveling at the speed of a hundred miles per hour. The train fare was less than a hundred dollars per person."

//What follows, is the full program and execution of it;

package com.jdojo.regex;

import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class AdvancedFindReplace {
      public static void main(String[] args) {
          String regex = "\\b\\d+\\b";
          StringBuffer sb = new StringBuffer();

          String replacementText = "";
          String matchedText = "";

          String text = "A train carrying 125 men and women was travling at" + " the speed of 100 miles per hour. " + "The train fare was 75 dollars per person." ;

          Pattern p = Pattern.compile(regex);
          Matcher m = p.matcher(text);

          while(m.find()) {
              matchedText = m.group();

          //Conver the text into an integer for comparing
          int num = Integer.parseInt(matchedText);

          if (num == 100) {
              replacementText = "a hundred";
          }
          else if (num < 100) {
              replacementText = "less than a hundred";
          }
          else {
              replacementText = "more than a hundred";
          }

          m.appendReplacement(sb, replacementText);
      }

      m.appendTail(sb);

      System.out.println("Old Text: " + text);
      System.out.println("New Text: " + sb.toString());

      }

}

//We then have converted all of the occurances of numbers, with checks, using a pattern matcher and replaced it with values from our StringBuffer.

ARRAYS;

//In java, Arrays have a set Length and a specific set type of data that it can hold.

//You can declare a Array, in two ways;

<type> <variable name>[<length of array>]

or 

<type>[<length of array>] <variable name>

//Arrays are objects.

//What follows, is a number of ways to declare Arrays;

int[] empId;

empId = new int[5];

int[] empId = new int[252];

int total = 23;
int[] array1 = new int[total];
int[] array2 = new int[total * 3];

int[] empId = new int[5];
Object obj = empId; //Since Arrays are objects, this is a valid assignment
//To enable this kind of assignment and support operation later on, you have to further cast it.

int[] tempIds = (int[])obj;

//You can see the length of a variable with;

int temp = <array name>.length;

//What follows, is an example of a for loop operating on an array;

for (int i = 0 ; i < <array name>.length; i++) {
      <array name>[i] = (i + 1) * 10; //This is just an example of operation on a element of the Array
}

//The length of an array, is final. You cannot change it after it has been initialized to be a certain length.

//When arrays initialize, they initialize to default values, as follows;

int = 0

boolean = false

String = null

references = null

//What follows, is a class that prints out the default values of initialized Arrays;

package com.jdojo.array;

public class ArrayInit {
      private boolean[] bArray = new boolean[3]; //A instance variable

      public ArrayInt() {
          //Print out the default values of the bArray

          for (int i = 0; i < bArray.length; i++) {
              System.out.println("bArray[" + i + "]:" + bArray[i]);
          }
      }

      public static void main(String[] args) {
           System.out.println("int aray initialization");

           int[] empId = new int[3];

           for (int i = 0; i < empId.length; i++) {
               System.out.println("empId[" + i + "]:" + empId[i]);
           }

           System.out.println("boolean array initialization");

           // Initial value for bArray elements are displayed
           // inside the constructor
           new ArrayInit();

           System.out.println("Reference type array initialization:");

           String[] name = new String[3]; //A local array variable

           for (int i = 0 ; i < name.length; i++) {
               System.out.println("name[" + i + "]:" + name[i]);
           }
      }
}

//The output we would get from this, would be the following;

int array initialization:
empId[0] = 0
empId[1] = 0
empId[2] = 0
boolean array initialization:
bArray[0]:false
bArray[1]:false
bArray[2]:false
Reference type array initialization:
name[0]:null
name[1]:null
name[2]:null

//You have to Initialize arrays, before you use them. What follows, is a oversight of how to do it;

String[] name = new String[5]: //A string array of 5 length

for (int i = 0 ; i < name.length; i++) {
      name[i] = "name" + (i + 1);
}

int len2 = name[0].length();

//If we would try to reference the elements of the array that are within the name String array, we would get a runtime error, as we would try to call a .length() function on a null value.

//You can also initialize Arrays in a different manner, as follows;

int[] empId = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

int[] empId = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, } //This is also a valid declaration

int[] empId = new int[]{1, 2, 3, 4, 5}; //Also valid

//You can also declare a empty Array list, as follows;

int[] emptyIntArray = { };

//You can also initialize an Array with string objects, as follows;

String[] name = {new String("Sara"), new String("Joe")};

//You can also use string literals;

String[] name = {"Sara", "Joe"};

//You can even initialize an array with Objects in it;
//NOTE; THIS ASSUMES YOU HAVE A CLASS THAT IS VALID AND CREATES INSTANCES FOR YOU TO USE;

Account[] ac = new Account[]{new Account(1), new Account(2)};

//Remember, when you do this kind of initialization, you cannot initialize the length of the array to your choosing, it is as long as the amount of elements in it

//The way to solve the length issue of the Array, is to simply use the static arraycopy() method of the java.lang.System class or using a loop.

//What follows, is an example of how to copy arrays;

int originalLength = 100;
int new Length = 15;
int[] ids = int[originalLength];

int[] tempIds = new int[newLength];
int elementsToCopy = 0;

if (originalLength > newLength) {
      elementsToCopy = newLength
}
else {
      elementsToCopy = originalLength;
}

for (int i = 0; i < elementsToCopy; i++) {
      tempIds[i] = ids[i];
}

ids = tempIds;

//This was basically a "Manual" way, of copying the elements of one array, and putting them in another.


//Or, you can use the Method of arraycopy(), which is as follows;

public static void arraycopy(Object sourceArray, int sourceStartPosition, Object destinationArray, int destinationStartPosition, int lengthToBeCopied);

//sourceArray is a reference to the source array, obviously
//soruceStartPosition is from which index it is to start copying, in the Source Array
//destinationArray is the reference to the destination array

//destinationStartPosition is the start index in the destination array, to which the copied elements will be put in
//lengthToBeCopied is the number of elements to be copied

//Thus, you can replace the "manual" way, with the following method call;

System.arraycopy (ids, 0, tempIds, 0, elementsToCopy);

//There is also, two types of objects, that can have a varied length, which are the following;

java.utilArrayList and java.util.Vector

//What follows, is a class approach to copying Arrays;

package com.jdojo.array;

import java.util.Arrays;

public class ArrayCopyTest {
      public static void main(String[] args) {
          //have an array with 5 elements
          int[] data = {1,2,3,4,5 };

          //expand the array to 7 elements
          int[] eData = expandArray(data, 7);

          //Shorten the array to 3 elements
          int[] tData = expandArray(data, 3);

          System.out.println("Using-for-loop...");
          System.out.println("Original Array: " + Arrays.toString(data));
          System.out.println("Expanded Array: " + Arrays.toString(data));
          System.out.println("Truncated Array: " + Arrays.toString(data));

          eData = new int[9];
          tData = new int[2];
          System.arraycopy(data, 0, eData, 0, 5);
          System.arraycopy(data, 0, tData, 0, 2);

          System.out.println("Using System.arraycopy() method...");
          System.out.println("Original Array: " + Arrays.toString(data));
          System.out.println("Extended Array: " + Arrays.toString(eData));
          System.out.println("Shortened Array: " + Arrays.toString(tData));
      }

      //Use a for loop to copy an Array

      public static int[] expandArray(int[] oldArray, int newLength) {
          int originalLength = oldArray.length;

          int[] newArray = new int[newLength];
          int elementsToCopy = 0;

          if (originalLength > newLength) {
              elementsToCopy = newLength;
          }
          else {
              elementsToCopy = originalLength;
          }

          for (int i = 0; i < elementsToCopy; i++) {
              newArray[i] = oldArray[i];
          }

          return newArray;
      }
}

//The output that we get from this, is as follows;

Using for-loop...
Original Array: [1,2,3,4,5]
Expanded Array: [1, 2, 3, 4, 5, 0, 0]
Truncated Array: [1,2,3]
Using System.arraycopy() method...
Original Array: [1, 2, 3, 4, 5]
Expanded Array: [1, 2, 3, 4, 5, 0, 0, 0, 0]
Truncated Array: [1,2]

VARIABLE-LENGTH ARRAYS;
//There are two Classes that are part of the java.util package that is relevant here


ArrayList

and

Vector

//The only difference between these, is that Vector is Synchronized, whilst ArrayList is not.

//If your object is accessed and modified by several threads at the same time, you should use Vector.
//It will be slower, but it will be Thread safe.

//Otherwise, just use ArrayList

//The difference between Arrays and ArrayList, is that ArrayList inheritly only works with objects.
//Thus, you need to use wrapper classes, to put Primitive data types into ArrayList

//What follows, is how to use ArrayList

import java.util.ArrayList;

ArrayList<Integer> ids = new ArrayList<>(); //To make a ArrayList able to handle Int values, we need to declare it to be an int ArrayList with a Wrapper Class

int total = ids.size(); // Zero currently

System.out.println("ArrayList size is " + total);
System.out.println("ArrayList elements are " + ids);

ids.add(new Integer(10)); //Add an integer object, worth of 10
ids.add(20); //Another int, autoboxing occurs
ids.add(30); //Another int, autoboxing occurs

total = ids.size(); //Total will be 3

System.out.println("ArrayList size is " + total);
System.out.println("ArrayList elements are " + ids);

//The clear command, is a command that empties an array list
ids.clear();

total = ids.size(); //Total will be 0, because we cleared it

System.out.println("Arraylist size is " + total);
System.out.println("ArrayList elements are " + ids);

//The output we'd get, is as follows;

ArrayList size is 0
ArrayList elements are []
ArrayList size is 3
ArrayList elements are [10,20,30]
ArrayList size is 0
ArrayList elements are []

//To retrieve the element of indexes in an ArrayList, you have to use the get() method, as follows;

int secondID = ids.get(1); //Autoboxing is at play

//You can check if a value is in an array, and it returns as a boolean value;

boolean RandomName = ids.contains(<variable to be found>);

//we can get iterate through an array with a for loop, as follows;

int total = ids.size();

for (int i = 0 ; i < total; i++) {
      int temp = ids.get(i);
      //Do something with temp
}

//We can also iterate through an array, whilst ignoring the indexes of said ArrayList

for (int temp : ids) {
      //Do some processing with temp
}



//What follows, is how to interact with Arraylists in a Class manner;

package com.jdojo.array;

import java.util.ArrayList;

public class NameIterator {
      public static void main(String[] args) {
          ArrayList<String> nameList = new ArrayList<String>();

          nameList.add("Chris");
          nameList.add("Lizzy");
          nameList.add("Frank");
          nameList.add("Jasmine");

          int count = nameList.size();

          System.out.println("list of names...");
          for(int i = 0 ; i < count; i++) {
              String name = nameList.get(i);
              System.out.println(name);
          }

          //Let's remove Frank from the list.

          nameList.remove("Frank");

          count = nameList.size();

          System.out.println("After removing Frank...");
          for(int i = 0 ; i < count; i++) {
              String name = nameList.get(i);
              System.out.println(name);
          }
      }
}


//We get the following output from having done this;

List of names...
Chris
Lizzy
Frank
Jasmine
After removing Frank...
Chris
Lizzy
Jasmine

//You can pass an arguemtn as an argumetn to a method or constructor, it must follow the type parameter of said method or constructor
//It looks something like this;

modifiers returnType methodName(ArrayType argumentName, ...)

//What follows, is a few examples of how this can work;

//The processSalary has two parameters:
//1. id is an array of int
//2. salary is an array of double

public static void processSalary(int[] id, double[] salary) {
      //Code goes here
}

//The setAKA() method has two parameters
//1. id is int (It is simply int type, not array of int)
//2. aka is an array of String

public static void printStates(String[] stateNames) {
      //Code goes here..
}

//The printStates method has one parameter;
//Which is a String array

//What follows, is how to build a class that mimicks the toString()  method of the ArrayList class
//It accepts an Int array, and returns a string value seperated with commas, as follows;

public static String arrayToString(int[] source) {
      if (source == null) {
          return null;
      }
      //use Stringbuilder to improve performance

      StringBuilder result = new StringBuilder("[");

      for (int i = 0; < source.length; i++) {
          if (i == source.length - 1) {
                  result.append(source[i]);
          }
          else {
                  result.append(source[i] + ",");
          }


      }

      results.append("]");
      return result.toString();
}

//You can call the above code, with the following example;

int[] ids = {10, 15, 19};
String str = arrayToString(ids); //Pass ids int array to arrayToString() method

//What follows, is a class that interacts with the Array by using the swap() method that switches place of two integers

package com.jdojo.array;

public class Swap {
      public static void main(String[] args) {
          int[] num = {17, 80};

          System.out.println("Before swap");
          System.out.println("#1: " + num[0]);
          System.out.println("#2: " + num[1]);

          //call the swap method, THE SWAT TEAM

          swap(num);

          System.out.println("AFTER SWAP YO");
          System.out.println("#1: " + num[0]);
          System.out.println("#2: " + num[1]);
      }

      // The swap method accepts and int array as argument and swaps the values if it contains 2 values

      public static void swap(int[] source) {
          if (source != null && source.length == 2) {
                  int temp = source[0];
                  source[0] = source[1];
                  source[1] = temp;
          }
      }
}

//With the said code, we would get the following;

Before swap
#1 : 17
#2 : 80

AFTER SWAP YO
#1: 80
#2: 17

//We could switch the values, because we had an actual array. The original array was passed here.

//in case we want to keep the original intact, we must create a copy of the Array, first.

//You can do a quick copy by the virtue of the clone() method of array, which works fine, if it's Primtive data types, as it generates a True copy.

//However, if it's an Array of references or objects, we have to make a Deep copy, to assert that we have a true copy, and not just another list of references to the same objects.

//NOTE; The return type of clone() is Object, so you need to cast it to whatever you want to return it as

int[] ids = {1,2,3};

int[] cloneIds;

cloneIds = (int[])ids.clone() //This works fine, as the list we are cloning, is a int array

String[] names = {"Lisa", "Pat", "Kathy"};

String[] clonedNames;

clonedNames = (String[])names.clone(); //This is not fine, as Strings are inheritly objects, thus, they are referening to the same String objects

//When we refer to the parameters of an Array, there are 3 things we can mean ;

Array parameter reference

Elements of the array parameter

The object referred by the array parameter elements

//Because an array is an object, a copy of it's reference is passed to the method.
//Thus, when you are inside a method, and handling a reference of an array, the actual parameter of the original array, may remain unchanged;
//Whilst, the effects of modification, are active, whilst in the Methods body.

//What follows, is an example of this;

package com.jdojo.array;

import java.util.Arrays;

public class ModifyArrayParam {
      public static void main(String[] args) {
          int[] origNum = {101, 307, 78};
          System.out.println("Before method call:" + Arrays.toString(origNum));

          tryArrayChange(origNum);

          System.out.println("After method call:" + Arrays.toString(orignum));
      }

      public static void tryArrayChange(int[] num) {
          System.out.println("Inside method-1:" + Arrays.toString(num));

          num = new int[]{10, 20};

          System.out.println("Inside method-2:" + Arrays.toString(num));
      }
}

Before method call:[101, 307, 78]
Inside method-1:[101, 307, 78]
Inside method-2:[10, 20]
After method call: [101, 307, 78]

//Since we modified the Array reference, we did not actually modify the original array.

//If you wish to stop the possibility of your Array being modified inside the method, you just need to declare the Array as final when you pass it;

public static void tryArrayChange(final int[] num) { <--- //Final causes it to be unmodifiably
      num = new int[]{10, 20}; //This will not work, cause it is set to be Final in the constructor
}



//What follows, is an example of changing elements of an array inside of a Method

package com.jdojo.array;

import java.util.Arrays;

public class ModifyArrayElements {
      public static void main(String[] args) {
          int[] origNum = {10, 89, 7}
          String[] origNames = {"Mike", "John"};
          System.out.println("Before method call, origNum:" + Arrays.toString(origNum));
          System.out.println("After method call, origNames:" + Arrays.toString(origNames));
      }

      public static void tryElementChange(int[] num) {
          if (num != null && num.length > 0) {
              num[0] = 1116;
          }
      }

      public static void tryElementChange(String[] names) {
          if (names != null && names.length > 0) {
              names[0] = "Twinkle";
          }
      }
}

Before method call, origNum:[10, 89, 7]
Before method call, origNames:[Mike, John]
After method call, origNum:[1116, 89, 7]
After method call, origNames:[Twinkle, John]

//Thus, we learn the difference of actually differing Arrays.
//If you simply change the reference of the Array, ie, try to assign it as a new array and change the reference, the original one is actually unaffected, outside of returning the value and then assigning it

//if you wish to operate on the actual array, you have to actually access the elements in the method and modify them directly;

//Also, if you pass the array argument as final, you can still change the arguments in the method, by direct accessing with index etc.
//You can just not re-define it as trying to assign it to be something else.

//An example of this, would be

final int[] num = {10,10, 10}

int[] num = {20, 20} //Won't work, as it's declared Final

num[0] = 400 //Works, despite final, cause you are accessing the direct element and changing it, you are not redefining the Array

//What follows, is examples of what happens when you wish to actually modify the object in question, and not just the reference to an object, when it is passed in an Array;

package com.jdojo.array;

public class Item {
      private double price;
      prive String name;

      public Item {String name, double initialPrice) {
          this.name = name;
          this.initialPrice = initialPrice;
      }
      public double getPrice() {
          return this.price;
      }
      public void setPrice(double newPrice ) {
          this.price = newPrice;
      }

      public String toString() {
          return "[" + this.name + ", " + this.price + "]";
      }
}

//Above is just a item class

//What follows, is an example, of how to access the original object, which, we of course, do through a setXXX method;

package com.jdojo.array;

public class ModifyArrayElementState {
      public static void main(String[] args) {
          Item[] myItems = {new Item("Pen", 25.11), new Item("Pencil", 0.10)};
          System.out.println("Before method call #1:" + myItems[0]);
          System.out.println("before method call #2:" + myItems[1]);

          //call the method by passing the array of item
          tryStateChange(myItems);

          System.out.println("After method call #1:" + myItems[0]);
          System.out.println("After method call #2:" + myItems[1]);
      }

      public static void tryStateChange(Item[] allItems) {
          if (allItems != null && allItems.length > 0) {
                  allItems[0].setPrice(10.38);
          }
      }
}

//From this, we would get the following output;

Before method call #1: [Pen, 25.11]
Before method call #2: [Pencil, 0.1]

After method call #1: [Pen, 10.38]
After method call #2: [pencil, 0.1]

//If you store the instance of an object in an Array, you should be careful, as when you return that Array, people would be able to modify the actual object.
//What follows, is an example of just this happening, and is something you should avoid;

public class MagicNumber {
      //These numbers are not meant for changing, albeit they can be observed
      private int[] magicNumbers = {5, 10, 15, 20, 25};

      //Some other code goes here

      public int[] getMagicNumbers () {
          //What follows, is something you should never do.
         return this.magicNumbers; //DO NOT DO
          //this is the actual object, which is then able to be modified. Never, ever, ever, do this.

          //if it's a Reference array, make a deep copy, if it's a primitive data type, just make a shallow copy with clone();

          return (int[])magicNumbers.clone();
          //never pass the original, just give a clone to pass the data but not giving them the chanse to modify the actual object per say.
      }
}

//You can also pass a Array, without actually declaring it as a reference first, when it comes to methods, in the way as follows;

setNumbers(new int[]{10, 20, 30});

RUNNING FROM COMMAND PROMPT;

//You can run Java from the command promt in the following way;

java <<options-list>> <<classname>>
//options-list is optional

//You can further more distinguish the command, by adding arguments in the command prompt as follows;

java <<classname>> <<List of Command-line Arguments>>

//Each argument is seperated by space, as follows in the example;

java com.jdojo.array.Test Cat Dog Rat

//The proceduer of running this, is as follows;

The JVM parses the argument list using space as a separator.

It creates a String array that is the same length as the number of arguments in the list.

It populates the String array with items in the arguments list sequentially.

It then passes said String array, to the Test class that you are running.

This is where the String[] part of Main functions come into play; if your Main does not have one, the JVM will create one with the length of 0
and feed the String value to it, if you run from the Command line

You can also feed arguments that inheritly have space in em, by enclosing them with "'s

You can also stop the system from interpeting special characters, by encasing them in "'s

//What follows, is an example of a Class that makes use of the Commandline;

package com.jdojo.array;

public class CommandLine {
      public static void main(String[] args) {
          System.out.println("Total arguments:" + args.length);

          for(int i = 0 ; i < args.length; i++) {
              System.out.println("Argument #" + (i+1) + ":" + args[i]);
          }
      }
}

//An example of this, is as follows;

java com.jdojo.array.CommandLine //Total arguments: 0

java com.jdojo.array.CommandLine Cat Dog Rat //Total Arguments: 3 #1 Cat #2 Dog #3 Rat

java com.jdojo.array.CommandLine "Cat Dog Rat" //Total arguments: 1 #1 Cat Dog Rat

java com.jdojo.array.CommandLine 29 Dogs //Total arguments: 2 #1 29 #2 Dogs

//The interesting part of running modifications through the Cmd, is that you do not have to re-compile your file, by modifying it in the Cmd

//If you wish to sort in Ascending/Descending order, you can do as follows;

java com.jdojo.array.SortFile <file name>.txt asc //this will sort the Txt file in a ascending matter

java com.jdojo.array.SortFile <file name>.txt //Will also sort the txt file in a ascending matter

java com.jdojo.array.SortFile <file name>.txt desc //This will sort the txt file in a descending matter

//If you wish to use numeric operations through a Main call through the Cmd, an example of this follows;

package com.jdojo.array;

import java.util.Arrays;

public class Calc {
      public static void main(String[] args {
          System.out.println(Arrays.toString(args));

          if (!(args.length == 3 && args[1].length() == 1)) {
              //This is in case of something not being Right

              printUsage();
              return; //Breaks
          }

          //First, we need to parse the numbers

          double n1 = 0.0;
          double n2 = 0.0;
          try {
                   n1 = Double.parseDouble(args[0]); //0 for first argument
                   n2 = Double.parseDouble(args[2]); //2 since 1 is the operator
                   //keep in mind, this calculator will only support +, -, / and *

          }

          catch(NumberFormatException e) {
              System.out.println("Both operands must be a number!");
              printUsage();
              return; //Breaks
          }

          String operation = args[1]; //The operator
          double result = compute(n1, n2, operation); //This is the actual computation and the call to the method we define

          System.out.println(args[0] + args[1] + args[2] + "=" + result);
      }

      public static double compute(double n1, double n2, String operation)
          {
                  double result = Double.NaN; //We initialize the result with being not a number

                  switch (operation) {
                          case "+":
                                  result = n1 + n2;
                                  break;
                          case "-":
                                  result = n1 - n2;
                                  break;

                          case "*":
                                  result = n1 * n2;
                                  break;

                          case "/":
                                  result = n / n2;
                                  break
                          default:
                                  System.out.println("Invalid operation:" + operation);
                  }

                  return result;
          }

          public static void printUsage() {
              System.out.println("Usage: java com.jdojo.array.Calc expr");
              System.out.println("Where expr could be:");
              System.out.println("n1 + n2");
              System.out.println("n1 - n2");
              System.out.println("n1 * n2");
              System.out.println("n1 / n2");
              System.out.println("n1 and n2 are two numbers");
          }
}

//You can use the calculator in the following ways;

java com.jdojo.array.Calc 3 + 7
java com.jdojo.array.Calc 78.9 * 98.5

//To use the *, you must encase it in "", to ensure it's interpetation

java com.jdojo.array.Calc 7 "*" 8

//Note, involving Command lines makes your program less Platform neutral, as some platforms do not support Cmd and some interpet characters differently in that context.

MUTLI-DIMENSIONAL ARRAYS;

//Multi-dimensional arrays have depth, i.e, they have X layers, which you can store for each index.

//They can be written as, for instance in the case of a integral Array;

int [][] table; //This is a two dimensional array, the amount of []'s define the dimensions of it, i.e, the depth of each layer that it has

//An example of a "3 wide" and "2 deep" multi-dimensional array, is as follows;

int [3][2] table;

//now we have 3 indexes on width, and for each index, there is a depth of 2, thus, in total we have 6 storing slots in the Array

//Java does not support true multi dimensional arrays, it simply supports linear, simple Arrays that hold another set of arrays
//You must at least define the size of the first part, in terms of making Multi-dimensional Arrays, as follows;

int [3][] table;

//The standard value of these, are as currently stands, null. To assign the length of the Collumns (After first space, basically), you can do as follows;

table[0] = new int[2]; //This means, that the first one will be of 2 length
table[1] = new int[5]; //They do not need ot be the same depth
table[2] = new int[1]; //They can all be different

//When a Array is like this, it's called a Ragged array

//In text printing context, \t is basically a tab of space between characters 

//When populating Multi-dimensional arrays, you use X amount of nested For loops to populate them, where X is the amount of dimensions, as follows;

package com.jdojo.array;

public class MDAccess {
      public static void main(String[] args) {
          int[][] ra = new int[3][];
          ra[0] = new int[2];
          ra[1] = new int[1];
          ra[2] = new int[3];

          for(int i = 0; i < ra.length ; i++) {
              for(int j = 0; j < ra[i].length; j++){
                  ra[i][j] = i + j;
              }
          }

          for (int i = 0 ; i < ra.length; i++) {
              for (int j = 0 ; j < ra[i].length; j++){
                      System.out.print(ra[i][j] + "\t");
              }

          System.out.println(); //we just add a empty line after each round
          }
      }
}

//With this, we'd get the following output;

0    1
1
2    3    4

//You can initialize multi dimensional array lists just as you can with normal Array lists;

int[][] arr = {{10, 20, 30}, {1,1,1,1}, {444, 444, 444}}; //This is valid.

//The depth is the amount of elements in that specific group. So, in this case, it would be 2 dimensions, divided as follows; 3, 4, 3

//We can do the same with String Arrays, really

String[][] acronymList = {{"JMF", "Java Media Framework"}, {"JSP", "Java Server Pages"}, {"JMS", "Java Message Service"}};

//You can also declare a Empty 2d array, as follows;

int[][] empty2D = { };

//You can iterate with a enhanced form of for iteration through arrays, as follows;

for(DataType e : Array) {
      //Loop body goes here..

      //e contains one element of the array at a time
}

//An example;

int[] numList = {1, 2, 3}
for(int num : numList) {
      System.out.println(num);
}

//this would give us;

1
2
3

//This is basically the same thing as;

for (int i = 0; i < numList.length; i++) {
      int num = numList[i];
      System.out.println(num);
}

//Tho, the format of;

for(DataType e : Array) {
  //blah
}

//is a simplified version, as it does not allow you to customize it as much, nor access indexes etc.
//it's more of a "Iterate through it", kind of loop

//Declaring an array can be done in two ways, as follows;

<type>[] <array name>;

or

<type> <array name>[];

//Java also lets you fiddle around with where you place the [] to define Arrays;

int[] points2d[]; //is a valid 2d Array assignment

int[] points2d[], points3d[][] //is a valid 2d and 3d Array assignment

int[][] points2D, points3D[];

//always use the length check of a Loop, it is only checked Runtime if you are out of boundary, and it is good practice to keep within bounds.
//kinda stupid to go out of bounds for no reason

//The types of the Class that the Array objects are, are as follows;

int array = [I

reference array = [L

byte array = [B

short array = [S

long array = [J

char array = [C

float array = [F

double array = [D

boolean array = [Z

com.jdojo.Person[] = [Lcom.jdojo.Person;

//Whatever you assign to a Array, must be compatible with the type of the Array

//You cannot cast a element in a Array, to a type that is inheritly incompatible with the Arrays type.

//What follows, is an example of this;

Object [] genericArray = new Object[4]; //This is a array with 4 generic objects

String str = (String)genericArray[0]; //When we convert to types, we have to explicitly cast the things
Person p = (Person)genericArray[1];
Account a = (Account)genericArray[2];

//You can't store the Superclass of a class, in an array containing said Type.

//An example of this, follows;

String[] names = new String[3];
names[0] = new Object(); //DOES NOT WORK, BECAUSE OBJECT IS THE SUPERCLASS OF STRING
names[1] = new Person(); //DOES NOT WORK, IS NOT A SUBCLASS OF STRING
names[2] = null; //Works, String can be Null values.

Converting an ArrayList/Vector to an Array;

//Sometimes, you wish to convert an Arraylist or a Vector to a Array.

//This could be because of the following reasons;

Needing to pass a Method a array, that is specifically a array

Storing inputs of a unknown length, and then converting said ArrayList to a Array

Accessing array values, compared to ArrayList elements, is faster. Thus, you will want to do it to improve performance.

//The ArrayList class has a overloaded function, the toArray() function. It is as follows;

Object[] toArray()

or

<T>T[] toArray(T[]a)

//The first method, returns said elements of a ArrayList as a Array of Object.

//The second method, takes a arraylist of any type, as a argument. It takes all the elements, from the ArrayList which is operated upon
//and tries to copy them into the passed arraylist. If there is not enough space, it creates a new one. The new array, will be the same type
//as the one provided. 

//What follows, is a class example of how to use Arrays;

package com.jdojo.array;

import java.util.ArrayList;
import java.util.Arrays;

public class ArrayListToArray {
      public static void main(String[] args) {
          ArrayList<String> al = new ArrayList<String>;
          al.add("Cat");
          al.add("Dog");
          al.add("rat");

          System.out.println("ArrayList:" + al);

          String[] s1 = new String[al.size()];

          String[] s2 = al.toArray(s1); //This returns itself since it has enough space

          System.out.println("s1 == s2:" + (s1 == s2)); //
          System.out.println("s1:" + Arrays.toString(s1));
          System.out.println("s2:" + Arrays.toString(s2));

          s1 = new String[1];
          s1[0] = "Hello!";

          s2 = al.toArray(s1); //This time, s1 does not have enough space, so it creates and returns a new array
          //By this virtue, s1 remains untouched

          System.out.println("s1 == s2:" + (s1 == s2));
          System.out.println("s1:" + Arrays.toString(s1));
          System.out.println("s2:" + Arrays.toString(s2));
      }
}

//we will get the following output;

ArrayList: [cat, dog, rat]
s1 == s2:true
s1:[cat, dog, rat]
s2:[cat, dog, rat]

s1 == s2:false
s1:[hello]
s2:[cat, dog, rat]

INHERITANCE;

//Inheritance is great for when we don't want to repeat identical methods for different classes, for instance.

//To cause inheritance, we need to use the extends keyword;

<<class modifiers>> class <<subClassName>> extends <<SuperclassName>> {
      //do something
}

//remember, there has to be a "is a" relationship, between two classes, for them to inherit.

//i.e, the class inheriting, must have the class it's inheriting from, as it's superclass

//An example of a method that can be great to inherit, is the following one;

package com.jdojo.inheritance;

public class Employee {
      private String name = "Unknown";

      public void SetName(String name) {
          this.name = name;
      }

      public String getName(String name) {
          return name;
      }
}

//These two basic foundation methods, are worth to extend to other classes, for the purpose of getting their name and returning their name (if it's relevant)

//It can be illustrated as follows;

package com.jdojo.inheritance;

public class Manager extends Employee {
      //Temp holding body
}

//This now allows the Manager class, to use itself of SetName and getName

//All classes in Java, inheritly have the Object Class as their Superclass

//In Java, a class can only have One Superclass, albeit a Superclass, can be a Superclass to many Subclasses

//A subclass inherits non private parts, of it's superclass.

//Instance variables, methods and Static methods/variables, are not inherited, as they are not part of a class.

//Protected variables and methods are inherited. 

//package level security methods and variables are only inherited if they are in the same package.

//You can assign a lower ranking hierarchy class to a higher ranked hierarchy class.

//It is called a widening conversion, since you are defining a more explicit class to a more general one.

//To see if you are comitting upcast, we just need to compare the left one to the right one, in assignment.

//If the left one, is a superclass of the right one, then you are comitting upcast, and it is safe.

//To downcast, which is the opposite of upcasting, you need to explicitly cast whatever you are downcasting.

//As follows;

mgr = (Manager)emp;

//There are two parts of confirmation when you run your code that involves DownCasting.

//The first to consider, is that the Type cast, the type within the ()'s, must be legit.
//The second, is the type, on runtime, that comes after the ()'s. If it's not compatible with whatever it was to casted to,
//during runtime, you will get a runtime error.


InstanceOf operator;

//When we want to make sure, that we can do downcasting, we can use the InstaceOf method, to asure what type we are assigning to what.

<<Class Reference Variable>>instanceof <<Class Name or Interface>>

//if <<Class Reference Variable>> refers to an object of class <<Class Name or Interface>>, it returns true.
//NOTE: If <Class Name or Interface>> is null, it will ALWAYS return false.

//What follows, is an example of how to use it;

Manager mgr = new Manager();
Employee emp = mgr;
if (emp instanceof Manager) {
      mgr = (Manager)emp;
}
else {
       //emp is not a Manager type
}

//When you try to use instanceof, you will generate a CompielError, if you try to use a Class, that is not inheritly related to what you have put in as Comparison.
//This means, that if you would try to compare a String object to a Employee Object, you'd get a Compile time error, as a String Object is not related to the hierarchy of Employee Hierarchy

//What follows, is an example of how to compare equality between objects, in terms of Class usage and Inheritance;

package com.jdojo.inheritance;

public class Employee {
       private String name = "Unknown";

       public void setName(String name) {
           this.name = name;
       }

       public boolean equals(Object obj) {
           if (obj instanceof Employee) {
               Employee e = (Employee)obj;
               String n = e.getName();
               isEqual = n.equals(this.name);
           }

           returns isEqual;
       }
}

//This allows us, to compare names between Objects, with the equals method. This is useful for name comparison, and assuming they are of the same Heritance.

Employee emp = new Employee();
emp.setName("John Jacobs");

Manager mgr = new Manager();
mgr.setName("John Jacobs");

System.out.println(mgr.equals(emp)); //True
System.out.println(emp.equals(mgr)); //True
System.out.println(emp.equals("John Jacobs")); //False, because you compare a Employee object with a String object. 

Binding;

//Binding, works as being the process of identifying the accessed class's variables or Methods when you assign them.
//There are two stages, of binding ; runtime binding and compileTime binding. 

compiletime binding //Also known as Early binding, static binding or compile-time binding

runtime binding //Also known as late binding, dynamic binding or runtime binding

//Early binding, occurs during following moments;

All field methods; Static or non-static

Static methods

Non-static final methods

//What follows, is a class example that ilustrates this, in context of inheritance;

// EarlyBindingSuper.java

package com.jdojo.inheritance;

public class EarlyBindingSuper {
      //An instance variable
      public String str = "EarlyBindingSuper";

      public static int count = 100; //A static variable

      public static void print() {
          System.out.println("Inside EarlyBindingSuper.print()");
      }
}

//Inheriting class, but different package, follows;

//EarlyBindingSub.java
package com.jdojo.inheritance;

public class EarlyBindingSub extends EarlyBindingSuper{
      //An instance variable
      public String str = "EarlyBindingSub";

      //A static variable
      public static int count = 200;

      public static void print() {
          System.out.println("Inisde EarlyBindingSub.print()");
      }
}

//What follows, is a java program that tests said two classes, to illustrate order of execution in terms of early binding and late binding;

//EarlyBindingTest.java

package com.jdojo.inheritance;

public class EarlyBindingTest {
      public static void main(String[] args) {
          EarlyBindingSuper ebSuper = new EarlyBindingSuper();
          EarlyBindingSub eSub = new EarlyBindingSub();

          //Will access EarlyBindingSuper.str
          System.out.println(ebSuper.str);

          //Will access EarlyBindingSuper.count
          System.out.println(ebSuper.count);

          //Will access EarlyBindingSuper.print()
          ebSuper.print();

          System.out.println("--------------------------------");

          //Will access EarlyBindingSub.str
          System.out.println(ebSub.str);

          //Will access EarlyBindingSub.count
          System.out.println(ebSub.count);

          //Will access EarlyBindingSub.print()
          ebSub.print();

          System.out.println("---------------------------------");

          //Will access EarlyBindingSuper.str
          System.out.println((EarlyBindingSuper)ebSub).str);

          //Will access EarlyBindingSuper.count
          System.out.println(((EarlyBindingSuper)ebSub).count);

          //Will access EarlyBindingSuper.print()
          ((EarlyBindingSuper)ebSub).print();

          System.out.println("------------------------------------");

          //Assign the ebSub to ebSuper
          ebSuper = ebSub; //Upcasting

          //Will access EarlyBindingSuper.str
          System.out.println(ebSuper.str);

          //Will access EarlyBindingSuper.count
          System.out.println(ebSuper.count);

          //Will access EarlyBindingSuper.print()
          ebSuper.print();
          System.out.println("------------------------------------------");
      }
}

//This will give the following output;

EarlyBindingSuper
100
Inside EarlyBindingSuper.print()
--------------------------------------
EarlyBindingSub
200
Inside EarlyBindingSub.print()
--------------------------------------
EarlyBindingSuper
100
Inside EarlyBindingSuper.print()
--------------------------------------
EarlyBindingSuper
100
Inside EarlyBindingSuper.print()
--------------------------------------

//An example of early binding interaction;

//Will access EarlyBindingSuper.str
System.out.println(((EarlyBindingSuper)ebSub).str);

//Will access EarlyBindingSuper.count
System.out.println(((EarlyBindingSuper)ebSub).count);


//Will Access EarlyBindingSuper.print
((EarlyBindingSuper)ebSub).print();

//When we use casting, the casted Class is considered to be the priority on CompileTime, and thus, they use the Super argument, instead of the Sub's argument, in this context.


LATE BINDING;
//Binding for all non-static, non-final methods follows the rules of late bindings.
//In other words, if you access a Non static method, which is not final, the decision of which one to use, is done at runtime.

//It looks upwards in the chain to find, from the defined Object type, to find what Class has the method.

//What follows, is code that showcases this;

//LateBindingSuer.java

package com.jdojo.inheritance;

public class LateBindingSuper {
      public void print() {
          System.out.println("inside LateBindingSuper.print()");
      }
}

//Then, we define a Subclass that also has the same method name

//LateBindingSub.java

package com.jdojo.inheritance;

public class LateBindingSub extends LateBindingSuper {
      public void print() {
          System.out.println("inside LateBindingSub.print()");
      }
}

//What follows, is an example of the two classes in action, in which priority they are chosen;

//LateBindingTest.java

package com.jdojo.inheritance;

public class LateBindingTest {
      public static void main(String[] args) {
          LateBindingSuper lbSuper = new LateBindingSuper();
          LateBindingSub lbSub = new LateBindingSub();

          lbSuper.print(); //#1

          lbSub.print(); //#2

          ((LateBindingSuper)lbSub).print(); //#3

          lbSuper = lbSub //Upcasting

          lbSuper.print(); //#4
      }
}

//The only one of these, that is refering to the Super class, is the first one, here.

//#1 binds to super, because it looks for an Object type of the LateBindingSuper type, which it finds - And there for, uses the Print, there.

//The logic is the same, in #2, except, it finds it in the Sub, as it refers to Sub.

//#3, at Runtime, is still refering to a Object type that is considered to be of the Subclass type, so it uses Sub there as well

//#4, since we did upcasting, found that lbSuper is the lbSub class, thus, it finds the print in the Subclass.

//In terms of Latebinding versus Early binding, Latebinding is a lot better, as it allows you to create Polymorphism code, and it allows greater distinction of control, compared to
//early binding. Since early Binding binds early, and does not really recognize to the same length that Late binding does.

//The performance hit, that occurs from Late binding, can also be mitigated, through for example Virtual method tables, which makes Late Binding the favored type of binding.

METHOD OVERRIDING;

//When we override a method, in terms of a inhereted method, the method upwards, so to speak, the method in the Superclass, is not affected ; But everything downwards, i.e the current and lower,
//subclasses, are affected by this, as they will inherit the latest definition of the method, depending on the hierarchy. This is due to basic rules of inheritance.

//They too, can override, and define their own, but this sort of defeats the point of inheritance, unless you need to partly inherit some things and others need to be self-defined.

//If we commit overloading (same named method, different amount of arguments) ; Method Overriding, does not occur. They are treated as seperate entities, then.

//What follows, is the rules, of when a method can be overridden, in terms of it having been inherited;

#1 ; The Method must be a instance method. It may not be static. 

#2 ; The name, must be the same, for the overriden method and the new incarnation of the method.

#3 ; The amount of arguments, types, and order, must be the same ; for it to be eligable for overriding. 
//NOTE; This does not apply to reference types, since Java 5, but it will be touched upon later.
//NOTE; Names of arguments, does not matter. If it's a string argument, it can be called msg or str, it does not matter.

#4 ; The return type, of the Overriden method, must be the same, as the new incarnation, If it's regarding Primitive Types.

If it's regarding Reference types, the new incarnation, must be applicable, to the Overriden version, without typecasting.

#5 ; The new incarnation of the method, must have an equal to or lower level of Restriction, compared to it's Overriden counterpart.

The ruleset is as follows;

public // Can override Public

protected // Can override Public ,protected

package-level // can override Public, protected, package-level

#6 ; When it comes to lists of Exceptions, the new incarnation, may not ADD to the list of exceptions, of the Overriden method.
It can REMOVE, one or all, it can REPLACE, one or all, But it CANNOT, ADD, to the list of the Overriden method.

//NOTE; THIS APPLIES TO CHECKED EXCEPTIONS

//Let's take a look at some interactions of said Rules;

public class P {
      public Employee getEmp(int empId) throwsNotFoundException {
           //Code goes here
      }
}

P p = //get a reference object of P or one of it's descendants

try {
      Employee emp = p.getEmp(10);
}
catch (EmpNotFoundException e) {
      //Handle the exception here
}

//When we do this kind of a reference, it could refer to P or any of it's descedants ; What gives it away, is the specification of method calling in terms of p.getEmp(10);
//Which means it must have a method that has 1 argument, that it accepts int, and that it has a method called getEmp

//What if we further wrote;

public class Q extends P {
      public Manager getEmp(int empID) {
          //Code goes here
      }
}

//This will still work, cause of a few reasons ;

//Manager is a Subclass of Employee, thus, upcasting is available, it has one argument as int, and it doesn't need to throw exceptions, cause it's already in a try clause.
//Thus, Employee emp = p.getEmp(10); , in this case, would refer to a instance of Q, which returns the Manager type Object, instead of Employee type

//What follows, is an example of a class that would not compile, due to a Exception not being accounted for;

public class Q2 extends P {
      public Manager getEmp(int empId) throws BadIdException {
          //code goes here lol
      }
}

P p = new Q2();
try {
      Employee emp = p.getemp(10);
}
catch(EmpNotFoundException e) {
      //handle the exception
}

//Note, this won't compile, because the catch is designed to handle EmpNotFoundExceptions, NOT BadIdException.
//Thus, this is a basic overlook and failure of having the overwritten method actually mesh with the overall structure.

//You should always make sure, that whatever you wrote, actually has the proper handling in the code, otherwise it will cause bugs liks this.

//When it comes to calling a Overridden method, you can use the keyword super. Albeit, it only allows one higher tier, as you cannot call from Tier 3 to Tier 1, for instance, in a direct manner.
//To do that, you would have to create a Chain of Command, that calls functions in a domino like effect to eventually reach the highest instance that you seek.

Overloading methods;

//Overloading is pretty simple, you take the same as another function, and change the Type and/or the amount of Arguments and/or the ordering, and the argument becomes overloaded.

//Thus, a Method, might have int n1 and double n2 as argument, albeit, you could overload it, by simply switching the place of the two, and keeping the method name.

//Or you could change the type, the amount of arguments etc.

//Remember, when we try to call methods with a "too small" argument "type size" (i.e, need an int, have a byte), Java automatically converts these into the larger parts, in an attempt to try to
//widen the argument, and there after identifies to one that it can fit into.

//Constructors are not inherited.

//When you create a new object of a Subclass, it goes through all the constructors of the Superclasses, first.

//When you call Super(), in a function, i.e, you call the parent class, this must be the first line, in the subclass. 

//Remember, when you call the parent class of something, it has to have a Constructor to begin with.
//Thus, if it doesn't, the compiler will try to add one as default, but it will fail, as the class you are calling, still does not have a empty constructor.

//This can be fixed, by just adding one, in case one needs to call it.

//An example of an empty constructor, is as follows;

public class Employee2 {
      public Employee2() {

      }
      //Everything else can be exactly the same, it doesn't matter
}

//You can add a no arguments constructor, and add a explicit call to the super class, that follows the parameters of what needs to be fed to the super class, as follows, for instance;

public class Employee2 {
      public Employee2() {
          super("unknown")
      }
}

//We could also pass the name of the Employee2 class, to the original constructor, easily;

public class Manager2 extends Employee2{
      public Manager2(String name) {
          super(name); //This way, we pass the name of manager2 directly to Employee2
      }
}

//This is a way to pass arguments, without actually having direct access to the instance variables themselves, which is good praxis, cause it creates a Safety layer and can prevent Bugs

//You can also avoid inheritance, by simply having a constructor of a class be private.
//It could also be, that you declare one of it's constructors private, whilst you allow another, to which you get a mix of what is private and not.
//Though, i don't think you will do that often.

Method Hiding;

//When you take a method, that is inherited and static, and Override the inherited class, it is considered Method hiding.

//The same rules as method overriding applies, just that Method hiding inheritly implies static, early assignment.

//Remember, when we have Early Assignment, whatever class is casted to be the superclass, is the one that gets assigned, not the Subclass.

//an example;

((MHidingSuper)mhSub).print();

//Assuming MHidingSuper is defined, it will be assigned to that class's Method of Print, Because it's involving static methods, which inheritly means early assignment.

//You can also hide field variables, by just declaring them in a Subclass, that overwrites the parent classes field variables, assuming they have the same type and name etc.

//Just for clarity, a field variable is as follows;

Public class G {
     protected int x = 5 //variables that are put in a class, but belong to not method with a constructor, are inheritly "Field variables"
}

//You can disable inheritance, by adding the security level of final, on a class.

//You cannot override a Method, that is final, either, in terms of having inherited it.

Abstract classes;

//You can declare a class as Abstract, which makes it so that you cannot create instances of the said class;

public abstract class Shape {
      //No code
}

//This means that we cannot create a instance, of the Shape class.

//You can also declare a incomplete method, with abstract, to act as a placeholder of doing nothing, but to be later implemented, as follows;

public abstract class Shape {
      public Shape() {

      }

      public abstract void draw(); //This is a method, except it has no body, so it's incomplete.
      //It is valid tho, because of the abstract notification
}

//An Abstract class, can still have concrete methods, but it cannot invoke thoose methods, by itself.
//Thus, an Abstract class, is used for Inheritance. You can inherit aspects of a Abstract class, but you cannot invoke the Abstract class itself.


//Let's make a scenario with an Abstract class, of Shape;

// Shape.java

package com.jdojo.inheritance;

public abstract class Shape {
      private string name;

      public Shape() {
              this.name = "Unknown Shape"; //This is the default name, we assign to Shapes
      }

      public Shape(String name) {
          this.name = name; //assigns the default name to Shape objects
      }

      public String getName() {
          return this.name //This is the get name function, where we return the name of an object
      }

      public void setName(String name) {
          this.name = name; //This is the function of setting the name of the Object
      }

      public abstract void draw(); //incomplete
      public abstract double getArea(); //incomplete
      public abstract double getPerimeter(); //incomplete
}

//What follows, is the follow up, by virtue of creating a Rectangle class, that expands on Shape class

//Rectangle.java

package com.jdojo.inheritance;

public class Rectangle extends Shape {
      private double width;
      private double height; //We initialize the values, so that rectangle can have a width and a height

      public Rectangle(double width, double height) {
          //Set the shape name as rectangle with Super
          super("Rectangle");

          this.width = width;
          this.height = height; //We reference the height and the Width of the object so that the object knows that it has it
      }

      public void draw() {
           System.out.println("Drawing a Rectangle, please wait!");
      }
      public double getArea() {
          return width * height; //we can calculate the Height and the width, by simple math
          //And since we already defined this.width and this.height as width and height, we can use the simple names for references of these
      }

      public double getPerimeter() {
          return 2.0 * (width + height);
      }
}

//remember, when we inherit from a Abstract class, we must override it's Abstract functions, otherwise it's considered incomplete

//Let's make another one, except this time, let's make a Circle!

//Circle.java

package com.jdojo.inheritance;

public class Circle extends Shape {
      private double radius;

      public Circle(double radius) {
          super("Circle"); //We call the parent class, which is Shape, with the name of setting it to Circle
          this.radius = radius;
      }

      public void draw() {
          system.out.println("Drawing a Circle, please wait!");
      }

      public double getArea() {
          return Math.PI * radius * radius; //We already set radius, so we can just calculate it by this
      }

      public double getPerimeter() {
          return 2.0 * Math.PI * radius;
      }
}

Shape s = new Rectangle(2.0, 5.0); //valid, since upcasting works

double area = s.getArea();
//We get the area from the Rectangle, by virtue of late bidning.
//The reason it is late binding, is that it first checks for getArea, which exists in Shape, and then later on is verified to exist in the Rectangle class, which we are referencing.

//let's consider a Polymorphic multi implementing Shape creator, as follows;

//ShapeUtil.java

package com.jdojo.inheritance;

public class ShapeUtil {
      public static void drawShapes(Shape[] list) {
              for (int i = 0; i < list.length; i++) {
                      list[i].draw(); //late binding, it simply assumes that it exists in Shape, and then confirms which one it belongs to
              }


      }

      public static void printShapedetails(Shape[] list) {
          for (int i = 0; i < list.length; i++) {
              String name = list[i].getName();
              double area = list[i].getArea();
              double perimeter = list[i].getPerimeter(); //These are all late bindings

              System.out.println("Name: " + name);
              System.out.println("Area: " + area);
              System.out.println("Perimeter: " + perimeter);
          }
      }
}

//The advantage of having a Abstract class, is mostly down to implementation. It allows for a clean structure, that allows for high polymorphism, and it allows you to
//keep your code clean/Abstract. You need not specify things, if you do it correctly ; And it allows you to differentiate the methods, based on how you build them, without
//having to further differentiate the actual big running method.

//An example of our classes in play, is as follows;

//ShapeUtilTest

package com.jdojo.inheritance;

public class ShapeUtilTest {
      public static void main(String[] args) {
          Shape[] shapelist = new Shape[2];
          shapeList[0] = new Rectangle(2.0, 4.0);
          shapeList[1] = new Circle(5.0);

          ShapeUtil.drawShapes(shapeList);

          ShapeUtil.printShapeDetails(shapeList);
      }
}

//This would run the functionalities of said objects in our Shape array, which in this case, consists of 2 elements

//The general rule of thumb with Abstract classes, is that it should be subclassed, and that the subclasses should replace the Abstractly defined ones, from the parent class

//Here are the rules of Abstract classes;

A class may be declared abstract even if it does not have an abstract method.

A class must be declared Abstract, if it Declares/Inherits abstract methods and do not override them/keep them as abstract.

You cannot create an object from a Abstract class

A abstract class cannot be declared Final

An Abstracts class variables should not be declared as private.

A static method, cannot be overwritten, tho it can be hidden.

An abstract class, cannot be declared static. And it has to be overwritten, in whatever it's inherited to.

Abstract methods cannot be declared private.

A abstract class, can overwrite a Abstract one from it's super class, without actual implementation. (Because it's abstract)
//Method Overriding rules must still be obeyed, tho, in terms of Exceptions and return Type

//Abstract classes, can also be used to force implementation of methods, if used to overwrite Concrete ones

Method Overriding and Generic Method Signatures;

//Let's take a look at type erasure, which happens compilation is done, where Generic types are replaced with their assumed value;

//GenericSuper.java

package com.jdojo.inheritance;

public class GenericSuper<T> {
       public void m1(T a) {
           //Code
       }

       public <P extends Employee> void m2(P a) {
           //Code
       }

}

//After Erasure is done, the code will be as follows;

//GenericSuper.java

package com.jdojo.inheritance;

public class GenericSuper<T> {
      public void m1(Object a) {
           //Code goes here
      }

      public void m2(Employee a) {
          //Code goes here
      }
}

//If you wish to be sure of Overriding, you can use the @Override , which makes a annotation to you, wether a method has been overridden or not.
//You use it by writing it before whatever method you seek to override.
//It works as follows;

//Assume we have earlier class to build extension on, here//

public class C2 extends C1 {
      @Override
      public void m1(int num) { //This is the one that we knowingly have that will not override properly, cause the compiler looks in the earlier one and uses Type extension to use an argument there instead
          //Do something
      }
}

//@Override would have told us this, if we decided to use it, it is useful

//You can also trace an error, by seeing the execution order, by virtue of ;

javap -c <your-fully-qualified-class-name>

//This will tell you where, and probably give you something like;

<line number>: invokeritual //action//     #<method table entry>; //Method com.jdojo/inheritance/C1.m1:(D)V

The D stands for Double, which is the parameter type

V stands for Void, the return type

invokeritual is denoted for when a late binding occurs

//In this case, it tries to find m1 that accepts a Double, it finds none in C2, it finds one in C1, thus, it uses the C1

IS-A, HAS-A, PART-OF relationships;

IS-A, is the relationship between two classes by inheritance, when a class inherts from another

HAS-A, is when an Object contains a whole other Object inside of itself, also known as Aggregation or HAS-A relationship, it is a Whole-part relationship
//Such as, a Person has a adress, whole + part argument

//The only way to define a Has-a relationship in Java, is by defining a Class that has attributes, and then passing it to another class, as follows;

Public class Address {
      //Code
}

Public class Person {
      //Person has a adress
      private Address addr;

      public Person(Address, addr) {
          this.addr = addr;
      }

      //other code
}

//The last one, which is Part-of-relationship
//Leads to be able to have a special case of aggregation, called composition

//The difference between Aggregation and composition, is that in Composition, the whole controls creates/destroys the part


//This could refer to a part of something, that cannot exist on it's own, or doesn't make sense to exist on it's own

//What follows, is an example, with the CPU class;

public class CPU {
      //Code 
}

public class Computer {
      //CPU part of the computer
      private CPU cpu = new CPU();

      //Other code
}

//If the Computer object is destroyed, the CPU goes with it, which defines the Part-of-relationship

//These can also be described as Inner classes, and written as follows;

public class Computer {
      private CPU cpu = new CPU();
      //Cpu is a inner class of Computer

      private class CPU {
              //Code
      }
}


//Classes in Java, can inherit from several different Interfaces, but not from different Superclasses.

INTERFACES;

//What follows, is an example of a implementation of a Class, and how Interfaces becomes relevant to it;

public class Person {
      private String name;

      public Person(String name) {
              this.name = name;
      }

      public void walk() {
              System.out.println(name + " (a person) is walking.");
      }
}

public class Walkables {
      public static void letThemWalk(Person[] list){
           for(Person person : list) {
               person.walk();
           }
      }
}

public class WalkablesTest {
      public static void main(String[] args) {
          Person[] persons = new Person[3];
          persons[0] = new Person("Jack");
          persons[1] = new Person("Jeff");
          persons[2] = new Person("Jill");

          Walkables.letThemWalk(persons);
      }
}

//This makes us run the class for "Walking", with all the objects in the Person array

//Further, we make a class that is Ducks

public class Duck {
      private String name;

      public Duck(String name) {
              this.name = name;
      }

      public void walk() {
              System.out.println(name + " (a duck) is walking.");
      }
}

//There are three ways, without creating an interface, that we could solve the problem of having Both ducks and people, walk at the same time;

//Soltuion #1

//Walkables.java
import java.lang.reflect.Method;

Public class Walkables {
      public static void letThemWalk(Objec[] list) {
           for (int i = 0; i < list.length; i++) {
                   Method walkMethod = getWalkMethod(list[i]);
           }

           if (walkMethod != null) {
               try {
                    //Invoke the walk method for each element in the list
                       walkMethod.invoke(list[i]);

               }
               catch (Exception e) {
                   e.printStackTrace();
               }


           }
      }
}

//In this solution, we changed the Array to just be an Array of Objects. This means we can iterate through it, and interact on the premise of everything being objects.

//This solution is not good, as it can be easily broken by the virtue of changing the method name for one of the parts, and it is not polymoprhic enough.

//Solution #2

//The second one, is to an seperate array with the method for every type that interacts with it. Which, is silly. It's not flexible or extendable enough.

public class Walkables {
      public static void letThemWalk(Person[] list) {
          for (Person person : list) {
              person.walk();
          }
      }

      public static void letDucksWalk(Duck[] list) {
          for (Duck duck : list) {
              duck.walk();
          }
      }
}


//Solution #3

//The third one, is to add a common ancestor class, so that it inherits the walk method. This is close, but not what we will have ; because it does not allow us to handle the 
//situation of needing to put in a case where we can diffirentiate who gets to Walk and does not.

//We need interfaces.

//Interfaces are declared with the keyword interface, and a example of how to declare one, follows;

//Walkable.java

package com.jdojo.interfaces;

public interface Walkable {
      void walk();
}

//A class can implement one or more interfaces
//To declare one, you do as follows;

//Person.java

package com.jdojo.interfaces;

public class Person implements Walkable {
      private String name;

      public Person(String name) {
          this.name = name;
      }

      public void walk() {
          System.out.println(name + ' (a person is walking.')
      }
}

//Duck.java

package com.jdojo.interfaces;

public class Duck implements Walkable {
      private String name;

      public Duck(String name) {
          this.name = name;
      }

      public void walk() {
          System.out.println(name + " (a duck) is walking.");
      }
}

//we can create reference types of walkable interfaces, but we cannot make new objects of them, as follows;

Walkable w; //Ok, we can make reference types of Walkable

new Walkable() ; //No, does not work

Walkable w1 = new Person("Jack"); //okay
Walkable w2 = new Duck("Jeff"); //okay

//We can only do this, for classes that actually implement the interface of something

//What we can do with this, is call the function on the ones that implement this, as follows;

w1.walk(); //Let Jack walk
w2.walk(); //let Jeff walk

//we could rework the representation and have it be a list that iterates through and runs the walk function for each object in the Array, as followws;

//Walkables.java

package com.jdojo.interfaces;

public class Walkables {
       public static void letThemWalk(Walkable[] list) {
           for (Walkable w : list) {
               w.walk();
           }
       }
}

//WalkableTest.java

package com.jdojo.interfaces;

public class WalkablesTest {
       public static void main(String[] args) {
           Walkable[] w = new Walkable[3];
           w[0] = new Person("Jack");
           w[1] = new Duck("Jeff");
           w[2] = new Person("John");

           Walkables.letThemWalk(w); //We cal the Walkables function on the w Array of walkable objects

       }
}

//What if we want to implement said interface interaction in a new class, named Cat;

//Cat.java

package com.jdojo.interfaces;

public class Cat implements Walkable {
      private String name;

      public Cat(String name) {
          this.name = name;
      }

      public void walk() {
          System.out.println(name + " (a cat) is walking.");
      }
}

//The major benefit of having interfaces, is that they can be abstractly applied to anything without a solid ground.
//There of, having a inherited "ground" class, and extending that, is terrible brittle ; as it relies on solids.
//if the solids change, then the thing breaks.

//This is not the case for Abstracts ; There of, Abstraction which is still the best concept in programming, wins, in interfaces versus inheritance

//There is three ways to declare a interface;

a top level interface

a nested interface

annotation type

//In this book, we discuss top level interfaces
//They can be generally written as;

<modifiers> interface <interface-name> {
      Constant-declaration
      Method-declaration
      Nested-type-declaration
}

//Their modifier level can be public or package-level scope

//An empty example follows;

package com.jdojo.interfaces;

interface Updatable {
      //Empty body
}

//The simple name of it is it's given name, Updatable, the fully qualified name is as follows;

com.jdojo.interfaces. Updatable

//interfaces are inheritly abstract
//An interface can have three different types of members;

Constant fields
Abstract, static, and default methods
Static types(nested interfaces and classes)

//All members of a interface are inheritly public
//An interface cannot have mutable instance and class variables

//What follows, is an example of how to declare a interface and it's members

//Choices.java
package com.jdojo.interfaces;

public interface Choices {
      public static final int YES = 1;
      public static final int NO = 2;
}

//All fields in a interface is inheritly public, static and final.
//It's just redundant to write them on top of what already is written.

//Thus, you might as well just skip writing them before the variables

//You cannot set a value in a interface variable, unless it's done in it's first format, as it is Final

//Most commonly, you have interfaces to declare a API

//If you are grouping constants into a Group, you put them in a class

//Use enums to declare your constants

//There are three types of methods you can declare in a interface;

Abstract

Static

Default

//They follow the normal rules of declaring

//All methods of A interface are inheritly Abstract to begin with, unless declared otherwise

//Abstract methods are made to override and implement of your own kind, in the classes that inherit them.
//This might be a mix, as you may also define some as default or Static, which are inheritly inhereted as well.

//This leads to capacity of flexibility, in terms of switching between having pure Abstracts and partly abstract interfaces

//You can override abstract methods, with final methods, which implies that the inherited method, cannot be inherited further after the one where you made it final

//What follows, is an example of a interface that defines a static method that iterates through an array and applies the function;

//Walkable.java

package com.jdojo.interfaces;

public interface Walkable {
      //An abstract method
      void walk();

      //A static convinience method
      public static void letThemWalk(Walkable[] list) {
          for(int = 0; i < list.length; i++) {
                  list[i].walk();
          }
      }
}

//This allows you to implement the walk function for whatever object you are calling, as you see fit, or to implement one and overwrite it for specific ones

//Remember, subinterfaces, DO NOT inherit static methods from Interfaces. The only way to access them, is by full qualified name if you are outside of the instance environment
//if you are in the instance environment, you can use, the simple name, but that is not recommended, i recommend using the full name for clarity

//Interfaces can define methods as Default, as well, which leaves a Default template, that can later be overwritten by the inhereted Classes, but does not overwrite the original default
//So, you basically have "Here is the default behaviour, you can modify it, but it will replace the original, it will just be a modification of the Default"

//It is meant to be a way to extend the pattern, of how interfaces can act between each other

//What follows, is some examples of the interactions between these;

//Movable.java
package com.jdojo.interfaces;

public interface Movable {
      void setX(double x);
      void setY(double y);
      double getX();
      double getY();
}


//These are four abstracts, that we implement in the following Pen class;

//Pen.java
package com.jdojo.interfaces;

public class Pen implements Movable {
      private double x;
      private double y;

      public Pen() {
              //By default, the pen is at 0.0, 0.0 in terms of position
      }

      public Pen(double x, double y) {
              this.x = x;
              this.y = y; //We have to initialize the co-ordinates to the object
      }

      public void setX(double x) {
              this.x = x; //A standard set function interacting with X
      }

      public void setY(double y) {
              this.y = y; //A standard set function, interacting with Y
      }

      public void getX(double x) {
              return x; //We just return a reference to x, not the actual X
      }

      public void getY(double y) {
              return y; //We just return a refernece to y, not the actual Y
      }


      public String toString() {
              return "Pen(" + x + ", " + y + ")";
      }
}

//this is basically just ground work for interactions and showcasing the need for default, later on;

Movable p1 = new Pen();
System.out.println(p1);

p1.setX(10.0);
p1.setY(5.0);
System.out.println(p1);

//This prints;

Pen(0.0, 0.0)
Pen(10.0, 5.0)

//A default method is declared using default, it cannot be declared abstract or static, and it must provide implementation.

//A new form of Movable, with relative co-ordinates, with a default method defined;

//Movable.java
package com.jdojo.interfaces;

public interface Movable {
      void setX(double X);
      void setY(double Y);
      double getX();
      double getY();

      default void move(double deltaX, double deltaY) {
              double newX = getX() + deltaX;
              double newY = getY() + deltaY;
              setX(newX);
              setY(newY);
      }
}

//We can now call the move function with the Pen object, with the default interface interaction, it's straight forward, really

package com.jdojo.interfaces;

public class MovableTest {
      public static void main(String[] args) {
           Movable p1 = new Pen();
           System.out.println(p1);

           p1.setX(10.0);
           p1.setY(5.0);
           System.out.println(p1);

           p1.move(5.0, 2.0);
           System.out.println(p1);
      }
}

//This would just move the pen Object, basically

//Another option of default interface methods, are implementing methods as optional methods, as follows;

// Named.java
package com.jdojo.interfaces;

public interface Named {
      void setName(String name);

      default String getName() {
          return "John Doe";
      }

      default void setNickName(String nickname) {
          throw new UnsupportedOperationException("setNickname");
      }

      default getNickname() {
          throw new UnsupportedOperationException("getNickname");
      }
}

//This means that they default to throwing exceptions, and if you want to use them, you have to implement them. Thus, they are optional, and are declared within their own fashion.

//The major difference, between a Concrete method in a class, and one that is in a Interface, is that thoose in a concrete class, have direct access to the Class variables
//interfaces, don't, they have access through set/get functions, other functions, types etc.

//Interfaces can be nested, containing nests of Classes, enums, interfaces and annotations

//What follow is an example of a nested interface;

public interface ATM {
      boolean login(int account) throws AccountNotFoundExcpetion;
      boolean deposit(double amount);
      boolean withdraw(double amount) throws InsufficientFundException;
      double getBalance();

      //public and static are redundant, because they are inherit to nested interfaces;
      public static interface Card {
           String getNumber();
           String getSecurityCode();
           LocalDate getExpirationDate();
           String getCardHolderName();
      }
}

//The fully qualified names, are as follows;

com.jdojo.interfaces.ATM //The fully qualified name of the ATM interface

and

com.jdojo.interfaces.ATM.Card //The fully qualified name of the card interface of ATM

//You can put a nested class in a Interface

//What follow is an example of a structure that has a empty class within it's interface;

//Job.java

package com.jdojo.interfaces;

public interface Job {
      class EmptyJob implements Job {
          private EmptyJob() {
                  //This is private to make no-one else fudge this part up
          }

          public void runJob() {
                  System.out.println("Nothing serious to run....");
          }
      }

      Job EMPTY_JOB = new EmptyJob();

      void runJob();
}


//What follows is a test of the above implementation;

//JobTest.java

package com.jdojo.interfaces;

public class JobTest {
       public static void main(String[] args) {
            submitJob(Job.EMPTY_JOB);
       }

       public static void submitJob(Job job) {
           job.runJob();
       }
}

//Using a Interface type as reference types;

//Swimmable.java
package com.jdojo.interfaces;

public interface Swimmable {
      void swim();
}

//SwimmableTest.java
package com.jdojo.interfaces;

public class SwimmableTest {
      //First we make a private instance type variable
      private Swimmable iSwimmable;

      //Interface type to define parameter type for a constructor
      public SwimmableTest(Swimmable aSwimmable) {
           this.iSwimmable = aSwimmable;
      }

      //interface type to define a return type of a method
      public Swimmable getSwimmable() {
          retun this.iSwimmable;
      }

      //Interface type to define parameter type for a method
      public void setSwimmable(Swimmable new Swimmable) {
          this.iSwimable = newSwimmable;
      }

      public void letItSwim() {
          //interface type to declare a local variable
          Swimmable localSwimmable = null;

          localSwimmable = this.iSwimmable;
          localSwimmable.swim();
          
      }
}

//The above code does the following;

An instance variable called iSwimmable;

A parameter named aSwimmable for it's constructor;

The return type of its getSwimmable() method

A parameter named newSwimmable for its setSwimmable() method

A local variable named localSwimmable inside it's letItSwim() method, inside the method you could have invoked the
Swim() method directly on the instance variable, iSwimmable. You used a local variable just to demonstrate that
an interface type can be used anywhere a type can be used

//What follows, is a few rules of the interface type;

//You can assign a refecenre type to a reference of an object or null, as follows;

example = new ExampleClass();

Swimmable sw2 = null; or Swimmable sw2 = example;

//You can access constant fields, using either the type name of the interface, or using the interface name, as follows;

//Assume we implemented a interface called <Example Interface>

sw2 = Example Interface;

<example interface>.YES //Yes is a assumed constant of this interface

<example interface>.NO //No is a assumed constnat of this interface

//You can declare a Interface variable, which is related to a Object that implements the Interface, and call methods through that, as follows;

<Example Interface> sw3 = <Object that implements the Example interface>
sw3.swim(); //Assuming the interface implemented in the object has a method that is called swim()

//Interfaces can always inheritly call methods from the Object class, as follows;

Swimmable sw4 = get a Swimmable type object

int hc = sw4.hashCode();
Class c = sw4.getClass();
String str = sw4.toString();

//Another important rule, is that an instance or static variable of an interface type is by default initialized to null;
//And instance variables in Interfaces must still be initialized

Implementing Interfaces;

//Specification refers to specifying variables of a Interface
//Implementation means to actually realize said specifications

//The syntax of interface is as follows;

<modifiers> class <class name> implements <comma-seperated-list-of-interfaces> {
      //class body goes here
}

//You have to overwrite the abstract methods of a interface that is inherited to a class

//The only methods not inherited from the Interface, is static methods

//When a Object that involves interfaces is created, it has 2 types ; One for the interface type, one of the object type

//This is why you can define a interface type, based on two different ways of reference, as follows;

Fish guppi = new Fish("Guppi");
Swimmable hilda = New Fish("hilda");

//This is done by the virtue of the Interface object having 3 types, thus, you can define it as either the class, the interface type or the Object type

//As long as you follow the hierarchy, you can assign things. Thus, if a object is inheritly of a interface, you can assign object to be of interface
//But you cannot do the same way around, due to there not being any guarantee to what you are referencing

//You can also do type casting, if you are certain of a certain objects type, as follows

guppi = (Fish)hilda;

//This is if you are certain of what the types in this context are inheritly refering to.
//In this case, we assign a Swimmable type to a Fish object, through casting, if we are certain of that this is the case.

//What follows, are some examples of how to impliment interfaces;

public interface Banker {
      double withdraw(double amount) throws InsufficientFundException;
      void deposit(double amount) throws FundLimitExceededException;
}

//An example of how we would implement this interface;

public class MinimumBalanceBank implements Banker {
       public double withdraw(double amount) throws InsufficientFundException {
           //Some code
       }

       public void deposit(double amount) throws FundLimitExceededException {
           //Some code
       }
}

//You can ommmit throw clauses when writing methods that implement interfaces, but you are still forced to run try and catch clauses, if you do this, as follows;

public class NoLimitBank implements Banker {
      public double withdraw(double amount) {
          //Code goes here
      }

      public void deposit(double amount) {
          //Code goes here
      }
}

Banker b = get a banker type object;
try {
       double amount = b.withdraw(1000.90);
       //Code goes here
}
catch (InsufficientFundException e){
       //Code goes here
}

//This is allowed, however, adding exceptions afterwards, in terms of using a interface that does not specify one, and then later trying to use an object and force an exception check,
//is not allowed, as follows;

public class UnstablePredictableBank implements Banker {
      public double withdraw(double amount) throws InsufficientfundException, ArbitraryException {
          //code
      }
      public void deposit(double amount) throws FundLimitExceededException { <<<< Can only be public since it overrides deposit, public is also redundant cause they are inheritly public
          //Code
      }
}

Banker b = new UnstablePredictableBank();
try {
      double amount = b.withdraw(1000.90);
      //Code
}
catch (InsufficientFundException e){
      //Code
}

//Since the code cannot determine, on runtime, that it is UnstablePredictableBank that you are calling, which needs 2 exceptions, your code will not be ready to handle this type of code
//Thus, is why you need to always have AT LEAST all the exceptions covered, or less, that is also fine, but at least all

//If a class overrides the method of a inherited interface, it must be declared public

//You can implement multiple interfaces into classes, as follows;

public interface Adder {
      int add(int n1, int n2);
}

public interface Subtractor {
      int subtract(int n1, int n2);
}

//It's implimentation would be as follows;

public class ArithOps implements Adder, Subtractor {
       public int add(int n1, n2) {
            return n1 + n2;
       }

       public int subtract(int n1, n2) {
            return n1 - n2;
       }       
}

//for each implemented interface, the object inheriting the interface, gains each type of each respective interface inherited

//This means that for each type that you define with interfaces, that type can co-respond to it's hierarchy of inheritance superiors

//What follows is a better concrete example of how interfaces act, when there are multiple of them;

//Turtle.java
package com.jdojo.interfaces;

public class Turtle implements Walkable, Swimmable{ //This assumes that we already have defined the Walkable and Swimmable interface
       private String name;

       public Turtle(String name) {
            this.name = name;
       }

       public void Bite() {
            System.out.println(name + " a (turtle) is biting."); 
       }
       public void walk() {
            System.out.println(name + " a (turtle) is walking.");
       }
       public void swim() {
            System.out.println(name + " a (turtle) is swimming.");
       }
}

//TurtleTest.java
package com.jdojo.interfaces;

public class TurtleTest {
        public static void main(String[] args) {
             Turtle turti = new Turtle("Turti");

             letItBite(turti);
             letItWalk(turti);
             letItSwim(turti);
        }

        public static void letItBite(Turtle t) {
            t.bite();
        }

        public static void letItWalk(Walkable w) {
            w.walk();
        }

        public static void letItSwim(Swimmable s) {
            s.swim();
        }
}

//This produces;

Turti (a turtle) is biting.
Turti (a turtle) is walking.
Turti (a turtle) is swimming.

//we can access the methods easily, as follows;

Turtle t = new Turtle("Turti");
t.bite();
t.walk();
t.swim();

//As you can see, we can just call the attributes of the interface

//You can also partially implement interfaces, in different ways
//You could define a few methods that are inheritly implemented already, some that are static (not inherited) and leave the ones you wish to be defined, as abstract, so that they must be.

//If a Class inherits a interface that is not complete, that class must be declared abstract and is not invokable until it's completed.
//in the same sense, a interface must be completed, before it actually gets to the point of usage.

//The point of usage, however, is just defined on wether all methods are working or not. If they all work, then it's all fine.

//As long as a class has all of it's methods inheritance from interfaces as Concrete classes, then it is not an issue

//Classes that inherit from a interface, become subtypes of said Interface, thus they can be assigned as references to Object types of the Interface, since they are sub-types.
//Just gotta follow the inheritance hierarchy

//a Class can inherit from multiple interfaces

//If you have a conflict with several different interfaces implementing the same function, you override by making the new override method a default, which then resolves it
//The syntax is as follows;

//SingerPlayer.java

package com.jdojo.interface;

public interface SingerPlayer extends Singer, Player {
      @Override
      default double getRate() {
           return 700.00; //We just override all the conflicts of inheritance with a default method in the overriding process
      }
}

//To access the previous overwritten method, you can use the Super keyword, and as same as before, if it's more than 1 step up, you make a chain of command to access it
//It is as follows;

//SingerPlayer.java

package com.jdojo.interfaces;

public interface SingerPlayer extends Singer, Player{
      @Override
      default double getRate(){
          double playerRate = Player.super.getRate();
          double singerPlayerRate = playerRate * 3.5;
          return singerPlayerRate;
      }
}

//In other words, if you wish to override another method, you just need to apply a super.getRate() method that returns the rate of the super class

//Interfaces can inherit multiple other interfaces, and act according to the Supertype hierarchy

//There are three rules in terms of Inheritance, when it comes to interfaces;

1. The Superclass (not SuperInterface, SuperClass) is always higher priority in a conflict between two methods being identical

2. If #1 does not solve it, it's the most specific SuperInterface that wins.

3. If #1 and #2 does not work, then the Class must override the Function itself

//3 examples of Superclass winning;

//#1

public abstract class Employee {
       private double rate;

       public abstract void setRate(double rate);

       public double getRate() {
           return rate;
       }
}

public abstract class Manager extends Employee implements CharitySinger {
      //code goes here
}

//This class has 5 methods that it inherits;

CharitySinger.sing() method //Abstract

CharitySinger.setRate() method //Default

CharitySinger.getRate() method  //default

Employee.setRate() method    //abstract

Employee.getRate() method  //concrete

//Since there are two set and get rates, it chooses the Employee class to inherit from, since it's the Superclass


//#2

//What follow is an example of a default method that cannot be overwritten;

public interface Runner {
       void ruin();

       default String toString(){
               return "WhoCares";
       }
}

//This pile of code, won't work

//You are simply not allowed to override the inherit methods of the Object class with default ones in Interfaces

//#3

//Default methods cannot be declared Final, because they are meant to be overriden and if a default one is implemented, you are meant to be able to modify them, due to backwards compability

//What follows is a example;

public interface Sizeable {
       int size();
}

public class Bag implements Sizeable {
       private int size;

       @Override
       public int size() {
           return size;
       }

       public boolean isEmpty() {
            return (size == 0);
       }

       //Code
}

public interface Sizealbe {
       int size();

       //A new default method

       default boolean isEmpty() {
            return (size() == 0);
       }
}

//This overriding will work, assuming you do not declare isEmpty to be final, cause if you did, it would be unmodifiable, thus, non backwards compatible

//The most specific Superinterface wins;

//The easiet way to understand what Superinterface wins, is by making a flow chart of the inheritances, overridings and then figure out which one remains

//If nothing else works, you must override the method in the Class.

//To call the defaul method of a SuperInterface, you can do as follows;

SuperInterfaceName.super.superInterfaceDefaultMethod(arg1, arg2...)

//or if it's a superclass

ClassName.super.superClassMethod(arg1, arg2...)

//Assume we have a interface that won't compile, because a method can't be resolved;

public abstract class MultiTalented implements Singer, Player {
       //Won't compile, cuz of a Conflict of methods in Singer and player, so we have to Override it
}

public abstract class MultiTalented implements Singer, Player {
       @Override
       public double getRate(){
            //First we get the default from super
            double playerRate = Player.super.getRate();
            double rate = playerRate + 200.00;
            return rate;
       }
}

//The instanceof operator, operators on the fact of what type it is referenced as, at runtime, and what object type it COULD refer to.
//If something implements a interface type, it inheritly has that type associated to it, Thus it is a instaceof, of said thing

Marker Interfaces;

//You can declare Marker Interfaces, which are known as tag interfaces

//a marker interface, is basically a Empty interface, that can be used as a form of categorizing, in terms of identifying by instanceof

Functional Interfaces;

//A functional interface, is a interface that only defines 1 Abstract method, in it.

Comparing Objects;

USING THE COMPARABLE INTERFACE;

//If we wish to Order objects, we can use the following interfaces;

java.lang.Comparable

and

java.util.Comparator

//What follows, is an example of the Comparable interface interaction;

public interface Comparable<T> {
       public int compareTo(T o); //The compareTo method is Abstract. If the Compared object is greater, it returns a positive integer.
       //If the Compared object is lesser, it returns a negative integer.
       //If the two are equal, it returns 0.
}

//The String class and Wrapper classes for primtive types(int, float, double etc.), implment the Comparable interface.

//What follows, is an example of using the generic Comparable interface in a class, where we specify that only the A type, is compatible for comparison;

public class A implement Comparable<A> {
       public int compareTo(A a) {
            //Code
       }
}

//What follows, is a more intrecate interaction in a context of using the Comparable interface, that compares Person Objects, comparing names (first and last), and sorting there after;
//NOTE; compareTo function does not handle null values

//ComparablePerson.java
package com.jdojo.interfaces;

public class ComparablePerson implements Comparable<ComparablePerson> {
       private String firstName;
       private String lastName;

       public ComparablePerson(String firstName, String lastName) {
            this.firstName = firstName;
            this.lastName = lastName; //We assign the references of the attributes of the object, whilst we keept the actual variables private
       }

       public String getFirstName() {
            return firstName; //a simple get function of firstName
       }

       public void setFirstName(String firstName) {
            this.firstName = firstName; //a simple set function of firstName
       }



       public String getLastName() {
            return lastName; //a simple get function of lastName
       }

       public void setLastName(String lastName) {
            this.lastName = lastName;
       }

       //Compare two person objects last names, if the last names are the same, use first names
       public int compareTo(ComparablePerson anotherPerson) {
            int diff = getLastName().compareTo(anotherPerson.getLastName()); //First, we compare the last names of the first person and the other person.
            //NOTE; In java. you don't need to assign function calls as actual variables, you can just use the functioncall and call functioncalls on that,
            //Assuming it returns an valid thing to operate on
            if (diff == 0) {
                 diff = getFirstName().compareTo(anotherPerson.getFirstName()); //If the diff is 0, the last names are the Same. Thus, we then compare the first names between the people
            }
            return diff;
       }

       public String toString() {
            return getLastName() + ", " + getFirstName(); //Similarily, we are also allowed to just plain print function call returned objects, without assigment to a variable
       }


}

//The following Code, illustrates the usage of ComparablePerson interface, on a class that operates on an Array;

//ComparablePersonTest.java
package com.jdojo.interfaces;

import java.util.Arrays;

public class ComparablePersonTest {
       public static void main(String[] args) {
            ComparablePerson[] persons = new ComparablePerson[] {
                     new ComparablePerson("John", "Jacobs"),
                     new ComparablePerson("Jeff", "Jacobs"),
                     new ComparablePerson("Wally", "Inman")};

            //What we did here, is that we made an Array accepting ComparablPerson objects, called persons, initializing with John Jacobs, Jeff jacobs and Wally Inman person objects

            System.out.println("Before sorting...");
            print(persons);

            //Sort the persons list
            Arrays.sort(persons);

            System.out.println("\nAfter sorting..."); //The \n just means print it on a new line
            print(persons);
       }

       public static void print(ComparablePerson[] persons) {
            for(ComparablePerson person: persons){
                 System.out.println(person); 
                 //What we do here, is that we iterate through the array for the object of ComparablePerson Objects, assign it variable name of person, targeted at the persons array, and print out every person in said Array
            }
       }
}

//Thus, the output, would be as follows;

Before sorting...
Jacobs, John
Jacobs, Jeff
Inman, Wally

After sorting...
Inman, Wally
Jacobs, Jeff
Jacobs, John


USING THE COMPARATOR INTERFACE;

//The Comparator allows for Customized sorting, in terms of ordering of objects;

public interface Comparator<T> {
       int compare(T o1, o2);
       boolean equals(Object obj);

       //etc.
}

//Usually, you don't need to define the equals, as it's inherited from the Object superclass

//the compare function functions the same as in the Comparable interface, where it returns a negative integer if it's less, 0 if it's equal, or a positive integer if it's greater

//What follows, is an example of the Comparator interface at work, the first example, is that of first names comparison, then second is of last names comparison;

//FirstNameComparator.java
package com.jdojo.interfaces;

import java.util.Comparator;

public class FirstNameComparator implements Comparator<ComparablePerson> {
       public int compare(ComparablePerson p1, ComparablePerson p2) {
            String firstName1 = p1.getFirstName(); //This assumed you defined a Get function for ComparablePerson objects, which we did earlier
            String firstName2 = p2.getFirstName();

            int diff = firstName1.compareTo(firstName2);
            return diff;
       }
}

//LastNameComparator.java
package com.jdojo.interfaces;

import java.util.Comparator;

public class LastNameComparator implements Comparator<ComparablePerson> {
      public int compare(ComparablePerson p1, ComparablePerson p2) {
           String lastName1 = p1.getLastName();
           String lastName2 = p2.getLastName(); //This assumed you defined a get function for the Comparable objects, which we did earlier

           int diff = lastName1.compareTo(lastName2);
           return diff;
      }
}

//What follows, is an example of how to use a Comparator in terms of sorting an Array;

ComparablePersons[] persons = //Create and populate the Array

Comparator fnComparator = new FirstNameComparator();
Arrays.sort(persons, fnComparator);

//This would sort the Array by usage of the first class implementation, feeding the Array and the class object as arguments for the sort argument on Arrays;

//We could use the same logic for using lastname sorting;

Comparator lnComparator = new LastNameComparator();
Arrays.sort(persons, lnComparator);

//the Comparator have a built in method that inheritly allows you to create a chain of command, which the default format looks as;

default Comparator<T> thenComparing(Comparator<? super T> other)

//An example of this, where we have a chain of two interfaces that are chained and sort the things, are as follows;

Comparator firstLastComparator = fnComparator.thenComparing(lnComparator); //We declare the chain of command usage of interfaces here, beginning with the First name comparator, followed by the last name one
Arrays.sort(persons, firstLastComparator) //We then just feed the Array sort method with it.

//Keep in mind, you can make chain calls to thenComparing() to create a hierarchy of ordering in terms of how to apply sortings.

//You also have a reversed method, in the Comparator interface, which returns the reversed version of the Comparator, which can be used as follows;

//Assuming we defined the previous Comparators, we can get the reversed of the firstLastComparator;

Comparator firstLastReverseComparator = firstLastComparator.reversed(); //This gives us a Comparator that is simply the reversed version of what we had, as such, this will sort by first name first, and last name secondly
Arrays.sort(persons, firstLastReverseComparator);

//There is also two inherit methods, that allow for sorting of Null values, in terms of Comparators;

static <T> Comparator<T> nullsFirst(Comparator<? super T) comparator)
static <T> Comparator<T> nullsLast(Comparator<? super T> comparator)

//An example of how to use a nullFirst comparator, that returns null values first, followed by the First name and last name

Comparator nullFirstComparator = Comparator.nullsFirst(firstLastComparator);
Arrays.sort(persons, nullFirstComparator);

//You can also call the nullsLast, by the same way, just that you'd get null values last.

//What follows, is an example of a Class that implements all of the Comparator functions we covered so far;

//ComparablePersonTest2.java
package com.jdojo.interfaces;

import java.util.Arrays;
import java.util.Comparator;

public class ComparablePersonTest2 {
       public static void main(String[] args) {
           ComparablePerson[] persons = new ComparablePerson[] {
                new ComparablePerson("John", "Jacobs"),
                new ComparablePerson("Jeff", "Jacobs"),
                new ComparablePerson("Wally", "Inman")};


            System.out.println("Original Array....");
            print(persons);

            //Sort using first name
            Comparator<ComparablePerson> fnComparator = new FirstNameComparator();
            Arrays.sort(persons, Comparator);
            System.out.println("\nAfter sorting on first name...");
            print(persons);

            //Sort using last name
            Comparator<ComparablePerson> lnComparator = new LastNameComparator();
            Arrays.sort(persons, lnComparator);
            System.out.println("\nAfter sorting on last name...");
            print(persons);

            //Sort using first name, then last name
            Comparator<ComparablePerson> firstLastComparator = fnComparator.thenComparing(lnComparator);
            Arrays.sort(persons, firstLastComparator);
            System.out.println("\nAfter sorting on first, then last name..."

            //Sort using the first name, then last name in reversed order
            Comparator<ComparablePerson> firstLastReverseComparator = firstLastComparator.reversed();
            Arrays.sort(persons, firstLastReverseComparator);
            System.out.println("\nAfter sorting on first, then last name in reversed...")
            print(persons);

            //Sort using name first, then last name, using null first

            Comparator<ComparablePerson> nullFirstComparator = Comparator.nullsFirst(firstLastComparator);
            ComparablePerson[] personsWithNulls = new ComparablePerson[] {
                 new ComparablePerson("John", "Jacobs"), //We just write on seperate rows for readability
                 null,
                 new ComparablePerson("Jeff", "Jacobs"),
                 new ComparablePerson("Wally", "Inman"),
                 null};

            Arrays.sort(personWithNulls, nullFirstComparator);
            System.out.println("\nAfter sorting on first, then last name, using nulls first")
            print(personWithNulls);
       }

       public static void print(ComparablePerson[] persons) {
           for (ComparablePerson person : persons) {
                System.out.println(person); //A simple for loop which operates on the specific type of Object and prints out that specific variable name which is assigned to the Object
           }
       }
}

//With this, you'd get the following output;

Original array...
Jacobs, John
Jacobs, jeff
inman, Wally

After sorting on first name...
Jacobs, Jeff
Jacobs, John
Inman, Wally

After sorting on last name...
Inman, Wally
Jacobs, John
Jacobs, Jeff

After sorting on first name, then last name...
Jacobs, Jeff
Jacobs, John
Inman, Wally

After sorting on first, then last name in reversed...
Inman, Wally
Jacobs, John
Jacobs, Jeff

After sorting on first, then last name using null first...
null
null
Jacobs, Jeff
Jacobs, John
Inman, Wally

POLYMORPHISM;

//For every type of Interface inherited to a Class, then that type of Object has every single inherited interface as an additional type, as well as Object.
//This allows you to define objects as instances of a interface, call functions from said Interfaces etc. (NOTE: SAME INHERITANCE RULES GO AS PER USUAL FOR INTERFACES)

//A View, refers to a Method instance of a Object that is available for the Client or User.
//Thus, walk() from a Walkable type, is a Walkable view. 

//To say that you have a View of a object type, is to have access to all of it's Methods that are available, inherited from superclasses or declared, etc. etc.

//Depending on what view we use on an object, will define what methods we have access to them. What follows, is an example;

Turtle t = new Turtle("Turti");
Walkable w2 = t; //We get a Walkable view of the Turtle object with the name Turti
Walkwable w3 = new Turtle(); //We get a Walkable of a new, nameless Turtle object

//to define what kind of a View we have on an object, we can use instanceOf;

Object anObject = any object reference;

if (anObject instanceof Walkable){
      //anObject has a Walkable view
      Walkable w = (Walkable)anObject;

      //You can now access the view of the object by using w, and call any related methods as you wish on it, from the Walkable view
}
else {
      //anObject does not have the Walkable view
}

//To actually yield a view, the Object must have implemented the Type that you are trying to access, be that through inheritance, interface, superclass etc.
//The Object must simply have the Type that you are trying to get a view of.

//A view, is more or less, a perspective from a certain point in terms of what Type you are looking from, on an object.

DYNAMIC BINDINGS;

//is the same as Late binding/Runtime binding, when a variable is invoked using a Interface type

//The same rules for Compiletime and Runtime rules, as before, apply to when deciding for what kind of a method is used, in terms of interfaces.

//It looks for the method in the type that is declared, if it doesn't find it there, it'll look for it recursively up in the Class hierarchy

ENUM TYPES;

//What follows, is an example of what Enums can solve - As we need to discuss this before we get into the details of Enums;

public class Severity {
       public static final int LOW = 0;
       public static final int MEDIUM = 1;
       public static final int HIGH = 2;
       public static final int URGENT = 3;
}

public class DefectUtil {
      public static int getProjectedTurnaroundDays(int severity) {
          int days = 0;

          switch(severity) {
               case Severity.LOW:
                       days = 30;
                       break;
               case Severity.MEDIUM:
                       days = 15;
                       break;
               case Severity.HIGH;
                       days = 7;
                       break;
               case Severity.URGENT;
                       days = 1;
                       break;
          }

          return days;
      }

      //Other code, lol
}

//There is a number of problems with this, as follows;

Severity is just a int with no check, and adding a check would force us to recompile the code, for every single time we would add new checks to what is invalid

You'd also have to recompile if we re-define the levels of urgency in Severity

When you save the Severity, it'll just be a number, so you'd have to create a Seperate Map to be able to convert the Integers to Severity level

When you print the severity, it's just a integer ; That does not mean anything to the user.

If you were to add a new type of severity degree, you'd have to re-compile the code and change the hard-coded nature of it, cause it's done by numbers.

You cannot print all the ways, without hardcoding, in this specific example.

//Enumerate means to order one after another, and comes to the rescue to solve the situation, as follows;

<access-modifiers> enum <enum-type-name> {
       //list of comma seperated names of enum constants
}

//The access modifiers are the same as per classes, public, protected, private and package (standard)

//An example of a Enum;

public enum Gender {
      MALE, FEMALE; //Semi-colon is optional, but do it for readability
}

//Enums can be treated pretty much as classes, they can be imported, compiled, called upon, treated with publicity levels

//It's convention to name enum constants in Caps

//What follows, is an example of how ot use Enums;

package com.jdojo.enums;

public enum Severity {
      LOW, MEDIUM, HIGH, URGENT;
}

Severity defectSeverity; //A instance of Severity

//You can assign null to enums;

Severity defectSeverity = null;

//There is only two other things you can assign, in regards of Enums;

The variables that relates to that specific Enum type

and 

The order of thoose constants

//to assign a Enum variable, you use the dot notation, as follows;

Severity low = Severity.LOW; //Severity is the name of the Enum, in this case

Severity medium = Severity.MEDIUM; 

Severity high = Severity.HIGH;

Severity urgent = Severity.URGENT;

//YOU CANNOT INSTANSIATE INSTANCES OF ENUMS WITH THE new KEYWORD

//each Enum variable has a ordinal number, an index, which is assigned based on order of declaration

//each enum has a static method that is called values() that returns an array of constants in the order they are declared
//You can also read the ordinal (index)/name of a enum variable, by calling the name() and ordinal() function on a Enum type

//What follows, is an example of how the Compiler handles the code for Enum types

package com.jdojo.enums;

public final class Severity extends Enum {
      public static final Severity LOW;
      public static final Severity MEDIUM;
      public static final Severity HIGH;
      public static final Severity URGENT;

      static {
              LOW = new Severity("LOW", 0);
              MEDIUM = new Severity("MEDIUM", 1);
              HIGH = new Severity("HIGH", 2);
              URGENT = new Severity("URGENT", 3);
      }

      private Severity(String name, int ordinal) { //The constructor is private due to not wanting to enable direct instansiation
              super(name, ordinal); 
      }

      public static Severity[] values() {
              return new Severity[] {LOW, MEDIUM, HIGH, URGENT};
      }

      public static Severity valueOf(String name) {
              if (LOW.name().equals(name)) {
                      return LOW;
              }

              if (MEDIUM.name().equals(name)) {
                      return MEDIUM;
              }

              if (HIGH.name().equals(name)) {
                      return HIGH;
              }

              if (URGENT.name().equals(name)) {
                      return URGENT;
              }

              throw new IllegalArgumentException(
                      "Invalid enum constants" + name);
      }
}

//Every enum type, extends the java.lang.Enum class, thus, all methods defined in the Enum class can be used by all Enum types

//What follows, is the name of the methods available in the enum class

public final String name() //Returns the name of the Enum constants exactly as declared in the enum type declaration

public final int ordinal() //Returns the order (position or index) of the enum constants as declared in the enum declaration

public final boolean equals(Object other) //Returns true if specified object equals to the enum constant. Otherwise, it turns false.

public final int hashCode() //returns the Hash code value for an enum constant

public final compareTo(E o) //Compares the order of this enum constant with the specified enum. It returns the difference between the twos indexes(positions)
//Note, they must be of the same Enum type, or this throws an exception.

public final Class<E> getDeclaringClass() //returns the class object for the class that declares the Enum constant. two enum types are considered to be equal, if this method returns the same for both
//enum constants. 

//Note, this is not the same as getClass(), as the class of the Enum type, is a subclass to the Declaring class. getClass would get the class of the body of the Enum, whilst to get the actual declaring class
//you'll have to use getDeclaringClass(), which refers to the superclass of the Enum class

public String toString() //This returns the name of the enum Constant, which is the same value as the return value of the name() method, except this method is not final, so you can override it to create a more
//specified message regarding the error

public static <T extends Enum<T>>T valueOf(Class<T> enumType, String name) // Returns an enum constant of the specified enum type and name, an example of it's usage, is as follows;

Severity lowSeverity = Enum.valueOf(Severity.class, "LOW")
//This would get you the Constant Enum value of Low from the Severity Enum type

protected final Object clone() throws CloneNotSupportedException //This is a method that ALWAYS throws a Exception and is final ; Thus, it's function is to prevent cloning of Enums.
//This makes it so that there is only one set of Enums, for a specific type, at a time

protected final void finalize() //This is a method that provides an empty body. 

//Enum types are implicitly final

//You can also use valueOf on Enums, to find their value by String input;

Severity.valueOf("LOW")

//The values() returns an array of the order in which the enums are declared, and can be used as follows;

Severity.values()

//The Enum class implements the java.lang.Comparable and java.io.Serializable interfaces
//This means that every instance of a Enum type, can be serialized and compared. 
//You can compare the ordering of two Enums, by usage of the compareTo() function, as follows;

Severity s1 = Severity.LOW;
Severity s2 = Severity.HIGH;

int diff = s1.compareTo(s2);
if (diff > 0) {
          System.out.println(s1 + " occurs after " + s2);
}
else {
          System.out.println(s1 + " occurs before " + s2);
}

//This would tell you if one enum occurs before another

//You can avoid issues with null values (i.e, the Method will throw a nullException, if needed be), by using the following structure;

//DefectUtil.java

package com.jdojo.enums;

public class DefectUtil {
       public static int getProjectedTurnaroundDays(Severity severity) {
            int days = 0;
            switch (severity) {
                     //In this stucture, you must use the unqualified name, i.e the name after the class notation (the .)
                      case LOW;
                              days = 30;
                              break;
                      case MEDIUM;
                              days = 15;
                              break;
                      case HIGH;
                              days = 7;
                              break;
                      case URGENT;
                              days = 1;
                              break;

            }

            return days;
       }
}

//When we use a switch, we must use unqualified names and they must all be of the same type, and the Switch statements deduces what type the enum is. 
//You can also include a default label

//An Enum can have associated bodies to each Enums, as follows;

<access modifier> enum <enum-type-name> {
      CONST1 {
               //Body for CONST1 goes here
      },
      CONST2 {
               //Body for CONST2 goes here
      },
      CONST3(arguments-list){
               //Body for Const3 goes here
      };

      //other code goes here
}

//When you create a body, for a enum, the compiler creates an anonymous class, which inherits from the enum type.
//it then moves the body to that anonymous class. 

//An example of declaring a body in a Enum, is as follows;

public enum ETemp {
      C1 {
           //body of constant C1
           public int getValue(
                    return 100);
          }
      },
      C2,
      C3;
}

//Here, we declare a method in the Enum class, in the body of the C1.

//The compiler will automatically compile your code into something akin to the following;

public enum ETemp {
      public static final ETemp C1 = new ETemp() {
              public int getValue() {
                       return 100;
              }

      };
      public static final ETemp C2 = new ETemp();
      public static final ETemp C3 = new ETemp();
      //Code goes here
}

//In the above example, the class contains a Anonymously declared Method, which is redundant. Thus, to solve this, we can do as follows;

public enum ETemp {
      C1 {
              //Body of the Const C1

              public int getValue() {
                  return 100;
              }
      },
      C2,
      C3;

      public int getValue() {
          return 0; //What we made here, is a function that it defauls to, which is overwritten by C1, but without this, we would not be able to use it in the ETemp enum type
          //Because the enum ETemp type would not have a getValue() function
      }
}

//What follows, is the abstract implementation version of the Enum class

public enum ETemp {
       C1 {
               //Body of constant C1
               public int getValue() {
                        return 100;
               }
       },
       C2 {
               public int getValue() {
                       return 0;
               }
       },

       C3 {
               public int getValue() {
                       return 0;
               }
       };

       //We can make a default abstract one, that forces implementation, if that is the wanted result

       public abstract int getValue(); //This forces enum ETemp Types to define their Constants getValue() method,
       //in this specific situation, we have overwritten all of the possible outcomes for the abstract method.
       //If we were to define a new one, with a class that inherited this, we'd have to define a new one
}

//What follows, is a wholesome example, of a improved Enum declaration;

package com.jdojo.enums;

public enum SuperSmartSeverity {
      LOW("Low Priority", 30) {
              public double getProjectedCost() {
                      return 1000.0;
              }
      },
      MEDIUM("Medium Priority", 15) {
              public double getProjectedCost() {
                      return 2000.0;
              }
      },
      HIGH("High Priority", 7) {
              public double getProjectedCost() {
                      return 3000.0;
              }
      },
      URGENT("Urgent Priority", 1) {
              public double getProjectedCost() {
                      return 5000.0;
              }
      };

      //We have to declare instnace variables as well
      private String description;
      private int projectedTurnaroundDays;

      //Declare a private constructor
      private SuperSmartSeverity(String description, int projectedTurnaroundDays) {
              this.description = description;
              this.projectedTurnaroundDays = TurnaroundDays;
      }

      //Declare a public method to get the turn around days
      public int getProjectedTurnaroundDays() {
              return projectedTurnaroundDays;
      }

      //We have to override the toString function in the Enum class to return the description as we see fit
      @Override
      public String toString() {
              return this.description;
      }

      //Provide getProjectedCost() abstract method, so all constants override and provide implementation for it on
      //their body
      public abstract double getProjectedCost();
}

//We have made the following changes to the Severity Enum, which we now refer ot as SuperSmartSeverity;

We have made a function to return projected cost based on severity

It has a seperate body for each getProjectedCost method, which you can modify.
//NOTE; If one method is Abstract, in the Enum, it forces ALL of it's constants to have a Body

We have made it available to add a name description for the Severity type

We have overwritten it's toString method, which allows us to modify what the output is.

//What follows, is a example of using the said SmartSeverity Enum

//SuperSmartSeverityTest.java
package com.jdojo.enums;

public class SuperSmartSeverityTest {
          public static void main(String[] args) {
                  for(SuperSmartSeverity s : SuperSmartSeverity.values()) {
                          String name = s.name();
                          String desc = s.toString();
                          int ordinal = s.ordinal();
                          int projectedTurnaroundDays() = s.getProjectedTurnaroundDays();
                          double projectedCost = s.getProjectedCost();
                          System.out.println("name=" + name + ", description=" + desc + ", ordinal=" + ordinal + ", turnaround days=" + projectedTurnaroundDays + ", projected cost=" + projectedCost);
                  }
          }
}

//this would iterate through the array of SuperSmartSeverity.values(), with specifying SuperSmartSeverity as s, which we access the attributes of, to print information that we want

//When we want to compare two Enum constants, there is 3 ways we could this;

using the compareTo() method of the Enum class

using the equals() method of the enum class

using the == operator

//The compareTo() method, must compare in regards to Enums that are of the same type;

//For instance;

Severity s1 = Severity.LOW;
Severity s2 = Severity.URGENT;

int diff = s1.compareTo(s2);
System.out.println(diff);

//Assuming earlier code, we'd print -3

//However, if we made another enum, as follows;

public enum BasicColor {
      RED, GREEN, BLUE;
}

//We would not be allowed to do the following operation;

int diff = BasicColor.RED.compareTo(Severity.URGENT); //This is a compile time error, because the two enums are of different types

//if we call .equals() on something that is itself, it will return true.
//is it anything else, however, as in, another Enum type or another constant of enum, it returns False

//You can also use the == operator, albeit only on things that are of the same Enum Type

Nested Enums;

//You can declare a Enum inside a Class, Enum or Interface.
//They are inheritly static.

//You cannot, however, declare a Enum in a Methods body

//What follows, is a few examples of how you can interact with Enums;

package com.jdojo.enums;

import com.jdojo.Person.Gender;

public class Person {
      public enum Gender {MALE, FEMALE}
}

//if we want to use this, in another java file, we must import it, as follows;

package com.jdojo.enums.pkg1;

public class Test {
       public static void main(String[] args) {
            Gender m = Gender.MALE;
            Gender f = Gender.FEMALE;
            System.out.print(m);
            System.out.print(f);
       }
}

//You can also use simple names by using a static import, as follows;

//Test.java
package com.jdojo.enums.pkg1;

import com.jdojo.enums.Person.Gender;
import static com.jdojo.enums.Person.Gender.*;

public class Test {
       public static void main(String[] args) {
            Gender m = MALE;
            Gender f = FEMALE;
            System.out.println(m);
            System.out.println(f);
       }
}

//You can also nest Enums, as follows;

public enum OuterEnum {
       C1, C2, C3;

       public enum NestedEnum {
             C4, C5, C6;
       }
}


public interface MyInterface {
       int operation1();
       int operation2();

       public enum AnotherNestedEnum {
             CC1, CC2, CC3;
       }
}

//A Enum type, is NEVER abstract. And it also, can NEVER inherit, from other Enums.

//A Enum, can however, implement interfaces. If it does so, it must provide for all of it's abstract methods, to make it not Abstract.

//what follows, is examples of how to use a Enum, that is either partially used, or just run by virtue of their type;

//Command.java
package com.jdojo.enums;

public interface Command {
        void execute();
}

//CommandList.java
package com.jdojo.enums;

public enum CommandList implements Command {
        RUN {
              public void execute() {
                    System.out.println("Running...");
              }
        },
        JUMP {
              public void execute() {
                    System.out.println("Jumping...");
              }
        };

        //force all constants to implement the execute command
        public abstract void execute();
}


//What follows, is an example of how to run a Enum, by type;

//CommandTest.java

package com.jdojo.enums;

public class CommandTest {
         public static void main(String... args) {
               //Execute all commands in the command list
               for(Command cmd : CommandList.values()) {
                     cmd.execute();
               }
         }
}

//This would simply run the values of the Command enums, which we call cmd here, when iterating, and we retrieve the value for cmd by virtue of callign the values() of the Enum that we are iterating on

//You can also do, a lookup of the values of a Enum, which is called a Reversed look up, by virtue of Index number or name, as follows;

Severity low1 = Severity.valueOf("LOW"); //A reverse lookup with names
Severity low2 = Severity.values()[0]; //A reverse lookup using an ordinal (index)

//NOTE; The checkup with input of a String value, is case sensetive

//The Java API has a thing called EnumSets, which are very efficient and handle a range of Enums, which are of the same type.
//Suppose you have a set of Enum constants, as follows;

//Day.java
package com.jdojo.enums;

public enum Day {
      MONDAY,TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;
}

//What follows, is how to use a EnumSet for this;

//EnumSet.java
package com.jdojo.enums;

import java.util.EnumSet;

public class EnumSetTest {
       public static void main(String[] args) {
               EnumSet<Day> allDays = EnumSet.allOf(Day.class); //Here, we get a set of all the days, of the Day enum Class //NOTE: The allOf, means get all of them
               print(allDays, "All days: ");

               EnumSet<Day> weekDays = EnumSet.range(Day.MONDAY, Day.FRIDAY); //Here, we get the range from MONDAY, to FRIDAY
               print(weekDays, "Weekdays: ");

               //We can get the rest of remaining elements, by using complementOf
               EnumSet<Day> weekends = EnumSet.complentOf(weekDays);
               print(weekends, "Weekends: ");


       }


      public static void print(EnumSet<Day> days, String msg) {
             System.out.print(msg);
             for(Day d : days) { //Iterate through the EnumSet and use formatting to format the text properly
                  System.out.print(d + " ");
             }
             System.out.println();
      }
}

//The output, we'd get from this, is ;

All days: MONDAY TUESDAY WEDNESDAY THURSDAY FRIDAY SATURDAY SUNDAY
Weekdays: MONDAY TUESDAY WEDNESDAY THURSDAY FRIDAY
Weekends: SATURDAY, SUNDAY
