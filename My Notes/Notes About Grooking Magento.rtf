The book series has three main goals:

Help prepare for the Magento Certified Developer Exam (MCD)

To be used as a reference for best practices and Magento architechture

Given solutions to specific problems in a "developer cookbook" style

The book content follows the Magento Certification Study Group Moderation Kit published by Magento.

It takes the bare bones exercises and solutions provided by the Study Group Kit and provides insight
into the core architechture by researching how a solution may be approached. Then it discusses the example exercise
solutions provided with this book.

Along the way, many aspects of the Magento architechture are uncovered, thus providing the background knowledge and mindset required
to pass the MCD exam.

Almost as a side effect, readers will find they become more efficient and effective as Magento devs.

the first book in the series focuses on the exercises from the Basics and Request Flow section of the Study Group Kit.

It covers the following topics:

Class name resolution

How and why class rewrites work

Application Area Emulation

The Request Flow Process

The Front Controller

Database Based Request Rewrites

Configuration Based Request Rewrites

Action Controller instansiation

The Action Controller Dispatch Process

Route Configuration

Action Controller Rewrites

Action Controller Flags

The Event Dispatch Process and Observer Configuration

The Configuration XML Loading and Merging Process

Setting, Reading and Saving Config values

The Magento app dispatch process

The store view selection process

Approaches for Multi-Website setups

The Customer Session before AuthUrl after AuthUrl properties

Email Template Placeholders and Variables

Custom Email Template Variables

One of the main tools Magento offers to prepare for the Magento Certified Developer exam, is the Magento Developer Certified Preparation Study Group Moderator Kit,
A.K.A Study Group Kit.

The study group kit is good, but rather bare-bones. Besides instructions on how to organize and structure meetings, it comes with a bunch of exercises for each
of the content sections and some example solutions.

However, for some of the exercises no solutions are provided, and the solutions that do exist have only a few comments in the source code to explain what is occuring.

The Study Group Kit really is relying on you, or your study group, to dig deep into the Magento source code to figure out how things work exactly.

On one hand it makes sense, since it facilitates learning the ins and outs of the Magento framework.

On the other hand, it may not be the fastest way to learn for everybody and certainly not the easiest. Also, it is easy to miss things.

this book and the others in the Grokking Magento series aim to be a guide through the exercises and solutions, providing additonal insights while still
helping the reader to become accustomed to the Magento core code.

This book is not a basic introduction to Magento dev.
There are many books and online resources available for a Novice Magento dev to start creating custom Magento modules.

This books series expects the reader to have some prior knowledge about Magento.

To gain the most from this book, the reader should be familiar with the following topics:

Good knowledge of the PHP language

A solid understanding of object-oriented PHP

How to create a skeleton Magento module

The Magento dir structure

The details of Varien_Object's magic getters and setters.

The more context you already have, the more you will learn from this book.

If you are reading this book as a novice Magento dev, it makes sense to return to this book again later with more knowledge.

You can be sure to gain additional knowledge and understanding the second time around.

Firstly, this book better solutions to the exercises of one section of the MCD study group kit.

What's more, it not only comes with the solution code for the exercises, but also provides extensive documentation for the code in the form of this book.

This book can be used as a reference whenver you want to dig into a specific area of Magento dev, independant from being in the process of preparing for the MCD exam.

One of the best skills to develop in order to become a better Magento developer is the ability to read core code.
As everything in life, practice is key. The series also hopes to facilitate building that skill by taking apart core methods, commenting on what code sections do, and putting them into context.

Each exercise is discussed in detail.
First there is a reflection on real world scenarios, in which a given exercise might be relevnat.

Some ideas might be a little far-fetched, but i hope to come up with good scenarios that make sense for most cases.
I personally find it a lot easier to think about a problem if i know why i need to solve it.

Putting an exercise into context also helps remembering the solution, so the knowledge can be called upon in future projects.

The next part of each chapter is some background research.

This part of the chapter is a dive into the Magento core in order to find out what needs to be known to be able to implement a good soluiton.
Along the way, the discussion might take some detours on related subjects once in a while. this may happen out of two reasons:

The content could be part of the certification exam, and there is no better place to talk about it.

The content serves to get a bigger picture of how Magento works.

Simply follow along, as the text will be back on the main track towards the exercise solution again in a little while.

Then, after gathering the required architechtural information, the actual solution code is dissected step by step.

Because the example source code supplied with the study group kit is not free to be shared, all solutions have been developed specifically for this book.
However, it's in the nature of Magento that two solutions for the same problem might be similar to each other.

For example, building an adminhtml grid based on the adminhtml widget blocks simply has to be done in a specific way to get the desired outcome.

We recommend you take the time to compare solutions provided by this book, and the study Group ki to gain additonal insights, if possible.

The samples in the book might be abbreviated in order to make them easier to read. For example, any calls to Varien_Profiler::start() and Varien_Profiler::stop() will be removed.

Magento 1 still officially supports the Ancient version 5.2 of PHP, but consider running at least PHP 5.3.6 since it contains many useful features.
Magento has provided download patches to support PHP 5.4 for older versions of Magento, too, so there is no real reason to still use PHP 5.2

Many commmunity devs are using PHP 5.5 already with Magento in order to take advantage of the many new features without experiencing any real issues.

Using an OpCode Cache like the Zend Optimizer or APC is also highly recommended. Magento is a heavy weight application, and every little improvement helps.

Installing and learning to use xdebug (or the Zend debugger if you are using Zend Server) is one of the most valuable things a PHP dev can do.
So in case you are not familiar with it, start now.

Currently the IDE most Magento devs favor, is PHPStorm in combination with Magicento plugin.
This makes for a highly efficient Magento dev setup.
A single developer license for PHPStorm is very cheap when compared to other commersional IDE products.

There are free alternatives as well, of course: Eclipse and Eclipse Magento Plugin, or Netbeans most prominently.
Both IDEs are open source, free and excellent products. However, working with them isn't as smooth and effortless as with PHPStorm, and they tend to be slower.

Sublime text 2 with SublimePHPIntel is a combination many devs love, however it can't match the amount of support a dev gets from a full IDE (at least currently).

There are other IDEs and Editors (Zend Studio, Aptana, Komodo etc), however, they are far less popular and seem to be slowly losing ground in the Marketplace.

That said, it certainly is possible to develop Magento extension using nothing but a text editor. However, only a person with superhuman power (lol) could claim
to be as efficient that way with an IDE.

Since the first release of PHPUnit a lot happened in the world of PHP testing. It is a complex topic, however everybody who gets into the habit of writing 
tests doesn't want to go back.

It is very possible to write tests for custom Magento modules with plain PHPUnit.

However, because Magento uses many static method calls and practically violates the Law of Demeter in almost every method, it is
sometimes not a straightforward process.

Either large amounts of objects need to be mocked, or complex fixtures need to be created.

Several integrations have been developed to help writing tests for Magento.

The most well-known one is EcomDev_PHPUnit. Its outstanding feature is the excellent support for creating fixtures in yaml files.
besides that, it also offers many assertions and workarounds to make the Magento framework more test-friendly.
Check out the dev branch if you choose to try it out.

The Mage_Test integration is a much more lightweight PHPUnit integration. It provides basic support and help to make Magento testable.
It's under active , albeit slow, development. Check out  the dev branch to see what is going on . However, if you are already familiar with
PHPUnit you might feel quite at ease with it.

The project magetest.org aims to provide a set of unit-tests for the Magento core. It might be useful as a smoke-test. For the
Magento testing integration it uses EcomDev_PHPUnit.

The BDD framework Behat, and its magento integration BehatMage are different. IT does not aim to provide unit test features, but instead
enables users to test business specifications written in a human readable language known as Gerhkin. Behat itself
is getting quite mature, but the MAgento integration is still lacking some features.

For example, testing multi-site instances with separate domains isn't possible out of the box.

The PHPSpec2 functiona testing framework is another framework not based on PHPUnit. It features the semi-automatic generation of tests,
However, the standard mocking library Prophecy doesn't play well with Magento's Magic setter and getter methods, so it's nessecary to
fall back to Mockery (or even PHPUnit) for stubs and mocks.

There is a project to integrate Magento with PHPSpec2 called MageSpec, but once again Development isn't going very quickly.

A relativeily new testing framework is called codeception.
It follows a similar approach to testing as Behat, but as far as I'm aware of there is no toolset for Magento available yet.

Basically all tools to run functional tests can be used with Magento, too.
They either remote control a browser window (for example using Selenium or Sahi) or using a headless browser (currently the phantomjs based tools are very popular).

Choosing the right tool for the job is left to the reader, since there is no "one size fits all" recommendation.

Exercise: Rewrite the sales/order model, add the group ID as an email template variable

Original task descrip:

The original task descrip from the study group kit for the exercise is as follows:

Rewrite the sales/order model to add the customer group model as an email template variable in the sendNewOrderEmail() method, so the
group code can be added to the email using {{var customer_group.getCode}}.

OVERVIEW

This chapter discusses the following topics in the research section and the examiniation of the exercise solution:

The method sendNewOrderEmail() of the sales/Order model

Using core/app_emulation and its benefits over setCurrentStore()

Email template variables and placeholders

Custom CMS and email template directives

How class name resolution is done and how model rewrites work

SCENARIO

Imagine that for some reason the store owner wants to include the customer group name in the new order email.
Maybe they would like to add conditional blocks in to the template so they are able to display different promotions to different groups.

RESEARCH

Let's start by having a look at the method in question:

Mage_Sales_Model_Order::sendNewOrderEmail()

The method is quite long. A pity it doesn't follow the good old rule of thumb that each method should completely fit on the screen. (Since when did this ever apply?)

For reference purposes it is a good idea if you open the method in your IDE, while we break it up and examine it section by section here.

Along the way we will examine different areas of the Magento core code that make the process of sending emails work, but also are useful in other contexts.

Switching Areas:code/app_emulation

The first interesting part is at the beginning, where the store is pseudo-switched to the store view of the order.

The essential section of code in regards to this is about 10 lines into the method:

//Start store emulation process
$appEmulation = Mage::getSingleton('core/app_emulation'); //Get a singletone through Mage
$initialEnvironmentInfo = $appEmulation->startEnvironmentEmulation($storeId);

The original environemt will then be restored later using $appEmulation->stopEnvironmentEmulation($initialEnvironmentInfo).

Let's have a quick detour and look at what this environment emulation is about.

public function startEnvironmentEmulation(
	$storeId,
	$area = Mage_Core_Model_App_Area::AREA_FRONTEND,
	$emulateSroreInlineTranslation = false)
	{
		if (is_null($area)){
			$area = Mage_Core_Model_App_Area::AREA_FRONTEND; //if the area operated on, the frontend, is empty, designate it to be the front end area through the magento core model app area class
		}
		if ($emulateSroreInlineTranslation) { //if the emulateStoreInlineTranslation is true
			$initialTranslateInline = $this->_emulateInlineTranslation($storeId, $area); //then we assign the emulateINlineTranslation to bind from this to the translation call with the storeId and the area of the frontend
		} else {
			$initialTranslateInline = $this->_emulateInlineTranslation();
		}
		$initialDesign = $this->_emulateDesign($storeId, $area);

		//Current store needs to be changed right before 
		//locale change and after design change

		Mage::app()->setCurrentStore($storeId);
		$initialLocaleCode = $this->_emulateLocale($storeId, $area);

		$initialEnvironmentInfo = new Varien_Object();
		$initialEnvironmentInfo->setInitialTranslateInline($intialTranslateInline)
			->setInitialDesign($initialDesign)
			->setInitialLocaleCode($initialLocaleCode);

		return $initialEnvironmentInfo;
}

The method call takes care that the following aspects of Magento are set if the request had been for the specified store:

The area

The theme configuration

The locale

The current store

To summarize, using core/app_emulation is more complete than just calling the common Mage::app()->setCurrentStore($storeId);

Going back to the sendNewOrderEmail() method, what happens while the order's store is being emulated?

$paymentBlock = Mage::helper('payment')->getInfoBlock($this->getPayment())
	->setSecureMode(true);
$paymentBlock->getMethod()->setStore($storeId);
$paymentBlockHtml = $paymentBlock->toHtml();

The payment info block is rendered into a variable $paymentBlockHtml. After that, the environment emulation is ended.

Ask yourself, "why is the envirornment emulation needed?"

Usually, the store ID set on an order matches the current store while the order is placed.
But if the orderr is being placed using the Admin panel, the current store is the admin store view.
The adminhtml theme is being used, together with the admin user's locale configuration.

But of course, the payment information in an order email should match the customer's settings,
for whom the order is being created.

For that reason, the settings are switched accordingly during the payment info block rendering using the app emulation.

Email template placeholders and variables

Moving on further in the sendNewOrderEmail() method, we don't need to discuss
the next few lines in detail. They simply get config settings to initialize the core /
email_template_mailer instance. The relevant part for us is towards the end of the method,
where the template variables are specified:

$mailer->setTemplateParams(array(
		'order' 	=> $this,
		'billing' 	=> $this->getBillingAddress(),
		'payment_html' => $paymentBlockHtml)
	)
);
$mailer->send();

The array values will be accessible in the email templates by using {{var ...}} placeholders referencing the array keys passed to the setTemplateParams() method.
One example for such a placeholder directive could be {{var payment_html}}, which would include the rendered payment info block into the email.

Note that the template parameters are specified directly before the email is sent.

Please note that we are currently not discussing Magento's.phtml template files. This section
of the book is about the template system used for transactional emails and CMS content.

Only the name template is the same, but otherwise, these two are quite distinct! More info on theme template files can be 
found in the next book in the series, "Rendering and Widgets".

According to best practices, it would be ideal if we could add the new customer group template variable using an event observer.
But looking at the methods Mage_Core_Model_Email_Template_Mailer::setTemplateParams() and send() doesn't reveal any useful events.

There don't seem to be any earlier ones, either, as searching for the string "dispatchEvent" within the class turns up nothing.

We will have to look further for the best way to implement our customization. Let's continue
to analyze how the template variables are processed further.

The core/email_template_mailer class delegates to core/email_template, more specifically, to its sendTransactional() method.
This in turn calls its send() method, and there, finally, the template variables are processed.

$text = $this->getProcessedTemplate($variables, true);

The class Mage_Core_Model_Email_Template_Filter is not only used for email templates. The CMS filter class also makes
heavy use of it when rendering CMS blocks and pages.

it is worth taking another detour to look at the way variables can be accessed in templates.

The key method is Varien_Filter_Template::_getVariable()

This method implements all the different ways how template placeholder directives can be used to access the template variables.

protected function _getVariable($value, $default='{no_value_defined}')
{
	$tokenizer = new Varien_Filter_Template_Tokenizer_Variable(); //Instanciate the tokenzier
	$tokenizer->setString($value); //massign the tokenizer the value
	$stackVars = $tokenizer->tokenize(); //make the token

	//Continuation is below

The value passed to the method is the content part of a template {{var ...}} placeholder directive.
For example for a placeholder {{var foo}}, the argument variable $value would be set to foo.

This value is tokenized, that is split, using the dot character as a seperator. This character is hardcoded in the Varien_Filter_Template_Tokenizer_Variable class.

Then each of the tokens are analyzed in a for loop.
This is required because tokens can be chained, as we will see further below.

Each token that is resolved, will update the token stack to the latest value. This continues until the full stack of tokens is resolved, and the final
replacement value has been determined.

$result = default; //assign the default value
$last = 0; //the last value

for($i = 0; $i < count($stackVars); $i++){ //While i is less than the amount of vars in tsack
	if($i == 0 && isset($this->_templateVars[$stackVars[$i]['name']])) { //if i is 0 and the template vars name is set
		//Getting of template value
		$stackVars[$i]['variable'] =& $this ->_templateVars[$stackVars[$i]['name']]; //get the name
	} else if (isset($stackVars[$i-1]['variable']) //if the previous is set to be a variable
		&& $stackVars[$i-1]['variable'] instanceof Varien_Object) { //and that said thing is a instance of a Varien_Object
		//If object calling methods or getting properties
		if($stackVars[$i]['type'] == 'property') { //If it's the type is a property
			$caller = "get" . uc_words($stackVars[$i]['name'], '');
			if(is_callable(array($stackVars[$i-1]['variable'], $caller))) {
				//If specified getter for this property
				$stackVars[$i]['variable'] = $stackVars[$i-1]['variable']->$caller();
			} else {
				$stackVars[$i]['variable'] = $stackVars[$i-1]['variable']->getData($stackVars[$i]['name']);
			}
		} else if ($stackVars[$i]['type'] == 'method'){
			//calling of object method
			if (is_callable(
					array($stackVars[$i-1]['variable'], $stackVars[$i]['name'])
				) || substr($stackVars[$i]['name'],0,3) == 'get'
			) {
				$stackVars[$i]['variable'] = call_user_func_array(array($stackVars[$i-1]['variable'],
																			$stackVars[$i]['name'],
																			$stackVars[$i]['args']);
			}
			
		}

		$last = $i;
		}
	}

	if(isset($stackVars[$last]['variable'])){
		//If value for construction exists set it
		$result = $stackVars[$last]['variable'];
	}
	return $result;
}

//There is some general error regarding indention on this code

To be honest, it isn't easy to understand this piece of code.
An approach that tends to work well with code like this is to analyze it bit by bit to make it more digestable.

The most interesting part is within the for loop, where the code evalutes the type of the tokens (aka parts of the variable name) and fetches the value to replace it with.

Each token can be one of two things: Either it is a predefined name, or it is a property or method of a Varien_Object.

NOTE: Varien_Object is the Object super-type of all Objects in Magento.

To give some context: the method _getVariable() is called from several places (as you can confirm by a quick search over the core code):

Magento_Core_Model_Template_Filter::VarDirective()
Varien_Filter_Template::varDirective()
Varien_Filter_Template::dependDirective()
Varien_Filter_Template::ifDirective()
Varien_Filter_Template::_getIncludeParameters() (which is called, amongst others, from htmlescapeDirective())

Each of the methods whose name ends in Directive processes a matching directive that can be used in the template text.

For example, {{if ...}} will be processed by the ifDirective() method. The $value passed to the method above is the placeholder directive's content string.

Since assigned variables can be used in a variety of contexts, it is quite useful to know how to access variable contents in Email and CMS templates.

Here are some examples of valid variable template declaration so we know what we are looking for while reading the _getVariable() method.

Variables with plain text or HTML content:

{{var payment_html}}
{{htmlescape var=$payment_html}}

These would be the predefined names checked first in the for loop.

Properties of objects contained in variables can be accessed using a dot as a separator in a variety of ways.

Consider the following two variables from the current exercise:

{{var order.customer_name}}
{{var order.getCustomerName()}}

If such a token value "returns" a Varien_Object instance, further calls may be chained:

{{var order.billing_address.getCity()}}
{{var order.getBillingAddress().city}}
{{htmlescape var=$order.billing_address().city}}

This kind of method or property chaining to access object properties can be used everywhere _getVariable() is used.

Please read over the _getVariable() method one more time for each of the given example, and step through the code in your mind, resolving each token one at a time.

NOTE: Arrays in PHP is like multidimensional arrays or dictionariesi n Python, meaning we access keys to positons

Custom email template directives:

Let's go a bit deeper into the subject of email and CMS page directives, even if it's not directly relevant for 
the current exercise.

So far, this chapter only talked about the {{var ...}} and {{htmlescape var=...}} directives.

It is quite easy to imeplement custom directives, for example {{customergroup}}, to output the current customer group name.

The base functionality for this is inherited from class Varien_Filter_Template::filter().

Whenever a placeholder is found, the class checks if there is a method matching the placeholder name, followed by the word Directive.

The {{customgrp}} placeholder for example, would cause the filter class to check for a method customgrpDirective(). Note, that no underscores are allowed
in the placeholder names. The regex that is used to match the placeholder, is:

/{{([a-z]{0,10})(.*?)}}/si

The method implementing a directive recieves the captured parts from the regex as an argument.

Using $params = $this->_getIncludeParameters($matches[2]) any arguments to the directive can be easily parsed.

Any param values starting with a $ will automatically be evaluted using the _getVariable() method discussed above.

The placeholder will then be replaced by the string value the directives returns.

For example, a directive for the PH {{customgrp id=$order.getCustomerGroupId()}} could look like this:

public function customGrpDirective($matches)
{
	$param = $this->_getIncludeParameters($matches[2]);
	if (isset($params['id'])){
		$groupId = (int)$params['id'];
	} else {
		$groupId = Mage::getSingleton('customer/session')
						 ->getCustomerGroupId();
	}
	$group = Mage::getModel('customer/group')->load($groupId);
	return $group->getCode();
}

The method will render code of the customer group whose ID was specified as an argument using the id param.
if no group ID was specified, the current customer group is used.

The directive is called custmrgrp instead of customergroup because the regex matching the PH allows for a max of 10 chars as a PH name.

The example PH used above, {{custmrgrp id=$order.getCustomerGroupId()}}, uses the param $order which is available in the  new order emails.

There are several options available to let Magento know you want a custom filter class to be used.

For CMS pages and blocks you can either config a class rewrite for the cms/templates_filter model, or you can specify  the class
using the config XPath global/cms/page/template_filter and global/cms/page/template_filter

To make your custom directive available in email templates, you need to rewrite the model core/email_template_filter.

Enough of the template variable detour. Time to get back on track and figure out how to specify the customer group as a template variable.

Since we did not find any matching events, we need to fall back to a class rewrite of the sales/order class.
That is the only way we will be able to add our custom logic to the sendNewOrderEmail() method.

The example solution code can be found in the extension Meeting02_RewriteOrder.

All magento devs know how to specify a model rewrite in config XML, but few know WHY that works, and that is
what is needed during the MCD exam.

Magento uses factory methods. These factory methods take a string as their first arg. This string is then mapped to a real PHP class name
by a series of steps consisting mostly of looking up values form config XML. This process is known as class name resolution.

Let's go through a concrete example by having a look at the config xml which is nessecary to declare a rewrite for the sales/order model,
and then see how it is processed by Magento.

<config>
	<global>
		<models>
			<sales>
				<rewrite>
					<order>Meeting02_RewriteOrder_Model_Sales_Order</order>
				</rewrite>
			</sales>
		</models>
	</global>
</config>

In Magento, to create a fresh instance of a new model, usually the Mage::getModel() factory method is called.

$order = Mage::getModel('sales/order');

Let's have a look at the factory method itself:

public static function getModel($modelClass = '', $arguments = array())
{
	return self::getConfig()->getModelInstance($modelClass, $arguments);
}

Note: There is an optional second arg which will be passed to the constructor if present. This feature is shared
by most of Magento's factory methods.

The call is delegated to Mage_Core_Model_Config::getModelInstance().

public function getModelInstance($modelClass = '', $constructArguments=array())
{
	$className = $this->getModelClassName($modelClass);
	//Further code ommited from here
}

The class name resolution is delegated to the method getModelClassName():

public function getModelClassName($modelClass)
{
	$modelClass = trim($modelClass);
	if (strpos($modelClass, '/') ===false) {
		return $modelClass;
	}

	return $this->getGroupedClassName('model', $modelClass);
}

The condition in this method has the consequence that if you pass a regular PHP class name to Magento::getModel(),
it will abort the lookup process and simply use the name as-is. This means that for any rewrites to take effect, the class alias (with the /) needs to be used.

For example:

//Class rewrites apply if present
$order = Mage::getModel('sales/order');

//Class rewrites will be ignored
$order = Mage::getModel('Mage_Sales_Model_Order');

The method Mage_Core_Model_Config::getGroupedClassName() contains the generic code for class name resolution, regardless of the type of object being instansiated.
All other factory methods for helpers, blocks and so on use it as well. Whenever you question why a rewrite isn't working, this is the place to go and see what is actually happening.

Let's start by looking at each part in order:

public function getGroupedClassName($groupType, $classId, $groupRootNode=null)
{
	if(empty($groupRootNode)) {
		$groupRootNode = 'global/'.$groupType.'s',
	}



The first argument is the object type, which is one of model,block or helper.
The second argument is the string that was specified as an argument to the facotry method, for example sales/order.

We know it contains a / since that is confirmed in the preceding methods.
The third argument is not used in the core. It could be used to tell the method to do the class name resolution by 
looking at config in a custom branch of XML.

In the code section displayed above the variable $groupRootNode is set to point to the XML config branch for the specific object type.
Models will be resolved using config in global/models, block config will be in global/blocks and helpers will be found under global/helpers.

Note the 's' appended to the group type: It is a common mistake to forget the plural form there.

Moving on:

	$classArr = explode('/', trim($classId));
	$group = $classArr[0];
	$class = !empty($classArr[1]) ? $classArr[1] : null;

	if (isset($this->_classNameCache[$groupRootNode][$group][$class]))
		return $this->_classNameCache[$groupRootNode][$group][$class];
	}

This is one of the most important steps: the class alias is exploded on the /.
The string sales/order is split into sales and order. Let's clarify some naming conventions before we continue:

		Naming conventions during class name resolution
	Part 		Name 		Variable 		Sometimes also called
model 			Object Type $groupType 
sales/order 	Class Alias $classId 		Class ID or Factory Name
sales 			Class Group $group 			
order 			Class Suffix $class 		The-Part-After-Slash
Mage_Sales_Model Class Prefix 				See below what this is 

I will stick to the identifiers under the Name column, but at Magento meetups or conferences, you 
might also hear the parts called by other names.

As you can see, the core/config class which is doing the resolution utilizes a lookup cache.
Once a class alias is resolved, following requests for the same alias no longer needs to go through the 
whole process again.

	$config = $this->_xml->global->{$groupType.'s'}->{$group};

	//First - check maybe the entity class was rewritten
	$className = null;
	if (isset($config->rewrite->$class)){
		$className = (string)$config->rewrite->$class;
	}

The actual configuration for the specified class group is stored in the variable $config. IN our
example case, sales/order, that would be the entire config contained within the <sales> node:

<config>
	<global>
		<models>
			<sales>
			...
			</sales>
		</models>
	</global>
</config>

Or, in Magento's simplified XPath notation: global/models/sales.

Please note: the first real config lookup to determine the real PHP class name is done here.

To continue our example: if the node global/models/sales/rewrite/order exists, its value is assigned to the variable $className and it will be used
as the PHP class name. In this case class resolution, is complete!

This is why a class rewrite in XML uses the following structure:

<config>
	<global>
		<[Object Type]s>
			<[Class Group]>
				<rewrite>
					<[Class Suffix]>The_Php_Class_Name_That_Is_Used</[Class Suffix]>
				</rewrite>
			</[Class Group]>
		</[Object Types]s>
	</global>
</config>

Or in our concrete example case, a class rewrite for sales/order would need to be specified as follows:

<config>
	<global>
		<models>
			<sales>
				<rewrite>
					<order>Meeting02_RewriteOrder_Model_Sales_Order</order>
				</rewrite>
			</sales>
		</models>
	</global>
</config>

Class name resolution is not applied recursively, so it is not possible to rewrite a rewritten class and 
have both rewrites be in effect.
But what happens if no rewrite exists for the class alias in question?

	}
	else {
		/**
		* Backwards compability for pre-MMDB extensions
		* In MMDB release resource nodes <..._mysql4> were renamed
		* to <..._resource>. So <deprecatedNode> is left to keep
		* name of the previously usedn odes, that still may be used
		* by non updated extensions
		if ($config->deprecatedNode){
			$deprecatedNode = $config->deprecatedNode;
			$configOld = $this->_xml->global->{$groupType.'s'}->$deprecatedNode;
			if (isset($configOld->rewrite->$class)) {
				$className = (string) $configOld->rewrite->$class;
			}
		}
	}

Luckily, we get a nice comment. To understand it, we need to remember that this method is not only used for models,
blocks and helpers, but also for resource model class name resolution.

Magento 1.6 introduced a full DB abstraction layer called MMDB,i guess which stands for Magento Multi DB.

While doing so, they unified the resource model structure within all modules, and renamed all resource class groups.

			Examples of MMDB resource class group changes
	MOdule 			Magento 1.0-1.5 			Magento 1.6+
Mage_Catalog 	catalog_resource_eav_mysql4 	catalog_resource
Mage_Customer 	customer_entity 				customer_resource
Mage_Newsletter newsletter_mysql4 				newsletter_resource

As you can see, since Magento 1.6 all resource class group names follow the same convention.

Assume a rewrite would have been specified for the customer/address resource model in a Magento version before 1.6
The config path would had to be:

global/models/customer_entity/rewrite/address

With Magento 1.6 the path changed to:

gloal/models/customer_resource/rewrite/address

NOTE: BASICALLY WE CHANGED FROM ENTITIES TO RESOURCES AFTER MAGENTO 1.6

Any modules using the old path would break. for that reason, a new node was introduced:
<deprecatedNode>
It contains the old, pre-MMDB, resource model class group of each module.

If no regular rewrite for a class is found, the config model checks if a rewrite for the old name is present (see the code block above).

Class name resolution continued

We examined the code responsible for class rewrites, but there still is a little remainder of the getGroupedClassName() method left.
Insteado f inishing here, let's continue the exploration, even if it doesn't directly apply to the current exercise.

It is defenitly useful to know, MCD exam-relevant, and not very long.

Back to the previous question, what happens if no rewrite exists for the class alias being resolved?

	//Second - if entity is not rewritten then use class prefix to form class name
	if (empty($className)){
		if(!empty($config)){
			$className = $config->getClassName();
		}
		if(empty($className)){
			$className = 'mage_'.$group.'_'.$groupType;
		}
		if(!empty($class)){
			$className .= '_'.$class;
		}
		$className = uc_words($className);
	}

In the code block the config model tries to establish a Class Prefix, onto which it
appends the class suffix, to complete the class name resolution.

First it checks for the value returned by the method Mage_Core_Model_Config_Element::getClassName(). In effect, it returns
the value of a child node <class> or <model> of class group configs.

For the class group sales the config of the class prefix will be at global/models/sales/class or global/model/sales/model.

It might be confusing that the node name is <class>, however, the node value is never a PHP class - it is the class prefix only.
Bad naming choices like this one is part of the reason for Magento's reputation of being difficult to learn (lol)

	<global>
		<models>
			<sales>
				<class>Mage_Sales_Model</class>
			</sales>
		</model>
	</global>

Note: The class prefix is prepended directly to the $class variable without removing whitespace. Hence, the following creates an
invalid class name containing whitespace:

	<class>
		Mage_Sales_Model
	</class>

if getClassName() returns empty, the method getGroupedClassName() falls back to constructing a default class prefix:

$className = 'mage_'.$group.'_'.$groupType;

The consequence is that core developer's can get away without specifying a class prefix for their modules.
We on the other hand, as part of the Dev community working outside the Mage namespace, have to always specify a class group and prefix in our modules.

Finishing up, let's examine the last few lines of getGroupedClassName().

	$this->_classNameCache[$groupRootNode][$group][$class] = $className;
	return $className;
}

Not much to say about these two lines, except that the result of the class name resolution is stored in the 
$_classNameCache property to speed up future lookups during the current request. then the result is returned and the method is complete.

To complete this sub-section, here is the XML that specifies the class rewrite for the exercise at hand:

<config>
	<global>
		<models>
			<sales>
				<rewrite>
					<order>Meeting02_RewriteOrder_Model_Sales_Order</order>
				</rewrite>
			</sales>
		</models>
	</global>
</config>

With this bit of config in place, the sales/order class alias resolves to Meeting02_RewriteOrder_Model_Sales_Order instead of the original
Mage_Sales_Model_Order.

Using the module name in the object type dir (that is ...Model_Sales_Order instead of simply ...Model_Order helps organize the folder structure in our module. Following this
convention makes it possible to see at a glance which classes in our Model dir are originals and which ones are rewrites).

Adding the custom email template variable

According to best practices we should not copy a full method from a parent class when doing a rewrite, since that comproises the ability to upgrade. if the method
changes in a future version, those changes would be masked by our copy  in the rewrite target class. Instead, we should inject our logic before or after calling the parent method.

The next example would be following best practices:

public function sendNewOrderEmail()
{
	$this->_addOurCustomTemplateVariable();
	return parent::sendNewOrderEmail();
}

Unfortunately, we can't do that in this case. The piece of code we want to change is buried deep in the middle of the parent method:

public function sendNewOrderEmail()
{
	//A bunch of code
	$mailer->setTemplateParams(array(
			'order' 		=> $this,
			'billing' 		=> $this->getBillingAddress(),
			'payment_html' 	=> $paymentBlockHtml
		)
	);
	//more code lol :D
}

In cases such as these there is no other way than copying the full method to our rewritten class and adding our logic in there directly.
Here is the piece of code including our customization:

	$mailer->setTemplateParams(array(
			'order' => $this,
			'billing' => $this->getBillingAddress(),
			'payment_html' => $paymentBlockHtml,
			'customer_group' => $this->_getCustomerGroup()
		)
	);

The method to fetch the customer group model is not part of the native order model; we need to implement that ourselves.

/**
  * @return Mage_Customer_Model_Group
  */

protected function _getCustomerGroup()
{
	/** @var Mage_Customer_Model_Resource_Group_Collection $groups */
	$groups = Mage::helper('customer')->getGroups();
	$groupId = $this->getCustomerGroupId();
	$group = $groups->getItemById($groupId);
	if (! $group){
		$group = Mage::getModel('customer/group')->load($groupId);
	}
	return $group;
}

The customer helper class method Mage_Customer_Helper_Data::getGroups() returns a collection containing
all customer groups with an ID larger than 0.
The group with the ID 0 is a special group for guests, that is, not logged in customers.

If the order was placed as a guest, $this->getCustomerGroupId() will return 0.
Because of that it is not guaranteed that the collection will contain the needed group.

If that is the case, then $group will be null, and the customer group model will have to be instansiated and loaded individually.

The reason for trying to get the customer group out of helper's collection first is that we might be able to avoid an extra DB query. Since other
parts of Magento also use the helper's getGroups() method, and because helpers in Magento are always realized as singletons, the group already might
be pre-loaded.

Exercise: Redirect to / if the home page is accessed directly by CMS page identifer:

Original task description:

The original task description from the study group kit for this exercise is as follows:

Create an observer that redirects the visitor to the base URL if the CMS home page URL key is accessed directly (i.e /home -> /).

Overview:

This chapter discusses the following topics in the research section and the examination of the exercise solution:

CMS page url identifiers

The Request Flow process

The Front Controller

The Standard router

Database based request rewrites

Configuration based request rewrites

The action controller dispatch process

Action controller flags

The event dispatch process and observer configuration

Scenario:

Having the exact same content accessible on two distinct URLs is rated as duplicate content by Google.
For that reason, it makes sense to restrict the home page to only be available through a request to the Magento base URL.

Research:

In order to complete the task we need to research the following high-level items:

1. How is the URL key for a CMS page specified?

2. How is a CMS page displayed when its URL key is requested?

3. How can we trigger the redirect?

Additional details such as accessing the current request path will be handled along the way.

The first step requires a look at the cms/page entity.
The second step requires working out how Magento processes requests, a process called request flow.
The third step requires looking for a suitable event - or a rewrite candidate - to inject our logic.

The cms/page Entity

Let's start with the easiest task. CMS pages are flat table entities, meaning they are stored in a single
table - unlike EAV entities. The table name is cms_page.

An additonal table caleld cms_page_store is used to keep the info for the store views in which a page is accessible - this second
table can be ignored for this task though.

Looking at the cms_page table, two columns are the most interesting in regards to teh request flow:

The primary key column page_id

The URL key column identifier

A CMS Page can be accessed on the frontend, if the request path matches the page's identifier. Before the identifier,
the request path only contains the store base URL.

For example, if the configured Magento base URL is http://magento.dev/shop/, and the page's identifier is enable-cookies,
then the full URL to view the CMS page would be http://magento/dev/shop/enable-cookies.

Let's dive in and have a look at how Magento figures that out internally.

Request Flow

Almost all of the request flow process we analyze in this section applies to all page requests, not just the ones
related to CMS pages.

Each request starts with the index.php file in the Magento base dir.
In there, right at the end of the file, Mage::run($mageRunCode, $mageRunType); is called.
We will look into how $mageRunCode and $mageRunType are used to specify the store view in teh chapter Store View Selection.

Forn ow, we will take a more generic view of the request flow process.

The call to Mage::run() does two things: first it causes the basic run time env to be set up, and secondly,
it cuases the request to be processed. That process is started by delegating to Mage_Core_Model_App::run()

The following code block is an abbreviated version of that method and contains only the code most relevant for us:

public function run($param)
{
	// ... complete base setup...
	if ($this->_cache->processRequest()){
		$this->getResponse()->sendResponse();
	} else {
		// ... complete application initialization ...
		$this->getFrontController()->dispatch();
	}
	return $this;
}

UNless the cache processor is able to process the request, the Front Controller is initialized and dispatched.
The cache processor is only relevant for the Enterprise Edition Full Page Cache module, so we will not
go into more detail about it here. Instead, let's have a look at the Front Controller, which comes into 
play at the end of the code sample above when $this->getFrontController() is called.

The Front Controller Routing Process

The Front Controller is the actual start of the routing process.

This is what getFrontController() method and the method _initFrontController() it delegates looks like:

public function getFrontController()
{
	if(!$this->_frontController){
		$this->_initFrontController();
	}

	return $this->_frontController;
}

protected function _initFrontController()
{
	$this->_frontController = new Mage_Core_Controller_Varien_Front();
	Mage::register('controller', $this->_frontController());
	$this->_frontController->init();
	return $this;
}

On the first call to getFrontController(), the instnace of Mage_Core_Controller_Varien_Front is created.
Then init() is called on it. Let's look at that method first, before we continue with the dispatch() method after that.

/**
 * Init front controller
 *
 * @return Mage_Core_Controller_Varien_Front
 */
public function init()
{
	Mage::dispatchEvent('controller_front_init_before', array('front' => $this));

	$routesInfo = Mage::app()->getStore()->getConfig(self::XML_STORE_ROUTERS_PATH);

	foreach ($routersInfo as $routerCode => $routerInfo){
		if (isset($routerInfo['disabled']) && $routerInfo['disabled']) { //if the routing is disabled for that specific XML part
			continue;
		}
		if (isset($routerInfo['class'])) { //if the class is a allocated set of data
			$router = new $routerInfo['class']; //make a new router info based on the class
			if (isset($routerInfo['area'])) { //if the area is set
				$router->collectRoutes($routerInfo['area'], $routerCode); //get the routerCode from that specific area
			}
			$this->addRouter($routerCode, $router); //add the router
		}
	}

	Mage::dispatchEvent('controller_front_init_routers', array('front'=>$this)); //initialize routers based on the array

	//Add default router at the last
	$default = new Mage_Core_Controller_Varien_Router_Default(); //last one is the default router controller object
	$this->addRouter('default', $default); //add the router 

	return $this; //return the initialized object with all the routers rounded up
}

What happens here is actually a very important part of the Magento routing logic.
All the magento routers are initailized and added to the $this->_routers property of the Front controller.
This process is called gathering all routers (or gathering all routes, which is almost - but not quite - the same, as we will see below).

The question is, what is a router?

The purpose of a router is to analyze the browser request and check if it knows how to process it.
The actual processing of the request may then be handed off to an action controller (sometimes also called page controller).

To summarize what we have covered so far:

1. The Front Controller builds an array of router instances.
2. Each router checks if it can figure out what to do with a request.
3. The router that knows how to handle teh request may then delegate to an action controller for processing.

The first routers are created and added to the $_routers array in teh foreach loop in the previous code block.

The config section that the foreach iterates over can be found in the file Mage/Core/etc/config.xml:

<default>
	<web>
		<routers>
			<admin>
				<area>admin</area> //Al ot of Magento modules iterate through teh XML and treat them as associative arrays in terms of the sections, meaning that accessing ['area'] actually means go here, and grab the associated value in that place,
				//which is the respective Mage Core Controller Object for the respective area
				<class>Mage_Core_Controller_Varien_Router_Admin</class>
			</admin>
			<standard>
				<area>frontend</area>
				<class>Mage_Core_Controller_Varien_Router_Standard</class>
			</standard>
		</routers>
	</web>
</default>

Each of those two routers are created in the foreach loop in the init() method.
After instansiation, collectRoutes($routerInfo['area'], $routerCode) is called on each one, which causes it to create an array
with the routes that are configed within the config XML branch specified by the <area> node.

More details on the route definition will be covered in teh section The Route Config of the next chapter.

This is the gather all routes part mentioned earlier, as compared to gathering all routers. Put simply, routers contain a list of routes.

We will go into more detail later, but i think a bit of context regarding routes is required now. So here is a brief definiton of a route:

A configured route is a mapping between a frontName and a module.
For example, catalog is the frontName provided by the Mage_Catalog module.

While building the list of mappings, each router doesn't only look in the specified config area, but also only will gather routes with a matching <use> node.

The standard router builds a list of all routes within the <frontend> config area containing a <use>standard</use> node.
The admin route builds a list of all routes within the <admin> area that contain a <use>admin</use> node.

We will look at the route config within the Create a Controller chapter in more detail.

Let's get back to the Front Controller (which still is building its list of routers where we left off to look at routes)

After the routers configured in the XML section are instansiated and added to the Front Controller's $this->_routers array , the event
controller_front_init_routers is dispatched.

Mage::dispatchEvent('controller_front_init_routers', array('front'=>$this));

Looking for matching event observers, there will be one result within the Magento core, in Mage/Cms/etc/config.xml:

<global>
	<events>
		<controller_front_init_routers>
			<observers>
				<cms>
					<class>Mage_Cms_Controller_Router</class>
					<method>initControllerRouters</method>
				</cms>
			</observers>
		</controller_front_init_routers>
	</events>
</global>

No observer model factory name is specified in the <class> node; instead a regular PHP class name is used.
The observer method that is called on the class -
Mage_Cms_Controller_Router::initControllerRouters() - is very simple:

public function initControllerRouters($observer)
{
	/* @var $front Mage_Core_Controller_Varien_Front */
	$front = $observer->getEvent()->getFront();

	$front->addRouter('cms', $this);
}

The Mage_Cms module's event observer adds itself to the list of routers of the Front Controller.

The question present itself: WHy isn't the CMS router configured in the config XML, just like the standard and admin routers?

The only difference in the result is the order of the routers in the Front Controller's $this->_routers array.

The routers configured in the config XML will be listed first, then the routers added via the event will be appended after them.

The following paragraph could almost be classified as Magento Trivia, but it actually is valueable to think it through. It serves to deepen the
understanding of the config XML merge process, module dependencies, and how the Front Controller builds the routers array.

Because of module dependencies, the Mage_Core module will always be loaded before any other module. If the CMS router would have been
configured using the XML method, the order of the routers would still be the same.

Ths is because the CMS modules section would be merged in to the config XML DOM structure after the Mage_Core module XML.

So there is no technical reason why the CMS router is added via an event observer.

How about a practical question: If we want to add a custom router to the Front Controller's array, it is better to use the config XML or the controller_front_init_routers event?
The answer, is: it depends.

If we want a custom router to be added before the CMS one, we should declare the router in teh config XML.
If we want the custom router to be added after the CMS router, the observer method has to be used.

Once we proceed to analyzing the Front Controller's dispatch() method, it will become clear why the sort order of the routers is important
enough to spend so much time on it.

But first, let's finish dissecting the Front Controller's init() method - we are almost finished with it anyway.
The remaining code of the Method adds one final router:

	//Add default router at the last
	$default = new Mage_Core_Controller_Varien_Router_Default();
	$this->addRouter('default', $default);

Without resorting to hacks using PHP reflection, there is no way to add a custom router after it.
This Default browser is used to display the configured 404 page if no other router knows how to handle a request.

To summarize, a Magento installation without any customization uses 4 routers in the following order:

						Magento Routers
 Router 				Class 						Added via
admin 	Mage_Core_Controller_Varien_Router_Admin 	Config XML

standard Mage_Core_Controller_Varien_Router_Standard Config Xml

cms 	Mage_Cms_Controller_Router 					Event Observer

default Mage_Core_Controller_Varien_Router_Default Hardcoded in Front Controller

Time to move on to the Front Controller's dispatch() method, where each router in return is checked if it can match the current request.

public function dispatch()
{
	$request = $this->getRequest();

	//if pre-configured, check equality of the base URL and request URL
	$this->_checkBaseUrl($request);

	$request->setPathInfo()->setDispatched(false);
	if(!$request->isStraight()){
		Mage::getModel('core/url_rewrite')->rewrite();
	}
	$this->rewrite();
	$i = 0;
	while (!$request->isDispatched() && $i++<100){
		foreach ($this->_routers as $router){
			if ($router->match($this->getRequest())){
				break;
			}
		}
	}
	if ($i>100){
		Mage::throwException(
			'Front controller reached 100 router match iterations'
		);
	}

	//This event gives possibility to launch something before sending
	//output (allow cookie settings)

	Mage::dispatchEvent(
		'controller_front_send_response_before', array('front'=>$this)
	);

	$this->getResponse()->sendResponse();
	Mage::dispatchEvent(
		'controller_front_send_response_after', array('front'=>$this)
	);
	return $this;
}

The matching of the routers happens in the foreach loop within the while near the center of the method.
This nested set of loops requires some explonation.

Before we dive in further: the counter variable $i is just a sentry flag to avoid Magento getting stuck in a infinite loop. Unless you encounter a
bug, it will never hit a counter higher than 2.

The main indicator for the outer loop to exit is the isDispatched flag on the  request object.
As long as the isDispatched flag is false, it will continue.

The inner foreach loop iterates over all routers added during init().
The match() method is called on each of the routers in turn.

The purpose of the match() method is to check if a router knows how to process the request.
Processing the request means generating the response that will be sent back to the browser.

The response may consist of a full response body, or may only contain HTTP headers(for example in case of a redirect). Either case qualifies
as the request being processed.

If a response was generated, the router's match() method will set the isDispatch flag on the request to true, and the outer loop will exit.

Besides processing the request and generating output, a router also has another option: it can modify the $request object without setting the
isDispatched flag to true.

In that case the outer loop will continue, and a different router may now process the request, since it has been modified.
This is how one router delegates to another.

The following table shows the different cases that might occur while the nested loop is being processed, depending on the value returned by the
match() method and the isDispatched flag.

				Front Controller Routing
match() isDispatched Request modified Response Generated   Continue with
false false 				no 				no 					Continue inner loop

true false 					yes 			no 					Exit inner loop,
																continue outer loop
true true 				doesn't matter 		yes 				Exit both loops

To fully understand this process, it is important to know that the final router - the Default 404 page router - always matches.
it takes advantage of the option to delegate to a different router.

The Default router always modifies the request to point to the configured 404 page and returns true as the result of the match() method,
while keeping isDispatched set to false.

The result is that the process breaks out of the inner loop, but the outer loop continues, and so the inner iteration over the routers begins
again. However, this time the Standard router is able to match the modified request, so it will generate the response (the 404 page content) 
and set the isDispatched flag to true.

The following list of steps taken might help to illustrate when a non-existent route is accessed:

1. The outer loop starts (isDispatched is false)
2. The Admin router's match() returns false
3. The Standard router's match() returns false
4. The CMS router's match() returns false
5. The Default router match() method is called
	1. It modifies the request object
	2. It returns true (but isDispatched still is false)
6. The inner loop exits (because match() returned true)
7. The outer loop continues (because isDispatched still is false)
8. The inner loop starts again
9. The Admin router still doesn't match
10. The Standard router's match() method is called again
	1. It recognizes the values on the modified request object
	2. It processes the request (that is, it generates output)
	3. It sets isDispatched to true
	4. It returns true
11. The inner loop exits (because match() returned true)
12. The outer loop exits (because isDispatched is true)

The following table describes the requests each router matches and how the match is handled.

				Router Matching Overview
# Router 			Matches 				 				Match type
1 Admin Routes configured in the <admin> area 			Generate Content
2 Standard 	Routes configured in the <frontend> area 	Generate content
3 CMS 		Requests matching a CMS Page identifier 	Delegate to Standard router
4 Default 	Always matches(404 page) 					Delegate to Standard router

In terms of this chapter's exercise, this information is relevant: the match type of the CMS router.
According to the table, the CMS router Mage_Cms_Controller_Router also delegates to the Standard router to display the page content
(just like the Default router)

This means that we can focus on the functioning  of the Standard router in order to understand how the CMS page output is generated.

Also, the Admin router extends the Standard router class, thereby inheriting the Mage_Core_Controller_Varien_Router_Standard::match() method.

To summarize: in a native Magento installation, every page request always ends up being processed by the Standard router's match() method.
This happens either through a direct match, through class inheritance, or through delegation from another router.

Before we examine how the Standard router's match() method works, let's see how exactly the delegation from one router to another happens.

We will use the CMS router as an example.
The following code block is an excerpt from the Mage_Cms_Controller_Router::match() method.

$identifier = trim($request->getPathInfo(), '/');

$page = Mage::getModel('cms/page');
$pageId = $page->checkIdentifier(
	$identifier, Mage::app()->getStore()->getId()
);
if (!$pageId){
		return false;
}

$request->setModuleName('cms')
	->setControllerName('page')
	->setActionName('view')
	->setParam('page_id', $pageId),

return true;

In short, if a CMS page with an identifier matching the current request path info is found, the request is modified to delegate to the Standard router.

This is what the call to setModuleName(), setControllerName() and setActionName() is all about.

The delegation from Default to the Standard router in order to display the configured 404 page is done exactly the same way.

The Standard Router:

Now it is time to have a look at how the Mage_Core_Controller_Varien_Router_Standard::match() process works.
The method is quite long, so here we will break it up into several different parts. Each part will still  be an bbreviate version of the core code to  make it easier to follow: (lol)

public function match(Zend_Controller_Request_Http $request)
{
	$front = $this->getFront();
	$path = trim($request->getPathInfo(), '/');

	if($path){
		$p = explode('/', $path);
	} else {
		$p = explode('/', $this->_getDefaultPath());
	}

The variable $p is set to contain the request path split at the / char.
if the request path is empty, the return value of _getDefaultPath() is used. This value is taken from the system config option found at 
Web > Default Pages > Default Web Url, which defaults to simply "cms".

because of this, for a request to the base URL of a Magento Instance, $p will look as follows:

Array
(
	[0] => cms
)

For a request to /customer/account/login $p would be:

Array
(
	[0] => customer
	[1] => asccount
	[2] => login
)

Of course, there might be more parts to the request path, which would lead to more records in the array.

The next part of the match() method processes the first part of the array.

	//Get module name
	if ($request->getModuleName()){
		$module = $request->getModuleName();
	} else{
		if (!empty($p[0])){
			$module = $p[0];
		} else {
			$module = $this->getFront()->getDefault('module');
		}
	}

	$modules = $this->getModuleByFrontName($module);

	if ($modules === false) {
		return false;
	}

The variable $module is set to the first part of the request.
However, if $request->getModuleName() returns nothing, it will take predecence over the first entry in $p. This will be the case if a previous router has set to the module name
in order to delegate to the standard router.

In the rare case that neither getModuleName() returns value nor $p [0] is set, the default module is fetched from the Front Controller (setting $module to the value 'core')

Whatever the details, the important thing to remember is: the first part of the request path is set to $module.

The value of $module is used as the frontName for the request.

The frontName points to one or more modules which might have controllers that can process the current request. This mapping from the frontName to a list of modules is done in the config XML.

The router gets the list of modules via the method getModulebyFrontName().

The exact syntax for configuring this mapping of frontNames to modules in config XML will be covered later in the Create a Controller and 
Controller Rewrite chapters.

If $module doesn't match a configured frontName, the match() method returns false, that is, the Standard router can not come up with a match
(see the last paragraph of the previous code block above).

However, if at least one possible module is mapped to the frontName, the matching process continues as follows:

	/**
	* going through modules to find appropiate controller
	* /
	$found = false; //Sentry flag
	foreach($modules as $realModule){ //foreach through modules
		if ($request->getControllerName()){ //if the request has a controller name
			$controller = $request->getControllerName(); //assign the controller to be that name
		} else { //otherwise, it does not have a controller name
			if (!empty($p[1])) { //if the 1:th index is not empty, i.e it has the account controller
				$controller = $p[1]; //The controller is the $p arrays 1:th position, meaning we are accessing the account controller
			} else { //Otherwise, there is no current controller
				$controller = $front->getDefault('controller'); //fall through to accessing the default controller from the Front
			}
		}


The router iterates over the possible modules, and looks for a controller class matching the second part of the request ($p[1]).

Each iteration tries to match the request to a controller in a different module. The module being checked in store in the variable $realModule
by the foreach statement.

For example, let's assume the front name catalog is mapped to the modules Mage_Catalog and Example_Module_Catalog using config XML.

For a request to http://magento.dev/catalog, during the iteration those two values would be assigned in turn to $realModule.

To clarify:

						Values used during the request matching
	Variable 					Contents 				Example
$module 					The request frontName 		catalog
$modules 					The module mapped to the 
						frontName  						Array('Mage_Catalog',
														'Example_Module_Catalog')

$realModule 			A concrete module from $modules Mage_Catalog
						being checked for a matching
						controller. 

Luckily the value of $realModule is not used a lot during module development. It usually is
only used during the Standard router matching process.

Inside the foreach loop, the $controller variable is set to the second part of the request pat.
Similar to the setting  of $module, if $request->getControllerName() returns a string, it takes priority over $p[1].
Again, this will be the case if a previous router set the value to delegate to the Standard Router.

In case neither getControllerName() returns a value nor $p[1] is set, the default controller name is fetched from the Front Controller.
This will set $controller to 'index'.

PLease refer to the code block above to see the code discussed so far.

Now that $realModule and $controller are set, let's move on.

		//get action name
		if ($request->getActionName()){
			$action = $request->getActionName();
		} else {
			$action = !empty($p[2]) ? $p[2] : $front->getDefault('action');
		}

The third part of the request path is to fetch the action, to which it it assigns if it exists one, otherwise it acceses the action part of the $p array, to which it aquires the 2:nd index or it runs 
the getDefault router from front, based on 'action'

The only way that the check would have to default to the last else statement is if the value has been set since before by a previous router's match() method.

The default value for the action name is index, just like $controller

	$controllerClassName = $this
		->_validControllerClassName($realModule, $controller);
	if(!$controllerClassName){
		continue;
	}

Now that the $realModule, $controller and $action are set, the router finally checks if a matching controller file really exists.
In order to map the second part of the request $controller to a file, the standard router follows this process:

1. Replace all _ in $realModule with /
2. Uppercase the first char of each word
3. Prefix the full path to the $realModule's controller dir
4. Append $controller
5. Append Controller.php to the file name

Since a bit of code might be easier to understand, here is the method in question:

public function getControllerFileName($realModule, $controller)
{
	$parts = explode('_', $realModule);
	$realModule = implode('_', array_splice($parts, 0, 2));
	$file = Mage::getModuleDir('controller', $realModule);
	if(count($parts)){
		$file .= DS . implode(DS, $parts);
	}
	$file .= DS.uc_words($controller,  DS) . 'Controller.php';
	return $file;
}

For example, given $realModule is set to Mage_Catalog and $controller is set to product, the controller class would be 
Mage_Catalog_ProductController.

For security reasons, the routing process follows a very strict set of rules when mapping the request path (which is user input) to a file. That is why
every controller class has the Controller suffix.

That is also why the full file system path is built, and the PHP include path is not used to find controller class files.

The Standard router uses the $realModule value to determine the full path to the module dir, and then adds a lowercase controllers.
Once again, security. I guess it is better to be paranoid than sorry.

To continue the example, the controller for the class Mage_Catalog_ProductController would be .../app/code/Mage/Catalog/controllers/ProductController.php

Note that the controllers dir is added after the first 2 parts of the controllers class name.

here are some examples:

Examples for $realModule values mapped to module controllers dirs:

	$realModule value 				controllers dir
Mage_Catalog 					Mage/Catalog/controllers
Meeting02_Example 				Meeting02/Example/controllers
Mage_Widget_Adminhtml 			Mage/Widget/controllers/Adminhtml
Example_Module_Catalog 			Example/Module/controllers/Catalog

If the resulting controller file does not exist, the Standard router will continue to look for the file in the next module mapped to by the frontName.

However, if the controller file exists, it will be included, and the controller class is instansiated as can be seen in teh following code block
(just as quick reminder: we are still discussing the match() method of the Standard router).

		//Instansiate controller class
		$controllerInstance = Mage::getControllerInstance($controllerClassName, $request, $front->getResponse());

		if (!$controllerInstance->hasAction($action)){
			continue;
		}

		$found = true;
		break;
	}
	
	if (!$found){
		return false;
	}

Finally, the router checks if a matching action method exists on the controller.

The name of the PHP method to call  for a given action is determined by adding the suffix Action to the variable $action.

For example, the action index is handeled by a method indexAction() of the controller.

In case no matching action is found, the Standard router will continue looking in the next module mapped to by the frontName.

If all $modules were checked without finding a matching controller with a matching aciton, false is returned.
In this case the Standard router was not able to match the current request, and the Front Controller will continue with the next router.

On the other hand, if a match was found, there are a number of final steps before the controller's action method is called.

	//Set values only after all the checks are done
	$request->setModuleName($module);
	$request->setControllerName($controller);
	$request->setActionName($action);
	$request->setControllerModule($realModule);

	//Dispatch action
	$request->setDispatched(true);
	$controllerInstance->dispatch($action);

	return true;
}

The frontName, controller, action and the $realModule are set on the request object.
This can be very handy if, for example, we need to find out what page is currently being requested inside an event observer.

Then the isDispatched flag is set to true (finally!), and the router delegates to the controller by calling dispatch().

Finally we have completed reading through the Standard routers match() method!

Standard Router Summary

Before we continue analyzing the request processing inside the action controller, let's summarize the routing process from the Standard router context.

The steps the Standard router's match() method takes are:

1. Split the request path into parts (using /)
2. Match teh first part to a module dir (using XML config)
3. Match the second part to a controller file (by file name)
4. Match the third part to an action method (by method name)
5. If a matching controller class was found, dispatch() is called on it.

For some developers, it is confusing that the frontName is mapped to a module dir using config xml.
The request frontName can be completely different than the module's dir name, as will become apparent in the following two chapters.

However, when mapping the controller to a controller class there is a direct correlation between the controller name and the file system.
As stated onec before, the action method name is found by appending an Action suffix to the third part of the request path.

if no controller or action were specified in the request, teh default controller and aciton valeus are used, which both are index (mapping to an IndexController.php file or an indexAction() method respectively).

If a matching controller is found, the response content is generated by dispatching the action controller. Note that all this happens while 
the router's match() is called.

Maybe a better name for the method would have been matchAndProcess().

The Front Controller Responsibilities

Because knowing the workings of the Front Controller is useful beyond passing the MCD exam, there is more to be said about it.

So far, we only have discussed the aspects of the Front Controller directly related to the routing process, that is, the gathering of all routes
and finding a matching router.

There are 3 further responsibilities:

Applying DB based URL rewrites

Applying config XML based regex URL rewrites

Sending the response

All of these are handled inside the Front Controller's dispatch() method. In addition to these three, there are a few additional aspects - like additional events -
that are quite useful to know about.

Let's look at these in order to complete our understanding of the Front Controller.

Applying DB based URL rewrites

if (!$request->isStraight()){
	Mage::getModel('core/url_rewrite')->rewrite();
}

This code segment is found at the beginning of the dispatch() method.

Unless the isStraight flag is set on the request, database based rewrites are applied first.

The DB based rewrites are stored in the table core_url_rewrite.

If the current request path matches the request_path field for the current store, teh request object will be modified and further processing it will
take place as if the target_path column value was the requested path instead.

The catalog SEO friendly URLs are implemented using the rewrite mechanism.

The catalog-related records in core_url_rewrite are created by teh URL indexer.

It is also possible to add custom URL rewrite records using the adminhtml backend. Many projects also rewrites using custom PHP scripts,
too.

one thing to watch out for is that the table doesn't grow too large over time. There is no real safeguard for that available in Magento.

it is useful to have a look at the real table. You will probably find it is rather straight forward.

Applying Config XML based regex URL rewrites

$this->rewrite();

Not a lot of code. It has changed a little in newer Magento version since 1.7.0.2 on which, as a reminder, the current version of the cert is based on (1.8 actually or 1.9)

The main purpose is still the same though. The configuration based requests rewrites are applied right after the previous, DB based ones.

This type of URL rewrites has been declared deprecated, but it is still available for backward comapbility. It sets the request path info on the request object
to the matched value.

An example config to rewrite all requests to /customer/account/loginPost to a custom controller action would look as follows:

<global>
	<rewrite>
		<example_rewrite>
			<from>#^/customer/account/loginPost(.*)$#i</from>
			<to>/example/login/post$1</to>
			<!--<complete>1</complete>-->
		</example_rewrite>
	</rewrite>
</global>

The $_rewritedPathInfo property on the request object will be set to the original path info that was requested, unless the <complete> node is set
in the config.

If $_rewritedPathInfo is set (because <complete> is missing), URLs using the wirldcard * char to refer to teh current module, current controller or current action will 
be constructed using the original request path.

Kind of confusing, and the naming choice of the node does not help.
What it boils down to is that the original path info will be used to construct new URLs if <complete> is set. The name
<use_origin_pathfino> would have been better.

An example for a URL being constructed using wildcards would be Mage::getUrl('*/*/list') (current frontName, current controller, list action).

Generally it is better to omit the <complete> tag, since complete regex based URL rewrites can lead to having to rewrite further controllers or actions than wanted because of that behavior.

Assuming the XML rewrite example above from /customer/account/loginPost to /example/login/post is in effect, Mage::getUrl('*/*/test') would return the following request path:

Mage::getUrl('*/*/test') results differences with or without <complete>

	Request path before rewrite 			Configuration 				Request path after rewrite
/customer/account/loginPost 			Without <complete> 			/customer/account/test
/customer/account/loginPost 			With <complete> 			/example/login/test

Meaning that if the complete is not set, it just defaults back to the old one, and if there is one set since before, i.e a Complete exists, it runs against the new regex setup

The first version probably gives the desired result, unless you really are planning to rewrite further requests to /customer/account/ to the same custom controller.

Sending the Response

//This event gives possibility to launch something before sending
// output (allow cookie setting)
Mage::dispatchEvent('controller_front_send_response_before', array('front'=>$this));

$this->getResponse()->sendResponse();
Mage::dispatchEvent('controller_front_send_response_after', array('front'=>$this));

The fifth and final Front Controller responsibility - displayed in the code block above - is also part of the dispatch() method.
After the routing has taken place and the response has been generated, it is the final responsibility of the Front Controller to flush it to the browser.

This is the reason why no output should be echoed out directly from a controller action(or anywhere).

If some content is printed directly, bypassing the Front Controller, it would no longer be possible to add HTTP headers to the response after the routing completes.

Also, it would be impossible to capture and process the content that already was sent using the handy controller_front_send_response_before event, you can see being dispatched in the code snipped above.

Instead, any response data should always be added to the response object using $response->setBody(), $response->appendBody() or $response->setHeader().

That way the response content may be modified or new headers may be added via event observers right up to the moment the Front Controller calls 
$this->getResponse()->sendResponse().

Many caching modules for Magento rely on content object being set on the response object, including the Enterprise Edition Full Page Cache.

Secondary Responsibility: Check the base URL

//If pre-configured, check equality of base URL and requested URL, meaning we compare URLs
$this->_checkBaseUrl($request);

There is one additonal task the Front Controller takes care of at the beginning of the dispatch() method, and that is to check that the 
requested URL matches the configured base URL for the current store.

The line of code was omitted from the larger code sections of the dispatch() method further above in order to focus on the routing logic.

The purpose of the method _checkBaseUrl() is to redirect a visitor to the configured base URL if the current request doesn't match it.

For example, let's assume that the webserver is configured to serve Magento on both the www.example.com and example.com domains.

Without the base URL check, that would mean every page is available on two different domains. Google would rate that as duplicate content,
and reduce both site's rank.

For that reason, if the base URL configured in the system config is set to, let's say http://www.example.com/, then request to http://example.com/ are automatically redirected to the version of the domain with the www prefix.

That way there is only a single resource on the web with the content, and thus Google no longer sees it as duplicate content.

Please note, that it is a smarter approach to configure redirects to a single base URL on the webserver instead of in Magento, since that causes much less overhead.

For the Apache webserver mod_rewrite offers the option to add rewrite rules. Other webservers have similar capabilities that can be used to the same effect.

The base URL check in Magento can be disabled in the system config with the option web/url/redirect_to_base.

Checking the base URL is not considered one of the prime responsibilities of the Front Controller, but it still is useful to know about it.

Summary of the Front Controller Responsibilities:

The Front Controller has 5 main responsibilities:

1. Gathering all routes
2. DB based request rewrites
3. Config XML based (regex) request rewrites
4. Finding a matching router
5. Sending output

The purpose of a router is to provide a way to match requests to specific business logic.

An example from a real project for a customer router was a site where requests where mapped to articles by date, author or keywords, or combinations thereof.

The standard router matching doesn't fit that scheme at all, so a custom router was a easy solution.

However, usually the actual request processing and the generation of the response content is not done by the router class itself.
That task is delegated to an action controller.

For that reason, most core routers simply modify the respone object without setting the isDispatched flag, so the Standard router will match
the request on the next iteration.




Mage::run()    		Mage Core MOdel App 		Mage Core Controller Front Action 			Mage Core Controller Varien Router Admin, 
																							Mage Core Controller Varien Router Standard,
																							Mage CMS Controller Router,
	Run()																						Mage Core Controller Varien Router Default
>>>>>>>>>>>>>>>>>>>>>>>>>>>>																			
		 					init()
		 					>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
																							Responsibility 1:
																							Gather Routers
																							>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
							dispatch()
							>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
																							Responsibility 2:
																							DB request rewrites
																							>>>>
																							   v
																							   v
																							<<<<


																							Responsibility 3:
																							Config request rewrites
																							>>>>
																							   V
																							   V
																							<<<<

																							Responsibility 4:
																							Find a Matching Router
																							>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

																							Responsibility 5:
																							Send response
																							>>>>
																							   V
																							   V
																							<<<<

mage::run() 		Mage Core Model APp 		Mage Core Controller Front Action 			-II-

The Front Controller Responsibilities

The Action Controller Dispatch Process

Once the Standard router has matched a request and found a matching action controller, it will call dispatch() on it, passing along the requested action name.

	//Dispatch action
	$request->setDispatched(true);
	$controllerInstance->dispatch($action);

All controllers inherit the dispatch() method from the abstract class Mage_Core_Controller_Varien_Action.

The following code block is very abbreviated. The purpose is to illustrate the structure of the dispatch() method:

public function dispatch($actionMethodName)
{
	$this->preDispatch();

	if ($this->getRequest()->isDispatched()){
		if (!$this->getFlag('', self::FLAG_NO_DISPATCH)){
			$this->$actionMethodName();
			$this->postDispatch();
		}
	}
}

Remember, when this method is called by the Front Controller, the request isDispatched flag has already been set to true.

The structure of the dispatch() method offers two options that can be taken advantage of in the preDispatch() method:

If the isDispatched flag is reverted to false, the controller action will not be processed after all.
This opens the possibility to delegate to a different router from an action controller, since the outer matching loop of the Front
Controller will continue after the Match.

If the Mage_Core_Controller_Varien_Action::FLAG_NO_DISPATCH flag is set on the action controller, the action method will not be called.
The difference to the previous option is that in this case no further router matching will take place, since isDispatched still is true.
This allows the complete response to be generated during the preDispatch() method.

Let's inspect the (abbreviated) preDispatch() method code to see how this might be utilized.

public function preDispatch()
{
	if ($this->_rewrite()){
		$return;
	}

	if(!$this->getFlag('', self::FLAG_NO_START_SESSION)){
		$session = Mage::getSingleton('core/session', array('name' => $this->_sessionNamespace)
		)->start();
	}

	Mage::app()->loadArea($this->getLayout()->getArea());

	Mage::dispatchEvent('controller_action_predispatch', array('controller_action' => $this));

	Mage::dispatchEvent('controller_action_predispatch_' . $this->getRequest() -> getRouteName, array('controller_action' => $this));

	Mage::dispatchEvent('controller_action_predispatch_' . $this->getFullActionName(), array('controller_action' => $this));
}

First, right at the top of the method, another round of rewrites is applied. We will delve into this _rewrite() method later on.

Second, teh seession is started, unless the FLAG_NO_START_SESSION flag is set on the action controller.
This flag might come in handy when writing integration tests and you don't feel like mocking the session model.

However, the most important thing to remember is that the session is started by the action controller's preDispatch() method.

Then the current request area is loaded on the core/app model.
More on area loading later while discussing event observer configuration.

Third, 3 events are dispatched. They range from very generic to very specific.

The controller_action_predispatch event is dispatched for every page request in Magento.

the controller_action_predispatch_ event with the name of the current route appended is dispatched next.
The Standard router sets the route name on the request object using $request->setRouteName($this->getRouteByFrontName($module)).
We will have a closer look at route names in the following chapter, Create a Controller.
This event is much more specific than the previous one, but still is teh same for every page request within one route configuration.

The final event is controller_action_predispatch_, followed by the full action name.
The full action name consists of three parts:
1. The route name
2. The controller name
3. The action name.

Usually, these three parts are concatenated using an underscore. This results in an event name specific to every page in Magento.

For example, a request to the URL path /catalog/product/view would cause the following three events to be dispatched from the action controller's preDispatch() method:

1. controller_action_predispatch
2. controller_action_predispatch_catalog
3. controller_action_predispatch_catalog_product_view

The third one of these events is by far the most useful.

In fact, this finally brings us back to our main exercise objective:
redirect visitors back to the base URL if the configured home page is requested directly by its page identifier.

This event is used in exercise solution code to check if the current request is for the configured home page.

But let's not get ahead of ourselves, as there is one more thing to discuss before moving on to the solution:

Setting Flags on Action Controllers

public function setFlag($action, $flag, $value)
{
	if ('' === $action){ //if the name has not been set, assign it
		$action = $this->getRequest()->getActionName();
	}
	$this->_flags[$action][$flag] = $value; //access the action of the flag and assign it the associated flag value
	return $this; //return the request
}

public function getFlag($action, $flag='')
{
	if ('' === $action){ //Again, in the getter assign the flag
		$action = $this->getRequest()->getActionName();
	}
	if ('' === $flag){ //if the flag is empty, return the flag
		return $this->_flags;
	}
	elseif(isset($this->_flags[$action][$flag])){ //If the flag has already been set
		return $this->_flags[$action][$flag]; //Return the flag associatedf to the action
	}
	else { //The flag and the action has not been routed yet, meaning that we just return false
		return false;
	}
}

Controller flags are key-value pairs.

Each flag is set for a specific action. Usually an empty string is used as the action name, which means it will simply be set for the current action.

The core uses a number of flags to switch some behavior of the action controller on or off, like the FLAG_NO_DISPATCH or FLAG_NO_START_SESSION we have discussed earlier.
These flag names are available as class constants in the abstract class Mage_Core_Controller_Varien_Action.

Besides using flags as switches, they can also be used to store any key-value pairs on controllers, kind of like setData() can be used on Varien_Object instances.

Here is an example of a flag being set on the action to prohibit the session from being started:

$action = Mage::app()->getFrontController()->getAction();
$action->setFlag('', Mage_Core_Controller_Varien_Action::FLAG_NO_START_SESSION, 1);

The following code block is an example to set and get custom values on an action controller:

//get the action controller
$action = Mage::app()->getFrontController()->getAction();

//set custom flag
$action->setFlag('', 'request-cache-id', 'AB19534TG6');

//get custom flag value
$action->getFlag('', 'request-cache-id');

Action Controller Request Rewrites:

Close to the beginning of the preDispatch() method, another set of config based rewrites are applied to the request.
The method that is called to do this, is Mage_Core_Controller_Varien_Action::_rewrite().

However, this type of configuration based rewrite has also been deprecated, just like the Front Controller configuration based rewrites.
The reason for that is that the whole overhead of routing that has happened up to this point is wasted if a rewrite is configured using this method.

Similar to the regex config based request rewrites applied by the Front Controller, this rewrite facility still exists solely for backward compability.

You might encounter it in third party extensions, so it is a good thing to know about it.

The config based rewrite config that is applied by the action controller comes in two flavors:

1. Rewriet all actions of a given controller
2. Rewrite only specific actions

For example, rewriting all requests to the checkout/cart controller to a custom example/special_cart controller would look like this:

<!-- global only (not frontend or adminhtml) -->
<global>
	<routers>
		<!-- route name -->
		<checkout>
			<rewrite>
				<!-- controller name -->
				<cart>
					<!-- rewrite all controller actions -->
					<override_actions>false</override_actions>
					<to>example/special_cart</to>
				</cart>
			</rewrite>
		</checkout>
	</routers>
</global>

To only rewrite a specific action, the <override_actions> node is omitted and the action is added as a child node.
For example, to only rewrite the add action of the checkout/cart controller, the following code would be used:

<!-- global only (not frontend or admin) -->
<global>
	<routers>
		<!-- route name -->
		<checkout>
			<rewrite>
				<!-- controller name -->
				<cart>
					<actions>
						<!-- action name -->
						<add>
							<to>example/special_cart/add</to>
						</add>
					</actions>
				</cart>
			</rewrite>
		</checkout>
	</routers>
</global>

Regardless wether the route which is being rewritten is configured in the frontend or admin area, the rewrite always is specified in the <global> branch.

Wrap-Up Summary of the Exercise Research:

We started this section defining three things we need to know in order to implement the exercise solution:

1. How is the URL key for a CMS page specified?
2. How is a CMS page displayed when its URL key is requested?
3. How can we trigger the redirect?

It was a long section, so lets summarize the findings.

How is the URL key for a CMS page specified?

This has a straightforward answer to it. The CMS page URL key is specified using the cms/page attribute identifier.

How is a CMS page displayed when its URL key is requested?

1. Mage_Core_Model_App::run() initializes the Front Controller and calls its dispatch() method
2. The Front Controller gathers a list of all routers and proceeds to find one matching the current request.
3. The CMS router checks if the request Path matches a CMS page identifier and modifies the request obejct to delegate to the Standard router if that is the case.
4. The Standard router now can match the modified request, and it delegates to the action controller Mage_Cms_PageController::viewAction() method for processing.

How can we trigger the redirect?

Before the actual action method is called, the controller's preDispatch() method dispatches the page specific event controller_action_predispatch_cms_page_view.

Our redirect can be implemented in an event observer for this event.

The redirect itself is set on the response object instead of calling the PHP function header() directly, beacuse the sending of the response is handled by the Front Controller.

To prohibit further processing of the request, the Mage_Controller_Varien_Action::FLAG_NO_DISPATCH controller flag is set on the action controller instance.

Solution:

The code can be found in the extension Meeting02_RedirectToRoot.
After a long research section, the solution code is very short.

An event observer for the event controller_action_predispatch_cms_page_view is declared in the config XML:

	<frontend>
		<events>
			<controller_action_predispatch_cms_page_view>
				<observers>
					<meeting02_redirectToRoot>
						<type>model</type>
						<class>meeting02_redirectToRoot/observer</class>
						<method>controllerActionPredispatchCmsPageView</method>
					</meeting02_redirectToRoot>
				</observers>
			</controller_action_predispatch_cms_page_view>
		</events>
	</frontend>

Event Dispatch Process and Observer Configuration

Event Observers are one of the most powerful tools of a magento dev.
Even though the implementation in Magento isn't perfect, it is still possible to use them to great effect.
However, once again, it is useful to have a good understanding of how they work.

Let's analyze the event system code, starting with the method call which triggers an event:

Mage::dispatchEvent($eventCode, $eventArguments);

The event code is a string. if the optional $eventArguments argument is present it must be an array of key-value pairs which will be passed to 
the observer method as arguments, as we will see shortly.

AS often is the case, the Mage "god" class uses a delegate to do the real work.

public static function dispatchEvent($name, array $data = array())
{
	$result = self::app()->dispatchEvent($name, $data);
	return $result;
}

In this case, Mage delegates to the application model Mage_Core_Model_App, where the main event dispatching Process takes place.

Let's dissect the Mage_Core_Model_App::dispatchEvent() method bit by bit.

public function dispatchEvent($eventName, $args)
{
	foreach ($this->_events as $area=>$events) {

	}
}

The first thing that happens is that Magento iterates over an array containing the registered event areas. So what are these?

Event Areas

When the core/app model is instansiated, the $_events property is an empty array.

Then, when the Magento application initialization is triggered by calling Mage::run() or Mage::app(), the global events area is registered.
This happens by calling:

Mage::app()->loadAreaPart(
	Mage_Core_Model_App_Area::AREA_GLOBAL,
	Mage_Core_Model_App_Area::PART_EVENTS
);

You can find this code in Mage::app() and Mage_Core_Model_App::run().

The end effect is that a record is added to the core/app::$_events property with the area name as the key.
The value is, once again - an empty array.

$this->_events = array('global' => array())

Once an event area is "loaded" in this way, the foreach loop in core/app::dispatchEvent() will process the config within that 
config XML branch matching that area (please refer to the loop in teh code block a little big further up)

The loadAreaPart() only registers the area in the array. The actual configuration is lazy-loaded whenevr an event is dispatched.

Instead of using loadAreaPart(), the method Mage::app()->addEventArea($area); can be called alternatively. The end result is the same.

This alternative addEventArea() method is used in cron.php script to register the crontab event area.

In addition to the global event area, the frontend or adminhtml event areas are loaded during the action controller's preDispatch()
method, depending on wether it is a frontend or admin controller.

The following table gives an overview over where the different event areas are loaded.
							
							Event Areas

	Event Area 						Loaded In
global 	Mage:app()
		Mage::run()

frontend Mage_Core_Controller_Front_Action::preDispatch()

adminhtml Mage_Adminhtml_Controller_Action::preDispatch()
		  Mage_Api_Model_Server_Handler_Abstract::_construct()

crontab   cron.php file

Before the action controller is dispatched, only events configured under the <global> config
XML area will be processed.

This is good to know, especially when registering an event observer for the early events dispatched by the Front Controller.
Putting them in <frontend> or <adminhtml> just won't work.

When writing custom command line scripts which initialize the Magento environment, keep in mind that no area
besides global is registered when calling Mage::app()

Event setting a store view by calling Mage::app()->setCurrentStore($storeCode)
doesn't magically load the events for that store's area.

If you want the adminhtml or frontend events to be processed, the event needs to be loaded manually as shown in the following example code block:

require_once 'app/Mage.php';
Mage::app('admin');
Mage::app()->addEventArea('adminhtml');

Getting back on track dissecting the core/app:dispatchEvent() method.

When an event is dispatched, and no configuration for that event was previously loaded for a registered area, the event configuration is loaded via the config model:

	if(!isset($events[$eventName])){
		$eventConfig = $this->getConfig()->getEventConfig($area, $eventName);
		if (!$eventConfig){
			$this->_events[$area][$eventName] = false;
			continue;
		}

the $eventConfig variable will contain the full config/[area]/events/[event-name] branch from the config XML.
Next, this configuration is processed to find all observers that are registered for the current event:

		$observers = array();
		foreach($eventConfig->observers->children() as $obsName=>$obsConfig) {
			$observers[$obsName] = array(
				'type' => (string)$obsConfig->type,
					'model' => $obsConfig->class ? (string)$obsConfig->class : $obsConfig->getClassName(),
				'method' => (string)$obsConfig->method,
				'args' => (array)$obsConfig->args,
			);
		} 
		$events[$eventName]['observers'] = $observers;
		$this->_events[$area][$eventName]['observers'] = $observers;
	}

The configuration is processed and the result is assigned to the Mage_Core_Model_App::$_events[$area][$eventName] array.

We can see the code checks for the following nodes:

<type>
<class> or <model>
<method>
<args>

All of these nodes must be wrapped by a unqiue node, called observer name (assigned to the variable $obsName by the foreach statement)

The only purpose of the observer name is to avoid conflicts between modules that register observers for teh same events.
That's why it's important to use a unique node as the observer name.

According to best practice, use namespace - underscore - module name in lower case.
This follows the same convention as the class group for a module.

Here is an example observer configuration:

<config>
	<frontend>
		<events>
			<customer_login>
				<observers>
					<example_module>
						<type>Singleton</type>
						<class>example_module/observer</class>
						<method>customerLogin</method>
					</example_module>
				</observers>
			</customer_login>
		</events>
	</frontend>
</config>


					Examplt event observer config nodes
	Node 			Value 					Comment

Event Name 	customer_login 				Code passed to Mage::dispatchEvent() 

Observer Name  	example_module 			Unique node ([namespace]_[module])

<type> 			singleton 				instansiation type

<class> 		example_module/observer By convention a model called Observer

<method> 		customerLogin 			PHP method name on Observer Model

We will see how exactly the values listed in the table are used in the following code segments.

	if (false===$events[$eventName]){ //If there is no observer registered to the area, skip that area
		continue;
	} else{ //otherwise, dispatch an event for that area
		$event = new Varien_Event($args);
		$event->setName($eventName);
		$observer = new Varien_Event_Observer();
	}

If no observer is configured for the event within the area of the current iteration, the loop
continues with the next registered event area.
Otehrwise, the code begins to prepare dispatching the event observer methods.

A Varien_Event object is instansiated as a container object.
The $args array which was passed into the dispatchEvent() method is passed on to the constructor.

Since Varien_Event extends from Varien_Object all arguments will be available via magic getters.

The Varien_Event_Observer object, which is instansiated next, is a second container instance.

Don't be confused by the class name- the $observer is not "our" observer object. It is simply 
anotehr container object for the event arguments, just like the $event object.

Why a second container? Historical reasons. Same goes for the name. Looking for teh next Magento Trivia section for
a possible explonation. (bs)

	foreach($events[$eventName]['observers'] as $obsName=>$obs){ //Run a foreach loop on the eventname of events accessing with observers as designated obsname 
		$observer->setData(array('event'=>$event)); //call setdata on observer with an array of the current event occuring
	
Now finally all configured observers are processed in another foreach loop.
The $event instance is passed to the $observer instance.

The container object $observer now contains the other container object $event which can be accessed using $observer->getEvent().

			switch ($obs['type']){
				case 'disabled':
					break;
				case 'object':
				case 'model':
					$method = $obs['method'];
					$observer->addData($args);
					$object = Mage::getModel($obs['model']);
					$this->_callObserverMethod($object, $method, $observer);
					break;
				default:
					$method = $obs['method'];
					$observer->addData($args);
					$object = Mage::getSingleton($obs['model']);
					$this->_callObserverMethod($object, $method, $observer);
					break;
			}
		}
	}
	return $this;
}

Depending on the <type> node value, the real observer class - the one specified in the <class> node - is instansiated in a different fashion.
The following table shows the factory method that is used depending on the observer type:

					Observer Instansiation Types

Type Value 				Factory Method 				Comment
model 				Mage::getModel() 		-

object 				Mage::getModel() 		Generally not used, use model instead.

singleton 			Mage::getSingleton() 	The default if the <type> node is omitted

disabled 			n.a 					The event observer is not instansiated

If the type is set to disabled the observer will be skipped.
This is useful to disable event observers declared by the core or other extensions.

The only reason to use a singleton type is if you want to maintain some kind of state information in the observer instance.

Note that the event arguments are also assigned to the $observer container, for both the model and default cases of 
the switch block: $observer->addData($args).

This means that the event arguments can be accessed in many different ways from within the observer method.

For example, the argument to the event Mage::dispatchEvent('calculation_complete', array('the_answer' => 42)) Could be accessed in the following ways:

$observer->getData('the_answer'); //via Varien_Object::getData()

$observer->getTheAnswer(); //via Varien_Object magic getter

$observer->getEvent()->getData('the_answer');

$observer->getEvent()->getTheAnswer();

It doesn't make a difference which way you choose (except for the number of characters you type) - the result is always the same.

The one piece of information that is only available via the Varien_Event instance is the event name.

After the container objects have been prepared and the observer instance is created, finally the observer method is called:

protected function _callObserverMethod($object, $method, $observer)
{
	if (method_exists($object, $method)){ //if it exists, call the method
		$object->$method($observer);
	} elseif(Mage::getIsDeveloperMode()){ //otherwise, if we are in dev mode
		Mage::throwException('Method "'.$method'" is not defined in "'.get_class($object).'"');
	}
	return $this; //return the dispatch
}

The $observer container object is passed as an argument to the configured observer method.

Within the Magento dev community, it is common practice to choose event observer method names which match the event name, only in 
camel case so they match the coding standard.

For example, in the exercise solution, the observer for the event controller_action_predispatch_cms_page_view uses the method name controllerActionPredispatchCmsPageView();

It is very convenient to immediately see what event triggers a given method while reading the osberver class code.

The core team does not follow a clear convention though.
Some modules use method names that describes the method of the observer (for example checkQuoteItemQty()), while some use methods that match the event name (for example sales_quote_address_discount_item())

This books recommends naming the observer methods like the event names they are triggered by (in camel case).

This completes the observer configuration discussion.
Please refer to the exercise solution file app/code/local/Meeting02/RedirectToRoot/etc/config.xml for the full exercise solution code of the osberver config.

Exercise Solution Observer Method

The exercise solution observer method is quite small:

public function controllerActionPredispatchCmsPageView(Varien_Event_Observer $observer) //the controller for the predispatch cms page view
{
	/* @var $action Mage_Cms_PageController */
	$action = $observer->getControllerAction(); //get the action of the observer
	$pathInfo = $action->getRequest()->getPathInfo(); //get the path info
	list($homeCmsPage) = explode('|', Mage::getStoreConfig('web/default/cms_home_page')); //create a list of the homecms page where we explode on the |

	if(mb_strstr($pathInfo, "/$homeCmsPage") !== false){ 
		$action->getResponse()->setRedirect(Mage::getBaseUrl());
		$action->setFlag('', Mage_Core_Controller_Varien_Action::FLAG_NO_DISPATCH, true);
	}
}

Most of this code is rather self-explanatory after the extensive research chapter.

One thing which probably isn't clear on casual reading though is why the configuration setting is split using a | character.
The system configuration value that is read specifies the CMS page to display as the home page. It is compared against
the current request path after the explode() function call.

The question is, why is the value split at a pipe char?

The options of the system config select field are generated by the source model Mage_Adminhtml_Model_System_Config_Source_Cms_Page.

The cms/page title is used as the select label that is visible in the dropwdown.
The cms/page identier string is used for the option values.

However, cms/page identifiers are not globally unique.

It is possible to create two CMS pages with the same identifier, as long as they are assigned to different store views.
in that case, the CMS page selection soruce model values are qualified by appending the cms/page entity ID, seperated by a |.

For example, if two CMS pages exist with the identifier no-route - one for the "All Stores" scope and one for the "English" store view scope - the second one in
the list will recieve the CMS page ID as the suffix.

Technically, the CMS page selection source model for the system config (adminhtml/system_config_source_cms_page) calls the method
Mage_Cms_Model_Resource_Page_Collection::toOptionIdArray() method to generate the list of options,
which is where the qualification with the page ID takes place.

//Exceprt from Mage_Cms_Model_Resource_Page_Collection
public function toOptionIdArray()
{
	$res = array(); //Start an array
	$existingIdentifiers = array(); //Start an array
	foreach ($this as $item){ //iterate through the assigned item
		$identifeir = $item->getData('identifier'); //identifier is the getdata aquired through identifier from item

		$data['value'] = $identifier; // the value of the identfier is the value of the value in data
		$data['label'] = $item->getData('title'); //the label is the title of the item

		if (in_array($identifier, $existingIdentifiers)) { //if the identifier is in one of the existing identifiers
			$data['value'] .= '|' . $item->getData('page_id'); //add the page_id to the value
		} else {
			$existingIdentifiers[] = $identifier; //otherwise, the existingIdentifeirs is the one we just saw
		}

		$res[] = $data; //an empty array that holds the results
	}

	return $res; //return the results
}

That is the reason why the CMS home page identifier is split using a | char before its compared against the current request path by the observer.

It might seem like a lot of effort to extract the name of the configured CMS home page. Lots of people simply hardcode
"home" as the value to test against.

However, this course breaks if a different page were chosen, which is the case for default EE installation.

If the current request path starts with the configured CMS page identifier, a redirect to Magento base URL is set on the response object:

	$action->getResponse()->setRedirect(Mage::getBaseUrl());
	$action->setFlag('', Mage_Core_Controller_Varien_Action::FLAG_NO_DISPATCH, true);

Since the visitor will be redirected using a 302 HTTP request code and location header,
the response body will not be displayed by the browser. Because of that it would be
a waste of server resources to generate some HTML content.

To tell the action controller to skip calling the actual action method, the FLAG_NO_DISPATCH flag
is set on it. Setting the flag to true will cause the response body to be empty, and no resources
will be spent on loading and rendering the CMS page.

Magento Trivia:

Besides the event observer system implemented in Mage_Core_Model_App, the Mage class also contains
an alternative Event Observer implementation. It is functional but is never used within the
Magento framework.

Since it is part of the Varien lib, it probably predates Magento. In it, observers are
configured using the method Mage::addObserver($eventName, $callback, $args);

To add all configured event observers for a specific area, Mage::getConfig()->loadEventObservers($areaCode)
can be used. The config XML structure that is read is the same as for the core/app event observer
implementation.

To fetch the Varien_Event_Collection with all observers, the method Mage::getEvents() is available.
In order to dispatch an event, Mage::getEvents()->dispatch($eventCode, $args) is called.
Since this never happens in the core code, it is irrelevant.

I'm only guessing here, but the convoluted core/app event observer argument container structure
probably goes back to this implementation, where individual observers could be dispatched by calling
$observer->dispatch($event).

The Front Controller is not a controller for the front end, it is a controller that stands in front
of all others - meaning that before routers and action controllers take over, it handles the requests.

The config section exists twice in a section of code earlier written here: once under stores/config/default
and once under config/default.

The former is only used if the current frontEnd store has the code default. If a different store is set
as the current frontend store for the request, the latter config branch is used.
Technically, it would have been enough to only specify the config/default value. When adding
a custom router by adding to the config XML, it also needs to be specified in both sections.

Trivia: The default values are set on the Front Controller by the router in the beginning of the match() method
while fetchDefault() is called. Later, that value is read back again from the Front Controller into the router.
This was omitted from the code in the book because it is somewhat confusing (and unimportant), please inspect
the real source code to see yourself.

The isStraight flag is only set on the request object by the Enterprise Edition Full Page Cache module under
certain conditions.

Exercise: Custom frontend controller route; setting the response body

Original task desc:

Add a new frontend route and create an index controller that set the return value of $this->getFullActionName()
to the response body.

Overview:

This chapter discusses the following topics in the research section and the examination of the exercise solution:

Action controller instansiation

Route configuration

Scenario:

Every time an extension adds a new page (aka "a route") to a magento instance, a custom action
controller is required.
Example scenarios which use a custom controller could be:

A Custom Frontend Search Form

Custom Adminhtml Reports

Custom REST API resources

Payment Gateway Notification Target URLs

etc.

Basically, anywhere where we wish to have a custom interaction with something, we have to specify a custom
controller.

In the previous chapter the whole routing process was discussed in detail.
For every request the final situation of the routing process was that the Standard router dispatches
an action controller method.

However, all that the chapters covered was that the standard router loads a list of configured routers.
It did not discuss how the routes are configured.

Let's have a look at the Mage_Core_Controller_Varien_Router_Standard::collectRoutes(), which is responsible
for gathering all configured routes within the router area.

Just as a reminder, collectRoutes() is called from the Front Controller's init() method.
Since the Admin router inherits the collectRoutes() method from the Standard router through class inheritance,
the admin and frontend routes share the config structure.

The only difference in the config XML structure between Admin and Standard routes is that the
former go into the <admin> area, while the latter belong in the <frontend> config branch.

This is the code that fetches the router config from the routers area:

public function collectRoutes($configArea, $useRouterName)
{
	$routers = array(); //Start an array
	$routersConfigNode = Mage::getConfig()->getNode($configArea.'/routers'); //get the node in the respective are   // and fetch its routers
	if($routersConfigNode){ //If the configuredNode exists
		$routers = $routersConfigNode->children(); //retrieve it's children
	}

	The variable $routers now contains an array with all the routes that are configured in the 
	<frontend> or <admin> area respectively. In the next step the router iterates over all 
	those configured routes.

	foreach($routers as $routerName=>$routerConfig){ //Run a foreach on the routers from the router config 
		$use = (string)$routerConfig->use; //the use sub-attribute of the Router config
		if($use == $useRouterName){
			//if use is the same as the one being fed in

			Note that the value of the <use> node is compared with the value of $useRouterName, which was
			passed in as a method argument. The value that was passed in as the $useRouterName is taken
			from the router config.

			//NOTE TO SELF: READ MAGE -> THIS BOOK IS HALF SHIT

			$modules = array((sring)$routerConfig->args->module); //modules is an array of the string version of
			//the module from router config
			if($routerConfig->args->modules){ //if the modules exist
				foreach ($routerConfig->args->modules->children() as $customModule){ //go through the children
					if ($customModule){ //See if there is children
						$modules[] = (string)$customModule; //assign the child to be the modules array
					}
				}
			}

			$frontName = (string)$routerConfig->args->frontName;
			$this->addModule($frontName, $modules, $routerName);

			//Note, when we do referals in terms of ->, we are actually refencing XML structures
			//and accessing nodes with the specific names there of.

			The $modules array is initialized with the value of the <args><module>... node.
			Additional routes can be configed within the <args><modules>... branch. Each additional
			module is then also added to the $modules array.
			This mostly happens for the adminhtml route. For example, if we try the following debug
			code at the end of the collectRoutes() method:

			if('adminhtml' == $routerName) print_r($modules);

			it displays a list of all modules which register themselves for the adminhtml route

			Array
			(
				[0] => Mage_Index_Adminhtml
				[1] => Mage_Paygate_Adminhtml
				[2] => Mage_Paypal_Adminhtml
				[3] => Mage_Widget_Adminhtml
				[4] => Mage_Oauth_Adminhtml
				[5] => Mage_Authorizenet_Adminhtml
				[6] => Mage_Bundle_Adminhtml
				[7] => Mage_Centinel_Adminhtml
				[8] => Mage_Compiler_Adminhtml
				[9] => Mage_Connect_Adminhtml
				[10] => Mage_Downloadable_Adminhtml
				[11] => Mage_ImportExport_Adminhtml
				[12] => Mage_Api2_Adminhtml
				[13] => Mage_PageCache_Adminhtml
				[14] => Mage_XmlConnect_Adminhtml
				[15] => Mage_Adminhtml
				[16] => Phoenix_Moneyhookers
			)

			However, in a non-customized Magento instance all the frontend routes only contain a single
			module. Extensions however often add themselves to existing routes in this way.

			Finally, almost at the end of the collectRoutes() method, this list of modules is added
			to the Standard router's internal map of frontNames to modules.

			$this->addModule($frontName, $modules, $routerName);

			Here is a frontend route config example from the Mage_Catalog module with some comments
			throw in:

			<!-- route area -->
			<frontend>
				<routers>
					<!-- route name -->
					<catalog>
						<!-- the router name (standard or admin) -->
						<use>standard<use>
						<args>
							<!-- initial $modules entry -->
							<module>Mage_Catalog</module>
							<!-- first request path part -->
							<frontName>catalog</frontName>
						</args>
					</catalog>
				</routers>
			</frontend>

			The solution code is not available here, it is in the downloaded code section.

			The configuration for the custom route looks as follows:

			<!-- route area -->
			<frontend>
				<routers>
					<!-- route name -->
					<meeting02_customController>
						<!-- collected by the Standard Router -->
						<use>standard</use>
						<args>
							<!-- map frontName to Meeting02_CustomController module -->
							<module>Meeting02_CustomController</module>
							<frontName>custom</frontName>
						</args>
					</meeting02_customController>
				</routers>
			</frontend>

			The route is configured for the frontend area.
			For the route name the module's namespace and name is used (as seen on line 3), which follows
			best practice, since it has to be a unique node.

			The <use> value has to be standard so that the Standard router will add this route to its list.
			Then, the initial mapping from the frontName to a module is configured.
			To be more precise, this code actually configures a mapping from a frontName custom to the
			Meeting02_CustomController's controllers directly.

			Everytime a browser sends a request with a matching first request path part,
			the Standard router will check in that dir for a matching controller.

			The Action Conrtroller Class

			Examining the example solution's controllers dir, we can see that there is an IndexController.php file.
			As discussed in depth in the previous chapter, all files containing controller classes must 
			end with Controller.php suffix.

			A request path for /custom/index will cause the Standard router to check in this class
			for a matching action (the frontName custom and the controller name index).

			Repeating another fact discussed in the last chapter, the class name of the controller
			almost follows the same conventions as modules and blocks, except that the controllers
			dir is omitted from the class name.

			The full controller class from the sample exercise solution is as follows:

			class Meeting02_CustomController_IndexController extends Mage_Core_Controller_Front_Action
			{
				public function indexAction()
				{
					$this->getResponse()->setBody($this->getFullActionName());
				}
			}

			All frontend controllers have to extend from Mage_Core_Controller_Front_Action
			, so ours does too. Since the controller is called IndexController, it will be used
			as the default if no controller name is specified in the request.

			The only defiend action method has the name indexAction()

			This means it will be called as the default action  in case no action
			name was specified in the request path.

			The sample solution action method can be called using any of the request
			paths from teh following table:

				Request paths dispatching the example solution controller
			Request Path Comment

			/custom/index/index 	Full request path containing frontName, controller and action

			/custom/index 			Action name omitted

			/custom 				Controller and action omitted

			The full action name, which is set as the respone object body within
			the indexAction() method, has also been discussed in the previous chapter
			in the context of the events dispatched in the action controller's preDispatch() method.

			The return value consists of the current route name (meeting02_customController),
			 the controller name (index) and the action name (also index).

			 For the sample exercise it gives us:

			 meeting02_customController_index_index


Exercise: Action controller rewrite; customer/session before_auth_url property

Original task desc:

The original task description from the study group kit for this exercise is as follows:

Rewrite the Mage_Customer_AccountController::loginAction() method to set a category view
of your choice as the before_auth_url

Overview:

This chapter discusses the following topics in the research section and the 
examination of the exercise solution:

The recommended way of doing controller rewrites

The customer/sessionbefore_auth_url and after_auth_url properties.

Scenario:

There are several scenarios where redirecting the customer after login 
seems plausible:

Alert the customer of a change in terms-of-usage

Notify the customer of a special promotion

Ask the customer to complete the profile information

Admittedly, redirecting the customer to a category page doesn't really seem all that realistic,
but it does serve as an educational example.

Research:

So far several ways of rewriting requests where covered by this book.

The DB request rewrites applied by the Front Controller

The config XML regex request rewrites, also applied by the Front Controller

The config XML based rewrites applied by the action controller.

Each of these could be used to route a request to a custom controller when the login page is requested,
effectively implementing a controller rewrite.

But, all except the DB one, is deprecated.

The DB based URL rewrites are mainly used for mapping SEO URLs to internal routes.
Using the same functionality to implement a rewrite in a module would not be a clean
solution.

Magento provides another mechanism that hasn't been covered yet for controller rewrites,
and this method is the recommended way to implement them. It utilizes the fact that a
frontName can be mapped to more than module.

This feature was analyzed in depth in the exercise Custom frontend controller route; setting
the response body. To briefly reiterate: when the Standard (or Admin) router collects all
configured routes, the mapping of the frontName to a module is initially done using
the following config section.

<args>
	<!-- 
		map/example requests to controllers in Example/Module/controllers/
	-->
	<module>Example_Module</module>
	<frontName>example</frontName>
</args>

If addtional modules are listed under the args/modules node - note the plural <modules> -
then they are added to the list of possible matches, too.
The code sections which parse that config were discussed in the prev chapter.

However, the code sample there were abbreviated.
To understand how this feature can be used to implement controller rewrites, having
a look at the full code is nessecary.

Here is the full route collection code from Mage_Core_Controller_Varien_Router_Standard::collectRoutes():

	$modules = array((string)$routeConfig->args->module); //make an array of the module of the args from the         //routeConfig
	if($routerConfig->args->modules){ //if it exists
		foreach ($routerConfig->args->modules->children() as $customModule) { //go through the children
			if ($customModule){ //if it exists
				if ($before = $customModule->getAttribute('before')){ //if it exists before
					$position = array_search($before, $modules); //it's position is this
					if ($position === false){ //It doesn't have a position
						$position = 0; //Put it first in the list
					}

					array_splice($modules, $position+1, 0, (string)$customModule); //put it on this position

				} else { //otherwise, just append it as per normal
					$modules[] = (string)$customModule;
				}
			}
		}
	}

The initial frontName-to-module mapping is created right in the first line of the code block above.
The rest of the code iterates over all additional modules for the route currently being processed.

The difference from the previously discussed - abbreviated - version of the method is that the additional
modules are not simply appended to $modules.

Instead, what happens depends on the presence or absence of a before or after attribute on the XML node.
In case a before node is present, the new module will be added to the list of modules before a record
with the attributes value (see the first if branch).

In case an after node is present, the new module will be added after a record with the attribute
value (see the elseif branch)

In case there is neither a before or an after node, the new module will simply be appended to the list (see 
the else branch above).

Let's go over a few examples to make things clearer.

Let's assume the following route config is present in the merged config XML.

<admin>
	<routers>
		<adminhtml>
			<use>admin</use>
			<args>
				<module>Mage_Adminhtml</module>
				<frontName>admin</frontName>
				<modules>
					<Mage_Paypal
						before="Mage_Adminhtml">Mage_Paypal_Adminhtml</Mage_Paypal>
					<Widget
						before="Mage_Adminhtml">Mage_Widget_Adminhtml</widget>
					<moneybookers
						after="Mage_Adminhtml">Phoenix_Moneybookers</moneybookers>
					<example_mod
						before="Mage_Widget_Adminhtml">Example_Module_Adminhtml</example_mod>
			</modules>
			</args>
		</adminhtml>
	</routers>
</admin>

What will the final $modules array look like?

Let's go through step by step. Please make sure you follow why the array is built the way it is,
refrerring to the code from the collectRoutes() method above.

1. The list is initialized with the original module as:
	array('Mage_Adminhtml')

2. The before admin html call on mage paypal occurs:

	array('Mage_Paypal_Adminhtml', 
		'Mage_Adminhtml')

3. The next step, still puts it 1 step behind adminhtml, meaning it ends on index[1]:

	array('Mage_Paypal_Adminhtml', 'Mage_Widget_Adminhtml', 'Mage_Adminhtml')

4. The next step, puts it after the adminhtml, so it will occur on index [3]:
	array('Mage_Paypal_Adminhtml', 'Mage_Widget_Adminhtml', 'Mage_Adminhtml', 'Phoenix_Moneybookers')

5. The final step, puts Example_Module_Adminhtml before Mage_Widget_Adminhtml:
	array('Mage_Paypal_Adminhtml', 'Example_Module_Adminhtml', 'Mage_Widget_Adminhtml',
	'Mage_Adminhtml', 'Phoenix_Moneybookers')

For this example, this would be the full list of modules that the router would look inside for a matching
controller. Remember, each of those records is mapped to a dir in the module.

In this example, the router would look in the following dirs until it finds a matching controller class.

1. Mage/Paypal/controllers/Adminhtml/
2. Example/Module/controllers/Adminhtml/
3. Mage/Widget/controllers/Adminhtml/
4. Mage/Adminhtml/controllers/
5. Phoenix/Moneybookers/controllers/

This works just like the PHP include path.
The router looks into each of these dirs in turn for the controller file and includes
the first match it finds. The controller file name the router looks for is built from
the second part of the request path (the controller name) by appending Controller.php to it.

For sake of this example, let's assume the current request is for /admin/ajax. In this case,
the controller name would be ajax. The resulting controller file name would be AjaxController.php

The router will look in each of the listed dirs and use the first occurrence of AjaxControllerphp it finds.
The router will only dispatch the controller if it has a matching action method, otherwise
it will continue looking for another match.

In fact, the Magento core code contains a Mage/Adminhtml/controllers/AjaxController.php file.
Will this be the class file loaded?

Usually yes. but what if a controller file with the same name would have been added to a module
earlier in the list?

Then the earliest occurence will be dispatched. It is the recommended way of doing it.
This is regarding implementing controller rewrites.

To surmise, this feature can be used in two ways:

1. Add new controllers to an existing route (aka frontName)
2. Rewrite existing controllers

Adding new controllers is used mostly in context of the admin area.
Controller rewrites are used for both the frontend and the admin area.

This type of controller rewrite can be very useful, but suffers the same downside as module, block or helper
class rewrites: each class can only be rewritten once. If two modules try to rewrite the same
controller, only one of them will be used.

The other is silently ignored, which can of ocurse, lead to obscure bugs.

When adding a new controller to an existing route, usually it is a good idea to use the
after argument, with the original module name, so if a module with the same name is added to the core
in the future, you won't accidentaly mask it.

However, when rewriting a controller class, the new controller usually extends the original
controller class. Because controller classes are included by the router and not by the autoloader,
simply defining the inheritance in PHP is not enough.

For action controllers, we have to revert to manually specifying the class file to include, before
it can be used as the parent in the class definition. 

The best way to build the path to the original controller class is using the Mage::getModuleDir() method:

<?php

$controllerDir = Mage::getModuleDir('controllers', 'Mage_Customer');
require_once $controllerDir . '/AccountController.php';

class Example_Module_Customer_AccountController extends Mage_Customer_AccountController{
	
}

Controller class files are the only classes of the Magento framework that are not included
by the autoloader (besides Mage).

This section of the book now completes the whole routing process, starting with the Front Controller
instansiating all routers, router matching and router delegation, the Standard router
mapping the request to a route, instansiation of an action controller and finally the
action controller being dispatched.

TRIVIA:

the Adminhtml 404 page

This chapter stated that when adding new controllers dirs to a route, the config should use
the after argument for new controllers, and before when rewriting a controller.

However, when adding new controllers to the adminhtml route, before="Mage_Adminhtml" should always
be used instead of after="Mage_Adminhtml".

This should be done for new controllers as well as rewrites.

Some might consider the reason for this to be a bug in Magento. It isn't.

The Mage_Adminhtml implements it's own 404 page. It is used if the requested frontName matches
a route that is registered with the Admin router, but no matching controller or action is found.

in that case, the router will not pass the request on to the Standard router to look for a match.
Instead, if no matching controller is found, the Admin router simply sets $controller = 'index' and $action = 'noroute', and used that route to display the 404 page.

This case only occurs if all modules in the array for the current route were already checked for a match.
Because of that the variable $realModule contains the last value from that list.

That means the Admin router expects the last module in the list to contain an IndexController.php with
a norouteAction() method.

The Mage_Adminhtml module contains a IndexController.php file with a norouteAction() method.
However, if there is a custom module in the list AFTER Mage_Adminhtml, chances are it does not contain such a class.

In that case, Magento simply falls back to checking the next router for a match after all.
The Magento Adminhtml 404 page has been broken for a long time.

The reason is that the Phoenix_Moneybookers module adds itself to the adminhtml route, after Mage_Adminhtml.

If you want to see the original admin 404 page, all you have to do is open the file app/code/community/Phoenix/Moneybookers/etc/config.xml, find the admin router section and change after="Mage_Adminhtml" to before="Mage_Adminhtml".

Then access a non-existant admin route, for example /admin/show-me-the-404-page
However - before you go ahead and try it out - it might not even be worth it.

If we wish to see the code, we can find it in:

Mage_Core_Controller_Varien_Router_Admin::noRouteShouldBeApplied() and 
Mage_Core_Controller_Varien_Router_Standard::match().

Remember, that the Admin router extends the Standard router. Searching for the string _noRouteShouldBeApplied
quickly lets you find the right section.

Request Rewrite Summary:

Before we wrap up this section, let's summarize all options Magento provides to apply controller rewrites:

					Possibilities to rewrite requests in Magento
					---------------------------------------------------
					# Method 				Applied In 		Method 		Use For
					---------------------------------------------------
					1 DB based  			Front Controller dispatch() SEO URLs
					(table_core_url_rewrite)

					2 Config XML based 		Front Controller dispatch() Deprecated
					(regex)

					3 Config XML based 		Action Controller preDispatch() Deprecated

					4 Route to modules map 	Standard Router   match() 		Controller Rewrites

For the current exercise option number 4 will be the right choice to rewrite the Mage_Customer_AccountController
controller. But before we move on to the solution, there is one more little bit of info.

The Standard router contains yet another rewrite implementation, but fortunately that Mage_Core_Controller_Varien_Router_Standard::rewrite() method is never called.

Solution:

The example solution code can be found in the extension Meeting02_ControllerRewrite

The config.xml code consists of two parts.

<?xml version="1.0"?>
<config>
	<frontend>
		<routers>
			<customer>
				<args>
					<modules>
						<meeting02_controllerRewrite
before="Mage_Customer">Meeting02_ControllerRewrite_Customer</meeting02_controllerRewrite>
					</modules>
				</args>
			</customer>
		</routers>
	</frontend>
	<default>
		<meeting02>
			<controller_rewrite>
				<target_category_id>22</target_category_id>
			</controller_rewrite>
		</meeting02>
	</default>
</config>

The first part between the <routers> node adds Meeting02_ControllerRewrite_Customer to the list of modules
for the customer route. Since we want to implement a rewrite, the attribute before="Mage_Customer" has to be
specified. 

When a request matching the customer route's frontName is recieved, this will cause the Standard router
to look for a matching controller in the dir Meeting02/ControllerRewrite/controllers/Customer/, before
it looks in the Mage_Customer module.

Please note that the indentation for the node <meeting02_controllerRewrite> is strange because no
whitespace is allowed around the value.

If you (or your IDE) adds newlines or spaces, the rewrite will simply not work.
Who knows, maybe a trim() will be added in the future - it's never too late to dream
(or submit a patch lol).

The second part of the config within the <default> branch specifies the category ID to which a customer
should be redirected after a successful login.

Since the configuration already has been discussed in detail in the research section of this chapter,
let's move on to the controller code of the example exercise solution.

require_once Mage::getModuleDir('controllers', 'Mage_Customer') . '/AccountController.php';

class Meeting02_ControllerRewrite_Customer_AccountController extends Mage_Customer_AccountController
{
	
}

The parent class is manually included before the class declaration, since the Magento autoloader will not
include it (as already discussed earlier in this chapter).

The new class then can extend from the original rewritten class without PHP complaining about unknowns.
The new class overwrites the parent's loginAction() method and adds one new method of its own.

	public function loginAction()
	{
		parent::loginAction();

		$categoryId = Mage::getStoreConfig('meeting02/controller_rewrite/target_category_id');

		$storeId = Mage::app()->getStore()->getId();
		$url = $this->_getSeoCategoryUrl($categoryId, $storeId);
		$this->_getSession()->setBeforeAuthUrl($url);
	}
Before anything else is done, the parent::loginAction is called. This keeps the code as upgrade-safe as possible,
since any future changes will probably be picked up automatically - no code was copied and pasted from
the parent method.

To generate the target URL a custom method _getSeoCategoryUrl() is used - we will look at that next.
The returned URL is then set on the customer/session model using the magic setter:

setBeforeAuthUrl();

	protected function _getSeoCategoryUrl($categoryId, $storeId)
	{
		$requestPath = Mage::getResourceSingleton('core/url_rewrite')
			->getRequestPathByIdPath('category/' . $categoryId, $storeId);

		if ($requestPath){
			$url = Mage::getModel('core/url')->getDirectUrl($requestPath);
		} else {
			$url = Mage::getModel('core/url')->getUrl(
				'catalog/category/view', array('id' => $categoryId)
			);
		}
		return $url;
	}
}

In the method _getSeoCategoryUrl() it is first attempted to load the search engine friendly URL for the
given category ID. If that fails it falls back to the internal URL path /catalog/category/view/id/22.

The method calls to Mage_Core_Model_Url serve to add the configured base URL to the request path.
In the if branch of the code block above, the method getDirectUrl() leaves the request path as it is.

Additional params passed as a second arg will be ignored, the only thing it does
is it prefixes the path with the store's base URL.

On the other hand, if the request path consists of the route name, controller, and action, it has to
be passed through getUrl() (refer to the else branch)

It will replace the first part - the route name - with the matching frontName and then prefix
the result with the store's base URL.

Any params passed as the second arg to the method will be added to the request path.

The customer session before_ and after_auth_url:

If the customer/session model before_auth_url and after_auth_url properties are set, they are
used to determine the page a customer is redirected to after Login.

This happens in the method Mage_Customer_AccountController::loginPostRedirect()

The method is surprisingly complex. (lol) *3*

The details are not for the Exam.

I'll only go into the specifics below so it may be used as a reference.

The gist of it is that after_auth_url is only evaluted if the authentication was successful, that is,
when the customer logged in successfully.

Otherwise, if it is not set or the login failed, it uses the before_auth_url.

There also is a config option that influences the redirect target if the login was successful under some
conditions. The setting can be found at Customer Configuration > Login Options > Redirect Customer to
Account Dashboard after Logging in.

The following table explains most cases that can occur:

		Possible post login URL redirect targets
BEFORE SET 		AFTER SET 	LOGIN OKAY	 	CONFIG OPTION Set 	REDIRECT TARGET
yes 			yes 		yes 			- 					after_auth_url

yes 			no 			yes 			- 					before_auth_url

no 				yes 		yes 			no 					after_auth_url

no 				no 			yes 			no 					Account Page

no 				yes 		yes 			yes 				referer or Account Page

no 				no 			yes 			yes 				referer or Account Page

yes 			yes 		no 				- 					before_auth_url

yes 			no 			no 				- 					before_auth_url

no 				yes 		no 				- 					Login page

no 				no 			no 				- 					Login page

There are still two special cases that aren't included in the table that i'll just mention:

1. When the before_auth_url equals the base URL it is not used. The behavior is just as if before_auth_url
isn't set at all

2. If the before_auth_url equals the logout page URL it is changed to the customer account page.

The before_auth_url property is set in many places within the Magento core.
The after_auth_url property usually isn't set.

The usual flow is the following:

A page requires the customer to be logged in, so it calls Mage::getModel('customer/session')->setBeforeAuthUrl($url)
before it redirects the customer to the login page. ($url is the URL of the protected page)

After the customer then attempts to log in, he is redirected back to the before_auth_url, regardless of 
wether the login attempt was successful or not.

In case the customer did not log in, he will be redirected to the login form again.

If the login was successful, the customer now is able to view the protected page.

Use $session->setAfterAuthUrl($url) to force the customer to be redirected to a specific URL
after a successful login. In the Magento core the after_auth_url property is rarely set,
so it is an ideal candidate for customizations.

When setting the after_auth_url session property be aware that it also affects customer logins
during the checkout (which uses the before_auth_url property to redirect the customers back to
the checkout after authorization).

TRIVIA PARTS:

Just to reiterate: The controllers dir is inserted after the second part, so for example Mage_Widget_Adminhtml
maps to the dir Mage/Widget/controllers/Adminhtml.

To reiterate: the reason controller classes are not loaded by the autoloader is that the controllers
dir isn't part of the class name and - even if it would be - the first character of controllers
is lowercase.

Some devs still prefer to use the DIRECTORY_SEPARATOR or DS constants as Path seperators
instead of simply using / before the file name, but since PHP will take care of automatically
using the correct seperator independantly of what we specify, it does not change anything, apart from being
harder to read.

The cyclomatic complexity number of the Mage_Customer_AccountController::_loginPostRedirect() method is
11, even if it only consists of 39 lines of code.

Only the Mage_Oauth_AuthorizeController class sets the after_auth_url prop.
However, it is set to the customer login URL.
I leave it to the reader to decide if it makes sense to redirect the customer to the
login page after a successful authorization.

Exercise: Dynamic class rewrites

Original task desc:

The original task description from the study group kit for this exercise is as follows:

Create a dynamic rewrite of the payment/data helper only if the version of Magento is older
than version 1.4, and if the ccsave payment is enabled for the current store.

Overview:

This chapter discusses the following topics in the research section and the examination
of the exercise solution:

Reading and setting configuration settings (both scoped and unscoped)

Saving configuration settings

Scenario:

The idea behind this exercise is very useful. Being able to dynamically set configuration values
enables many customizations, mostly using observers, that otherwise would require a class rewrite
or other much more invasive code.

For example, it can be used for:

Providing backward compability for modules by rewriting a class only under specific circumstances

Enabling and Disabling payment methods and shipping carriers on the fly.

Working around method signature changes between Magento versions (for example, if a method used
to be private and now is protected)

Creating config fixtures for unit tests

Any configurable value can be set this way, making it an extremely powerful technique.

Research:

Let's start by having a look at how configuration values are read, because then it will become
obvious how they are set.

Reading Configuration Values:

In Magento there basically are two ways configuration values are accessed.

Scoped values (mainly used for system config settings) accesed via Mage_Core_Model_Store::getConfig()

General configuration values accessed via Mage_Core_Model_Config::getNode()

Scoped Configuration Values:

A scoped configuration value is a setting that can be defined in one or more scopes.
There are three scopes:

										Config Scopes
								Scope 		Priorty
								----------------------------
								default 	Lowest Prio
								website 	Overrides default scope values
								store 		Overrides default and website scope values

If a value is set in more than one scope, the more specific value will override the less
specific one.

In the next chapter, we will go over how the dispatch process to see how configs are loaded.
To access scoped values usually the static Mage::getStoreConfig() or
Mage::getStoreConfigFlag() methods are used.

They automatically return the value from the most specified scope for the specified path.

The two methods of the Mage class fetch the current (or the specified) store model and then use
$store->getConfig() to access the scoped value. 

The Mage_Core_Model_Store class getConfig() method looks like this:

public function getConfig($path)
{
	if (isset($this->_configCache[$path])) { //if the configCache for this path is set, return it
		return $this->_configCache[$path]; //Meaning that we don't have to reprocess requests
		//and re-run logic, because it already is cached
	}

	$config = Mage::getConfig(); //get the config, the Module

	$fullPath = 'stores/' . $this->getCode() . '/' . $path; //The full path is the stores, this codes fed in path
	$data = $config->getNode($fullPath); //Get the node of the full path from config

	if(!$data){ //If there is no node, just return null
		return null;
	}
	return $this->_processConfigValue($fullPath, $path, $data); 

	//In case we got here,
	//the configCache for this path was not set, and there is a node.
	//So, we process the config value by feeding in the fullpath, the relative path
	//and the node we retrieved.
}

We can see that the value is cached on the store model once it is accessed, so subsequent calls
with the same path will return the cached value. When trying to change values on the fly
it is important to considering caching, so let's keep that in mind, while we explore further.

In case a non-true value was returned by $config->getNode(), the method returns Null.

However, if a value evaluating to true was returned, it is passed through _processConfigValue()
before the value is returned (at the end of the code block above). The method _processConfigValue()
contains two little-know features.

Let's have a closer look at it:

protected function _processConfigValue($fullPath, $path, $node)
{

Just for reference, the variable $fullPath contains the full XPath to the configuration setting
including the store scope prefix. The variable $path contains the config path without any scope applied.

The $node variable contains the Mage_Core_Model_Config_Element node returned by $config->getNode()

Thus, the differential between fullpath and path, is that fullpath also carries the Scope, with it,
whilst the normal path does not.

Moving on:
	
	if($node->hasChildren()){ //Check for sub-nodes
		$aValue = array; //Start an array
		foreach ($node->children() as $k => $v){ //Go through 
		//the children as the variable $k mapped to $v

			//The associated data in $aValue of $k is processed with the COnfigValue of 
			//itself, the path and the fullpath, meaning we process every child in the 
			//process as well 

			$aValue[$k] = $this->_processConfigValue( 
				$fullPath . '/' . $k, $path . '/' . $k, $v
			);
		}

		//Assign the cache to the said path to be the array we processed
		$this->_configCache[$path] = $aValue;

		//return the processed array
		return $aValue;
	}

The above section of code builds the content for the already mentioned config
cache property. If the requested node has children, the values of all branches below
 the requested node are cached as an array. Not a lot we can do with that.

Moving on:

	$sValue = (string) $node; //cast the node to a string
	if (!empty($node['backend_model']) && !empty($sValue)){ //if the sValue is not empty
		//and the nodes backend_model value is not empty

		//Assign the backend cast to a string by getting the backend Model
		$backend = Mage::getModel((string) $node['backend_model']);

		//assign the path and node to the backend and apply the afterLoad to it
		$backend->setPath($path)->setValue($sValue)->afterLoad();

		//get the value from the backend
		$sValue = $backend->getValue();
	}

First the node value is cast to a string. Up until now it still was a 
Mage_Core_Model_Config_Element instance.

And here, we discover a little-known feature: any scoped config value may have a backend model.
If a backend_model="..." argument is present, the model is instansiated, the config value is set on it,
then afterLoad() is called, and the returned value is used after that.

This functionality might be used for many things:

mapping ID values to labels

translation

processing placeholders

loading the contents of files specified in the config value

That list surely is very incomplete but hopefully is enough to trigger your own
idea on how to use it. Getting back to the _processConfigValue() method, some further
processing of the string value happens next:

if (is_string($sValue) && strpos($sValue, '{{') !== false) { //if the sValue is set since before
	//and there exists a set of '{{' in the str

	if (strpos($sValue, '{{unsecure_base_url}}') !== false) { //if unsecure base url and the clammers is in the //$sValue

		//aquire the unsecure base Url from the XML
		$unsecureBaseUrl = $this->getConfig(self::XML_PATH_UNSECURE_BASE_URL);

		//Run a regex to replace the PH value with the true unsecureBaseUrl
		$sValue = str_replace(
			'{{unsecure_base_url}}', $unsecureBaseUrl, $sValue
		);

	//see if secure base url is there
	} elseif (strpos($sValue, '{{secure_base_url}}') !== false){

		//Aquire the secure base Url through the xml path getConfig
		$secureBaseUrl = $this->getConfig(self::XML_PATH_SECURE_BASE_URL);

		//run a regex to replace the securebaseurl with the actual securebaseurl value in the sValue
		$sValue = str_replace('{{secure_base_url}}', $secureBaseUrl, $sValue);

	//see if base url is there
	} elseif (strpos($sValue, '{{base_url}}') !== false) { 
		//if base_url is in sValue
		$sValue = Mage::getConfig()->substDistroServerVars($sValue);
	}
}

Configuration values can contain references to the configured secure or unsecure base URL
(see the if or the first elseif branches). However, the most interesting one is the last one,
for it contains the substDistroServerVars() call.

What it does, is that it replaces it with currently requested host name (including the http or
https schema).

If the store code is configured to be part of the request path, it will not be included in the
{{base_url}} replacement value. 

The remainder of the _processConfigValue() method simply sets the store's config cache prop
for the current path and returns the final value:

	$this->_configCache[$path] = $sValue;
	return $sValue;
}

Magento Trivia:

The method Mage_Core_Model_Config::substDistroServerVars() actually does a str_replace() on more than just
the {{base_url}}, even tho that string has to be present in the config value to trigger the replacement call.

The method will also process the following PHs if present in the config value:

						substDistroServerVars() PHs
						---------------------------
						Placeholder Replacement
						---------------------------
						{{root_dir}}  Magento Base Dir
						{{app_dir}}   Magento base dir+ /app
						{{var_dir}}   Magento base dir + /var
						{{base_url}}  Currently requested base url

Since the {{base_url}} PH has to be present in the config value to trigger the automatic replacement,
the other values will probably never be useful. Unless, of course, you call Mage::getConfig()->substDistroServerVars($string) yourself, passing in a string containing any of the four PHs.

However, when refering to the other dirs in custom code, it is much more common to call Mage::getBaseDir(),
with the appropiate type as an argument.

Most of the time, when we call getConfig, we use the Mage::getStoreConfig() instead of making a pure
call on the store itself.

the Mage::getStoreConfig($path, $store = null) call, directly returns the value from $store->getConfig().
Unless a specific store code, ID or model is passed as an arg, the current view is used.

the Mage::getStoreConfigFlag($path, $store = null) call, takes the return value of 
Mage::getStoreConfig() and returns it as a boolean. But instead of using PHP to simply typecast
the value, getStoreConfigFlag() does that for us.

The result is the same as if:

return (bool) Mage::getStoreConfig($path, $store);

NOTE: if the config node value is false, it will return false, unlike casting.

Unscoped Configuration Values:

The scoped configuration is only a small subsection of the overall Magento config.
To access an arbitrary node with the config DOM structure, the method
Mage_Core_Model_Config::getNode() is used.

Since the XML processing in Magento is based on PHP's simpleXml, the request paths always
are in the context of a node. usually, this is the root node, <config>, which means this node
is omitted when specifying a config path.

For example, given the following XML tree:

<config>
	<modules>
		<Mage_Log>
			<active>true</active>
			<codePool>local</codePool>
		</Mage_Log>
	</modules>
</config>

to read the value of codePool, we just use getConfig()->getNode and leave out the config part:

$codePool = (string) Mage::getConfig()->getNode('modules/Mage_Log/codePool');

The path is modules/Mage_Log/codePool without the <config> node at the beginning.
Note that the returned value of getNode() is a Mage_Core_Model_Config_Element instance, so it might
need to be cast to a string. If the requested path does not exist, the return value
of getNode() is false.

It is very important to be attentive to the casing of the XML path expression.
Access to nodes through Mage::getConfig is case sensitive.

Setting Configuration Values:

Coming back to the exercise at hand, we still have to see how configuration values can be 
specified dynamically on the fly.

Setting Scoped Config Values

Since scoped values are accessed via the store model, they should also be set that way.
The Mage_Core_Model_Store class offers the method setConfig() for this purpose:

public function setConfig($path, $value)
{
	if(isset($this->_configCache[$path])){
		$this->_configCache[$path] = $value; //if the path is already defined in the configCache, assign it the value
	}
	$fullPath = 'stores/' . $this->getCode() . '/' . $path; //the full path, is this
	mage::getConfig()->setNode($fullPath, $value); //get the config and set the node

	return $this; //return the request
}

The reason it is important to use this method instead of simply setting the value on the core/config
singleton is that it takes care of updating the config cache prop in the store model.

In case the config value was previously accessed through the core/store model, simply changing the node 
value in the core/config singleton would not be enough, since the $_configCache store prop would
mask the changes.

This implies a interaction between the caches and the values of the XML nodes. Meaning, that
we can never presume that something acts in isolation in terms of being unrelated to the caches.

Setting Unscoped Configuration Values:

The store model's setConfig() method already shows us how generic config values are set.

Mage::getConfig->setNode($path, $value);

Note the value will not be saved to the DB or even the Magento cache backend.

Since plain setting the node with set node does not cache the things or interact with the DB,
unlike allowing for cached data.

Meaning that we use just setNode for the Unscoped values.

It is only valid for the duration of the current request.
This is exactly what we need for this chapters exercise, which is to dynamically implement
a class rewrite.

But we also could have use of knowing how to save config values.

Persisting Configuration Values:

Even though it is not required for the current exercise, it is useful to know how to
persist config values.

Saving Scoped Config Values:

Any scoped value can be persisted in the core_config_data table.
There are several ways to accomplish this (besides plain SQL queries).

For example, let's assume we want to set the value for general/locale/code to uk_UA (Ukrania) on a store
view scope for the store with the ID 3.

There's a number of ways we could do this:

1. use the core/config singleton:

//In any context

Mage::getConfig()->saveConfig('general/locale/code', 'uk_UA', 'stores', 3);

The method signature looks akin to the following:

public function saveConfig($path, $value, $scope = 'default', $scopeId = 0)

2. use the core/config_data model:

//in any context

Mage::getModel('core/config_data')
	->setScope('stores')
	->setScopeId(3)
	->setPath('general/locale/code')
	->setValue('uk_UA')
	->save();

Any existing value for the specified path and scope would automatically be replaced, even if the model
wasn't previously loaded. The third and final way to save scoped config values is mostly used
within setup scripts:

//In setup scripts
$installer->setConfigData('general/locale/code', 'uk_UA', 'stores', 3);

All setup classes inherits this method from Mage_Core_Model_Resource_Setup.

The method signature is identical to the one of the core/config class (except for the method name).
In the end it doesn't matter which of these methods you choose - the end result is the same.

Saving Unscoped Config Values:

The Magento core does not provide a mechanism to save unscoped config values.
The only way to accomplish that would be to write them to an XML file, which is then merged into the config
DOM on subsequent Requests.

If you ever find yourself in the need for doing that, chances are there is a better approach
then saving arbitrary config XML. However, let's explore how it might be accomplished nevertheless.

Since the installation requires the app/etc dir to be writeable for creating the app/etc/local.xml file,
writing a file there would probably work on many installations. This file would also automatically
be parsed and included in the config DOM during the loading of the base config.

However, it probably is not a good idea, since any security-aware webmaster should restrict write
access to that dir again after the Magento installation is complete. So how about writing the XML
to a file in a sub-dir of media/ or var/, and manually merge it into the loaded config?

That would certainly be possible. Making it work with more then a single webserver would be 
hard, though. Probably it would be better to revise your module's architechture to use regular
entity storage tables instead.

Solution:

The example solution code can be found in the extension Meeting02_DynamicRewrite.
The entry point for the module logic is an event observer for the controller_front_init_before event.

As discussed in the observer section of the "redirect to base URL chapter", that event is triggered
very early during dispatch. It is a good point to do dynamic config changes, since chances are taht
the evaluation of the config values has not taken place yet.

When choosing this event to do dynamic class rewrites, one thing to watch out for is that the rewrite
will only be applied if Magento is processing a request.

If the Magento runtime env is initialized from a cron script or a custom command line script,
the Front Controller is not dispatched, and thus the event will not be fired.

The observer method in exercise solution's class Meeting02_DynamicRewrite_Model_Observer looks as follows:

public function controllerFrontInitBefore(Varien_Event_Observer $observer)
{
	$store = $this->_getStore(); //get the store in the request
	if ($store->getConfig('payment/ccsave/active')){ //if ccsave payment is active
		$helper = $this->_getHelper(); //get the helper
		$helper->rewritePaymentHelperIfAncient(); //Config the version through the helper,
		//this is a custom helper function
	}
}

Adhering to best practices, the observer delegates the main work to a model, or in this case,
a helper. The method is a Meeting02_DynamicRewrite_Helper_Data::rewritePaymentHelperIfAncient():

public function rewritePaymentHelperIfAncient()
{
	$this->setConfigIfVersion(
		'1.4', //version to compare
		'<', //operator to use
		'global/helpers/payment/rewrite/data', //rewrite config path
		'Meeting02_DynamicRewrite_Helper_Payment_Data' //rewrite value
	);
}

public function setConfigIfVersion($version, $comp, $path, $value)
{
	if (version_compare($this->_getMageVersion(), $version, $comp)){
		$config = $this->_getConfig();
		$config->setNode($path, $value);
	}
}

According to the method, an ancient version is anything older than Magento v 1.4.

In that case, the config value Meeting02_DynamicRewrite_Helper_Payment_Data is set for the 
config path global/helpers/payment/rewrite/data using setNode() on the core/config model.

In the replacement class for the payment helper, the filtering of available payment
providers can take place for Magento versions older than 1.4

The reason the rewrite only needs to be done in Magento versions older than 1.4
is because since then payment provider filtering can be done using an observer
for the event payment_method_is_active, which is dispatched in:

Mage_Payment_Model_Method_Abstract::isAvailable()

This completes the exercise solution code discussion.

Before finishing this chapter, please note that payment method availability could also
be altered by setting the config node values of the payment method's <active> setting to false.

This is an alternative way of achieving the same result, filtering available payment methods - which
would not require a class rewrite in any Magento version.

On the other hand, it might be more difficult to find a good event candidate where all required
information is available that is needed decide if a payment method should be active or
not.

Here is an example of how a payment method could be deactivated using this approach:

$store = Mage::app()->getStore();
if(version_compare(Mage::getVersion(), '1.4', '<')){
	$store->setConfig('payment/ccsave/active', false);
}

TRIVIA: The Mage_Core_Model_Config_Element is just a wrapper around Varien_Simplexml_Element, which is a extension of
the standard PHP SimpleXmlElement class.

Exercise: Diagram of the dispatch process

The original task desc:

Create a diagram of the important classes involved in a request dispatch.

Overview:

This chapter discusses the following topics in the research and the examination of the exercise
solution:

A brief comparison of Mage vs. Mage_Core_Model_App

Configuration XML merging

Configuration XML load order

The Application Dispatch Process

Scenario:

Since this chapters exercise doesn't require writing any code, there really is no scenario for it.
It is useful for debugging and customizing Magento, tho.

Research:

This exercise gives us the oppurtounity to have a look at one very important aspect of Magento which
we haven't covered so far: the config load process.

But before the config is loaded, a few even more basic elements of the Magento framework 
has to be initialized.

The very first step is including the file app/Mage.php, which sets up the autoloader
and the include path.

But that alone isn't enough to init Magento, we have to prepare the Magento runtime env too.

Mage vs. Mage::app():

There are two ways the Magento runtime env is initialized after the file app/Mage.php is included:

								Magento Initialization
						-----------------------------------------
						Initialization Method Purpose
						-----------------------------------------
						Mage::run() 				Sets up the Magento runtime env and processes
													the current browser request.

						Mage:app() 					Just sets up the Magento runtime env.
													No request processing is done,
													This is mostly used within custom commandline scripts.

Either way, inside the Mage class the static property self::$_app = new Mage_Core_Model_App(); is set
first.

The difference between the static Mage class and the instance returned by Mage::app(), is notable.

The Mage class, acts as the Superobject, as in the parent class of most Mage interaction.
The main two purposes of it, is for retrieval of two objects relevant to the framework:

Mage::getConfig() and Mage::app(). It also provides most of the factory methods, for example
Mage::getModel() and Mage::helper().

The special method Mage::run() starts the Magento dispatch process after initializing 
the runtime env. Also, the Mage class is the home of the Magento registry.

On the other hand, the Mage_Core_Model_App instance generally is used to access most 
of the request specific object instances within the Magento framework.

These include but are not limited to:

The request and response objects (Mage::app()->getRequest() and Mage::app()->getResponse())

All store models(Mage::app()->getStores())

The Front Controller Instance (Mage::app()->getFrontController())

The layout object(Mage::app()->getLayout())

Consider core/app more of a stateful object then the static Mage class, even though
that distinction isn't 100% accurate.

After Mage_Core_Model_App is instansiated, the first thing that it does is register the Magento
error handler and set the default timer zone.

This happens within the method Mage_Core_Model_App::_initEnvironment()

The Magento error handler mageCodeErrorHandler() can be found in the file app/code/core/Mage/Core/functions.php,
which is included directly by app/Mage.php

The Configuration Load Process:

Since Magento is a configuration based framework (in contrast to convention based frameworks),
almost every feature - core or custom - starts with the config XML.

At runtime, the XML files are loaded into Magento into a DOM-tree-like object structure.
Let's inspect how the config DOM is created, what aspects to keep in mind when working with it,
and how to use it to our advantage.

Let's get back to the config load process.

The configuration model is assigned using the method self::_setConfigModel($options);
The $options argument seen in the next code block is passed to Mage::run() or Mage::app()
as an optional third argument.

protected static function _setConfigModel($options = array())
{
	if ( //if the config model is set and the config model class exists
		isset($options['config_model']) && class_exists($options['config_model'])
	) {
		//get the config model name
		$alternativeConfigModelName = $options['config_model'];
		//unset it
		unset($options['config_model']);
		//Create a new one with the new options
		$alternativeConfigModel = new $alternativeConfigModelName($options);
	} else {
		//Otherwise, the alternativeConfigModel is null, since it does not exist
		$alternativeConfigModel = null;
	}
	if(!is_null($alternativeConfigModel) && ($alternativeConfigModel instanceof Mage_Core_Model_Config)
	){	//if the alternative configmodel exists and its a config model
		self::$_config = $alternativeConfigModel;
	} else { //Otherwise, create a new one with the options
		self::$_config = new Mage_Core_Model_Config($options);
	}
}

The code block reveals that an alternative configuration model can be specified in the $options array.
This can be used to customize Magento to a very high degree, for example to utilize a different
dir structure than the normal Magento folder hierarchy.

Using an alternative config model also is a technique used by test framework integrations 
to provide a way to mock models and resource models.

The norm however, is that no custom model is specified, in which case the default config model 
Mage_Core_Model_Config will be used.

After the configuration model is assigned, the Mage class delegates to Mage_Core_Model_App.
The most important next steps are the same, regardless if Mage::run() or Mage::app() was used
to fire up Magento.

First, a custom error handler is registered, before a reference to config model is set on
the core/app instance. From this point onward, calling Mage::getConfig() or Mage::app()->getConfig()
will return the same instance.

Note that the current config object is empty, no XML has been loaded yet.

Loading of the Base Configuration

The actual loading of the configuration begins next, when $this->_config->loadBase(); is called
by core/app. Note the following loadBase() method belongs to the core/config class, not core/app.

public function loadBase()
{
	$etcDir = $this->getOptions()->getEtcDir(); //get hte dir
	$files = glob($etcDir.DS.'*.xml'); //DS is directory seperator
	$this->loadFile(current($files)); //load the files for the request
	while ($file = next($files)){ //while there is a next file in list of files to go through
		$merge = clone $this->_prototype; //make a clone of the prototype of this object
		$merge->loadFile($file); //load the file into the prototype 
		$this->extend($merge); //extend files loaded from the merge, into the request
		//meaning they are merged into the DOM tree
	}
	if (in_array($etcDir.DS.'local.xml', $files)){ //if the dir name is in files
		$this->_isLocalConfigLoaded = true; //LocalConfigLoaded is done
	}
	return $this; //return the request
}

The method loads all XML files in the app/etc/ dir in alphabetical order.
All the files are listed in the following table (unless of course custom XML files where
added there).

						XML files in the app/etc dir
				File 					Edition 			Contents
				----------------------------------------------------
				app/etc/config.xml 		 CE and EE 			A "bootstrap" config skeleton

				app/etc/enterprise.xml 	 EE only 			FPC Request Processor and Cache settings

				app/etc/local.xml 		 CE and EE 			DB credentials and adminhtml frontName

Additional custom XML files can be added, but be aware that they are not cached and will be parsed
and merged on each request.

The most interesting part of the loadBase() method above are the lines inside the while loop.
Each file is loaded using a Mage_Core_Model_Config_Base instance cloned from $this->_prototype.

The core/config_base class uses the PHP function simplexml_load_string() to parse the file contents,
converting each node into a Mage_Core_Model_Config_Element instance along the way.

The Mage_Core_Model_Config_Element class is a small wrapper for Varien_Simplexml_Element, which
in turn extends from the native PHP class SimpleXMLElement.

Then the loaded nodes are merged into the main DOM tree using the extend() method.

The extend() method takes an optional second parameter - $overwrite - which defaults to true.
This refers to existing node values, which will be overwritten by nodes at the same position
during the merge.

This is the basis of the Magento configuration load process. New DOM node children
are added to the existing XML tree sturcture during the merging. Existing DOM node values
are overwritten in case a file that is loaded later contains the same node structure
with a different value.

For example, let's assume the first XML file which is loaded contains the following nodes:

XML #1

<config>
	<modules>
		<Meeting02_ExampleXml>
			<active>true</active>
			<codePool>local</codePool>
		</Meeting02_ExampleXml>
	</modules>
</config>

XML #2

<config>
	<modules>
		<Meeting02_ExampleXml>
			<version>0.1.0</version>
		</Meeting02_ExampleXml>
	</modules>
</config>

Once the two files are merged, the resulting DOM structure would be:

<config>
	<modules>
		<Meeting02_ExampleXml>
			<active>true</active>
			<codePool>local</codePool>
			<version>0.1.0</version>
		</Meeting02_ExampleXml>
	</modules>
</config>

The new <version> node is added to the existing DOM structure.
Now assume the third XML is loaded:

XML #3
<config>
	<modules>
		<Meeting02_ExampleXml>
			<active>false</active>
		</Meeting02_ExampleXml>
	</modules>
</config>

This would cause a over-write of the previous active, from true, to false.
Meaning that new nodes get appended, and previous ones get overwritten.

Understanding this is one of the main steps of mastering the Magento framework.
This behavior is also the reason why the load order of XML files is very important.

Any file may overwrite values defined in config files that are loaded earlier.
Now that we have an understanding of the nature of the XML merging process, we can focus
on the order of XML files that are loaded.

After all the XML files in the app/etc/ dir are merged, the Magento cache is initialized by the core/app model.
This can't be done earlier, since the cache configuration only just was loaded with the base config.

As note before, a consequence of this is that the merging of the base XML files happen on every
request - regardless if the config cache is turned on or off.

The exact methods which are used to complete the loading of the config differ slightly, depending on wether
Mage::run() or Mage::app() was called to initializing the runtime env.

However, the order of the following next steps regarding loading of the config are the same:

							Module configuration load process

							#METHOD 					COMMENT
							-----------------------------------
		1 $this->_config->loadModulesCache() 			The following steps occur only if the cache
														can't be loaded.
		2 $this->_config->loadModules()

		//Mage_Core_Model_Resource_Setup::applyAllUpdates() is called here

		3 $this->_config->loadDb()

		4 $this->_config->saveCache()

On a side node, between step 2 and 3 listed in the table above,
Mage_Core_Model_Resource_Setup::applyAllUpdates() is called.

This is an important part of the Magento initialization process, however it doesn't directly influence
the config load process.

More details about install and upgrade scripts will be covered in the third book of the series: ORM and Setup Scripts.

Our next step is to have a closer look at the methods loadModules() and loadDb() (line 2 and 3)

Loading of the Module Registry:

Every module that is known to Magento should be registered in an XML file in the app/etc/modules 
dir.

The method Mage_Core_Model_Config::loadModules() delegates to $this->_loadDeclaredModules() in order to process
those registry files.

That method does so by:

	a. loading all XML files in app/etc/modules

	b. Sorting all declared modules according to their dependencies

	c. merging the results into the main config DOM

The list of files to do step a) is retrieved from the _getDeclaredModuleFiles() method.

It sorts the list of files in app/etc/modules into three lists:

	foreach ($moduleFiles as $v){ //go through the moduleFiles
		$name = explode(DIRECTORY_SEPERATOR, $v); //explode the name
		$name = substr($name[count($name) - 1], 0, -4); //assign the substr to check

		if ($name == 'Mage_All'){ //if the name is mage all
			$collectModuleFiles['base'][] = $v; //put it in base
		} else if (substr($name, 0, 5) == 'Mage_') { //if its Mage_ but not Mage_All, put it here
			$collectModuleFiles['mage'][] = $v;
		} else {
			$collectModuleFiles['custom'][] = $v; //put the rest here
		}
	}

The base list only contains the file Mage_All.xml

The mage list contains all files beisdes Mage_All.xml that starts with Mage_.

The custom list contains all other files in alphabetic order.

The further loading and merging of these files will happen in this order.
This means that any extension can overwrite values from the files starting with Mage_.

Notice that modules from the Enterprise namespace is treated according to the custom clause.

Every extension that should be active during the Magento process is required to have an XML file in the module registry.

By convention the module namespace and name separated by an underscore should be used for the file name.
Some developers have taken to the bad habit of using a single registry file for multiple modules (following the example given by the file Mage_All.xml)

This goes against best practices since it offers no real benefit except being less open to modification, less transparent and breaks modularityt.

The registry files should contain only the minimal amount of info required for Magento to load the main module config.

That minimal info is:

	The modules namespace and name.

	The modules activation state

	The module's code pool

	The module's dependencies (optional)

The registration file should not contain any other info, even if it seems related because of a similar XML path.
For example, leave out a module's <version> that belongs into the modules etc/config.xml file.

Here is an example of a module reg file:

<?xml version="1.0"?>
<config>
	<modules>
		<Meeting02_RewriteOrder>
			<active>true</active>
			<codePool>local</codePool>
			<depends>
				<Mage_Core/>
				<Mage_Sales/>
			</depends>
		</Meeting02_RewriteOrder>
	</modules>
</config>

When the reg files are loaded, the contents are first merged into a seperate DOM structure.

The module list will be added to the main config DOM soon, but first, _sortModuleDepends() is used to create a sorted
list based on module dependancies.

If a dependency can't be satisfied because a depended on module is missing or inactive, Magento catches an exception.

After the list of modules is sorted, it is used to append each module to the main XML DOM structure in the correct order:

$sortedConfig->getNode('modules')->appendChild($node);

Loading of the Module Config:

The loading of the Modules config.xml files is often referred to as module initialization.
It means that a module's config is merged into the main config DOM.

Now that Magento knows which modules to initialize, and the order in which to do it, the core/config method loadModulesConfiguration() is called.

This method can be used to load an arbitrary XML file from every module's etc/dir. It's not only used for the etc/config.xml files, but also for every other file in that dir,
for example adminhtml.xml or system.xml

It can also be used to load and merge custom XML files.

For example, the extension Firegento_GriControl uses the method loadModulesConfiguration() to load a custom config file called gridcontrol.xml from every module.

It is commonly believed by many module devs that extensions are loaded in alphabetical order. However, this is not true.

Only extension registry files are loaded in alphabetical order. The more important module config.xml files load order is determined by module dependencies.

The config.xml files of modules depended upon are merged before the depending module is loaded. So modules are not really loaded in alphabetical order,
if they are, it's just random at work.

Remember, the reason it is important to know the module load order is because through the merge process a module can overwrite config values from any module
that was loaded earlier.

TRIVIA:

The following is a feature not used that often.

Config XML nodes can be forced to extend another existing node besides the parent by specifying an extends="the/x/path" arg.

This has no benefit over using normal nesting XML structure, except possibly avoiding code duplication.

For further info, have a look at the method Varien_Simplexml_Config::applyExtends().
It is called from Mage_Core_Model_Config::loadModules().

Loading local.xml - again:

After all modules are loaded, the contents of the local.xml are merged into the config DOM a second time.

This happens so that no module is able to overwrite values declared in local.xml
Another way to say it is that the contents of local.xml have a higher prio than any module config file.

Loading of the DB Configuration:

At this point during the Magento initialization all XML files have been merged into the config DOM structure.

The things missing are the system config settings which are stored in the core_config_data table.

To add these settings to the other config, the core/config model's loadDb() method delegates to the resource model's $this->getResource()->loadToXml($this) method.

This method has 120 lines of code, but its easy to read.

Lets have a look at the table structure to provide a little context for the upcomign seciton.

				Database Table 	core_config_data columns
	Field 			Type 				Content
config_id 		int(10) 		Auto Increment Primary Key

scope 			varchar(8) 		default, websites or stores

scope_id 		int(11) 		0 for default scope, otherwise the numeric website or store ID

path 			varchar(255) 	XML Config path

value 			text 			config value

The loadToXml method loads all records from the table and then does some multi-pass processing to merge
the values into the config DOM.

It does the following steps:

1. Copy all default scope records to the default config branch

Example:

Record:

	Scope 	scope_id 		path 					value
default 	0 			contacts/contacts/enabled  		1

would be added to the config DOM like this:

<config>
	<default>
		<contacts>
			<contacts>
				<enabled>1</enabled>
			</contacts>
		</contacts>
	</default>
</config>


2. The website scope settings

All settings from teh default node of the main config DOM - including the data from the XML files as well as the default values from teh DB table,
are copied to a branch under websites.

This happens once for each website in Magento.

To continue the previous example, assuming two websites with the codes base_website and wholesale_website exist in a shop, the DOM structure is extended in the following way:

<config>
	<websites>
		<base_websites>
			<contacts>
				<contacts>
					<enabled>1</enabled>
				</contacts>
			</contacts>
		</base_website>
		<wholesale_website>
			<contacts>
				<contacts>
					<enabled>1</enabled>
				</contacts>
			</contacts>
		</wholesale_website>
	</websties>
</config>

This is data dupication, in the works.

3. All websites scope records from the core_config_data table are merged into the config DOM, into each matching website branch.

4. All website scope DOM branches contain all settings from the default scope, which might have been changed or amended by the websites scope values from the DB.

5. all these values are copied into each store view scope under the stores branch of the config DOM, similar to the websites branch.

6. Every default setting now is present once under <default>, once for each website under <websites>, and once for each store under <stores>.

7. Finally, all the stores scope values from the core_config_data table are added to each matching stores branch of the config DOM.

8. In the end, each store branch contains a full set of configuration values that are valid for its scope, regardless which scope the setting was specified on.

These are the values that are accessed when getConfig() is called on a store model.

Please refer to Scoped Config Values section of the previous chapter for details.

It's good to remmber that most of the config merging is bypassed when the config cache is turned on.

That not only saves Magento to read and parse many XML files, but also MAgento will only load the 
config sections that are actually used, which reduces the memory footprint qutie a bit.

Configuration XML Load Order Summary:

The details can always be looked up in the core, but in many situations it is helpful to be aware of the
basic load order of all the parts that make up the config XML.

The load order is so import because:

Parts that are loaded later can overwrite node values from parts that were loaded earlier

Observers are processed in module load order

The processing order of layout XML instructions within one update handle are defined by module load order.

Module load order can help resolving rewrite conflicts.

Remember, the module load order can be influenced through module dependencies.

The load order of the different config parts is listed in the following table:

						Configuration load order
# 				Source 				Cached ? 				Mage_Core_Model_Config Method
1 app/etc/*.xml 					no 						loadBase() loadModules() delegates to

2 app/etc/modules/Mage_All.xml 		Yes 					_loadDeclaredModules()

3 app/etc/modules/Mage_*.xml 		Yes 					_loadDeclaredModules()

4 app/etc/modules/*.xml 			yes 					_loadDeclaredModules()

5 Module etc/config.xml files 		yes 					loadModules()

6 app/etc/local.xml 				yes 					loadModules() (again)

7 The core_config_data table 		yes 					loadDB() delegates to getResource()->loadToXml()

The Magento Dispatch Process overview:

So far this book covered the following aspects of the dispatch process:

Configuration loading(in this chapter)

The Front Controller(in the Redirect to / chapter)

The routing process (in the Custom frontend controller chapter)

One important part of the dispatch process that hasn't been covered yet, is the view layer (the V in the MVC).

The defailts of the rendering process will be discussed in detail in teh next book of this series: Rendering and Widgets.

Let's have a high level look at the main PHP classes used, so teh diagram for this exercise can be comppleted: the layout and the layout update models.

The Magento view layer usually is initialized when $this->loadLayout() is called from within the context of an action controller.

public function loadLayout($handles = null, $generateBlocks = true, $generateXml = true)
{
	// if handles were specified in arguments load them first
	if (false !== $handles && '' !== $handles) {
		$this-getLayout()->getUpdate()->addHandle($handles ? $handles : 'default');
	}
	//add defautl layout handles for this action
	$this->addActionLayoutHandles();
}

The layout object returned by $this->getLayout() is instansiated using Mage::getSingleton('core/layout').

The layout object's main responsibility is to manage the block class instances created for rendering.

The layout update model Mage_Core_Model_Layout_Update is responsible for loading the view configuration from the merged layout XML files.

to render the instansiated block classes, usually the method $this->renderLayout() is called from within an action controller.

The generated HTML output is then assigned to the response objects content body.

To see the details of this part of the dispatch process please refer to the core methods mentioned.

The final step in the dispatch process is handled by the Front Controller: it instructs the 
response object to send the response header and body to the browser.

$this->getResponse()->sendResponse();

Now that the most important parts of the Magento dispatch process have been discussed, its time to move on to the solution.

The Magento Dispatch Process:

The following, are the most important classes during the dispatch process:

Mage

Mage_Core_Model_App

Mage_Core_Model_Config

Mage_Core_Model_Resource_Setup

Varien_Db_Adapter_Pdo_MySql

Mage_Core_Model_Website

Mage_Core_Model_Store

Mage_Core_Controller_Request_Http

Mage_Core_Controller_Varien_Front

Mage_Core_Controller_Varien_Router_Standard (is actually, all routers)

Mage_Core_controller_Varien_Action (is actually teh concrete action controller handling the request)

Mage_Core_Model_Layout

Mage_Core_Model_Layout_Update

Mage_Core_Controller_Response_Http

Of course, there are many more classes involved while a request is being processed.

Some of them might arguably belong in the sequence displayed in the diagram (for example the session initialization)

However, in some cases the place where a class is used for the first time might vary depending on which page is requested, which modules are installed,
or how Magento is initialized.

A Senior Magento dev should know the classes listed above and the role they play during the dispatch process.

The ability to create a process diagram, as per the previous page, helps identify targets for customizations and for debugging.

The flow can be described as something as follows:

DIAGRAM

Request Object >>>>>>>>	Front Controller >>>>>>>>>>>>>>>>> Routers >>>>>>> Action Controller >>>>>>>> core layout update >>>>>>>> Response
						Collect Routers 					Dispatch 		 Initialize  				load updates
						Rewrite 											 add handles
						match()                                              render blocks 
						match or modify or pass                              send response
																			 set body & headers

Exercise: Store view selection priorities

The original task desc:

Magento can use several ways to specify the current store view for a given request. List the prio of all the different ways.

Overview:

This chapter discusses the following topics in the research section and the examination of the exercise solution:

The process how the current store view is determined

Multi-website, multi-domain setups

Admin store view selection

Scenario:

Whenever you need to set up a Magento instance with localized domains for more than one website or store view, it is helpful to know how the 
store view selection process works. It's also nessecary to be able to build customized store switchers.

Also it can assist in explaining some core behavior that might be considred a bug, and make it easier to create extensons that work well with multi-site instances.

Research:

To analyze the store view selection process, we need to start right at the beginning, right before Mage::run() is called in the index.php file:

/* Store or Website code */
$mageRunCode = isset($_SERVER['MAGE_RUN_CODE']) ? $_SERVER['MAGE_RUN_CODE'] : '';

/* Run store or run website
$mageRunType = isset($_SERVER['MAGE_RUN_TYPE']) ? $_SERVER['MAGE_RUN_TYPE'] : 'store';

Mage::run($mageRunCode, $mageRunType);

We get back to environmental vars later.
For now, all we need to know is that two arguments are passed to the run() method: the run code and the run type.

Let's have a look at what happens with those two args inside of Mage::run():

public static function run($code = '', $type = 'store', $options = array())
{
	try{
		self::$_app = new Mage_Core_Model_App();

		//... basic initialization occurrs here

		self::$_app->run(array(
			'scope_code' => $code,
			'scope_type' => $type,
			'options' 	 => $options,
		));

		// :.. cleanup and exception handling happens here .. 
	}
}

As you will have noticed, the code sample above is very abbreviated and only contains the code relevant to the current exercise.
The arguments passed to Mage::run() are passed on to Mage_Core_Model_App::run() as an array.

There, after the configuration is loaded, the arguments are extracted again and passed to _initCurrentStore() like this, as can be seen in the following code block:

public function run($params)
{
	//More app setup

	$this->_initModules();
	if ($this->_config->isLocalConfigLoaded()) {
		$scopeCode = isset($params['scope_code']) ? $params['scope_code'] : '';
		$scopeType = isset($params['scope_type']) ? $params['scope_type'] : 'store';
		$this->_initCurrentStore($scopeCode, $scopeType);

		// .. even more setup ..

		$this->getFrontController()->dispatch();
	}
}

Judging by the method name _initCurrentStore() it looks like we are finally getting to the code responsible for the store view selection.

protected function _initCurrentStore($scopeCode, $scopeType)
{
	$this->_initStores();

Well, almost. In order to understand the remainder of the _initCurrentStore() method, we first have to know what _initStores() does.

The main thing that happens in _initStores() is that the website, store group and store collections are loaded.

This is when the arrays are populated that are returned by Mage::app()->getStores() or Mage::app()->getWebsites()

Also, while iterating over the store collection, the default store is set to the first store with a "truthy" ID value, that is, the first Store that isn't the
admin store view (which always has the hardcoded store ID of 0)

	if (is_null($this->_store) && $store->getId()) { //if no store has been assigned to be the current one, and the store being iterated upon has a id, assign it to the dispatch
		$this->_store = $store;
	}

The same is done for the default website, only in this case it is a property of the core/website model that specifies which one is the default website.

	if ($website->getIsDefault()){
		$this->_website = $website;
	}

After the _initStores() method completes, any store or website can be fetched from the preloaded lists using Mage:app()->getStore($code) or Mage::app()->getWebsite($code)

At this time, the default store and website are set, but the current store - that is, the context for the current request, has not been determined yet.

Let's continue with the _initCurrentStore() method after $this->_initStores() was called:

protected function _initCurrentStore($scopeCode, $scopeType)
{
	$this->_initStores();

	if (empty($scopeCode) && !is_null($this->_website)){
		$scopeCode = $this->_website->getCode();
		$scopeType = 'website';
	}

	switch ($scopeType){
		case 'store':
			$this->_currentStore = $scopeCode;
			break;
		case 'group':
			$this->_currentStore = $this->_getStoreByGroup($scopeCode);
			break;
		case 'website':
			$this->_currentStore = $this->_getStoreByWebsite($scopeCode);
			break;
		default:
			$this->throwStoreException();
	}



The gist of it is that the current store is set according to the specified $scopeCode and $scopeType.

However, in an unmodified Magento installation, the $scopeCode will be set to an empty string, in which case the scope type and code are set to the default website.
Because of that, it will trigger the website in the switch case, and the current store will be put to the default websites default store.

At this point, if the scope code was empty, the current store is set to the default value.

if the scope code was set however, the specified store will be set as the current one for the request.

But the _initCurrentStore() method isn't complete yet:

	if (!empty($this->_currentStore)){
		$this->_checkCookieStore($scopeType);
		$this->_checkGetStore($scopeType);
	}
}

The two methods _checkCookieStore() and _checkGetStore() take care of setting the current store to something else then default, if the current requests says so.

First _checkCookieStore() checks for a cookie with the name store.
If it is set to a valid store code, $this->_currentStore is set to that value.

After that, _checkGetStore() checks if $_GET['___store'] is set to a valid store code. If yes, it replaces any previous value in $this->_currentStore.

The ___store query param is used by Magento store switcher to specify the target store view.

The _checkGetStore() method also contains some additonal logic to set the store cookie that was read earlier in _checkCookieStore():

	if ($store->getWebsite()->getDefaultStore()->getId() == $store->getId()) {
		$this->getCookie()->delete(Mage_Core_Model_Store::COOKIE_NAME);
	} else {
		$this->getCookie()->set(Mage_Core_Model_Store::COOKIE_NAME, $this->_currentStore, true);
	}

If the current store is the default store of the current website, the store cookie is deleted.

Otherwise, the store cookie is set to the current store's code.

Most of the time, this works as expected.
That is, it works as expected if the default store of the current website is the same that was specified as the default store for the current request using 
MAGE_RUN_CODE, or if the store cookie or query param was present.

However, if a different default store view was specified using the MAGE_RUN_CODE env variable, then unsetting the store cookie introduces a bug:

To reproduce this issue, a Magento instance with at least two store views is needed.

For example, let's assume there are two store vies with the codes english and french present.

Further, let's assume there is only a single website. this website's default store view is english.

If Mage::run('', 'store'); is called and no cookie or query param is present, the english store will be rendered.

Now, let's assume a env variable MAGE_RUN_CODE was set to french.

In this Magento will be initialized with the values Mage::run('french', 'store');

The store cookie will be set to the value french.

So far no problem, the french view will be displayed.

But let's play through what happens if the visitor now switches to the english store view.

The query parameter ___store=english will be appended to the request path by the store switcher.

The english store will be displayed, despite MAGE_RUN_CODE being set to french, as it should.

But because the current store now matches the website default store, the store cookie is now removed.

if the visitor now clicks on any link, the request will no longer contain the ___store=english query param, and the value from
the MAGE_RUN_CODE env variable will be used again, switching the current store back to french.

One way to fix that behavior is to not compare the current store with the websites default store, but instead compare the current store
with the store specified by MAGE_RUN_CODE.

A alternative fix would be to always set the store cookie, regardless if it is the default store view or not.

The latter fix is easy to implement, for example using an observer for the controller_front_init_before event.
The former fix, however, requires a change to the Mage_Core_Model_App code code.

Summary of the core/app store view selection:

The following store view selection priorities have become apparent from the code discused so far in this chapter:

1. If the __store query param is set, it will override any other method of setting the current store.

2. Otherwise, if present, the store cookie value is used.

3. If neither query param nor cookie is present, the value of the MAGE_RUN_CODE env var is used to specify the current store.

4. The default store view of the default website is used.

However, the list is not complete yet.

The Store Code in URL setting:

There is one system config option which also influences the current store view selection.
It can be found under System > Config > Web > Url Options > Add Store Code to Urls.

The XML config path for that setting is web/url/use_store.

If set to Yes, all Links will be rendered with the store code directly after the base URL.

For example, assuming the current store code is en and the base URL is http://mage.example.com/, then the login
page route would be http://mage.example.com/en/customer/account/login.

By changing the store code in the request path, the current store view is changed.

Since we haven't encountered this setting while going through the store view selection process within 
the core/app code, the question arises where this setting is applied.

The answer can be found during the initialization of the request object Mage_Core_Controller_Request_Http.
The request object is initialized in Mage_Core_Model_App::run().

Right after the code we have discussed so far, after the stores array and the current store are set, $this->_initRequest() is called.

The only thing this method call does is to call $this->getRequest()->setPathInfo() on the request object.

The purpose of the setPathInfo() method is to analyze the current request and extract the request path, so it is available during the routing process.
In that method, we can find the following code:


	if($this->_canBeStoreCodeInUrl()){ //If the request object can be storeCode in URL
		$pathParts = explode('/', ltrim($pathInfo, '/'), 2); //explode the path and trim the / off
		$storeCode = $pathParts[0]; //assign the storecode to be the first part of the array

		if(!$this->isDirectAccessFrontendName($storeCode)){ //if the request is not a directaccessfrontend name
			$stores = Mage::app()->getStores(true, true); //get the stores
			if ($storeCode !== '' && isset($stores[$storeCode])){ //if storeCode is not empty and the storeCode is set in stores
				Mage::app()->setCurrentStore($storeCode); //set the current store to the store code
				$pathInfo = '/'.(isset($pathParts[1]) ? $pathParts[1] : ''); //if the pathparts 1 is set, return that, otherwise, return a empty string
			}
			elseif ($storeCode !== ''){ //otherwise, its not set, meaning there is no route to it
				$this->setActionName('noRoute'); //Set the action of that there is no route to it
			}
		}
	}

The outermost if branch checks if the store-code-in-url feature is enabled.

If yes, then the first part of the request path is split from the right, right inside the outer if condition.

If the first part is not listed in the config under global/request/direct_front_name in the config (the second if branch),
and it is a valid store code, then the first part of the request is set as the current store code.

From an architechtural point of view, setting the current store view from within the request object breaks the principle
of the single responsibility.

However, since the code is processed after the core/app store view processing takes place, it overrides all previous 
methods of setting the current store view.

Setting MAGE_RUN_CODE and MAGE_RUN_TYPE:

As discussed earlier, the env var MAGE_RUN_CODE and MAGE_RUN_TYPE can be used to specify the default store view to show a visitor.

This enables us to easily set up Magento instance with more than one domain.

The feature can be used to have localized domainds for different store views within one single website.

it can also be used to configure Magento to serve completely different websites for different domains, without the visitor knowing
that it's a single Magento instance on the backend.

here is the code from the index.php file again:

/* Store or website code */
$mageRunCode = isset($_SERVER['MAGE_RUN_CODE']) ? $_SERVER['MAGE_RUN_CODE'] : '';

/* Run store or run website */
$mageRunType = isset($_SERVER['MAGE_RUN_TYPE']) ? $_SERVER['MAGE_RUNT_TYPE'] : 'store';

Mage::run($mageRunCode, $mageRunType);

As the comments in the code tell us, the run code specifies a store or website code, and the run type has to be set to either 
website or store, depending on what we used to run the code.

Since env var are used to specify the values, no Magento files need to be modified - not even the index.php file.

The idea is that the var are set on a webserver level, ideally within the virtual host config.

Since most Magento instances are served on Apache, what follows is an example of how the env var may be set:

# Match www.example.com or example.com
SetEnvIf Host ^ (wwww|)\.example.com$ MAGE_RUN_CODE=us

# Match any domain ending with example.co.uk
SetEnvIf Host \.example\.co\.uk$ MAGE_RUN_CODE=en

Depending on the requested host name, the env var is set to a different value.

For futher info on the SetEnv and related config dirs, please refer to the apache documentation.

Still a number of tutorials can be found with instructions to set up a multi-website Magento instance using
subdirs and symlinks.

However, just setting the env vars is a much easier way to configure a multi-domain setup.

The specific domain names also need to be configed in the system config within the matching store
or website scope under the System > Config > Web > Unsecure > Base URL and Web > Secure > Base URL

The Base URL config value is used to render the correct domain name for links on the website.

Of course the MAGE_RUN_CODE and MAGE_RUN_TYPE vars can be set based on different criteria 
then the requested domain, too.

A popular chose is to use a geo-ip lookup service to determine the country a visitor is physically
located in and then display the appropiate website.

Another often-used criterion is to read the browser's Accept-Language HTTP request header to 
find the best matching store view.

But since the env var have to be set before Magento is initialized, this provides us with a little challenge.

If they can be set on the webserver level - like when matching the requested domain name - it's no problem.

However, conditions like checking more complex HTTP headers or geo-ip lookups are more difficult to setup, since more logic goes into it.

The quick and dirty solution would be to introduce a core code hack by adding the required PHP to the index.php file before Mage::run() ios called.

Changing core code however, always impacts Magento when it comes time to upgrade.

For that reason, a more elegant solution is to either implement the logic as a custom Apache module, or to use PHP config setting auto_prepend_file to always
include the code before the index.php file is executed.

Trivia:

When switching between store views using the built-in Magento store switcher, the ___store query param is used to
specify the new store view to display.

if the store-code-in-url feature is enabled, the ___store query arg is not appended, since the store code
already is part of the request path.

Under both circumstances however, Magento also adds the additonal query param ___from_store with the value of the previous store code.

Since on first glance it doesn't seem to serve any purpose, it is a very common customization to remove it from the store switcher target URLS.

So, why is it added then, if it does nothing?

The ___from_store query param is actually used in the method Mage_Core_Model_Url_Rewrite::rewrite() to check if there is a record matching the current
request path for the previous store.

If it does find a match, the visitor redirected to the new store view's SEO Friendly URL for that page.

This enables Magento to use localized SEO URLs.

For example, a product's url_key attribute might be set to designer-chair in the english store scope, and to chaise-design in the french store scope.

When switching from the english store scope to the french store scope, the URL /designer-chair.html?___store=frenche____from_store=english is requested.

Because of the ___store request param, the current store is set to french.

During request rewrite phase, Magento first checks if it finds a matchin rewrite for the designer-chair.html for the french store view.

Since it doesn't find a match, it falls back to the ___from_store value's store view, english. now it finds a match for designer-chair.html, and also
finds that the correct SEO URL for the current french store view is chaise-design.html

But instead of directly serving the requested page content, the visitor is redirected to the SEO URL/chaise-design.html, so he will 
see the correct localized request path in the browser, without the ugly query params anymore.

The french store view still is set as the current store view, because it was set as the store cookie value.

The following isn't interesting in regarding to becoming certified, however, it might be useful while doing project work:

In Magento 1.8 a bug was introduced that breaks this feature. 
In the new class Mage_Core_Model_Url_Rewrite_Request, the method _rewritedb() tries to match the ___from_store query param value -
a store code - against a numeric list of store IDs.

Hopefully it will be fixed again, soon. Until then, we fix it ourselves or use a pre-written extension like VinaiKopp_StoreUrlRewrites.

The Admin store View:

There is one special case in regards to store views, and that is the admin interface.

The Adminhtml area is treated like the frontend store views.
It has a hardcoded store code and ID, which can be found in the class constants Mage_Core_Model_Store::ADMIN_CODE and Mage_Core_Model_App::ADMIN_STORE_ID with the values
admin and 0 respectively.

When the Adminhtml interface is accessed, the current store view is set in a different way.

All backend pages are served by action controllers extending the class Mage_Adminhtml_Controller_Action, which in turn extends
from the Mage_Core_Controller_Varien_Action.

Amongst other things, the admin page controller implements the method preDispatch(), where an event is triggered:

Mage::dispatchEvent('adminhtml_controller_action_predispatch_start', array());

the Mage_Adminhtml module declares an event observer for this event, more specifically
the method bindStore() of the class adminhtml/observer.

The method is very simple. Its only responsibility is to set the current store view to admin.

public function bindStore()
{
	Mage::app()->setCurrentStore('admin');
}

To summarize, whenever an Adminhtml page is accessed, first the regular store selection process takes place.
Then the Admin router matches the request and dispatches the aciton controller.

The action controller then dispatches the adminhtml_controller_action_predispatch_start event, and the
configured observer overwrites the previous value for the current store with admin.

Admin Store View Selection

Mage Adminhtml Controller Action 														Mage Core Model App 	Mage Adminhtml Model Observer
				v 																				v 							v
				v dispatchEvent('adminhtml controller action predispatch start') 	 			v 							v
				>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>v 							v
				v																				v 			bindStore() 	v
				v																				v>>>>>>>>>>>>>>>>>>>>>>>>>>>v
			  - II - 																			V setCurrentStore('admin')  v
			  																					V<<<<<<<<<<<<<<<<<<<<<<<<<<<<
			  																				Mage Core Model App 		Mage Adminhtml Model Observer

Solution:

After all the research, the solution is rather straight forward.

Summary of all store view selection methods:

The lower the number in the left column, the higher the prio.

					List of Store View selection methods sorted by Prio
# 			Type 									Class and Method
1.Admin area store view 					Mage_Adminhtml_Model_Observer::bindStore()
2.store code in URL (if enabled) 			Mage_Core_Controller_Request_Http::setPathInfo()
3.___store query param 						Mage_Core_Model_App::_checkGetStore()
4.store cookie 								Mage_Core_Model_App::_checkCookieStore()
5.MAGE_RUN_CODE env variable 				Mage_Core_Model_App::_initCurrentStore()
6.Default store of default website 			Mage_Core_Model_App::_initCurrentStore()

Since there is no code to be discussed here, that completes the chapter.

Trivia:

The only reason to unset the store cookie, is that it might take config of a reverse proxy like varnish a little easier.
Saving bandwidth by removing a few bytes from a HTTP header certainly doesn't qualify as a reason, given todays capcity.

The global/request/direct_front_name node lists special front names which are always accessible without the store code, even if the store-code-in-url feature is
enabled. In a native Magento installation it only contains the api and xmlconnect front names.

The option to specify the default store view using env vars was introduced in Magento 1.4

To enable store view scope url_key attribute values for products, teh Attribute Management page in the
Magento backend can be used to change the scope of the attribute.

For catagories, it is also possible, however, the attribute value scope has to be set using a 
setup script, since the admin interface doesn't allow editing category attribute props.
More details on EAV attrs scopes and how to change them will be covered in the fourth book of the series.


Addendum:

varien_Object Magic Setters and Getters:

The Varien_Object class is so basic, we originally decided that understanding the class would be amongst the pre-reqs for this book.

However, for sake of completeness, we add some of the stuff relevant.

All block classes and every model extending Mage_Core_Model_Abstract extend from Varien_Object. Often it is used directly, too, as a container object.

The most prominent features of Varien_Object are its magic setter and getter implementations.

Through the catch-all method ___call() impl., every object inheriting from this class has instant setters and getters.

setData and getData relegate through ___call() and _underscore().

getData methods, however, also allows for direct access to sub-array records directly.

This handy feature is not know nearly as well as the simple getter and setter methods.

For example, a simple use case of a magic setter and getter would be:

$obj->setBackgroundColor('magenta');

The equivilant setData call looks like this:

$obj->setData('background_color', 'magenta');

To get thevalue, we could use either of the ofllowing:

$obj->getBackgroundColor();
$obj->getData('background_color');

Now assume the following setter call is made on a Varien_Object:

$obj->setColor(array(
		'background' => 'magenta',
		'foreground' => 'lightcyan'
));

Let's look at some ways to retrieve the background color again in this case.

The obvious way would be the regular getter methods, returning the array, which then needs to be dereferenced using the correct key.

$obj->getColor()['background'];
$obj->getData('color')['background'];

However, the getData() method allows to specify child array records directly:

$obj->getColor('background');
$obj->getData('color/background');

If the sub array is nested deeper than one level, the method getData() has to be used directly.
The magic getter only allows access to the first nesting level.

$obj->setColor(array(
	'light' => array(
		'background' => 'lightcyan',
		'foreground' => 'orange',
	),
	'dark' => array(
		'background' => 'cyan',
		'foreground' => 'red',
	)
));

$obj->getData('color/light/foreground');

Using getColor('light/foreground') would return null in this case, cause it only allows for 1 level depth access.

Even though Varien_Object contains many other useful methods, this concludes this section of the book. If you have never 
done so, it is highly recommended you take the time to read through the available methods.

Class Name Resolution:

Class instansiation using the Magento factory methods is difficult to debug.

To debug them, we just gotta follow the class instansiation of Magento.

The steps Magento uses for class instansiton for models, helpers, and blocks are exactly the same.
For resource models there are two additional steps involved.

Magento uses XPaths during class resolution.

In the following example, example/thing will be used.
It is split by Magento to a "class group" example and a part-after-the-slash "thing".

All of the following class name resolution steps areh andled inside the Mage_Core_Model_Config.

Model instansiation Steps:

The following steps are used whenever a factory name is passed to one of the following factory methods (that is the class name is specified using the Magento notation with a /):

Mage::getModel()
Mage::getSingleton()
Mage::helper()
Mage::app()->getLayout()->createBlock()

1. Factory method call, example given Mage::getModel('example/thing')
2. The factory name is example/thing
3. split into class group example and the class suffix thing
4. Config XPath lookup: global/models/example/rewrite/thing
5. if exists, use a class name, if not, continue.
6. Config Xpath lookup: global/models/example/class
7. If exists, resolves to model class prefix, example given This_Example_Model
8. Otherwise build class prefix as 'Mage_' . 'example' . '_Model_' . 'thing'
9. Append the class suffix, that is, the part of the factory name after the slash
10. Resolve to This_Example_Model_Thing
11. Trigger autoloader if class is not known to PHP
12. Resolves to file system path This/Example/Model/Resource/Thing.php
13. Include this file and instansiate the class

The most common mistake is that step 6 fails, that is, Magento is unable to resolve the class group to a class prefix.
The best method to starte debugging instansiation within the core/config instance is Mage_Core_Model_Config::getGroupedClassName().

Resource Model instansiation Steps:

The following steps are used when instansiating resource models or collections.

That is, any class instansiated using Mage::getResourceModel() or Mage::getResourceSingleton() will use the following steps during class
resolution (if a factory name containing a / is used to specify the class).

1. call to factory method, example given Mage::getResourceModel('example/thing')
2. The factory name is example/thing
3. Split into class group example and the class suffix thing
4. Config XPath lookup: global/models/example/resourceModel
5. Resolves to the resource class group, for example example_resource.
6. Config XPath lookup: global/models/example_resource/rewrite/thing
7. If exists, use a class name; if not, continue.
8. Config XPath lookup: global/models/example_resource/deprecatedNode
9. Resolves to former (pre Magento 1.6) resource class group, example given example_mysql4
10. If it exists, config XPath lookup: global/models/example_mysql4/rewrite/thing
11. If exists, use a class name, if not, Continue
12. Config XPath lookup: global/models/example_resource/class
13. If exists, resolves to resource class prefix, example given This_Example_Model_Resource
14. Otherwise build resource class prefix as 'Mage_' . 'example_resource' . '_Model_' . 'thing'
15. Append the class suffix, that is, the part of the factory name after the slash
16. Resolve to This_Example_Model_Resource_Thing
17. Trigger autoloader if class is not known to PHP
18. Resolve to file system path This/Example/Model/Resource/Thing.php
19. Include this file and instansiate the class

The purpose of the step 8 is for backwards compability

The best method to start debugging resource model instansiation within the core/config instance is
Mage_Core_Model_Config::getResourceModelClassName()