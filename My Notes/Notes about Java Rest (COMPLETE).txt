The set of the architectual principles is called REpresentational State Transfer.
A.K.A REST.

It is defined by:

Addressable resources:

The key abstraction of information and data in REST is a resource,
and each resource must be Addressable via a URI.

A uniform, constrained interface:

A small set of well-defined methods to manipulate resources

Representation-oriented:

You interact with services using representations of that service.
A resource referenced by one URI can have different formats.

Different platforms need different formats. Browsers need HTML, JS needs JSON
and Java may need xml.

Communicate statelessly:

Stateless apps are easier to scale.

Hypermedia As The Engine of Application State (HATEOAS):

Let your data formats drive state transitions in your apps.

REST and the Rebirth of HTTP:

Rest isn't bound by protocol, but most delegate it to mean REST over HTTP.
Non-Rest techs such as SOAP and WS-* use HTTP strictly as a transport protocol,
and thus use a small part of it's capacity.

Some say that SOAP and WS-* only use HTTP to tunnel through firewalls.

HTTP is a Synch request/response-based application network protocol used for
distributed, collaborative, document-based systems. This does not exclude the capacity
of using HTTP in asynch structure.

The protocol is as follows:

Send a request message made up of the HTTP method being invoked, the location
of the resource you are interested in invoking, a variable set of headers,
and a optional message body that can be HTML, text, XML, JSON, or binary data.

An example:

GET /resteasy HTTP/1.1
Host: jboss.org //These variables are message headers
User-Agent: Mozilla/5.0
Accept: text/html, application/xhtml+xml, application/xml; q=0.9, */*; q=0.8
Accept-Language: en-us, en;q=0.5
Accept-Encoding: gzip, deflate

This is a get request towards jboss.org/resteasy

There is no request body here, because we are querying for info in a GET request.

An example of a Server response:

HTTP/1.1 200 OK
X-Powered-By Servlet 2.4; JBoss-4.2.2.GA
Content-Type: text/html

<head>
<title>JBoss RESTEasy Project</title>
</head>
<body>
<h1>JBoss RESTEasy</h1>
<p>//stuff</p>

RESTful Architechtural Principles:

We can use REST to build distirbuted services and model service-oriented architechtures (SOAs).

SOA is the idea of app devs designing their systems to be reusable, decoupled, distributed services.

Nowdays, SOA is related to SOAP-based web services.

Addressability:

Resources should be reachable through a unique identifier. We use URIs to refer to resources in REST.
The general structure of the URI:

scheme://host:port/path?queryString#fragment

The ? acts as seperator for each part.

Scheme is the protocol, host and port is the addressing, path is the path to the file.
The query part is a query, and has the & char as delimeter.

The fragment is delimeted by #, and used to point to a specific part in the document we are 
pointing to.

Space is converted to + in URIs.

The chars are converted into sequence of bytes using a specific encoding scheme.
A two-digit hexadecimal number prefixed by % represents each byte.

Using a unique URI to idenfity each of your services makes each of your
resources linkable.

Using the link to the resources, you can identify issues by replicating them and
the data that the services publish can also be composed into larger data streams.

An example of an ecommerce order entry in XML:

<order id="111">
	<customer>http://customers.myintranet.com/customers/32133</customer>
	<order-entries>
		<order-entry>
			<quantity>5</quantity>
			<product>http://products.myintranet.com/products/111</product>
...

The uniform, constrained interface:

We use the uniform operations of HTTP to interact. GET, PUT, DELETE, POST, HEAD, OPTIONS, TRACE, CONNECT etc.

Quick refresher:

GET:

Gets data. Non-mutating. Non-mutating against state. Only load is request itself.
idempotent (> 1 run does not change underlying structure past first change).
safe (Does not change structure at all).

PUT:

Stores or updates a given document under the location provided in the HTTP message.
It is idempotent. Meaning that no matter how many times you run it, it will remain
the same after the first time.

DELETE: 

Idempotent. (Delete first item with specific format, leaves server in the same state).
Deletes an item.

POST:

nonidempotent and unsafe. Modifies the server. May or may not send info with the request.
May or may not receive info from the response.

HEAD:

Like a get. But returns response code and headers associated with it. No response body.

OPTIONS:

Retrieves available options against the server.

Why is the Uniform Interface Important?:

Familiarity:

Knowing the extent of methods available on that resource.

Interoperability:

Requires no vendors. Has little requirements around it.

Scalability:

Caching allows high speed. We can define our Caches a lot.

PUT and DELETE are idempotent, meaning no message duplication.

Representation-Oriented:

Focuses on representational state. GET gets the representational state of the data.
PUT or POST posts a representation of the data, so the underlying resource can change.

Representations can be XML, JSON, YAML or whatever.

MIME (multipurpose internet mail extension) format, is the different formats
HTTP message bodies can be represented in.

Such as:

text/plain
text/html

application/xml

etc.

The typing is <main format family>/<category>

Basically because so little changes in ways of HTTP (the MIME), and you can address
so many formats in such a wide way, leads to it being a decoupled protocol.

Communicate Statelessly:

No session data is inheritly saved in REST. To have sessions, use requests to send
them and use them from the client.

Allows for greater scaling, does not force server to replicate sessions as numbers go up.

HATEOAS:

use Hypermedia as the engine of application state.

Hypermedia is a document-centric approach with added support
for embedding links to other services and info. Like HTML.

It simply allows for more info by embedding links.

Engine of application state:

Gives you direction and referal to new place of propogating server state.
Like pagination of products. Produce 5 at a time and a "Next page" link.

Example of this XML structure:

<products>
	<link rel="previous" href="http://example.com/store/products?startIndex=0"/>
	<link rel="next" href="http://example.com/webstore/products?startIndex=10"/>
	<product id="128">
		<name>stuff</name>
		<price>$16.99</price>
	</product>
...
</products>

Desining RESTful Services:

Model the URIs:

Enpoints in URIs are resource points where we can aquire the resources:

/orders

/orders/{id}

/products

/products/{id}

/customers

/customers/{id}

Defining the Data Format:

We decide on a format. XML, JSON or whatever. (JSON is good for JS, more condense than XML and instantly understandable by JS.  and Ajax. There are other formats as well.)

Read and Update Format:

Common Link Element:

<link rel="self" href="http://example.com/..."/>

The details:

Basically we define a object oriented structure in XML to represent all attributes and values.


<customer id="117">
	<link rel="self" href="http://example.com/customers/117"/>
	<first-name>Bill</first-name>
	//etc.
</customer>

Etc.

Another example:

<order id="123">
	<link rel="self" href="http://example.com/orders/233"/>
	<total>$199.02</total>
	<date>December 22, 2008 06:56</date>
	<customer id="117">
		<link rel="self" href="http://example.com/customers/117"/>
		//attributes
	</customer>
	<line-items>
		<line-item id="144">
			<product id="543">
				<link rel="self" href="http://example.com/products/543"/>
				//attributes
			</product>
			<quantity>1</quantity>
		</line-item>
	</lime-items>
</order>

Create Format:

When creating new ones, we don't have the link or id. The Server generates 
the URI for us, DB does the id etc. So, we just do a basic mashup for creating:

<product>
	<name>iPhone</name>
	<cost>$199.99</cost>
</product>

Assigning HTTP methods:

Browsing All Orders, Customer or Products:

A simple Get query (for all elements of that kind):

GET /products HTTP/1.1

Response will be

HTTP/1.1 200 OK
Content-Type: application/xml

<products>
	<product id="111">
		<link rel self="http://example.com/products/111"/>
		//attributes
	</product>
</products>

to mitigate, involve queries:

GET /orders?startIndex=0&size=5 HTTP/1.1 //Get 5 orders from starting index 0

Obtaining Individual Stuff:

Since our format is : /orders/{id}

We can simply:

GET /orders/{id} HTTP/1.1 //Example: GET /orders/233 HTTP/1.1

Will give:

HTTP/1.1 200 OK
Content-Type: application/xml

<order id="233">...</order>

Creating an Order, Customer or Product:

We can create by PUT or POST.

Creating with PUT:

An example of using PUT to create:

PUT /orders/233 HTTP/1.1 

Creating with POST:

Post requries the XML structure to create stuff and the response message tells of 
the ID etc.

POST /orders HTTP/1.1
Content-Type: application/xml

<order>
	<total>$199.02</total>
	<date>December 22, 2008 06:56</date>
</order>

The server creates a DB entry with a new ID (assuming we defined our servlet to do so)

The response:

HTTP/1.1 201 Created
Content-Type: application/xml
Location: http://example.com/orders/233

<order id="233">
	<link rel="self" href="http://example.com/orders/233"/>
	//attributes
</order>

HTTP requries that if a new resource was made, a repsonse code is 201 created.

A important part of REST is adhering to the structure. Cause the methods
have a very precise way of interacting, straying away from thoose can make assumptions
that breaks stuff.

Updating an Order, Customer or Product:

PUT /orders/233 HTTP/1.1
Content-Type: application/xml

<product id="111">
	//attributes
</product>

We could update with POSt as well, but that causes duplication response handling.

Removing an Item:

Just run DELETE on the exact URI

DELETE /orders/233 HTTP/1.1 

For instance

Cancelling an Order:

We can overload DELETE with a query param:

DELETE /orders/233?cancel=true

However, we shouldn't. cause adhering to REST.

Just change the data structure of the XML to add one more attribute:

<order id="233">
	//attributes
	<cancelled>false</cancelled>
</order>


We can use PUT for it, tho:

PUT /orders/233 HTTP/1.1
Content-Type: application/xml

<order id="233">
	<total>$199.02</total>
	<date>//stuff</date>
	<cancelled>true</cancelled>
</order>

What if we want to mass remove? We just define it as a new resource and trigger that action on that one:

POST /orders/purge HTTP/1.1

It is now a URI. It is a resource. We can thus make it react to different things in different ways.

Your First JAX-RS Service:

JAX-RS is a framework for applying URI pattern and HTTP operatons to individual
methods of your java class. It has parameter injection annotatison so that you can
easily pull in info from the HTTP request.

It has getters and setters for body. It has exception-mappers (map exceptions to HTTP responses),
and it has HTTP content negotiation.

Developing a JAX-RS RESTful Service:

We are goign to make a JAX-RS Service that allows read, create and update customers.

Two classes are needed. Customer and the JAX-RS service.

Customer Class is just a standard Customer class with attributes and setters/getters.

The only thing is the package:

package com.restfully.shop.domain;

In Java Enterprise app, the Customer class would usually be a Java Persistence API (JPA)
Entity bean and would be used to interact with a relational DB.

It could be annotated with JAXB annotations that allow to map JAVA classes directly to
XML. later on, we'll see how JAXB can be used with JAX-RS to translate between
XML and Objects.

Later we will see JAX-RS in Java EE and JPA.

CustomerResource: Our JAX-RS Service

JAX-RS binds HTTP requests to Java objects.

We could either make the JAX-RS work on per request basis on a Singleton format,
where all request the same thing. Or we could make it per request, to make the 
Resource pend from DB per request. Making a object per request.

Anyhow, the following is the customerResource:

package com.restfully.shop.services;

import ...; //omitted?

@Path("/customers") //Designated path in terms of REST format and designated that it's a JAX-RS 
public class CustomerResource{
	private Map<Integer, Customer> customerDB = new ConcurrentHashMap<Integer, Customer>();

	private AtomicInteger idCounter = new AtomicInteger();


}

NOTE: THe path notation is really a @javax.ws.rs.Path annotation


The concurrentHashMap is for multithreading and mapping of integer to Customer (ID),
the AtomicINteger is just for a unique number.

Creating Customers:

@POST //Binds it to post requests, this and the Path notation binds this method to the /customers part
@Consumes("application/xml") //accepts XML
public Response createCustomer(InputStream is){
	Customer customer = readCustomer(is);
	customer.setId(idCounter.incrementAndGet());
	customerDB.put(customer.getId(), customer);
	System.out.println("Created customer " + customer.getId());

	return Response.created(URI.create("/customers/" + customer.getId())).build(); //make a created response with
	//the absolute path of the created resource
}

The only in param that is allowed in JAX-RS that is not something to do with JAX-RS, is http request bodies.
For this, we use a InputStream. 

Retrieving Customers:

@GET //Binds gets here
@Path("{id}") //The path 
@Produces("application/xml") //What it produces
public StreamingOutput getCustomer(@PathParam("id") int id){ //inparam is the ID from the rest path
	final Customer customer = customerDB.get(id); //get the id from the DB
	if (customer == null){ //if the customer does not exist
		throw new WebApplicationException(Response.Status.NOT_FOUND); //Throw a Response status of not found
	}
	return new StreamingOutput(){ //return a streaming output
		public void write(OutputStream outputStream) //Write the outpustream
						throws IOException, WebApplicationException{
			outputCustomer(outputStream, customer); //write hte outputstream with the customer object
		}
	};
}

When we write responses manually, we must define a interface of the javax.ws.rs.core:

package javax.ws.rs.core;

public interface StreamingOutput{
	public void write(OutputStream os) throws IOException, WebApplicationException;
}

NOTE TO SELF: The examples in this book are kind of shit. Presumes methods that are not explicitly stated
etc.

Updating a Customer:

@PUT //Bind put to this
@Path("{id}") //The path is the customers/id. If there is a earlier path and we simply do like this, it's a relative path that builds on the previous notation of which we set.
@Consumes("application/xml")
public void updateCustomer(@PathParam("id") int id, InputStream is){
	Customer update = readCustomer(is);

	Customer current = customerDB.get(id);
	if(current == null)
		throw new WebApplicationException(Response.Status.NOT_FOUND);

	//Set attributes of by getting values from the update object, which we read from the inputstream
	//For example:

	current.<setSomething>(update.<getSomething>());
}

Utility Methods:

A method to convert the customer stuff to XML:

protected void outputCustomer(OutputStream os, Customer cust) throws IOException{
	PrintStream writer = new PrintStream(os);
	writer.println("customer id=\"" + cust.getId() + "\">");
	//etc.

	//basically we just give in a output stream, spawn a printstream from it, which is bound to it,
	//And then write to it from the customer object
}

To read customer, we use a inputstream and iterate over the nodes:

procted Customer readCustomer(InputStream is){
	try{
		DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();

		Document doc = builder.parse(is);
		Element root = doc.getDocumentElement();

		Customer cust = new Customer();

		if(root.getAttribute("id") != null && !root.getAttribute("id").trim().equals("")){
			cust.setId(Integer.valueOf(root.getAttribute("id")));
		}

		NodeList nodes = root.getChildNodes();
		for (int i = 0; i < nodes.getLength(); i ++){
			Element element = (Element) nodes.item(i);

			if(element.getTagName().equals("first-name")){
				cust.setFirstName(element.getTextContent());
			}
			//The rest is just checks against the other values and setters with TextContent
		}
		return cust;
	} catch (Exception e){
		throw new WebApplicationExcetpion(e, Response.Status.BAD_REQUEST);
	}
}

Later on, we will use JAXB to map our Customer object to XML and have JAX-RS automatically
transform the HTTP message body to and from XML.

JAX-RS and Java Interfaces:

We can also convert the interactions to a interface:

package com.restfully.shop.services;

import ...;

@Path("/customers")
public interface CustomerResource{
	@POST
	@Consumes("application/xml")
	public Response createCustomer(InputStream is);

	@GET
	@Path("{id}")
	@Produces("application/xml")
	public StreamingOutput getCustomer(@PathParam("id") int id);

	@PUT
	@Path("{id}")
	@Consumes("application/xml")
	public void updateCustomer(@PathParam("id") int id, InputStream is);
}

Then just implement the interface

package com.restfully.shop.services;

import ...;

public class CustomerResourceService implements CustomerResource{
	
	public Response createCustomer(InputStream is){
		//The implementation
	}

	public StreamingOutput getCustomer(int id){
		//implementation
	}

	public void updateCustomer(int id, InputStream is){
		//implementation
	}
}

To override the JAX-RS parent components, just put in teh annotations in the class implementing the interface:

public class CustomerResourceService implements CustomerResource{
	
	@POST
	@Consumes("application/xml;charset=utf-8")
	public Response createCustomer(InputStream is){
		//the implementation
	}
}

Inheritance:

We can inherit things with JAX-RS. Just put the @Path("<path>") notation in the inerhtied class.

Example:

//package and import

public abstract class AbstractCustomerResource{
	
	@POST
	@Consumes("application/xml")
	public Response createCustomer(InputStream is){
		//Code
	}

	@GET
	@Path("{id}")
	@Produces("application/xml")
	public StreamingOutput getCustomer(@PathParam("id") int id){
		//Code
	}

	@PUT
	@Path("{id}")
	@Consumes("application/xml")
	public void updateCustomer(@PathParam("id") int id, InputStream is){
		//code
	}

	abstract protected void outputCustomer(OutputStream os, Customer cust) throws IOException;

	abstract protected Customer readCustomer(InputStream is);
}

To inherit it, just place @Path notation to denote JAX-RS relation:

//package and import

@Path("/customers")
public class CustomerResource extends AbstractCustomerResource{
	protected void outputCustomer(OutputStream os, Customer cust) 
		throws IOException{
		//code
	}

	protected Customer readCustomer(InputStream is){
		//Code
	}
}

Deploying our Service:

It is easiest to deploy JAX-RS with a Java EE-certified application server (JBoss)
or standalone Servlet 3 container (Tomcat)

Before this, we must write one class that denotes components to register:

package javax.ws.rs.core;

//imports

public abstract class Application{
	private static final Set<Object> emptySet = Collection.emptySet();

	public abstract Set<Class<?>> getClasses();

	public Set<Object> getSingletons(){
		return emptySet;
	}
}

getClasses() returns a list of JAX-RS service classes (and providers).

All of the services provided this way are built on a per-request model.

The getSingletons() returns a list of JAX-RS service objects (and providers).
We create and initialize the objects.

An example of telling JAX-RS vendor which services you want deployed:

package com.restfully.shop.services;

import javax.ws.rs.ApplicationPath; //Relative base URL path for all JAX-RS services in the deployment
import javax.ws.rs.core.Application;
import java.util.HashSet;
import java.util.Set;

@ApplicationPath("/services") //all JAX-RS RESTful services are prefixed with /services path when we execute on them
public class ShoppingApplication extends Application {
	private Set<Object> singletons = new HashSet<Object>();
	private set<Class<?>> empty = new HashSet<Class<?>>();

	public ShoppingApplication(){
		singletons.add(new CustomerResource());
	}

	@Override
	public Set<Class<?>> getClasses(){
		return empty;
	}

	@Override
	public Set<Object> getSingletons(){
		return singletons;
	}
}

In Java EE and standlone servlet deployments, JAX-RS classes must be 
deployed within the app server's servlet container as a Web Archie (WAR).

A servlet acts as a server's web server. A WAR is a JAR file that, contains
other content as well for the actual website, like HTML, JSPs etc. along with Java libs.

The structure of a WAR file is as follows:

<any static content> //images, HTML, etc.
WEB-INF/
		web.xml
		classes/  //Where we can place our Java classes
				com/restfully/shop/domain
										Customer.class
				com/restfully/shop/services/
											CustomerResource.class
											ShoppingApplication.class
		lib/

If we had third lib party dependancies, we have to put them in lib/ , but ours don't. So.
If the Server does not provide support for JAX-RS tho, we have to put the vendor implication
in the lib/

Next up, we just create the WEB-INF/web.xml file in our archive:

<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://java.sun.com/xml/ns/javaee"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
							http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
		version="3.0">
</web-app>

Since it deploys with java EE or a Standalone servlet 3.x container, all we need
is a empty web.xml file. It will detect that the application class is within
our WAR and deploy it. That's why we import the Application class.

Writing a Client:

If you need to interact with a remote RESTful service like we just created,
you can use the JAX-RS 2.0 Client API. The Client Interface is responsible
for managing client HTTP connections.

An example:

import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.client.Client;
import javax.ws.rs.client.Entity;
import javax.ws.rs.core.Response;

public class MyClient{
	public static void main(String[] args) throws Exception{
		Client client = ClientBuilder.newClient();
		try{
			System.out.println("*** Create a new Customer***");

			String xml = "<customer>"
				+ "<first-name>Bill</first-name>"
				+ "<last-name>Burke</last-name>"
				+ "<street>256 Clarendon Street</street>"
				+ "<city>Boston</city>"
				+ "<state>MA</state>"
				+ "<zip>02115</zip>"
				+ "<country>USA</country>"
				+ "</customer>";

			//Perform a post request
			Response response = client.target(
					"http://localhost:8080/services/customers")
					.request().post(Entity.xml(xml));

			if (response.getStatus() != 201) throw new RuntimeException(
					"Failed to create");

			String location = response.getLocation().toString();
			System.out.println("Location: " + location);
			response.close();

			//To get created customer

			String customer = client.target(location).request().get(String.class);
			System.out.println(customer);

			String updateCustomer = "<customer>"
					+ "<first-name>William</first-name>"
					+ "<last-name>Burke</last-name>"
					+ "<street>256 Clarendon Street</street>"
					+ "<city>Boston</city>"
					+ "<state>MA</state>"
					+ "<zip>02115</zip>"
					+ "<country>USA</country>"
					+ "</customer>";

			//PUT the new customer
			response = client.target(location)
							 .request()
							 .put(Entity.xml(updateCustomer));

			if (response.getStatus() != 204)
				throw new RuntimeException("Failed to update");
			response.close();

			customer = client.target(location).request().get(String.class);
			System.out.println(customer);
		} finally {
			client.close();
		}
	}
}

HTTP Method and URI Matching:

We may only deploy one @ binding annotation per method. Doing more than one causes a exception.

JAX-RS defines 5.

GET

PUST

POST

DELETE

HEAD

An example:

@Path("/customers") //Process get requests to the /customers URI
public class CustomerService{
	@GET
	@Produces("application/xml")
	public String getAllCustomers(){}
}

In reality, the @ Annotations actually carry a Metadata set which can be specified as follows:

package javax.ws.rs;

import ...;

@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@HttpMethod(HttpMethod.GET)
public @interface GET {
	
}

The JAX-RS looks for the HttpMethod annotation to bind the method, as above,
we can see that the GET is what will occur, when we bind the metaData to it.

HTTP Method Extensions:

By virtue of this, we can include other HTTP method extensions, as the following.
For example, WebDAV is a protocol that allows for interactive, readable and writable medium.

It allows users to create, change and move documents on web servers. It adds a bunch of 
HTTP methods like :

MOVE

COPY

MKCOL

LOCK

UNLOCK

To implement them:

package org.rest.webdav;

import ...;

@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@HttpMethod("LOCK")
public @interface LOCK{
	
}

The @HttpMethod works akin to hooking in other functions, basically.

To now use the LOCK:

@Path("/customers")
public class CustomerResource{
	@Path("{id}")
	@Lock
	public void lockIt(@PathParam("id") String id){
		...
	}
}

Now, we can dispatch LOCK requests and they will go to the lockIt method.

@Path:

Can have regex so that we can be more specific of what request gets bound to 
which incoming URI. @Path can also be used on a Java method as sort of an
object factory for subresources of your app.

Binding URIs:

We can use the @Path to designate to either methods or classes.
for a class to be eligable for HTTP requests, the class must be preluded with @Path("/")

These types of classes, are called, JAX-RS root resources

The @Path denotes a relative URI to the base URI used access the page.

To receive a request, a Java method must have at least an HTTP method annotation
like @javax.ws.rs GET applied to it. As follows:

@Path("/orders")
public class OrderResource{
	@GET //makes the method able to accept get requests
	public String getAllOrders(){
		...
	}
}

We can also "build" paths, by several path notations, to build up a structure of pathing:

@Path("/orders")
public class OrderResource{
	
	@GET
	@Path("unpaid") //The path becomes /orders/unpaid, because of building on earlier path notations
	public String getUnpaidOrders(){
		...
	}
}

@Path Expressions:

The value of the @Path annotation is usually a simple string, but you can also
define more complex expressions to satisfy your URI matching needs.

Template parameters:

Earlier we did a wildcard of a ID param:

@Path("/customers")
public class CustomerResource{
	@GET
	@Path("{id}")
	public String getCustomer(@PathParam("id") int id){
		...
	}
}

The wildcard above, is the id param

We can do several in the path:

@Path("/")
public class CustomerResource{
	@GET
	@Path("customers/{firstname}-{lastname}")
	public String getCustomer(@PathParam("firstname") String first,
							  @PathParam("lastname") String last){
		...
	}
}

Thus to match get requests, we'd have to supply 2 strings:

GET /customers/bill-murrey for instance

Regex:

We can put regexin the Path matcher:

@Path("/customers")
public class CustomerResource{
	@GET
	@Path("{id : \\d+}") //matches only digits
	public String getCustomer(@PathParam("id") int id){
		...
	}
}

We can further more apply regex rules:

@Path("/customers")
public class CustomerResource{
	@GET
	@Path("{id : .+}") //Match against any stream of chars after /customers
	public String getCustomer(@PathParam("id") String id){
		...
	}

	@GET
	@Path("{id : .+}/address") //match against specifically beginning with /customers and ending with /address
	public String getAddress(@PathParam("id") String id){
		...
	}
}

Precedence rules:

The ordering of Regex matching is that the most exact pattern gets higher predecence.

This includes:

length of non regex chars, highest first

number of template exressions in the regex (such as {id} or {id : .+}), in descending order 

Number of non-default expressions, such as regex.

Let us look at a list of them, and sort out why they get sorted as they do:

1 /customers/{id}/{name}/address
2 /customers/{id : .+}/address
3 /customers/{id}/address
4 /customers/{id : .+}

1-3 come first, because ascending order of length of normal chars(higher first)

#1 comes first, because it has more regex expressions than the rest.

#2 and #3 have the same amount of chars and template expressions. But not regex.
2 has 1 regex, 3 has 0, so 2 comes 2

There can still be ambiguity, but then we are forced to refactor cause this library is sorta
shit on that part.

Encoding:

The following are allowed in a URI: a-zA-Z0-9_-!.~'()*.

These are allowed, but reserved for URI syntax: ,;:$&+=?/\[]@

All other chars must be encoded by %<two hexadecimal numbers>

The hexa number is corespondant to the ASCII conversion table. For example:

bill&burke would be bill%26burke

If we put a illegal char in our Path URI declaration, it will autoconvert them before
attempting to match. If it is illegal, that is. If its legal, it does not care. (i.e its a illegal encoded
char already)

Matrix Parameters:

They are the added flavor args of identification of things, akin to :

http://example.cars.com/mercedes/e55;color=black/2006
									  ^
									A matrix param
								Are ignored when matching requests.
								Illegal to put in the @Path

An example:

@Path("/mercedes")
public class MercedesService{
	@GET
	@Path("/e55/{year}")
	@Produces("image/jpeg")
	public Jpeg getE55Picture(@PathParam("year") String year) {
		...
	}
}

If we queried against GET /mercedes/e55;color=black/2006, getE55Picture would trigger
You can access them if you wish, but we will see that later.

Subresource Locators:

We can use Subresource Locators to act as a resource getter performing the rest of a query
inside of an already other query, that returns the result. An example:

In this example, we have split it up so that DBs can be based on geographical location 
based on the URI specified.

@Path("/customers")
public class CustomerDatabaseResource{
	@Path("{database}-db")
	public CustomerResource getDatabase(@PathParam("database") String db){
		//find the instnace based on the DB param
		CustomerResource resource = locateCustomerResource(db);
		return resource;
	}

	protected CustomerResource locateCustomerResource(String db){
		...
	}
}

This class, does not process any HTTP requests directly. instead, it identifies the resource from the DB
Path Param

The second class is the :

public class CustomerResource{
	private Map<Integer, Customer> customerDB = new ConcurrentHashMap<Integer, Customer()>;
	private AtomicInteger idCounter = new AtomicInteger();

	public CustomerResource(Map<Integer, Customer> customerDB)
	{
		this.customerDB = customerDB;
	}

	@POST
	@Consumes("application/xml")
	public Response createCustomer(InputStream is){
		...
	}

	@GET
	@Path("{id}")
	@Produces("application/xml")
	public StreamingOutput getCustomer(@PathParam("id") int id){
		...
	}

	@PUT
	@Path("{id}")
	@Consumes("application/xml")
	public void updateCustomer(@PathParam("id") int id, InputStream is){
		...
	}
}

Now, if we have the request GET /customers/northamerica-db/333, the JAX-RS will match
the expression on the method CustomerDatabaseResource.getDatabase()

It will then run the rest of it, on CustomerResource.getCustomer()

THe difference here is just the fact of that the CustomerResource class 
has not @Path notation as it is a subresource. Meaning it gets delegated
it's call through a higher hierarchy of classes. The higher hierarchy being the 
DB first.

The hierarchy becomes DB->Customer->return Customer

The problem is, still, the fact that the locateCustomerResource is not written out how it 
was done.

Full Dynamic Dispatching:

The CustomerDatabaseResource.getDatabase() method can return any instance of any class. (?)
AT runtime, the JAX-RS provider will introspect the instance's class for resource methods
that can handle the request.

Let's say that in our example, we have two customer DBs with different kinds of 
identifiers. One DB uses a numeric key, the other uses firstname and lastname 
as a composite key.

We would need to have two different classes to extract the appropiate info from the 
URL.  let's change our example:

@Path("/customers")
public class CustomerDatabaseResource{
	protected CustomerResource europe = new CustomerResource();

	protected FirstLastCustomerResource northAmerica = new FirstLastCustomerResource();

	@Path("{database}-db")
	public Object getDatabase(@PathParam("database") String db){
		if (db.equals("europe")){
			return europe;
		} 
		else if (db.equals("northamerica")){
			return northamerica;
		}
		else return null;
	}
}

What it returns in actuallity is a Object, that it just inspects to see what kind of a Object it is.
Based on this, we return different Resources to process the request for.

If it's europe, we just use the old CustomerResource class to sort out the dispatch.

If it's northamerica, we use the new FirstLastCustomerResource():

public class FirstLastCustomerResource{
	private Map<String, Customer> customerDB = new ConcurrentHashMap<String, Customer>();

	@GET
	@Path("{first}-{last}")
	@Produces("application/xml")
	public StreamingOutput getCustomer(@PathParam("first") String firstName,
									   @PathParam("last") String lastName){
		...
	}

	@PUT
	@Path("{first}-{last}")
	@Consumes("application/xml")
	public void updateCustomer(@PathParam("first") String firstName,
							   @PathParam("last") String lastName,
							   InputStream is){
		...
   }
}

This means that the hierarchy would go as :

/customers/{database}-db/{id} -> CustomerResource

/customers/{database}-db/{first}-{last} -> FirstLastCustomerResource

Gotchas in Request Matching:

Matching can get wierd. The following example:

@Path("/a")
public class Resource1{
	@GET
	@Path("/b")
	public Response get() {}
}

@Path("/{any : .*}")
public class Resource2{
	@GET
	public Response get() {}

	@OPTIONS
	public Response options() {}
}

if we call GET /a/b, we trigger the resource 1 path, cause it best matche the first part.

If we were to run OPTIONS /a/b we still match against resource1, meaning we get an error,
cause there no method to handle the OPTIONS dispatch

If we changed the Resource2 so that it has a coherent path of /a/b (b being with a @OPTION) notation,
it would work.

An example:

@Path("/a")
public class Resource2{
	
	@OPTIONS
	@Path("b")
	public Response options() {}
}

If the @Path are the same between two resources, they both are used for request matching.

NOTE: If a @Path matches, no subresource locator is traversed.

An example:

@Path("/a")
public class Foo{
	@GET
	@Path("b")
	public String get() {...}

	@Path("{id}")
	public Locator locator() { return new Locator(); }
}

public class Locator{
	@PUT
	public void put(){...}
}

If we do PUT /a/b, that will get a error. 

JAX-RS Injection:

A lot of JAX-RS is pulling information from an HTTP request and injecting it
into a Java method. You may be interested in a fragment of the incoming URI.
You might be interested in a URI query string value.

The client might be sending critical HTTP headers or cookie values that your
service needs to process the request.

JAX-RS let's us grab this with injection annotations and APIs.

The Basics:

There are a lot of JAX-RS annotations taht can inject. Here is a list of those
provided by the spec:

@javax.ws.rs.PathParam
	Allows you to extract values from URI template parameters
	
	Such as: {id}

@javax.ws.rs.MatrixParam
	Allows you to get URI matrix params

	Such as: <URI>/person=guy;color=black/

@javax.ws.rs.QueryParam
	Allwos extraction from URI query params

@javax.ws.rs.FormParam
	Allows extraction from posted form data.

@javax.ws.rs.HeaderParam
	Allows extraction from HTTP request headers

@javax.ws.rs.CookieParam
	Allows extraction from HTTP cookies set by the client

@javax.ws.rs.core.Context
	all-purpose injection annotation. Allows inject various
	helper and informational objects that are provided by the JAX-RS API

These notations are used on java methods that match requests.
The respective Injection, takes the info from the Request, as per the @<param>.

For example, setting @MatrixParam({something}) allows you to get the MatrixParam something as a 
arg in the Method with : (@MatrixParam("something") String)

These only work on per-request instansiation. Singletons process HTTP requests
concurrently, meaning the values overwrite and conflict with each other.

@PathParam

As we have seen it before:

@Path("/customers")
public class CustomerResource{
	...

	@Path("{id}")
	@GET
	@Produces("application/xml")
	public StreamingOutput getCustomer(@PathParam("id") int id){
		...
	}
}

More than one Path param:

You can reference more than one URI path param in Java methods. 

An example:

@Path("/customers")
public class CustomerResource{
	...

	@Path("{first}-{last}")
	@GET
	@Produces("application/xml")
	public StreamingOutput getCustomer(@PathParam("first") String firstName,
									   @PathParam("last") String lastName){
		...
	}
}

Scope of Path params:

When a Path param is repeated more than once and later refered, the closest one
refered is chosen:

@Path("/customers/{id}")
public class CustomerResource{
	@Path("/address/{id}")
	@Produces("text/plain")
	@GET
	public String getAddress(@PathParam("id") String addressid) {...}
}

If we run a GET /customers/123/address/456, we end up with id being 456.

PathSegment and Matrix Parameters:

Path segment is defined as follows:

package javax.ws.rs.core;

public interface PathSegment{
	String getPath();
	MultivalueMap<String, String> getMatrixParameters();
}

getPath returns the address without matrix params. 


the getMatrixParameters() reurns all the matrix params.

In combination with @PathParam we can access matrix params applied to our request URI:

@Path("/cars/{make}")
public class CarResource{
	@GET
	@Path("/{model}/{year}")
	@Produces("image/jpeg")
	public Jpeg getPicture(@PathParam("make") String make,
						   @PathParam("model") PathSegment car,
						   @PathParam("year") String year) {
		String carColor = car.getMatrixParameters().getFirst("color");
	}
By injecting the model as a PathSegment, we can aaccess it by the matrix params.

Example of a URI containing a Matrix arg:

GET /cars/mercedes/e55;color=black/2006

Matching with multiple PathSegments:

@Path("/cars/{make}")
public class CarResource{
	@GET
	@Path("/{model : .+}/year/{year}")
	@Produces("image/jpeg")
	public Jpeg getPicture(@PathParam("make") String make,
							@PathParam("model") List<PathSegment> car,
							 @PathParam("year") String year){

	}
}

In the above example, we would be able to process two PathSegments injected:

GET /cars/mercedes/e55/amg/year/2006

We could then query and pull in matrix params as needed from these segments.

Programmatic URI information:

If we wish to have info in a more, programmatic manner:

public interface UriInfo {
	public String getPath();
	public String getPath(boolean decode);
	public List<PathSegment> getPathSegments();
	public List<PathSegment> getPathSegments(boolean decode);
	public MultivaluedMap<String, String> getPathParameters();
	public MultivaluedMap<String, String> getPathParameters(boolean decode);
}

These are simply getters for the different values in URIs.

We can obtain an instance of UriInfo interface by using the @javax.ws.rs.core.Context 
injection annotation. An example:

@Path("/cars/{make}")
public class CarResource{
	@GET
	@Path("/{model}/{year}")
	@Produces("image/jpeg")
	public Jpeg getPicture(@Context UriInfo info){
		String make = info.getPathParameters().getFirst("make");
		PathSegment model = info.getPathSegments().get(1);
		String color = model.getMatrixParameters().getFirst("color");
	}
}

We simply inject the UriInfo interface into it and extract info from it.

@MatrixParam

We can also just straight up inject the MatrixParam instead:

@Path("/{make}")
public class CarResource{
	
	@GET
	@Path("/{model}/{year}")
	@Produces("image/jpeg")
	public Jpeg getPicture(@PathParam("make") String make,
						   @PathParam("model") String model,
						   @MatrixParam("color") String color){

	}
}

In case of that the Matrix param repeats itself, as in, the same 
matrix param occurs more than once, it becomes ambigious and we are 
forced to parse PathSegments.

An example of ambigious matix param occurances:

GET /mercedes/e55;color=black/2006/interior;color=tan

@QueryParam

Assume the URI contains query info, then we can can run Queryparams:

GET /customers?start=0&size=10

@Path("/customers")
public class CustomerResource{
	@GET
	@Produces("application/xml")
	public String getCustomers(@QueryParam("start") int start,
							   @QueryParam("size") int size){

	}
}

The query params in the URI is the start and size, so we put them in with Query params.

Injections like this automatically convert Strings to Integer.

Programmatic Query Parameter Information:

Once more, we can use the UriInfo interface to access all QueryParams, if we wish:

public interface UriInfo{
	public MultivaluedMap<String, String> getQueryParameters();
	public MultivaluedMap<String, String> getQueryParameters(boolean decode);
}

Again, we can inject the URiInfo:

@Path("/customers")
public class CustomerResource{
	
	@GET
	@Produces("application/xml")
	public String getCustomers(@Context UriInfo info){
		String start = info.getQueryParameters().getFirst("start");
		String size = info.getQueryParameters().getFirst("size");
	}
}

@FormParam

Assume we have a Form in HTML:

<FORM action="http://example.com/customers" method="post">
	<p>
	First Name: <INPUT type="text" name="firstname"><BR>
	Last Name: <INPUT type="text" name="lastname"><BR>
	</p>
</FORM>

We can access the form params with injections as per usual:

@Path("/customers")
public class CustomerResource{
	@POST
	public void createCustomer(@FormParam("firstname") String first,
								@FormParam("lastname") String last){
	...
	}
}

Automatic decoding occurs when injecting these.

@HeaderParam

We can access the HTTP header as well with param injection:

@Path("/myservice")
public class MyService{
	
	@GET
	@Produces("text/html")
	public String get(@HeaderParam("Referer") String referer){

	}
}

Raw Heaeders:

To gain access to raw headers, we have:

public interface HttpHeaders{
	public List<String> getRequestHeader(String name); //one particular
	public MultivaluedMap<String, String> getRequestHeaders(); //All of the headers
}

As per injection, an example:

@Path("/myservice")
public class MyService{
	@GET
	@Produces("text/html")
	public String get(@Context HttpHeaders headers){
		String referer = headers.getRequestHeaders("Referer").get(0);
		for (String header : headers.getRequestHeaders().keySet()){
			System.out.println("This header was set: " + header);
		}
	}
}

@CookieParam

Servers can store state info in cookies on the client, and can retreive 
that information when the client makes its next request. Many web apps use cookies
to set up sessions between client and the server.

They also use cookies to remember identity and user preferences between requests.

The cookie values are transmitted via cookie headers, back and forth.

Again, we can use a CookieParam to inject cookies sent by a client request
into JAX-RS. Let's assume our app push a customerId cookie to our clients so that
we can track users as they invoke and interact with our web services.

An example of cookie Params:

@Path("/myservice")
public class MyService{
	
	@GET
	@Produces("text/html")
	public String get(@CookieParam("customerId") int custId){
		...
	}
}

This just tranfers the base value of that specified header in any of the ocokies.
To aquire the actually cookie:

@Path("/myservice")
public class MyService{
	@GET
	@Produces("text/html")
	public String get(@CookieParam("customerId") Cookie custId){
		....
	}
}

The above actually inserts the entire cookie.

The cookie has a bit more info than just name and value:

package javax.ws.rs.core;

public class Cookie
{
	public String getName() {...} //name of cookie
	public String getValue() {...} //Value
	public int getVersion() {...} //Version
	public String getDomain() {...} //DNS name that the cookie matched
	public String getPath() {...} //The URI path matched to get the cookie
}

To get a map of all cookies sent by the client, inject HttpHeaders:

public interface HttpHeaders{
	...
	public Map<String, Cookie> getCookies();
}

As per with Httpheaders, we have to pass the @Context and then extract the info:

@Path("/myservice")
public class MyService{
	@GET
	@Produces("text/html")

	public String get(@Context HttpHeaders headers){
		for (String name: headers.getCookies().keySet())
		{
			Cookie cookie = headers.getCookies().get(name);
			System.out.println("Cookie: " + name + "=" + cookie.getValue());
		}
	}
}

@BeanParam

This allows injection of entire classes.

An example:

public class CustomerInput{
	@FormParam("first")
	String firstName;

	@FormParam("list")
	String lastName;

	@HeaderParam("Content-Type")
	String contentType;

	public String getFirstName() {...}
	...
}

To actually inject this class:

@Path("/customers")
public class CustomerResource{
	@POST
	public void createCustomer(@BeanParam CustomerInput newCust){
		....
	}
}

This bundles up all the given Params defiend in the class and injects them.

Common Functionality:

There are some common interactions with these injections. The ability to conver them
to respective Java type. To give them default values if they do not exist
in the header. And we can get the raw encoded strings.

Automatic Java Type conversion:

The conversion can occur as long as one of the following criterias are true:

It's a primitive. (int, short, double, byte, float, char and boolean)

It is a java class that has a constructor with a single String param

It is a java class that has a Static method that returns a instance of the class,
it takes a single String arg.

It is a Java.util.List<T>, java.util.Set<T>, or java.util.SortedSet<T>,
where T is a type that satisfies criteria 2 or 3 or is a String. Examples are:
List<Double>, Set<String>, or SortedSet<Integer>

Primitive Type Conversion:

A simple example:

@GET
@Path("{id}")
public String get(@PathParam("id") int id) {...}

Extract the ind ID of incoming request URI.

Java object conversion:

What if we wish to make, for instance, Referer as a URL class, since it is a URL?

Simple:

import java.net.URL;

@Path("/myservice")
public class MyService{
	
	@GET
	@Produces("text/html")
	public String get(@HeaderParam("Referer") URL referer){

	}
}

It can convert cause URL takes one String as a arg in it's constructor.

The matrix param of color, we could doredo as a Enum injection, as Enums 
have a valueOf() method:

public enum Color{
	BLACK,
	BLUE,
	RED, 
	WHITE, 
	SILVER
}

public class CarResource{
	@GET
	@Path("/{model}/{year}")
	@Produces("image/jpeg")
	public Jpeg getPictures(@PathParam("make") String make,
							@PathParam("model") String model,
							@MatrixParam("color") Color color)
	{

	}
}


ParamConverters:

We can have ParamConverters:

package javax.ws.rs.ext;

public interface ParamConverter<T>{
	public T fromString(String value);
	public String toString(T value);
}

The names are self explanetory, using Wildcard type conversion and String conversion.
Let's implement a ColorConverter, so that we don't need to have the UPPERCASE on color:

public class ColorConverter implements ParamConverter<Color>{
	
	public Color fromString(String value){
		if (value.equalsIgnoreCase(BLACK.toString())) return BLACK;
		//etc for other colors
		throw new IllegalArgumentException("Invalid color: " + value);
	}

	public String toString(Color value) { return value.toString(); }
}

We still have to implement the ParamConverterProvider interface:

package javax.ws.rs.ext;
public interface ParamConverterProvider{
	public <T> ParamConverter<T> getConverter(Class<T> rawType,
											  Type genericType,
											  Annotation annotations[]);
}

This is basically a factory for ParamConverters and is the component that
must be scanned or registered with your Application deploy class:

@Provider
public class ColorConverterProvider{
	private final ColorConverter converter = new ColorConverter();
	
	public <T> ParamConverter<T> getConverter(class<T> rawType,
											  Type genericType,
											  Annotation[] annotations){
	    if (!rawType.equals(Color.class)) return null;

	    return converter;
	}
}

This basically makes it so that we check for if the raw typing is of the Color class.
If it is, return the converter. Otherwise, just reutrn null.

The Annotation is just a list of the assign annotation params to the arg
you are converting. This allows you to tailor the behavior of your converter
based on any additional metadata applied.

Collections:

All the param types described so far, may have multiple values for the same named param.

We can generalize a Collection by virtue of applying a abstract type to all the things
being there.

An example:

Assume the query GET /customers?orderBy=last&orderBy=first

import java.util.list;

@Path("/customers")
public class CustomerResource{
	@GET
	@Produces("application/xml")
	public String getCustomers(
					@QueryParam("start") int start,
					@QueryParam("size") int size,
					@QueryParam("orderBy") List<String> orderBy){
		...
	}
}

Again, the generic type contained within the list must be the typing of the list.

Conversion failures:

If it fails to convert to a java type, its a client error.

If it fails during processing of injection: 404, not found

If it is failure with @HeaderParam or @CookieParam, 400, bad request

@DefaultValue

We can use defaults to avoid nulls and 0's, used in placed of default construction in
absence of args:

import java.util.List;

@Path("/customers")
public class CustomerResource{
	
	@GET
	@Produces("application/xml")
	public String getCustomers(@DefaultValue("0") @QueryParam("start") int start,
							@DefaultValue("10") @QueryParam("size") int size)
	{
	
	}						
}

@Encoded:

If we wish, we can designated values to be encoded only:

@GET
@Produce("application/xml")
public String get(@Encoded @QueryParam("something") String str) {...}

If we wish to encode everything, we can of course just change the scope of the Encoded param
designation. As per giving it to an entire class or whatever.

JAX-RS Content Handlers:

We are now going to look at Content bodies of requests. Previously we used low level accessing.
We can use high level accessing to see things. It is called Marshalling.

Built-in Content Marshalling

javax.ws.rs.core.StreamingOutput

A simple callbakci nterface that you implement when you wish to do raw streaming of 
response bodies:

public interface StreamingOutput {
	void write(OutputStream output) throws IOException, WebApplicationException;
}

We simply use an output stream to asynch callback to it when we are ready and write out:

An example:

@Path("/myservice")
public class MyService{
	@GET
	@Produces("text/plain")
	StreamingOutput get(){
		return new StreamingOutput(){
			public void write(OutputStream output) throws IOException,
												WebApplicationException {
				output.write("Hello world".getBytes());
			}
		}
	};
}

Using the callback fits both Asynch and does not bypass caching and GZIP encodings handlings.

java.io.InputStream, java.io.Reader:

For reading request message bodies, you can use raw InputStream or Reader
for inputting any media type. For example:

@Path("/")
public class myService{
	@PUT
	@Path("/stuff")
	public void putStuff(InputStream is){
		byte[] bytes = readFromStream(is);
		Sring input = new String(bytes);
		System.out.println(input);
	} 

	private byte[] readFromStream(InputStream stream) throws IOException
	{
		ByteArrayOutputStream baos = new ByteArrayOutputStream();

		byte[] buffer = new byte[1000];
		int wasRead = 0;
		do{
			wasRead = stream.read(buffer);
			if (wasRead > 0){
				baos.write(buffer, 0, wasRead);
			}
		} while (wasRead > -1); //Basically just read as long as it's not EOF
		return baos.toByteArray();
	}

	@PUT
	@Path("/morestuff")
	public void putMore(Reader reader){
		lineNumberReader lineReader = new LineNumberReader(reader);
		do{
			String line = lineReader.readline();
			if (line != null) System.out.println(line);
		} while (line != null);
	}

	//Create a file from disk to use a response body
	@Path("/file")
	public class FileService{

		private static final String basePath = "...";
		@GET
		@Path("{filepath: .*}") //Get hte file path from the request
		@Produces("text/plain")
		public InputStream getFile(@PathParam("filepath") String path){ //feed in he filepath
			FileInputStream is = new FileInputStream(basePath + path); //make a FileInputStream from the path
			return is; //return it as a Response
		}
	}
}

java.io.File:

We can use java.io.File for input and output of any file, really.	

An example of returning a reference to a file on disk:

@Path("/file")
public class FileService{
	
	private static final String basePath = "...";
	@GET
	@Path("{filepath: .*}")
	@Produces("text/plain")
	public File getFile(@PathParam("filepath") String path){
		return new File(basePath + path);
	}

	//We can also parse incoming files

	@POST
	@Path("/morestuff")
	public void post(File file){
		Reader reader = new Reader(new FileInputStream(file));
		lineNumberReader lineReader = new LineNumberReader(reader);
		do{
			String line = lineReader.readLine();
			if (line != null) System.out.println(line);
		} while (line != null);
	}
}

The above POST method works akin to that it creates a temp file ,
reads from the File into buffers, reads from the buffers, etc. Basically
it's high level interfaces of Channels, Streams and ByteBuffers

byte[]:

We can read and write bytes as well, of course:

@Path("/")
public class MyService{
	@GET
	@Produces("text/plain")
	public byte[] get(){
		return "hello world".getBytes();
	}

	@POST
	@Consumes("text/plain")
	public void post(byte[] bytes){
		System.out.println(new String(bytes));
	}
}

String, char[]:

We can produce XML:

@Path("/")
public class MyService{
	@GET
	@Produces("application/xml")
	public String get(){
		return "<customer><name>Bill Burker</name></customer>";
	}

	@POST
	@Consumes("text/plain")
	public void post(String str){
		System.out.println(str);
	}
}

As per usual, if it produces anything, you must define what it produces, as to
define what it will put in the content-type header.

The specification enforces Char encodings when injecting. Such as the injected string
being UTF-8 if the content-type is UTF-8

MultivaluedMap<String, String> and Form Input:

Form data is encoded as the application/x-www-form-urlencoded media type.
We already know we can inejct with @FormParam

We can also inject MultivalueMap<String, String> to get ALL the form data sent:

@Path("/")
public class MyService{
	
	@POST
	@Consumes("application/x-www-form-urlencoded")
	@Produces("application/x-www-form-urlencoded")
	public MultivaluedMap<String, String> post(
								MultivaluedMap<String, String> form){
		return form;
	}
}

javax.xml.transform.Source:

represents XML input or output. usually used for XSLT transformations on input documents.
An example:

@Path("/transform")
public class TransformationService{
	@POST
	@Consumes("application/xml")
	@Produces("application/xml")
	public String post(Source source){
		javax.xml.transform.TransformerFactory tFactory =
				javax.xml.transform.TransformerFactory.newInstance();

		javax.xml.transform.Transformer transformer =
			tFactory.newTransformer(new javax.xml.transform.stream.StreamSource("foo.xsl"));

		SringWriter writer = new StringWriter();
		transformer.transform(source,
			new javax.xml.transform.stream.StreamResult(writer));

		return writer.toString();
	}
}

in this example we use java.xml.transform.Source that presents out request body,
and transform it using an XSLT transformation.

It is the only one other for JAXB, that requires implementers to support.

JAXB:

It is a framework that maps Java to XML and XML Schema.

An example of using JAXB:

@XmlRootElement(name="customer")
@XmlAccessorType(XmlAccessType.FIELD)
public class Customer {
	@XmlAttribute
	protected int id;

	@XmlElement
	protected String fullname;

	public Customer() {}

	public int getId() { return this.id; }
	public void setId(int id) { this.id = id; }

	public String getFullName() { return this.fullname; }
	public void setFullName(String name){ this.fullname = name; }
}

The output of the above would be:

<customer id="42">
	<fullname>Bill Burke</fullname>
</customer>

Assume we wish to write an address as well:

@XmlRootElement(name="address")
@XmlAccessorType(XmlAccessType.FIELD)

public class Address {
	@XmlElement
	protected String street;

	@XmlElement
	protected String city;

	@XmlElement
	protected String state;

	@XmlElement
	protected String zip;

	//getters and setters
}

To add a address field, just add a new Address with attributes (This one is just empty):

@XmlElement 
protected Address address;

JaxB can also reverse engineer XML to Java classes.

A marshaller makes XML out of Java, an Unmarshaller makes Java out of XML.

An example of creating a customer, marshalling it and then unmarshalling it:

Customer customer = new Customer();
customer.setId(42);
customer.setName("Bill Burke")

JAXBContext ctx = JAXBContext.newInstance(Customer.class); //make a context object of the class
StringWriter writer = new StringWriter();

ctx.createMarshaller().marshal(customer, writer); //Marshal the Customer object with a writer from the
//Context object

String custString = writer.toString();

customer = (Customer)ctx.createUnmarshaller()
			  .unmarshal(new StringReader(custString)); //Recreate the customer from XML

JAXB JAX-RS Handlers:

We need specific support to be able to handle @XmlRootElements
or @XmlType objects wrapped inside javax.xml.bind.JAXBElement

An example of interacting with the class since earlier:

@Path("/customers")
public class CustomerResource{
	@GET
	@Path("{id}")
	@Produces("application/xml")
	public Customer getCustomer(@PathParam("id") int id){
		Customer cust = findCustomer(id);
		return cust;
	}

	@POST
	@Consumes("application/xml")
	public void createCustomer(Customer cust){
		...
	}
}

JAXB, once implemented, handles the application/xml conversion of Java objects.
And once context objects are made, they are cached, cause they are expensive to make.

Managing  your own JAXBContexts with ContextResolvers:

To plug in our own JAXBContexts, we have to implement a ContextResolver
interface:

	public interface ContextResolver<T> {
		T getContext(Class<?> type);
	}

The context instances can be configured a lot to specify class, output etc.

An example of a implementation of a context provider, ias as follows:

@Provider //Has to be annoted with it being a provider
@Produces("application/xml") //produces app/xml tag for JAXB implementation, is optional
public class CustomerResolver implements ContextResolver<JAXBContext>{ //Has to implement Context Resolver
	private JAXBContext ctx; //Context

	public CustomerResolver(){
		this.ctx = ...; //Initialize it the way you want
	}

	public JAXBContext getContext(Class<?> type){ //Wildcard the input class
		if (type.equals(Customer.class)){ //if the type equals customer
			return ctx; //Return the context object
		} else {
			return null; //We don't allow context for other objects
		}
	}
}

The way the resolver calls works, is that they iterate until they find one that
provides a proper type. Until that point, it will ignore them, as Null is not a relevant
field to care for.

JAXB can be used to convert to other formats as well, not just XML.

JAXB and JSON:

JAXB can use something called Jettson, to allow for conversion of JAXB annoted classes, to
and from JSON.

To map XML to JSON, we can use BadgerFish. This exists in JAX-RS implementations that
support JAXB/JSON.

The mapping would look as follows:
 								  To JSON
<customer>Bill Burke</customer> ------------> { "customer" : { "$" : "Bill Burke" }}

Assume you had:

<customer>
	<first>Bill</first>
	<last>Burke</last>
</customer>

     v
     v
     v To JSON
     v
     v
{ "customer" :
	{ "first" : { "$" : "Bill"},
	  "last" : { "$" : "Burke" }
	}
}

Multiple nested elements in a row get treated like array conversion:

<customer>
	<phone>978-666-5555</phone>
	<phone>978-555-2233</phone>
</customer>

	v
	v
	v To JSON
	v
	v
{ "customer" :
	{ "phone" : [ { "$", "978-666-5555"}, {"$", "978-555-2233"} ] }
}

XML attributes such as id and what not, becomes @notations in JSON:

<customer id="42">
	<name>Bill Burke</name>
</customer>

	V
	V
	V To JSON
	V
	V
{ "customer" :
	{ "@id" : 42,
	  "name" : "Bill Burke"
	}
}

If we have active namespaes included in the XML, it becomes like this:

<customer xmlns="urn:cust" xmlns:address="urn:address">
	<name>Bill Burke</name>
	<addess:zip>02115</address:zip>
</customer>

The JSON mapping would be:

{ "customer" :
	{ "@Xmlns" : { "$" : "urn:cust", 
					"address" : "urn:address" } ,
	  "name" : { "$" : "Bill Burke",
	  			   "@xmlns" : { "$" : "urn:cust", 
	  			   				 "address" : "urn:address" } },
	  "address:zip" : { "$" : "02115",
	  					 "@xmlns" : { "$" : "urn:cust",
	  					 "address" : "urn:address" }}
	 }
}

JSON and JSON Schema:

The thing with using XML schema and the BadgerFish mapping to define our JSON,
is that it gets clunky to use in JS.

There are a lot of ways we could convert between different formas.
Such as going from Java to JSON etc.

One way to describe XML schemas is the JSON schema, as follows:

{
 "description":"A customer",
 "type":"object",

 "properties":
  {"first": {"type": "string"},
   "last" : {"type" : "string"}
  }
}

There is another Framework as well, called Jackson, that can convert
Java beans to and from JSON. It can also generate JSON schema
documents from a Java object model.

An example:

Assume a simple Java class with attributes, getters and setters Just a random Customer class.

and sample data:

{
	"id" : 42,
	"firstName" : "Bill",
	"lastName" : "Burke"
}

Reading and writing would be as easy as:

Reading:

ObjectMapper mapper = new ObjectMapper();
Customer cust = mapper.readValue(inputStream, Customer.class);

Writing the data would be as easy as:

ObjectMapper mapper = new ObjectMapper();
mapper.writeValue(outputStream, customer);

The JAX-RS in Jackson actually does all of this for you, so all you gotta do is
specify input and output format as application/json when writing your JAX-RS methods.

Custom Marshalling:

There is so many data formats, that perhaps we wish to have our own dataformat handling.
We can do so, by using the JAX-RS APIs.

MessageBodyWriter:

The first thing we need, is JAXB-marshalling support. To automatically
convert Java objects into XML, we have to create a class that implements
the javax.ws.rs.ext.MessageBodyWriter interface:

public interface MessageBodyWriter<T> {
	boolean isWriteable(Class<?> type, Type genericType,
						Annotation annotations[],
										MediaType mediaType);

	long getSize(T t, Class<?> type, Type genericType, Annotation annotations[],
					MediaType mediaType);

	void writeTo(T t, Class<?> type, Type genericType,
				 Annotation annotations[],
				 MediaType mediaType,
				 MultivaluedMap<String, Object> httpHeaders,
				 OutputStream entityStream)
				 		throws IOException, WebApplicationException;
}

The MessageBodyWriter interface has only three methods.

The first is called at runtime to verify if it is supported in marshalling the given type.
It is a callback.

the getSize() is called on runtime to determine Content-Length of the output.

writeTo() does all the heavy lifting and writes the content out to the HTTP response buffer.
Let's implement this interface to support JAXB:

@Provider //Annotation for inclusion
@Produces("application/xml") //Annotation for what values are produced
public class JAXBMarshaller implements MessageBodyWriter{
	
	public boolean isWriteable(Class<?> type, Type genericType,
					  Annotation annotations[], MediaType mediatype){
		return type.isAnnotationPresent(XmlRootElement.class);
	}
}

JAX-RS follows this algo to find an appropiate MessageBodyWriter to write out a 
Java object into the HTTP response:

1. First, JAX-RS calculates a list of MessageBodyWriters by looking at each writer's
@Produces annotation to see if it supports the media type that the JAX-RS resource
method wants to output.

2. The list is sorted, With the best match for the desired media type coming first.
for example, if ous JAX-RS resource method wants to output application/xml
and we have three different MessageBodyWriters(one for application/*, one for all */* and
the last supports application/xml), then the last will be chosen, cause it's the best matching one.

3. JAX-RS then iterates through this list in order and calls the MessageBodyWriter.isWriteable() on each.
The first one to return true, is used to output the data.

The isWriteable() takes 4 params. The first being the object being marshalled.
We call getClass() to determine if it is a valid typing. In our example we do against @XmlRootElement

The second param is java.lang.reflect.Type. This is a generic type info about hte object,
like, is it a list etc. It's useful if we use a generic type of something and want to see what type it is.

The third param is an array of Annotations applied to the JAX-RS resource method we are 
marshalling the response for. Some MessageBodyWriters trigger on method annotations instead of class ones.

The 4th is the media type the JAX-RS should produce.

Carrying on with the implementation:

	public long getSize(Object obj, Class<?> type, Type genericType,
					Annotation[] annotations, MediaType mediaType)
	{
		return -1;
	}

The above method returns Content-Length of the content. If it's inedeterminable,
just return -1.

The underlying HTTP layer (the servlet container) handles populating the Content-Length
in this scenario or use the chunked transfer encoding.

And the final part is how to wire the JAXB object as XML:

	public void writeTo(Object target, 
						Class<?> type,
						Type genericType,
						Annotation[] annotations,
						MediaType mediaType,
						MultivaluedMap<String, Object> httpHeaders,
						OutputStream outputStream) throws IOException
	{
		try {
			JAXBContext ctx = JAXBContext.newInstance(type);
			ctx.createMarshaller().marshal(target, outputStream);
		} catch (JAXBExcetpion ex){
			throw new RuntimeException(ex);
		}
	}

The target type, genericType, annotations, and mediaType params of the writeTo()
method are the same info passed into the getSize() and isWriteable() methods.

The httpHeaders param is a javax.ws.rs.core.MultivaluedMap that represents
the HTTP response header. You may modify this map and add, remove, or change
the value of a specific HTTP header as long as you do this before outputting the response body.

our example simple takes Java and makes it to XML.

Adding pretty printing:

The output will in raw format, just be a long String, to make it "prettier", and readable,
we just add the @Pretty annotation:

@Path("/customers")
public class CustomerService {
	@GET
	@Path("{id}")
	@Produces("application/xml")
	@Pretty
	public Customer getCustomer(@PathParam("id") int id) {...}
}

Since the writeTo of the MessageBodyWriter has access to getCustomer(), we can implement
this easily. Let's modify the JAXB Marshaller class:

	public void writeTo(Object target,
						Class<?> type,
						Type genericType,
						Annotation[] annotations,
						MediaType mediaType,
						MultivaluedMap<String, Object> httpHeaders,
						OutputStream outputStream) throws IOException
	{
		try {
			JAXBContext ctx = JAXBContext.newInstance(type);
			Marshaller m = ctx.createMarshaller();

			boolean pretty = false;
			for (Annotation ann : annotations) {
				if (ann.annotationType().equals(Pretty.class)){
					pretty = true;
					break;
				}
			}
			if (pretty) {
				marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
			}

			m.marshal(target, outputStream);
		} catch (JAXBException ex) {
			throw new RuntimeException(ex);
		}
	}

We just iterate over the annotations and check to see if there is a pretty annotation
and run formatting if it is.

Since we should just register to hte first one we find, we just break the loop and marshal it
if we run into it.

Pluggable JAXBContexts using ContextResolvers:

To then add the Resolver to our JAXBMarshaller class, we first need 
to define a provider for the resolver:

public interface Providers {
	<T> ContextResolver<T> getContextResolver(Class<T> contextType,
											  MediaType mediaType);

	<T> MessageBodyReader<T> getMessageBodyReader(Class<T> type, 
											Type GenericType, Annotation annotations[], 
											MediaType mediaType);
	<T> MessageBodyWriter<T> getMessageBodyWriter(Class <T> type, Type genericType,
											Annotation annotations[], MediaType mediaType);

	<T extends Throwable> ExceptionMapper<T> getExceptionMapper(Class<T> type);
}

We use the Providers.getContextResolver() to find a ContextResolver. We inject
a reference to a Providers object using the @Context annotation. Let's modify 
our JAXBMarshaller class to add this functionality:

@Context
protected Providers providers;

public void writeTo(Object target, Class<?> type, Type genericType, Annotation[] annotations,
					MediaType mediaType, MultivaluedMap<String, Object> httpHeaders,
					OutputStream outputStream) throws IOException
{
	try{
		JAXBContext ctx = null;

		//Get a context resolver
		ContextResolver<JAXBContext> resolver = providers.getContextResolver(JAXBContext.class, mediaType);

		//if the resolver does not return empty, resolve it
		if (resolver != null){
			ctx = resolver.getContext(type);
		} 

		//if it is empty, create our own
		if (ctx == null){
			//Create one ourselves then 
			ctx = JAXBContext.newInstance(type);
		}

		//marshal the type to target
		ctx.createMarshaller().marshal(target, outputStream);
	} catch (JAXBException ex){
		throw new RuntimeException(ex);
	}
}

MessageBodyReader:

Now that we have made a MessageBodyWriter that can marshal a Java object into xml 
and output it as the HTTP response body, let's write an unmarshaller that knows how to
convert HTTP XML request bodies back into a Java object.

To do this, we need the javax.ws.rs.ext.MessageBodyReader interface:

public interface MessageBodyReader<T>{
	
	boolean isReadable(Class<?> type, Type genericType,
						Annotatio annotations[], MediaType mediaType);

	T readFrom(Class<T> type, Type genericType, Annotation annotations[], MediaType mediaType,
				MultivaluedMap<String, String> httpHeaders, InputStream entityStream)
						throws IOException, WebApplicationException;
}

It only has two methods, one for reading and one to see if it is readable.

implementing a MessageBodyReader is very similar to writing a MessageBodyWriter:

@Provider
@Consumes("application/xml")
public class JAXBUnmarshaller implements MessageBodyReader {
	
	public boolean isReadable(Class<?> type, Type genericType,
					Annotation annotations[], MediaType mediaType) {
		return type.isAnnotationPresent(XmlRootElement.class);
	}
}

As per expected, it implements the Provider, consumes XML and converts it,
next let's look at how we read and convert our HTTP message into a Java object:

Object readFrom(Class<Object>, Type genericType,
				Annotation annotations[], MediaType mediaType,
				MultivaluedMap<String, String> httpHeaders,
				InputStream entityStream) throws IOException, WebApplicationException{
	try{
		JAXBContext ctx = JAXBContext.newInstance(type);
		return ctx.createUnmarshaller().unmarshal(entityStream);
	} catch (JAXBException ex){
		throw new RuntimeException(ex);
	}
}

We create a unmarshaller and retrieve the data from it. Generally, we could actually
do these kinds of things ourselves with bigger ease, i think. Just put in a XML parser
that is able to read from the file and parse the data.

Life Cycle and Environment:

By default, only one instance of MessageBodyReader, MessageBodyWriter or
ContextResolver is created per application. if JAX-RS is allocating instances
of these components, the classes must provide a public constructor with all the params.

It may only include params annoted with the @Context annotation as per normal, since
we are allocating external dependancy from the JAX-RS structure.

@Provider
@Consumes("application/json")
public class MyJsonReader implements MessageBodyReader{
	public MyJsonReader(@Context Providers providers){
		this.providers = providers;
	}
}

Server Responses and Exception Handling:

Default Response Codes:

Jax-RS has a 1:1 relationship with HTTP error and success
reporting. 

Assume the following setup:

@Path("/customers")
public class CustomerResource{
	
	@Path("{id}")
	@GET
	@Produces("application/xml")
	public Customer getCustomer(@PathParam("id") int id) {...}

	@POST
	@Produces("application/xml")
	@Consumes("application/xml")
	public Customer create(Customer newCust) {...}

	@PUT
	@Path("{id}")
	@Consumes("application/xml")
	public void update(@PathParam("id") int id, Customer cust) {...}

	@Path("{id}")
	@DELETE
	public void delete(@PathParam("id") int id) {...}
}

The success responses are as per expected in terms of HTTP, ranging from 200 to 399.

Error Responses:

Most of the error handling is as per expected. The only difference being if no
existing method can handle OPTIONS, the JAX-RS implementation is required to
send back some automated, meaningful info.

Complex Responses:

if needed, we can use JAX-RS resource methods to return instances of 
javax.ws.rs.core.Response:

public abstract class Response {
	
	public abstract Object getEntity();
	public abstract int getStatus();
	public abstract MultivaluedMap<String, Object> getMetaData();
}

Entity returns the java object you wish to convert to a HTTP message body.
getStatus() is the status response code.

The getMetaData returns a multivalued Map of respone headers.

The class is abstract, and is created from javax.ws.rs.core.Response.ResponseBuilder instanced
returned by one of the static helper methods of Response:

public abstract class Response{
	...
	public static ResponseBuilder status(Status status) {...}
	public static ResponseBuilder status(int status) {...}

	public static ResponseBuilder ok() {...}
	public static ResponseBuilder ok(Object entity) {...}
	public static ResponseBuilder ok(Object entity, MediaType type) {...}

	public static ResponseBuilder ok(Object entity, String type) {...}
	public static ResponseBuilder ok(Object entity, Variant var) {...}

	public static ResponseBuilder serverError() {...}
	public static ResponseBuilder created(URI location) {...}

	public static ResponseBuilder noContent() {...}
	public static ResponseBuilder notModified() {...}

	public static ResponseBuilder notModified(EntityTag tag) {...}
	public static ResponseBuilder notModified(String tag) {...}

	public static ResponseBuilder seeOther(URI location) {...}
	public static ResponseBuilder temporaryRedirect(URI location) {...}

	public static ResponseBuilder notAcceptable(List<Variant> variants) {...}
	public static ResponseBuilder fromResponse(Response response) {...}
}

If we want the full explonation for each, it exists in the Docs.
Most of them build on the most common response.

They just generally return the pre-initialize Response with the respective header
messages to send.

We then use the ResponseBuilder class to modify the options of the Response,
and to actually build it:

public static abstract class ResponseBuilder{
	public abstract Response build();
	public abstract ResponseBuilder clone();

	public abstract ResponseBuilder status(int status);
	public ResponseBuilder status(Status status) {...}

	public abstract ResponseBuilder entity(Object entity);
	public abstract ResponseBuilder type(MediaType type);

	public abstract ResponseBuilder type(String type);

	public abstract ResponseBuilder variant(Variant variant);
	public abstract ResponseBuilder variants(List<Variant> variants);

	public abstract ResponseBuilder language(String language);
	public abstract ResponseBuilder language(Locale language);

	public abstract ResponseBuilder location(URI location);

	public abstract ResponseBuilder contentLocation(URI location);
	public abstract ResponseBuilder tag(EntityTag tag);
	public abstract ResponseBuilder tag(String tag);

	public abstract ResponseBuilder lastModified(Date lastModified);
	public abstract ResponseBuilder cacheControl(CacheControl cacheControl);

	public abstract ResponseBuilder expires(Date expires);
	public abstract ResponseBuilder header(String name, Object value);

	public abstract ResponseBuilder cookie(NewCookie... cookies);
}

Next up, an examlpe of specifying headers:

@Path("/textbook")
public class TextBookService{
	
	@GET
	@Path("/restfuljava")
	@Produces("text/plain")
	public Response getBook(){
		String book = ...;
		ResponseBuilder builder = Response.ok(book);
		builder.language("fr")
			   .header("Some-Header", "Some value");

		return builder.build();
	}
}

The only interesting thing about this is the implied nature of the @Produces that autosets the
Content-Type.

Returning Cookies:

We can also build cookies if we wish:

public class NewCookie extends Cookie {
	
	public static final int DEFAULT_MAX_AGE = -1;

	public NewCookie(String name, String value) {}

	public NewCookie(String name, String value, String path,
					  String domain, String comment, int maxAge,
					  boolean secure) {}

	public NewCookie(String name, String value, String path,
					 String domain, int version, String comment,
					 int maxAge, boolean secure) {}

	public NewCookie(Cookie cookie) {}

	public NewCookie(Cookie cookie, String comment, int maxAge, boolean secure) {}

	public static NewCookie valueOf(String value) throws IllegalArguemntException {}

	public String getComment() {}

	public int getMaxAge() {}

	public boolean isSecure() {}

	public Cookie toCookie() {}
}

To send response cookies, we can do as follows:

@Path("/myservice")
public class MyService{
	@GET
	public Response get(){
		NewCookie cookie = new NewCookie("key", "value");
		ResponseBuilder builder = Response.ok("hello", "text/plain");
		return builder.cookie(cookie).build();
	}
}

Here we just build a response with a cookie attached that is named key, with the value value.

The Status Enum:

We have a enum declaration that contains some methods to getters and Constructors.

it looks as follows:

public enum Status {
	OK(200, "OK"),
	CREATED(201, "Created"),
	ACCEPTED(202, "Accepted"),
	NO_CONTENT(204, "No Content"),
	MOVE_PERMANENTLY(301, "Moved Permanently"),
	SEE_OTHER(303, "See Other"),
	NOT_MODIFIED(304, "Not Modified"),
	TEMPORARY_REDIRECT(307, "Temporary Redirect"),
	BAD_REQUEST(400, "Bad Request"),
	UNAUTHORIZED(401, "Unauthorized"),
	FORBIDDEN(403, "Forbidden"),
	NOT_FOUND(404, "Not Found"),
	NOT_ACCEPTABLE(406, "Not Acceptable"),
	CONFLICT(409, "Conflict"),
	GONE(410, "Gone"),
	PRECONDITION_FAILED(412, "Precondition Failed"),
	UNSUPPORTED_MEDIA_TYPE(415, "Unsupported Media Type"),
	INTERNAL_SERVER_ERROR(500, "Internal Server Error"),
	SERVICE_UNAVAILABLE(503, "Service Unavailable");

	public enum Family {
		INFORMATION, SUCCESSFUL, REDIRECTION,
		CLIENT_ERROR, SERVER_ERROR, OTHER
	}

	public Family getFamily()

	public int getStatusCode()

	public static Status fromStatusCode(final int statusCode)
}

The ranges are:

100 - 199 : information

200 - 299: Succesful

300 - 399: Redirect

400 - 499: Client eror codes

500 - 599: server error code

An example of returning a "Already deleted" status:

@DELETE
Response delete(){
	...

	return Response.status(Status.GONE).build(); //410, gone
} 

javax.ws.rs.core.GenericEntity:

To convert typings to be a bit more Generic, we could do as follows:

@GET
@Produces("application/xml")
public Response getCustomerList(){
	List<Customer> list = new ArrayList<Customer>();
	list.add(new Customer(...));

	GenericEntity entity = new GenericEntity<List<Customer>>(list){};
	return Response.ok(entity).build();
}

The generic entity is a generic template. We simply delegate to a lambda class
and process things from there.

Exception Handling:

We can handle exceptions by either creating and returning the appropiate Response object,
or we just throw an exception.

Thrown exceptions are handled if a mapper is registered onto them. If not,
the errors are propogated to the servlet running JAX-RS.

JAX-RS also has the javax.ws.rs.WebApplicationException. It can be handeled
automaticlaly by JAX-RS.

javax.ws.rs.WebApplicationException:

public class WebApplicationException extends RuntimeException {
	
	public WebApplicationException() {...}

	public WebApplicationException(Response response) {...}

	public WebApplicationException(int status) {...}

	public WebApplicationException(Response.Status status) {...}

	public WebApplicationException(Throwable cause) {...}

	public WebApplicationException(Throwable cause, Response response) {...}

	public WebApplicationException(Throwable cause, int status) {...}

	public WebApplicationException(Throwable cause, Response.Status status) {...}

	public Response getResponse() {...}
}

An example:

@Path("/customers")
public class CustomerResource {
	
	@GET
	@Path("{id}")
	@Produces("application/xml")
	public Customer getCustomer(@PathParam("id") int id){

		Customer cust = findCustomer(id);
		if (cust == null){
			throw new WebApplicationException(Response.Status.NOT_FOUND);
		}
		return cust;
	}
}

If we did not find the customer, just throw 404

Exception Mapping:

These Exceptionmappers map exceptiosn to response objects:

public interface ExceptionMapper<E extends Throwable>
{
	Response toResponse(E exception);	
}

A common error is EntityNotFoundException, in terms of JPA (Java Persistance APIs), DB related
Server structures, where querying the thing does not exist.

We could make a ExceptionMapper for that:

@Provider
public class EntityNotFoundMapper implements ExceptionMapper<EntityNotFoundException> {
	
	public Response toResponse(EntityNotFoundException e){
		return Response.status(Response.Status.NOT_FOUND).build();
	}
}

has to be followed by provider, cause it's a Component, and it has to have the explicit type of 
Exception to map and give a REsponse for.

It inheritly maps to higher hierarchies of superclasses and goes up the chain to find out
what the SuperClass of Exception has a Mapper to it. If there is one, it uses that.

Exception Hierarchy:

In JAX-RS 2.0, we get the added benefit of Instansiatable Exceptions that derive from WebApplicationException.
An example, with the previous situation:

@Path("/customers")
public class CustomerResource{
	
	@GET
	@Path("{id}")
	@Produces("application/xml")
	public Customer getCustomer(@PathParam("id") int id){
		Customer cust = findCustomer(id);
		if(cust == null){
			throw new NotFoundException();
		}
		return cust;
	}
}

The hierarchy is pretty much as the one we expect:

Exception 				Code 			Desc

BadRequestException 	400 			Malformed message

NotAuthorizedException 	401 			Authentication failure

ForbiddenException 		403 			Not permitted to access

NotFoundException 		404 			Couldn't find resource

NotAllowedException 	405 			HTTP method not supported

NotAcceptableException 	406 			Client media type requested not supported

NotSupportedException 	415 			Client posted media type not supported

InternalServerErrorException 500 		General server error

ServiceUnavailableException 503 		Server is temporarily unavailable or busy

BadRequest can be thrown when failing to convert cookies, for instance:

@HeadParam("Custom-Header") int header;
@CookieParam("myCookie") int cookie;

If the cookie cannot be converted to int, its an exception

NotAuthorizedException is usually thrown when we make our own authentication
protocols. The 401 represents sending back a challenge header called WWW-Authenticate.

An example of constructing it:

public NotAuthorizedException(Object challenge, Object... moreChallenges) {}

For instance, if we need OAuth Bearer tokens for authentication:

throw new NotAuthorizedException("Bearer");

The client would get:

HTTP/1.1 401 Not Authorized
WWW-Authenticate: Bearer

Forbidden is a securityException. Privileges.

NotFoundException is nonexisting resource. In JAX-RS, if the runtime fails
to inject into an @PathParam, @QueryParam or @MatrixParam, it will throw this
exception.

NotAllowedException is when you try to invoked non-supported HTTP methods.

NotAcceptableException is used when the client is requesting a specific 
format through the Accept header. JAX-RS runtime can produce this if 
there is not a JAX-RS method with an @Produces annotation that is compatible
with the client's Accept header.

NotSupportedException is like above, except for Client to server.

InternalServerErrorException thrown if a MessageBodyWriter fails or if 
there is an exception thrown from an ExceptionMapper.

ServiceUnavailableException - usually for temporary downtime. Comes with
 a Retry-After header, usually. Can be retried later. Error code 503.

it has two constructors to help out:

public ServiceUnavailableException(Long retryAfter) {}
public ServiceUnavailableException(Date retryAfter) {}

Mapping default exceptions:

We can map defaulting exceptions, with a ExceptionMapper

JAX-RS Client API:

We have a Client side for JAX-RS, as well. There are others as well,
such as Apache, who have Client side APIs as well.

Client INtroduction:

A basic example of the basics of the API:

Client client = ClientBuilder.newClient();

WebTarget target = client.target("http://commerce.com/customers");

Response response = target.post(Entity.xml(new Customer("Bill", "Burke")));
response.close();

Customer customer = target.queryParam("name", "Bill Burke")
						  .request()
						  .get(Customer.class);

client.close();

In the above, we make a post request where we put in a Customer called Bill Burke,
then we run a get to aquire the new Customer.

Bootstrapping with ClientBuilder:

The java.ws.rs.client.Client interface is the main entry point into 
the JAX-RS Client API.

Client instances manage client socket connections and are pretty heavy-weight.
Reuse if possible.

An example of the package of building them:

package javax.ws.rs.client;

import java.net.URL;
import java.security.KeyStore;

import javax.ws.rs.core.Configurable;
import javax.ws.rs.core.Configuration;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLContext;

public abstract class ClientBuilder implements Configurable<ClientBuilder> {
	
	public static Client newClient() {...}
	public static Client newClient(final Configuration configuration) {...}

	public static ClientBuilder newBuilder() {...}

	public abstract ClientBuilder sslContext(final SLLContext sslContext);
	public abstract ClientBuilder keyStore(final Keystore keyStore,
										    final char[] password);

	public ClientBuilder keyStore(final KeyStore keyStore,
											final char[] password);
	public abstract ClientBuilder trustStore(final KeyStore trustStore);
	public abstract ClientBuilder hostnameVerifier(final HostnameVerifier verifier);

	public abstract Client build();
}

The easiest way to create a Client is to call ClientBuilder.newClient().
It makes a preinitialized Client that you can use right away.

To fine-tune the construction of your Client interfaces, the newBuilder() 
creates a ClientBuilder instance that allows us to register 
components and config it.

It inherits these configs from Configurable interface:

package javax.ws.rs.core;

public interface Configurable<C extends Configurable>{
	public C property(String name, Object value);

	public C register(Class<?> componentClass);

	public C register(Object component);
}

The ClientBuilder also has methods to configure SSL. We'll cover 
this in detail later.

Client client = ClientBuilder.newBuilder()
							 .property("connection.timeout", 100)
							 .sslContext(sslContext)
							 .register(JacksonJsonProvider.class)
							 .build();

We simply register a JsonProvider, assign the sslContext, assign the property

Note: Always close the client Objects. They work akin to connections. Basically
since JAX-RS is a high-level integration system of handling Connections, Streams and Sockets,
etc. So just close them to assure performance so no leaks occur.

Client and WebTarget:

Like ClientBuilder, the Client interface implements Configurable.
Meaning we can config it.

The most important purpose of Client, though, is to create WebTarget
instances:

package javax.ws.rs.client.Client;

public interface Client extends Configurable<Client>{
	
	public void close();

	public WebTarget target(String uri);
	public WebTarget target(URI uri);
	public WebTarget target(UriBuilder uriBuilder);

	public WebTarget target(Link link);
}

The WebTarget interface represents a specific URI you want to invoke on.
Through the Client interface, you can create a WebTarget using one of the
target() methods:

package javax.ws.rs.client.Client;

public interface WebTarget extends Configurable<WebTarget>{
	public URI getUri();

	public UriBuilder getUriBuilder();

	public WebTarget path(String path);
	public WebTarget resolveTemplate(String name, Object value);

	public WebTarget resolveTemplate(String name, Object value,
									boolean encodeSlashInPath);

	public WebTarget resolveTemplateFromEncoded(String name, Object value);
	public WebTarget resolveTemplates(Map<String, Object> templateValues);

	public WebTarget resolveTemplates(Map<String, Object> templateValues,
									  boolean encodedSlashInPath);

	public WebTarget resolveTemplatesFromEncoded(
									 Map<String, Object> templateValues);

	public WebTarget matrixParam(String name, Object... values);
	public WebTarget queryParam(String name, Object... values);
}

WebTarget has some cool mehods to extend the URI that we built it from.

We can add path segments or query parameters by invoking path() 
and queryParam(). If the WebTarget represents a URI template, the 
resolveTemplate() method can fill those in:

WebTarget target = client.target("http://commerce.com/customers/{id}")
						 .resolveTemplate("id", "123")
						 .queryParam("verbose", true);

WebTargets is the target of HTTP requests, and is a smoother way of building
than building pure URIs.

Building and Invoking Requests:

Once you have a WebTarget that represents the exact URI you want to invoke on,
you can begin building and invoking HTTP requests through one of it's request() methods:

public interface WebTarget extends Configurable<WebTarget> {
	
	public Invocation.Builder request();
	public Invocation.Builder request(String... acceptedResponseTypes);
	public Invocation.Builder request(MediaType... acceptedResponseTypes);
}

The Invocation.Builder is a bit convoluted, but a bit of it is here:

package javax.ws.rs.client;

public interface Invocation {
	...
		public interface Builder extends SyncInvoker, Configurable<Builder>{
			...
			public Builder accept(String... types);
			public Builder accept(MediaType... types);
			public Builder acceptLanguage(Locale... locales);

			public Builder acceptLanguage(String... locales);
			public Builder acceptEncoding(String... encodings);

			public Builder cookie(Cookie cookie);
			public Builder cookie(String name, String value);

			public Builder cacheControl(CacheControl cacheControl);
			public Builder header(String name, Object value);
			public Builder headers(MultivaluedMap<String, Object> headers);
		}
}

The accept methods of variation kind, is for content negotiation.

The cookie is for setting cookies to return to the server.

Then there is header and headers to cover creating headers and header fields.

After setting the headers that we require, we can retrieve the data 
with getters:

<T> T get(Class<T> responseType);
<T> T get(GenericType<T> responseType);

Response get();

the first two generic getters convers successful HTTP requests to Java types.
An example:

Customer customer = client.target("http://commerce.com/customers/123")
						  .accept("application/json")
						  .get(Customer.class);

List<Customer> customer = client.target("http://commerce.com/customers")
								.accept("application/xml")
								.get(new GenericType<List<Customer>>() {});

The first one accepts json and converts it.

The second one utilizes Lambda assignment of the Generic class and assign the info into it.

There's also a get() method that returns a Response object. 
it is the same Response class that is on the server side.

import java.ws.rs.core.Response;

Response response = client.target("http://commerce.com/customers/123")
						  .accept("application/json")
						  .get();

try {
	if (response.getStatus() == 200){
		Customer customer = response.readEntity(Customer.class);
	}
} finally {
	response.close();
}

In this example, we run a get for json. See what the response code is. If it is 200, read it.
readEntity matches the class with a appropiate MessageBodyReader.

To read from teh response more than once, declare the Entity as being a bufferEntity:

Response response = client.target("http://commerce.com/customers/123")
						  .accept("application/json")
						  .get();
try{
	if (response.getStatus() == 200){
		response.bufferEntity();
		Customer customer = response.readEntity(Customer.class);
		Map rawJson = response.readEntity(Map.class);
	}
} finally {
	response.close();
}

As per normal, close response instances.

As per normal, only one response per Client object. This is the downfall of JAX-RS.
The ease of which readers specify ourselves, is not worth the cost.
We could easily read the formats and make our own parses combined with our own
server structure.

The biggest hindrance would be to handle WAR files. Figure out way to write handler
for own WAR files? Perhaps. Or just use GlassFish for that? Hm. 

put and post are similar, but also specify an entity:

<T> T put(Entity<?> entity, Class<T> responseType);
<T> T put(Entity<?> entity, GenericType<T> responseType);
<T> T post(Entity<?> entity, Class<T> responseType);
<T> T post(Entity<?> entity, GenericType<T> responseType);

Response post(Entity<?> entity);
Response put(Entity<?> entity);

The Entity class encapsulates the java object we want to send with POST or GET 
request:

package javax.ws.rs.client;

public final class Entity<T> {
	public Variant getVariant() {}

	public MediaType getMediaType() {...}

	public String getEncoding() {...}

	public Locale getLanguage() {...}

	public T getEntity() {...}

	public Annotation[] getAnnotations() {}
}

An entity is basically like a object. Except it can represent XML, forms, json, whatever, really.

it does not have a public constructor, you must invoke them with a respective method.

package javax.ws.rs.client;

public final class Entity<T>{
	public static <T> Entity<T> xml(final T entity) {...}

	public static <T> Entity<T> json(final T entity) {...}

	public static Entity<Form> form(final Form form) {...}
}

json and xml are defaulted to just being able to be converted in by originating from
a Java class object. the form() method needs a Form object.

An example:

Customer customer = new Customer("Bill", "Burke");
Response response = client.target("http://commerce.com/customers")
						  .request().(? Typo?)
						  .post(Entity.json(customer));

response.close();

The above sets the content-type header to json.

to submit form params, we must use the Form class:

package javax.ws.rs.core;

public class Form {
	public Form() {...}
	public Form(final String parameterName, final String parameterValue) {...}

	public Form(final MultivaluedMap<String, String> store) {...}
	public Form param(final String name, final String value) {...}

	public MultivaluedMap<String, String> asMap() {...}
}

This class represents application/x-www-form-urlencoded in a request.
Here's an exampel of it in use:

Form form = new Form().param("first", "Bill")
					  .param("last", "Burke");

response = client.target("http://commerce.com/customers")
				 .request(). (Again? Typo?)
				 .post(Entity.form(form));

response.close();

Invocation:

The previous example is one way of invocating stuff, using the client API.
However, we can manually make invocations and call them later:

public interface Invocation {
	public interface Builder extends SyncInvoker, Configurable<Builder> {
		Invocation build(String method);
		Invocation build(String method, Entity<?> entity);

		Invocation buildGet();
		Invocation buildDelete();

		Invocation buildPost(Entity<?> entity);
		Invocation buildPut(Entity<?> entity);
	}
}

To invoke these invokations, simply call the invoke() of Invocation:

package javax.ws.rs.client;

public interface Invocation {
	public Response invoke();

	public <T> T invoke(Class<T> responseType);
	public <T> T invoke(GenericType<T> responseType);
}

Having these in a manual invocation format, means we can build structures
around them doing cronjobs. Example:

Invocation generateReport = client.target("http://commerce.com/orders/report")
								  .queryParam("start", "now - 5 minutes")
								  .queryParam("end", "now")
								  .request()
								  .accept("application/json")
								  .buildGet();

while (true) {
	Report report = generateReport.invoke(Report.class);
	renderReport(report);
	Thread.sleep(300000);
}

The above example runs a pre-built get request and then re-renders it every 5 minutes.

Exception Handling:

Not all exceptions are automatically handeled by the unmarshalling and marshalling 
system. For example, to handle normal errors such as 404 and NotAcceptAble responses,
just try and catch them.

When 3xx Redirection exceptions occur, we have to manually handle them. An example:

WebTarget target = client.target("http://commerce.com/customers/123");
boolean redirected = false;

Customer customer = null;
do{
	try{
		customer = target.accept("application/json")
							  .get(Customer.class);
	} catch (RedirectionException redirect) {
		if (redirected) throw redirect;
		redirected = true;

		target = client.target(redirect.getLocation());
	}
} while (customer == null);

Above we just use a sentry flag to check for redirection occurances
and run redirection to the target if redirection occured.

We can further expand it to handle other errors as well.

Configuration Scopes:

ClientBuilder, Client, Webtarget, Invocation and Invocation.Builder all
implement the Configurable interface.

We can override previous client attributes if we wish:

Client client = ClientBuilder.newBuilder()
							 .property("authentication.mode", "Basic")
							 .property("username", "bburke")
							 .property("password", "geheim")
							 .build();

WebTarget target1 = client.target("http://facebook.com");
WebTarget target2 = client.target("http://google.com")
						  .property("username", "wburke")
						  .register(JacksonJsonProvider.class);

The above example simple uses another username for google and registers
a JSON parser to it.

HTTP Content Negotation:

Content negotation, or Conneg as is, allows for specification against 
many different forms of Data and interaction against servers.

Such as encodings, Data types (YAML (Ruby), XML, Json) etc.

Conneg Explained:

The first part of HTTP negotiation is the Accept header. It can contain wildcards.

GET http://example.com/stuff
Accept: application/xml, application/json

An example of wilcarding:

GET http://example.com/stuff
Accept: text/*, text/html;levle=1

Preference Ordering:

Preference ordering can occur on a float 0.1 to 1.0 or just 1.

Setting a level is the highest predecence in combo with a specified type.
Beyond that, it resolves after specificity:

Assume the header of:

GET http://example.com/stuff
Accept: text/*, text/html;level=1, */*, application/xml

1. text/html;level=1

2. application/xml

3. text/*

4. */*

Another example:

GET http://example.com/stuff
Accept: text/*;q=0.9, */*;q=.01, audio/mpeg, application/xml;q=0.5

NOTE: If no value is given, it is presumed to be 1.

thus, the ordering is:

audio/mpeg

text/*

application/xml

*/*

Language Negotiation:

HTTP Content Negotiation also includes a simple protocol to negotiation
languages:

GET http://example.com/stuff
Accept-Language: en-us, es, fr

The two digits way is the ISO-639 standard. You can further identify by virtue
of the ISO-3166 country protocol. 

Again, preferences and "defaults", can be set: //The lowest value is the defaulting

GET http://example.com/stuff
Accept-Language: fr;q=1.0, es;q=1.0, en=0.1

Encoding Negotiation:

Clients can also run negotiations on encodings of the message body.

As per usual, we can run with preferences. THe most common encoding type is GZIP:

GET http://example.com/stuff
Accept-Encoding: gzip, deflate

And we can run with preferences:

GET http://example.com/stuff
Accept-Encoding: gzip;q=1.0, compress;0.5; deflate;q=0.1

When a client or a server encodes a message body, it must set the
Content-Encoding header. For purpose of communicating the encoding format.

JAX-RS and Conneg:

There are a number of negotiation APIs that allow for multiple decision points.

Method Dispatching:

Based on predecence, it defiens what it should return and what it should select:

@Path("/customers")
public class CustomerResource {
	
	@GET
	@Path("{id}")
	@Produces("application/xml")
	public Customer getCustomerXml(@PathParam("id") int id) {...}

	@GET
	@Path("{id}")
	@Produces("text/plain")
	public String getCustomerText(@PathParam("id") int id) {...}

	@GET
	@Path("{id}")
	@Produces("application/json")
	public Customer getCustomerJson(@PathParam("id") int id) {...}
}

We can conclude what will be chosen of these, based on predecence of the 
preferential in the Accept Header:

GET http://example.com/customers/1
Accept: application/json;q=1.0, application/xml;q=0.5

Leveraging Conneg with JAXB:

If we wish, we can create multiple options for returnal of objects:

@Path("/service")
public class MyService{
	@GET
	@Produces({"application/xml", "application/json"})
	public Customer getCustomer(@PathParam("id") int id) {...}
}

The above code allows for returnal of either xml or JSON.

Complex Negotiation:

To perform complex negotiation, we must look at the info manually.

Viewing Accept headers:

public interface HttpHeaders {
	public List<MediaType> getAcceptableMediaTypes();

	public List<Locale> getAcceptableLanguages();
}

Both of these return what you expect them to.

@Path("/myservice")
public class MyService{
	
	@GET
	public Response get(@Context HttpHeaders headers){
		MediaType type = headers.getAcceptableMediaTypes().get(0);
		Locale language = headers.getAcceptableLanguages().get(0);

		Object responseObject = ...;

		Response.ResponseBuilder builder = Response.ok(responseObject, type);
		builder.language(language);

		return builder.build();
	}
}

In the above code, we build a response with the given type and languages, retrieving
the first element of the list. The lists are sorted after explicit or implicit q values.

Variant Processing:

To perform more complex mapping, we can use Request and Variant.

The following is the Variant class.

package javax.ws.rs.core.Variant

public class Variant {
	
	public Variant(MediaType mediaType, Locale language, String encoding) {...}

	public Locale getLanguage() {...}

	public MediaType getMediaType() {...}

	public String getEncoding() {...}
}

A variant is a object that contains one of each type, as we can see.

Request, has a selectVariant to choose one from the listing:

package javax.ws.rs.core.Request

public interface Request {
	Variant selectVariant(List<Variant> variants) throws IllegalArgumentException;
}

the selectVariant choses the most matching one, with explicit > less explicit.
It returns null if none of the variants matches the accept headers.

An example of using it:

@Path("/myservice")
public class MyService{
	
	@GET
	Response getSomething(@Context Request request){
		List<Variant> variants = new ArrayList<Variant>();

		variants.add(new Variant(MediaType.APPLICATION_XML_TYPE, "en", "deflate"));

		variants.add(new Variant(MediaType.APPLICATION_XML_TYPE, "es", "deflate"));

		variants.add(new Variant(MediaType.APPLICATION_JSON_TYPE, "en", "deflate"));

		variants.add(new Variant(MediaType.APPLICATION_JSON_TYPE, "es", "deflate"));

		variants.add(new Variant(MediaType.APPLICATION_XML_TYPE, "en", "gzip"));

		variants.add(new Variant(MediaType.APPLICATION_XML_TYPE, "es", "gzip"));

		variants.add(new Variant(MediaType.APPLICATION_JSON_TYPE, "en", "gzip"));

		variants.add(new Variant(MediaType.APPLICATION_JSON_TYPE, "es", "gzip"));

		//Pick the variant
		Variant v = request.selectVariant(variants);
		Object entity = ...; //Get the object you want to return

		ResponseBuilder builder = Response.ok(entity);
		builder.type(v.getMediaType())
			   .language(v.getLanguage())
			   .header("Content-Encoding", v.getEncoding());

		return builder.build();
	}
}

We can circumvent the need of long code by virtue of the VariantListBuilder:

public static abstract class VariantListBuilder {
	
	public static VariantListBuilder newInstance() {...}

	public abstract VariantListBuilder mediaTypes(MediaType... mediaTypes);

	public abstract VariantListBuilder languages(Locale... languages);

	public abstract VariantListBuilder encodings(String... encodings);

	public abstract List<Variant> build();

	public abstract VariantListBuilder add();
}

By this, we can add languages, encodings, types, etc.

An example:

@Path("/myservice")
public class MyService{
	@GET
	Response getSomething(@Context Request request){

		Variant.VariantListBuilder vb = Variant.VariantListBuilder.newInstance();
		vb.mediaTypes(MediaType.APPLICATION_XML_TYPE, 
						MediaType.APPLICATION_JSON_TYPE)
		  .languages(new Locale("en"), new Locale("es"))
		  .encodings("deflate", "gzip").add();

		List<Variant> variants = vb.build();

		//Pick the variant
		Variant v = request.selectVariant(variants);
		Object entity = ...; //Get the object you want to return

		ResponseBuilder builder = Response.ok(entity);
		builder.type(v.getMediaType())
			   .language(v.getLanguage())
			   .header("Content-Encoding", v.getEncoding());

		return builder.build();
	}
}

To delimit between sets, diffrentiate with add():

Variant.VariantListBuilder vb = Variant.VariantListBuilder.newInstance();
vb.mediaTypes(MediaType.APPLICATION_XML_TYPE,
				   MediaType.APPLICATION_JSON_TYPE)
  .languages(new Locale("en"), new Locale("es"))
  .encodings("deflate", "gzip")
  .add()

  .mediaTypes(MediaType.TEXT_PLAIN_TYPE)
  .languages(new Locale("en"), new Locale("es"), new Locale("fr"))
  .encodings("compress")

Negotiation by URI Patterns:

Conneg is cool, but some clients, specifically browsers, don't support it.

For example firefox hardcodes the Accept header it sends to the web
server it connects to as follows:

text/html, application/xhtml+xml, application/xml;q=0.9,*/*;q=0.8

if you wanted to view a JSON representation of a specific URI through
your browser, you would not be able to if JSON is not one of the preferred 
formats that your browser is hardcoded to accept.

A common pattern is to include such in the URI instead of passing it with an Accept header:

/customers/en-US/xml/3323
/customers/3323.xml.en-US

We could model this in the @Path URI:

@Path("/customers/{id}.{type}.{language}")
@GET
public Customer getCustomer(@PathParam("id") int id,
				  @PathParam("type") String type,
				  @PathParam("language") String language) {...}

By virtue of mapping media types to types, we could extract file types
in teh URI from the Path:

@Path("/customers")
public class CustomerResource{
	
	@GET
	@Produces("application/xml")
	public Customer getXml() {...}

	@GET
	@Produces("application/json")
	public Customer getJson() {...}
}

if the GET request of /customer.json came in, it would run the getJson(),
assuming it was mapped like that.

Leveraging Content Negotiation:

To account for evolving data types, we can use Conneg.

Creating New Media Types:

To denote our own type, we have to access the vendor class with a 
specific naming that we want:

application/vnd.rht.customers+xml

We could do the same for json:

application/vnd.rht.customers+json

We can also append version numbers to account for what version we need to apply.

application/vnd.rht.customers+xml;version=1.0

Flexible Schemas:

We should make flexbile schemas. An example:

<schema targetNamespace="http://www.example.org/customer"
		   xmlns="http://www.w3.org/2001/XMLSchema">
	<element name="customer" type="customerType"/>
	<complexType name="customerType">
		<attribute name="id" use="required" type="string"/>
		<anyAttribute/>
		<element name="first" type="string" minOccurs="1"/>
		<element name="last" type="string" minOccurs="1"/>
		<any/>
	</complexType>
</schema>

The above structure defines what kind of elements must occur at least once.
We can say that we want to have so that something is optional:

<schema targetNamespace="http://www.example.org/customer"
		   xmlns="http://www.w3.org/2001/XMLSchema">
	<element name="customer" type="customerType"/>
	<complexType name="customerType">
		<attribute name="id" use="required" type="string"/>
		<anyAttribute/>
		<element name="first" type="string" minOccurs="1"/>
		<element name="last" type="string" minOccurs="1"/>
		<element name="street" type="string" minOccurs="0"/>
		<element name="city" type="string" minOccurs="0"/>
		<element name="state" type="string" minOccurs="0"/>
		<element name="zip" type="string" minOccurs="0"/>
		<any/>
	</complexType>
</schema>

HATEOAS:

Hypermedia As The Engine of Application State. Simply use HTML as a way to
set states by HTML links.

These can be through links (Documents), or change a state of a specific thing
on the server by way of forms.

HATEOAS and Web Services:

We could use plain URLs, but we shall use Atom to insert stuff into our XMLs:

<customers>
	<link rel="next"
		href="http://example.com/customers?start=2&size=2"
		type="application/xml"/>
	<customer id="123">
		<name>Bill Burke</name>
	</customer>
	<customer id="332">
		<name>Roy Fielding</name>
	</customer>
</customers>

The atom link, consists of a few predictable attributes:

rel:

Relation of the link. It denotes what kind of relation the link has. 

href:

the actual URI

type:

The type of data expected to be processed

hreflang:

The language of the data translated to. can be any of the languages, English,
German and Spanish, etc.

When a client receives a document with embedded Atom links, it looks up the
relationship it is interested in and invokes the URI embedded within the href
link attribute.

Advantages of Using HATEOAS with Web Services:

Location Transparency:

Easier to use URIs to process links.

Decoupling interaction details:

Allocate state transition such as access to DB in the URI in the XML.

An example:

<customers>
	<link rel="next"
		href="http://example.com/customers?start=2&size=2"
		type="application/xml"/>
		<customer id="123">
			<name>Bill Burke</name>
		</customer>
		<customer id="332">
			<name>Roy Fielding</name>
		</customer>
</customers>

Reduced state transition errors:

Another scenario, would be where a person has the following structure
of a order:

<order id="333">
	<customer id="123">...</customer>
	<amount>$99.99</amount>
	<order-entries>
		....
	</order-entries>
</order>

Assume someone cancelled this order. Deleting it plain and simple,
would be kinda stupid. We might do a PUT insteaD:

PUT /orders/333 HTTP/1.1
Content-Type: application/xml

<order id="333">
	<customer id="123">...</customer>
	<amount>$99.99</amount>
	<cancelled>true</cancelled>
	<order-entries>
		...
	</order-entries>
</order>

If it cannot be cancelled per say, we can't give a HTTP status
code to send back. 

We could, however, embed a cancel link:

<order id="333">
	<customer id="123">...</customer>
	<amount>$99.99</amount>
	<cancelled>false</cancelled>
	<link rel="cancel"
			href="http://example.com/orders/333/cancelled"/>
	<order-entries>
		...
	</order-entries>
</order>

to then cancel the order, just send a empty POST or PUT to the URI referenced.

W3C standardized relationships:

There are some standardizations of links. An example list:

Relationship 				Description

previous 					A URI that refers to the immediately preceding document in a series of documents

next 						A URI that refers to the immediately following document in a series of documents

edit 						A URI that can be retrieved, updated and deleted.

payment 					A URI where payment is accepted. It is meant as a general way to facilitate acts of
							payment.

Link Headers versus Atom Links:

we can also simply add a Link header to our HTTP response:

HTTP/1.1 200 OK
Content-Type: application/xml
Link: <http://example.com/orders/333/cancelled>; rel=cancel

<order id="333">
	...
</order>

Also, this allows you to do a HEAD request instead of a GET to parse the whole document.

HATEOAS and JAX-RS:

JAX-RS does not supply many facilities to help with HATEOAS. It's done in the app.
However, there are helper classes that you can use to build the URIs that you link 
to in your data formats.

Building URIs with UriBuilder:

The UriBuilder allows you to build URIs, piece by piece:

public abstract class UriBuilder {
	public static UriBuilder fromUri(URI uri) throws IllegalArgumentException

	public static UriBuilder fromUri(String uri) throws IllegalArgumentException

	public static UriBuilder fromPath(String path) throws IllegalArgumentException

	public static UriBuilder fromResource(Class<?> resource) throws IllegalArgumentException

	public static UriBuilder fromLink(Link link) throws IllegalArgumentException

UriBuilder instances can only be spawned from the static helper methods listed.

They can be initialized by a URI, path, or the @Path annotation of a JAX-RS resource class:

public abstract UriBuilder clone();

public abstract UriBuilder uri(URI uri) throws IllegalArgumentException;

public abstract UriBuilder scheme(String scheme) throws IllegalArgumentException;

public abstract UriBuilder schemeSpecificPart(String ssp) throws IllegalArgumentException;

public abstract UriBuilder userInfo(String ui);

public abstract UriBuilder host(String host) throws IllegalArgumentException;

public abstract UriBuilder port(int port) throws IllegalArgumentException;

public abstract UriBuilder replacePath(String path);

public abstract UriBuilder path(String path) throws IllegalArgumentException;

public abstract UriBuilder path(Class resource) throws IllegalArgumentException;

public abstract UriBuilder path(Class resource, String method) throws IllegalArgumentException;

public abstract UriBuilder path(Method method) throws IllegalArgumentException;

public abstract UriBuilder segment(String... segments) throws IllegalArgumentException;

public abstract UriBuilder replaceMatrix(String matrix) throws IllegalArgumentException;

//etc, might have missed one or two.

to then build them:

public abstract URI buildFromMap(Map<String, ? extends Object> values) throws IllegalArgumentException,
			  UriBuilderException;

public abstract URI buildFromEncodedMap(Map<String, ? extends Object> values) throws IllegalArgumentException,
			  UriBuilderException;

public abstract URI build(Object... values) throws IllegalArgumentException, UriBuilderException;

public abstract URI buildFromEncoded(Object... values) throws IllegalArgumentException, UriBuilderException;

An example of using the builder to build a URI:

UriBuilder builder = UriBuilder.fromPath("/customers/{id}");
builder.scheme("http")
	   .host("{hostname}")
	   .queryParam("param={param}");

The URI pattern is as follows:

http://{hostname}/customers/{id}?param={param}

To reuse it, clone the Builder:

UriBuilder clone = builder.clone();
URI uri = clone.build("example.com", "333", "value");

It creates:

http://example.com/customers/333?param=value

We can also make a map to define the template vals:

Map<String, Object> map = new HashMap<String, Object>();
map.put("hostname", "example.com");
map.put("id", 333);
map.put("param", "value");

UriBuilder clone = builder.clone();
URI uri = clone.buildFromMap(map);

We could also make a URI by the @Path notation:

@Path("/customers")
public class CustomerService{
	
	@Path("{id}")
	public Customer getCustomer(@PathParam("id") int id) {...}
}

We can then build a URI out of the class:

UriBuilder builder = UriBuilder.fromResource(CustomerService.class);
builder.host("{hostname}")
builder.path(CustomerService.class, "getCustomer");

This would make the pattern:

http://{hostname}/customers/{id}

we can then build a URI from it with one of the other build() calls.

The build(Object...) and build(Map<String, ?>) encode / chars:

URI uri = UriBuilder.fromUri("/{id}").build("a/b");

It would result in:

/a%2Fb

Thus, two new builds came along in JAX-RS 2.0:

public abstract URI build(Object[] values, boolean encodeSlashInPath) throws IllegalArgumentException,
			UriBuilderException

public abstract URI buildFromMap(Map<String, ?> values, boolean encodeSlashInPath) throws IllegalArgumentException,
			UriBuilderException

if you set the encodeSlashInpath to false, they will not be encoded.

We can also choose to aprtially resolve templating to return it in a resolved state:

public abstract UriBuilder resolveTemplate(String name, Object value);

public abstract UriBuilder resolveTemplate(String name, Object value,
											boolean encodeSlashInPath);

public abstract UriBuilder resolveTemplateFromEncoded(String name,
													  Object value);

public abstract UriBuilder resolveTemplates(Map<String, Object> templateValues);

public abstract UriBuilder resolveTemplates(Map<String, Object> templateValues, boolean encodeSlashInPath)
		throws IllegalArgumentException;

public abstract UriBuilder resolveTemplatesFromEncoded(Map<String, Object> templateValues);

They work to partially resolve URIs. An example:

String original = "http://{host}/{id}";
String newTemplate = UriBuilder.fromUri(original)
					 .resolveTemplate("host", "localhost")
					 .toTemplate();

Relative URIs with UriInfo:

To get the base URI, use the UriInfo interface:

public interface UriInfo {
	public URI getRequestUri();
	public UriBuilder getRequestUriBuilder();

	public URI getAbsolutePath();
	public UriBuilder getAbsolutePathBuilder();

	public URI getBaseUri();
	public UriBuilder getBaseUriBuilder();
}

An example of invoking the GET request with UriBuilder:

@Path("/customers")
public class CustomerService{
	
	@GET
	@Produces("application/xml")
	public String getCustomers(@Context UriInfo uriInfo){
		UriBuilder nextLinkBuilder = uriInfo.getAbsolutePathBuilder();

		nextLinkBuilder.queryParam("start", 5);
		nextLinkBuilder.queryParam("size", 10);
		URI next = nextLinkBuilder.build();

		... Set up the rest
	}
}

The uri might return to look as per:

http://example.com/jaxrs/customer?start=5&size=10

To relativilize the URI, just call relativize(URI uri);

You can also resolve URIs with respect to the base URI of your 
JAX-RS using resolve():

public URI resolve(URI uri);

It is the same as per calling uriInfo.getBaseURI().resolve(uri)

We can match against partial URIs with getMatchedURIs():

public interface UriInfo{
	public List<String> getMatchedURIs();
	public List<String> getMatchedURIs(boolean decode);
}

Thus, let's take the base example of handling sub resources:

@Path("/customers")
public class CustomerDatabaseResource {
	@Path("{database}-db")
	public CustomerResource getDatabase(@PathParam("database") String db){
		Map map = ...; //Find the db based on the db param
		return new CustomerResource(map);
	}
}

CustomerDatabaseResource is the sub-resource locator. We could
print out the matching URIs, by virtue of the getMatchedUris:

public class CustomerResource{
	private Map customerDB;

	public CustomerResource(Map db){
		this.customerDB = db;
	}

	@GET
	@Path("{id}")
	@Produces("application/xml")
	public StreamingOutput getCustomer(@PathParam("id") int id, @Context UriInfo uriInfo){
		for(String uri : uriInfo.getMatchedURIs()){
			System.out.println(uri);
		}
	}
}

If the get request was: GET http://example.com/customers/usa-db/333, the output would be:

http://example.com/customers
http://example.com/customers/usa-db
http://example.com/customers/usa-db/333

Then there is getMatchedResources:

public interface UriInfo{
	public List<Object> getMatchedResources();
}

This allows us to access the objects that were used to serve the request:

public class CustomerResource{
	private Map customerDB;

	publlic CustomerResource(Map db){
		this.customerDB = db;
	}

	@GET
	@Path("{id}")
	@Produces("application/xml")
	public StreamingOutput getCustomer(@PathParam("id") int id,
										@Context UriInfo uriInfo){
		for(Object match : uriInfo.getMatchedResources()){
			System.out.println(match.getClass().getName());
		}
	}
}

Assuming the same request as before with: GET http://example.com/customers/usa-db/333,
we'd get:

com.acme.CustomerDatabaseResource

com.acme.CustomerResource

Building Links and Link Headers:

JAX-RS 2.0 added support for building Link headers and embedding links in 
XML documents through Link and Link.Builder classes:

package javax.ws.rs.core;

public abstract class Link{
	public abstract URI getUri();

	public abstract UriBuilder getUriBuilder();

	public abstract String getRel();

	public abstract List<String> getRels();

	public abstract String getTitle();

	public abstract String getType();

	public abstract Map<String, String> getParams();

	public abstract String toString();
}

Link is the representation of the link headers or Atom links.
The getUri() is the href of the Atom links.

getRel() is the rel attribute and so on.

We can get all through the getParams();

we can convert links into Link headers with toString();

to build links, you need to get a instance of the Link.Builder, which is done
by one of the following methods:

public abstract class Link{
	public static Builder fromUri(URI uri)

	public static Builder fromUri(String uri)

	public static Builder fromUriBuilder(UriBuilder uriBuilder)

	public static Builder fromLink(Link link)

	public static Builder fromPath(String path)

	public static Builder fromResource(Class<?> Resource)

	public static Builder fromMethod(Class<?> resource, String method)

Further more, if we put in the Builder interface we can override attributes:

public abstract Link interface Builder {
	public Builder link(Link link);
	public Builder link(String link);
	public Builder uri(URI uri);
	public Builder uri(String uri);
	public Builder uriBuilder(UriBuilder uriBuilder);

	The above methods allows for overwriting of underlying URIs.

	public Builder rel(String rel);
	public Builder title(String title);
	public Builder type(String type);
	public Builder param(String name, String value);

	And finally, the build:

	public Link build(Object... values);


}
}

An example of building a link would be:

Link link = Link.fromUri("http://{host}/root/customers/{id}")
				.rel("update").type("text/plain")
				.build("localhost", "1234");

calling toString() will get us:

<http://localhost/root/customers/1234>; rel="update"; type="text/plain"

We can also build relativized URIs if we wish. Will not include that here.

To build a link header:

@Path
@GET
Response get(){
	Link link = Link.fromUri("a/b/c")build();
	Response response = Response.noContent()
								.links(link)
								.build();
	return response;
}

Embedding Links in XML:

We can also embed links within JAXB classes. For example, let's take our familiar Customer
domain class and enable it to add one or more embedded links:

import javax.ws.rs.core.Link;

@XmlRootElement
public class Customer{
	private String name;
	private List<Link> links = new ArrayList<Link>();

	@XmlElement
	public String getName()
	{
		return name;
	}

	public void setName(String name)
	{
		this.name = name;
	}

	@XmlElement(name = "link")
	XmlJavaTypeAdapter(Link.JaxbAdapter.class)
	public List<Link> getLinks()
	{
		return links;
	}
}

Scaling JAX-RS apps:

Caching:

We can cache either normally in our own websites or use Proxy caches, which is like
a middleman of caching, basically. A psuedo-webserver that contains info for
the real servers.

We should cache either static or highly frequent accessed things.

HTTP Caching:

Expires Header:

An example of a expires header:

HTTP/1.1 200 OK
Content-Type: application/xml
Expires: Tue, 15 May 2014 16:00 GMT

//data

An example of building this:

@Path("/customers")
public class CustomerResource{
	@Path("{id}")
	@GET
	@Produces("application/xml")
	public Response getCustomer(@PathParam("id") int id){
		Customer cust = findCustomer(id);
		ResponseBuilder builder = Response.ok(cust, "application/xml");
		Date date = Calendar.getInstance(TimeZone.getTimeZone("GMT"))
							.set(2010, 5, 15, 16, 0);

		builder.expires(date);
		return builder.build();
	}
}

Cache-Control:

The expirs header is deprecated. What follows are the attributes of the Cache-Control
we should use:

private:

Does not allow for CDN or proxies to cache the data. Only the client can.

public:

May be cached by any entity within the request/response chain

no-cache:

Preference of not caching. If cached anyway, should revalidate with the server.

no-store:

Browsers cache data on disks. This turns that off, so that neither proxy or browser will do so.

no-transform:

Prevents compression of data formats and transformations

max-age:

How long the time is left until expiration in seconds. If both an
Expires header and max-age dir is present, then max-age > Expires.

s-maxage:

Expiration timer for intermediate (Shared) caches, like proxies.

A simple example of Cache-Control:

HTTP/1.1 200 OK
Content-Type: application/xml
Cache-Control: private, no-store, max-age=300

The Cache-Control header is represented by a CacheControl object:

public class CacheControl{
	public CacheControl() {...}

	public static CacheControl valueOf(String value) throws IllegalArgumentException {...}

	public boolean isMustRevalidate() {...}

	public void setMustRevalidate(boolean mustRevalidate) {...}

	public boolean isProxyRevalidate() {...}

	public void setProxyRevalidate(boolean proxyRevalidate) {...}

	public int getMaxAge() {...}

	public void setMaxAge(int maxAge) {...}

	public void setSMaxAge() {...}

	public int getSMaxAge() {...}

	public List<String> getNoCacheFields() {...}

	public void setNoCache(boolean noCache) {...}

	public boolean isNoCache() {...}

	public boolean isPrivate() {...}

	public List<String> getPrivateFields() {...}

	public void setPrivate(boolean _private) {...}

	public boolean isNoTransform() {...}

	public void setNoTransform(boolean noTransform) {...}

	public boolean isNoStore() {...}

	public void setNoStore(boolean noStore) {...}

	public Map<String, String> getCacheExtension() {...}
}

The ResponseBuilder class has a method called cacheControl() that can
accept a CacheControl object:

@Path("/customers")
public class CustomerResource{
	@Path("{id}")
	@GET
	@Produces("application/xml")
	public Response getCustomer(@PathParam("id") int id){
		Customer cust = findCustomer(id);

		CacheControl cc = new CacheControl();
		cc.setMaxAge(300);
		cc.setPrivate(true);
		cc.setNoStore(true);

		ResponseBuilder builder = Response.ok(cust, "application/xml");
		builder.cacheControl(cc);
		return builder.build();
	}
}

Revalidation and Conditional GETs:

To revalidate, just get the Last-Modified and/or a ETag header.

Last-Modified:

An example of a Last-Modified field:

HTTP/1.1 200 OK
Content-Type: application/xml
Cache-Control: max-age=1000
Last-Modified: Tue, 15 May 2013 09:56 EST

After the max-age passes, it can do a conditional GET to revalidate the cache´, with a 
If-Modified-Since header:

GET /customers/123 HTTP/1.1
If-Modified-Since: Tue, 15 May 2013 09:56 EST

If the resource has been modified since, a new representation of the resource is returned.
Otherwise, it will respond with a 304, "Not Modified".

In both cases, the server should send an updated Cache-Control and Last-Modified
header if appropiate.

ETag:

ETags work as psuedo-ID MD5 Hashes. An example:

HTTP/1.1 200 OK
Content-Type: application/xml
Cache-Control: max-age=1000
ETag: "<value>"

When it revalidated after 1000 seconds, it looks at the If-None-Match header:

GET /customers/123 HTTP/1.1
If-None-Match: "<value>"

It tries to match the current ETag hash of the resource with the one provided
within the If-None-Match header.

If the tags don't match, we get a 200 respone with the new resource representation.
Otherwise, we get a 304, not modified, and no new resource.

Etags come in two flavors. STrong and Weak. Weak ones are used for when larger semantic
changes occur, and are followed by a /W. Strong, is when any bit has changed.

An example of a Weak ETag:

HTTP/1.1 200 OK
Content-Type: application/xml
Cache-Control: max-age=1000
ETag: W/"<String>"

The class for the EntityTag:

public class EntityTag{
	public EntityTag(String value) {...}
	public EntityTag(String value, boolean weak) {...}

	public static EntityTag valueOf(String value) throws IllegalArgumentException {...}

	public boolean isWeak() {...}

	public String getValue() {...}
}

They do what you expect them to.

JAX-RS and conditional GETs:

To help with conditional GETs, JAX-RS provides an injectable helper
class called javax.ws.rs.core.Request:

public interface Request {
	...

	ResponseBuilder evaluatePreconditions(EntityTag eTag);
	ResponseBuilder evaluatePreconditions(Date lastModified);
	ResponseBuilder evaluatePreconditions(Date lastModified, EntityTag eTag);
}

An example of matching ETags: //Not the best way

@Path("/customers")
public class CustomerResource{
	@Path("{id}")
	@GET
	@Produces("application/xml")
	public Response getCustomer(@PathParam("id") int id,
								 @Context Request request){
		Customer cust = findCustomer(id);

		EntityTag tag = new EntityTag(Integer.toString(cust.hashCode()));

		CacheControl cc = new CacheControl();
		cc.setMaxAge(1000);

		ResponseBuilder builder = request.evaluatePreconditions(tag);
		if (builder != null){
			builder.cacheControl(cc);
			return builder.build();
		}

		//Preconditions not met

		builder = Response.ok(cust, "application/xml");
		builder.cacheControl(cc);
		builder.tag(tag);
		return builder.build();
	}
}

Concurrency:

To account for concurrency, we can do conditional PUTs and POSTs:

PUT /customers/123 HTTP/1.1
If-Match: "<string>"
If-Unmodified-Since: Tue, 15 May 2013 09:56 EST
Content-Type: application/xml

If the precondition failed, it returns 412 error response.

JAX-RS and Conditional Updates:

to do conditional with JAX-RS, use evalutePreconditions:

@Path("/customers")
public class CustomerResource{
	@Path("{id}")
	@PUT
	@Consumes("application/xml")
	public Response updateCustomer(@PathParam("id") int id,
									@Context Request request,
									 Customer update){
		Customer cust = findCustomer(id);

		EntityTag tag  = new EntityTag(Integer.toString(cust.hashCode()));

		Date timestamp = ...; //Get the timestamp

		ResponseBuilder builder = request.evaluatePreconditions(timestmap, tag);

		if (builder != null){
			return builder.build();
		}

		//Perform the update

		builder = Response.noContent();
		return builder.build();
	}
}

Find the customer, make a entity tag based on the hashcode on the customer, make a timestamp, evaludate preconditions,
if there is a good response, return that current version

if there is none, make a update 

and return that built version.

Filters and Interceptors:

Server-Side filters:

On the server, there are two filter types. Request filters and Response filters.

Response filters are by default bound to all HTTP requests, but can be bound to specific
JAX-RS methods.

Internally, the algorithm executing an HTTP on the server side looks as follows:

for (filter : preMatchFilters){
	filter.filter(request);
}

jaxrs_method = match(request);

for (filter : postMatchFilters){
	filter.filter(request);
}

response = jaxrs_method.invoke();

for (filter : responseFilters){
	filter.filter(request, response);
}

Since JAX-RS has a asynch API, JAX-RS filters cannot run in the same Java call stack.
The request filters run before the jaxrs methods are invoked.

In asynch, response filters run after resume(), cancel() or a timeout occurs.

Server Request Filters:

Request filters are implementations of the ContainerRequestFilter interface:

package javax.ws.rs.container;

public interface ContainerRequestFilter{
	public void filter(ContainerRequestContext requestContext) throws IOException;
}

ContainerRequestFilters come in two flavors: prematching and postmatching.
EAch respective version is begun with the @PreMatching or @PostMatching annotations.

Prematching filters are often used to modify request attributes to change
how they match to a specific resource. For example, some firewalls do not
allow PUT and/or DELETE invocations. 

To circumvent that, many applications tunnel the HTTP method through the 
HTTP header X-Http-Method-Override:

import javax.ws.rs.container.ContainerRequestFilter;
import javax.ws.rs.container.ContainerRequestContext;

@Provider
@PreMatching
public class HttpMethodOverride implements ContainerRequestFilter{
	public void filter(ContainerRequestContext ctx) throws IOException{
		String methodOverride = ctx.getHeaderString("X-Http-Method-Override");
		if (methodOverride != null) ctx.setMethod(methodOverride);
	}
}

Filters can modify requests as they see fit, before they are mapped to JAX-RS methods.

Another use of request filters is implementing custom authentication
protocols. For example, OAuth 2.0 has a token protocol that is transmitted
through the Authorization HTTP header. Here's an example:

import javax.ws.rs.container.ContainerRequestFilter;
import javax.ws.rs.container.ContainerRequestContext;
import javax.ws.rs.NotAuthorizedException;

@Provider
@PreMatching
public class BearerTokenFilter implements ContainerRequestFilter {
	public void filter(ContainerRequestContext ctx) throws IOException{
		String authHeader = request.getHeaderString(HttpHeaders.AUTHORIZATION);

		if(authHeader == null) throw new NotAuthorizedException("Bearer");
		String token = parseToken(authHeader);

		if(verifyToken(token) == false){
			throw new NotAuthorizedException("Bearer error=\"invalid token\"");
		}
	}

	private String parseToken(String header) {...}
	private boolean verifyToken(String token) {...}
}

If we wish to avoid exception mapping, then we can use the ContainerRequestContext.abortWith() method instead.

Server Response Filters:

Response filters are implementations of the ContainerResponseFilter interface:

package javax.ws.rs.container;

public interface ContainerResponseFilter {
	public void filter(ContainerRequestContext requestContext,
						ContainerResponseContext responseContext) throws IOException;
}

Generally, we use these filters to decorate the response by adding or modifying
response headers. One example is if you wanted to set a default Cache-Control header
for each response to a GET request.

Here's an example:

//imports

@Provider
public class CacheControlFilter implements ContainerResponseFilter{
	public void filter(ContainerRequestContext req, ContainerResponseContext res) throws IOException
	{
		if (req.getMethod().equals("GET")){
			CacheControl cc = new CacheControl();
			cc.setMaxAge(100);
			req.getHeaders().add("Cache-Control", cc);
		}
	}
}

Create cachecontrol, cache it for 100 seconds, aquire headers and add the Cache-Control
response header to the cache control.

Reader and Writer Interceptors:

While filters modify request and response headers, reader and writer interceptors
deal with message bodies.

They work in conjunction with a MessageBodyReader or MessageBodyWriter and are usable
on both the client and server. Reader interceptors implement the ReadInterceptor interface.

Writer interceptors implement the WriterInterceptor interface:

package javax.ws.rs.ext;

public interface ReaderInterceptor {
	public Object aroundReadFrom(ReaderInterceptorContext context) 
			 throws java.io.IOException, javax.ws.rs.WebApplicationException;
	}

public interface WriterInterceptor {
	void aroundWriteTo(WriterInterceptorContext context)
			throws java.io.IOException, javax.ws.rs.WebApplicationException;
}

These interceptors are only triggered when a MessageBodyReader or MessageBodyWriter 
is needed to unmarshal or marshal a Java object to and from the HTTP message body.

They are also invoked in the same Java call stack. In other words, a ReaderInterceptor
wraps around the invocation of MessageBodyReader.readFrom() and WriterInterceptor
wraps around the invocation of MessageBodyWriter.writeTo().

An example of JAX-RS allow support for using a ReaderInterceptor and WriterInterceptor:

@Provider
public class GZIPEncoder implements WriterInterceptor {
	
	public void aroundWriteTo(WriterInterceptorContext ctx) throws IOException, WebApplicationException {

		GZIPOutputStream os = new GZIPOutputStream(ctx.getOutputStream());

		ctx.getHeaders().putSingle("Content-Encoding", "gzip");
		ctx.setOutputStream(os);

		ctx.proceed();
		return;
	}
}

The proceed call above either runs the next registered WriterInterceptor or invoke the 
underlying MessageBodyWriter.writeTo() method.

What we did above, was just to make a new OutputStream based on GZIP and register it as the output
stream for the context, and we put Content-Encoding: Gzip on the headers

Next example, is the ReaderInterceptor counterpart to this example:

@Provider
public class GZIPDecoder implements ReaderInterceptor {
	public Object aroundReadFrom(ReaderInterceptorContext ctx) throws IOException {
		String encoding = ctx.getHeaders().getFirst("Content-Encoding");

		if(!"gzip".equalsIgnoreCase(encoding)){
			return ctx.proceed();
		}
		GZipInputStream is = new GZipInputStream(ctx.getInputStream());
		ctx.setInputStream(is);
		return ctx.proceed(is);
	}
}

We can use interceptors for a wide array of things. Encrypting message bodies 
into different formats or digitally sign things.

A WriterInterceptor could be used to add a JSONP wrapper to your JSON content.

A ReaderInterceptor could augment the unmarshalled Java object with additional
data pulled from the request or response.

Client-Side Filters:

The JAX-RS Client API also has its own set of request and response 
filter interfaces:

package javax.ws.rs.client;

public interface ClientRequestFilter {
	public void filter(ClientRequestContext requestContext) throws IOException;
}

public interface ClientResponseFilter {
	public void filter(ClientRequestContext requestContext,
							ClientResponseContext responseContext) throws IOException;
}

Let's use thse to ape a Browsers cache. We want cache entries to expire based on
the metadata within Cache-Control response headers. We want to perform conditional
GETs if the client is requesting an expired cache entry.

Let's implement our ClientRequestFilter first:

import javax.ws.rs.client.ClientRequestFilter;
import javax.ws.rs.client.ClientRequestContext;

public class ClientCacheRequestFilter implements ClientRequestFilter {
	private Cache cache;

	public ClientCacheRequestFilter(Cache cache){
		this.cache = cache;
	}

	public void filter(ClientRequestContext ctx) throws IOException{
		if (!ctx.getMethod().equalsIgnoreCase("GET")) return;

		CacheEntry entry = cache.getEntry(request.getUri());
		if (entry == null) return;

		if (!entry.isExpired()){
			ByteArrayInputStream is = new ByteArrayInputStream(entry.getContent());
			Response response = Response.ok(is)
										.type(entry.getContentType()).build();

			ctx.abortWith(response);
			return;
		}

		String etag = entry.getETagHeader();
		String lastModified = entry.getLastModified();

		if (etag != null){
			ctx.getHeaders.putSingle("If-None-Match", etag);
		}

		if (lastModified != null){
			ctx.getHeaders.putSingle("If-Modified-Since", lastModified);
		}
	}
}

In the above example we initiate a Cache.

It should only handle get requests. WE get the uri, and proceed if the entry is not null.
If the entry is not expired, build a ok response, return it.

Else, get the etag and last modified. Set them if you have it. And then perform
a conditional GET request. By letting it through.

Now that we have the request filter, let's finish this example by implementing
the response filter:

public class CacheResponseFilter implements ClientResponseFilter {
	private Cache cache;

	public CacheResponseFilter(Cache cache){
		this.cache = cache;
	}

	public void filter(ClientRequestContext request, ClientResponseContext response) throws IOException{

		if(!request.getMethod().equalsIgnoreCase("GET")) return;

		if(response.getStatus() == 200){
			cache.cacheResponse(response, request.getUri());
		} else if (response.getStatus() == 304){
			CacheEntry entry = cache.getEntry(request.getUri());

			entry.updateCacheHeaders(response);
			response.getHeaders().clear();

			response.setStatus(200);
			response.getHeaders().putSingle("Content-Type", entry.getContentType());
			ByteArrayInputStream is = new ByteArrayInputStream(entry.getContent());

			response.setInputStream(is);
		}
	}
}

If it's not a GET, return.

Start the cache. If the response status is 200, cachetheresponse with the response and teh URI.

If it's 304, get the entry, update the headers with the response for the entry, clear the responses headers,
set it to status 200, put the contentType of the entry, set the inputStream to the response to
allocate the resources.

Deploying Filters and Interceptors:

On the server side, filters and interceptors are deployed the same way any other
@Provider is deployed. You either put the @Provider and let it be registered
automatically by scanning, or you add the filter or interceptor to the Application
class's classes or singletons list.

On the client side, you register filters and interceptors the same way you would
register any other provider. There are a few components in the Client API that 
implement the Configurable interface.

This interface has a register() method that allows you to pass in your filter
or interceptor class or singleton instance. ClientBuilder, Client and WebTarget
all implement the Configurable interface. 

We can have different filters for different WebTargets. You may have higher security
implementations for one than another.

You could assign a Basic Auth filter for one, for another, go with a token filter.

Ordering Filters and Interceptors:

Order can be very important, as to when Authentications and Encryptions occur.

To assign the numeric prioerity of something, just run the @Priority(Priorities.<number>).
Lower is higher predecence.

The Priority annotation itself, holds a default listing of values:

package javax.ws.rs;

public final class Priorities {
	
	private Priorities(){
		//prevents construction
	}

	//Security authentication filter/interceptor prio
	public static final int AUTHENTICATION = 1000;

	//Security authorization filter/interceptor prio
	public static final int AUTHORIZATION = 2000;

	//Header decorator filter/interceptor prio
	public static final int HEADER_DECORATOR = 3000;

	//Message encoder or decoder filter/interceptor prio
	public static final int ENTITY_CODER = 4000;

	//User-level filter/interceptor prio
	public static final int USER = 5000;
}

If no prio is specified, the default of 5k is used. By using the Configurable.register(),
we can change the prio:

ClientBuilder builder = ClientBuilder.newBuilder();
builder.register(GZipEncoder.class, Priorities.ENTITY_CODER);

On the server side, we can just dependency inject the Configurable into the App class:

@ApplicationPath("/")
public class MyApplication{
	
	public MyApplication(@Context Configurable configurable){
		configurable.register(BearerTokenFilter.class, Priorities.AUTHENTICATION);
	}
}

Per-JAX-RS Method bindings:

On the server-side, we can apply a filter or interceptor on a per-JAX-RS method basis.
This allows us to add annotation extensions to our JAX-RS container.

We can do this by two ways: Register an implementation of the DynamicFeature interface.
Or, through annotation binding.

DynamicFeature:

package javax.ws.rs.container;

public interface DynamicFeature{
	public void configure(ResourceInfo resourceInfo, FeatureContext context);
}

public interface ResourceInfo{
	
	//Get the resource method that is the target of a request
	//returns method instance or null

	Method getResourceMethod();

	//get the resource class that is the target of a request
	//return resource class instance or null

	Class<?> getResourceClass();
}

The Configure callback allows us to make our own annotations.
We will use this to make a @MaxAge annotation.

package com.commerce.MaxAge;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface MaxAge {
	int value();
}

The modification of the filter looks like this:

public class CacheControlFilter implements ContainerResponseFilter {
	private int maxAge;

	public CacheControlFilter(int maxAge){
		this.maxAge = maxAge;
	}

	public void filter(ContainerRequestContext req, ContainerResponseContext res) throws IOException
	{
		if (req.getMethod().equals("GET")){
			CacheControl cc = new CacheControl();
			cc.setMaxAge(this.maxAge);
			res.getHeaders().add("Cache-Control", cc);
		}
	}
}

We defined a new constructor to parse in values and remove the @Provider annotation
which makes it not automatically scanned in.

Instead, we use DynamicFeature to create and register it:

@Provider
public class MaxAgeFeature implements DynamicFeature{
	
	public void configure(ResourceInfo ri, FeatureContext ctx){
		MaxAge max = ri.getResourceMethod().getAnnotation(MaxAge.class);
		if (max == null) return;

		CacheControlFilter filter = new CacheControlFilter(max.value());
		ctx.register(filter);
	}
}

It checks for the existence of a @MaxAge annotation and registers the max.value() if it exists.

The configure method itself is run for every deployed JAX-RS resource method.

Name Bindings:

The other way, to bind a filter or interceptor to a particular JAX-RS 
method is to use the @NameBinding meta-annotation:

@Target(ElementType.ANNOTATION_TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface NameBinding {
	
}

To define a new annotation, we begin by definingi t:

@NameBinding
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface TokenAuthenticated {}

To bind the annotation, just write it as one:

@Provider
@PreMatching
@TokenAuthenticated
public class BearerTokenFilter implements ContainerRequestFilter {
	
}

By having bound the annotation to the BearerTokenFilter, can now invoke it
ismply by running it on whatever we wish:

@Path("/customers")
public class CustomerResource {
	
	@GET
	@Path("{id}")
	@TokenAuthenticated
	public String getCustomer(@PathParam("id") String id) {...}
}

DynamicFeature versus @NameBinding:

DynamicFeature is better performancewise compared to NameBinding. Because of added
overhead in bigger initializations.

Exception Processing:

On the server side, we expect exceptions to be handled by Exception Mappings. 
On the client isde, it is inside of WebApplicationException and propogates
back to the Application code.

Otherwise, it is wrapped in a ProcessingException if it is thrown before 
the request goes over the wire. The exception is wrapped in a ResponseProcessingException
if proccessing a Response.

Asynch JAX-RS:

AsyncInvoker Client API:

The client Asynch API allows for spinning off HTTP requests in the background, and then
either poll for a response or register a callback that is invoked when the HTTP response
is available.

to do so, we must either interact with:

javax.ws.rs.client.AsyncInvoker interface 

or 

submit() methods on javax.ws.rs.client.Invocation.

Let's look at polling HTTP requests that are run in the background.

Using Futures:

The AsyncInvoker invokes HTTP requests and returns Future instances.

To invoke AsyncInvoker methods, call async() on the Invocation.Builder interface.

package javax.ws.rs.client;

public interface AsynchInvoker {
	Future<Response> get();

	<T> Future<T> get(Class<T> responseType);

	Future<Response> put(Entity<?> entity);
	<T> Future<T> put(Entity<?> entity, Class<T> responseType);

	Future<Response> post(Entity<?> entity);
	<T> Future<T> post(Entity<?> entity, Class<T> responseType);

	Future<Response> delete(Entity<?> entity);
	<T> Future<T> delete(Entity<?> entity, Class<T> responseType);
}

the Future interface is as follows:

package java.util.concurrent;

public interface Future<V> {
	boolean cancel(boolean mayInterupptIfRunning);
	boolean isCancelled();
	boolean isDone();

	V get() throws InterupptedException, ExecutionException;
	V get(long timeout, TimeUnit unit) throws InterupptedException, ExecutionException, TimeoutException;
}

An example:

Client client = ClientBuilder.newClient();

Future<Response> future1 = client.target("http://example.com/customers/123")
								 .request()
								 .async().get();

Future<Order> future2 = client.target("http://foobar.com/orders/456")
							  .request()
							  .async().get(Order.class);

//Block until complete
Response res1 = future1.get();
Customer result1 = res.readEntity(Customer.class);

//wait 5 seconds
try{
	Order result2 = future2.get(5, TimeUnit.SECONDS);
} catch (TimeoutException timeout){
	//Handle the exception
}

Both of the requests are done in parallel, and one ends up blocking, the other waits 5 seconds.

Exception Handling:

To handle exceptions is a bit more pain in the arse, if we wish to be.. specific, about it:

try{
	Order result2 = future2.get(5, TimeUnit.SECONDS);
} catch (TimeoutException timeout){
	System.err.println("request timed out");
} catch (InterupptedException ie){
	System.err.println("request was interuppted");
} catch (ExecutionException ee) {
	Throwable cause = ee.getCause();

	if (cause instanceof WebApplicationException){
		(WebApplicationException)wae = (WebApplicationException)cause;
		wae.close();
	} else if (cause instanceof ResponseProcessingException){
		ResponseProcessingException rpe = (ResponseProcessingException)cause;
		rpe.close();
	} else if (cause instanceof ProcessingException) {
		//Handle processing exception
	} else {
		//unknown
	}
}

As per usual, we need to close our resources, for performance reasons.

We have to refactor the code. Again:

Client client = ClientBuilder.newClient();

Future<Response> future1 = client.target("http://example.com/service")
								 .request()
								 .async().get();

Future<Order> future2 = null;
try{
	future2 = client.target("http://foobar.com/service2")
					.request()
					.async().get(Order.class);
} catch (Throwable ignored) {
	ignored.printStackTrace();
}

//Block until complete
Response res1 = future1.get();
try{
	Customer result1 = res.readEntity(Customer.class);
} catch (Throwable ignored) {
	ignored.printStackTrace();
} finally {
	res1.close();
}

if (future2 != null) {
	try{
		Order result2 = future2.get(5, TimeUnit.SECONDS);
	} catch (TimeoutException timeout) {
		System.err.println("request timed out");
	} catch (InterupptedException ie) {
		System.err.println("request was interuppted");
	} catch (ExecutionException ee) {
		Throwable cause = ee.getCause();

		if (cause instanceof WebApplicationException) {
			(WebApplicationException)wae = (WebApplicationException)cause;
			wae.close();
		} else if (cause instanceof ResponseProcessingException) {
			ResponseProcessingException rpe = (ResponseProcessingException)cause;
			rpe.close();
		} else if (cause instanceof ProcessingException){
			//HAndle processing exception
		} else {
			//unknown
		}
	}
}


Using Callbacks:

the AsyncInvoker has an additional callback invocation style. You can
register an object that will be called back when the asynch invocation is
ready for processing.

package javax.ws.rs.client;

public interface AsyncInvoker {
	<T> Future<T> get(InvocationCallback<T> callback);
	<T> Future<T> post(Entity<?> entity, InvocationCallback<T> callback);
	<T> Future<T> put(Entity<?> entity, InvocationCallback<T> callback);
	<T> Future<T> delete(Entity<?> entity, InvocationCallback<T> callback);
}

The InvocationCallback interface is as follows:

package javax.rs.ws.client;

public interface InvocationCallback<RESPONSE> {
	public void completed(RESPONSE response);
	public void failed(Throwable throwable);
}

For the first initial request we implement a callback as follows:

public class CustomerCallback implements InvocationCallback<Response> {
	public void completed(Response response){
		if (response.getStatus() == 200){
			Customer cust = response.readEntity(Customer.class);
		} else {
			System.err.println("Request error:" + response.getStatus());
		}
	}

	public void failed(Throwable throwable){
		throwable.printStackTrace();
	}
}

We simply run with a structure of running Response as a Generic type,
allowing for a untouched Response object to be passed in. If the complete()
finishes as per expected, completed gets run.

Otherwise, we run failed.

For the second callback, we cause conversion:

public class OrderCallback implements InvocationCallback<Order>{
	public void completed(Order order){
		System.out.println("We received an order");
	}

	public void failed(Throwable throwable){
		if (throwable instanceof WebApplicationException){
			WebApplicationException wae = (WebApplicationException)throwable;
			System.err.println("Failed with status: " + wae.getResponse().getStatus());
		} else if (throwable instanceof ResponseProcessingException){
			ResponseProcessingException rpe = (ResponseProcessingException)cause;
			System.err.println("Failed with status: " + rpe.getResponse().getStatus());
		} else {
			throwable.printStackTrace();
		}
	}
}

The only difference here is that we convert the HTTP request to Order.

next, we just call the callbacks:

Client client = ClientBuilder.newClient();

Future<Response> future1 = client.target("http://example.com/customers/123")
								 .request()
								 .async().get(new CustomerCallback());

Future<Order> future2 = client.target("http://foobar.com/orders/456")
							  .request()
							  .async().get(new OrderCallback());

We can interact with the Future object, such as doing cancel() or isDone().
Beyond that, we might have callback issues.

Future versus Callbacks:

Use futures if you need to do a collective operation after all Asynch tasks are done.

Use callbacks for seperated tasks and no need of mashup.

Server Asynch Response Processing:

Inheritly, if we are using normal HTTP serving requests, we do not 
have issues with the concurrent HTTp model.

Issues arise with thousands of connections needing updates.

This is when we should use AsyncResponse API. However, we should only
use it, if we are truly certain that we need it.

AsyncResponse API:

to use server-side async response processing, you interact with the AsyncResponse interface:

package javax.ws.rs.container;

public interface AsyncResponse {
	boolean resume(Object response);
	boolean resume(Throwable response);
}

to access the AsyncResponse in JAX-RS, use @Suspended:

@Path("/orders")
public class OrderResource{
	@POST
	@Consumes("application/json")
	public void submit(final Order order,
						final @Suspended AsyncResponse response){

	}
}

We have to, however, put in the actual logic as well:

@Path("/orders")
public class OrderResource {
	
	@POST
	@Consumes("application/json")
	@Produces("application/json")
	public void submit(final Order order,
						final @Suspended AsyncResponse response){
		new Thread(){
			public void run(){
				OrderConfirmation confirmation = orderProcessor.process(order);
				response.resume(order);
			}
		}.start();
	}
}

The only noteworthy thing here is that we further the response with resume

Alternatively, we build a more precise response:

@Path("/orders")
public class OrderResource {
	
	@POST
	@Consumes("application/json")
	public void submit(final Order order,
						final @Suspended AsyncResponse response){
		new Thread(){
			public void run() {
				OrderConfirmation confirmation = orderProcessor.process(order);
				Response response = Response.ok(confirmation,
												MediaType.APPLICATION_XML_TYPE)
											.build();
				response.resume(response);
			}
		}.start();
	}
}

By manually creationg the response, we can omit the @Produces

Exception Handling:

If we wish to throw a exception on an actual thread, as in, processing():

@Path("/orders")
public class OrderResource{
	
	@POST
	@Consumes("application/json")
	public void submit(final Order order,
						final @Suspended AsyncResponse response) {
		new Thread(){
			public void run(){
				OrderConfirmation confirmation = null;
				try{
					confirmation = orderProcessor.process(order);
				} catch (Exception ex) {
					response.resume(ex);
					return;
				}
				Response response = Response.ok(confirmation,
												MediaType.APPLICATION_XML_TYPE)
											.build();
				response.resume(response);
			}
		}.start();
	}
}

The only thing we did different with exception handling is the fact of
sending back a exception.

Cancel:

Cancel is a pre-canned call to resume() with a delay:

//cancel()
response.resume(Response.status(503).build());

//cancel(int)
response.resume(Response.status(503)
						.header(HttpHeaders.RETRY_AFTER, 100)
						.build());

//cancel (Date)
response.resume(Response.status(503)
						.header(HttpHeaders.RETRY_AFTER, date)
						.build());

Thus, we can see, that the ones with input are used for retrying after X point.

Status Methods:

There is a few methods to check status of the Process:

public interface AsynchResponse{
	


	boolean isSuspended();

	boolean isCancelled();

	boolean isDone();
}

Timeouts:

Assuming a thread does not get resumed or cancelled, it will eventually
time out.

We can set the timer as follows:

response.setTimeout(5, TimeUnit.SECONDS);

We can also trigger a callback on timeouts:

response.setTimeoutHandler(
	new TimeoutHandler {
		void handleTimeout(AsyncResponse response) {
			response.resume(Response.serverError().build());
		}
	}
);

The default error would be 503, but in the above example we build a 500 error.

Callbacks:

The AsyncResponse interface allows us to do all kinds of callback objects
for other types of events:

package javax.ws.rs.container;

public interface CompletionCallback{
	public void onComplete(Throwable throwable);
}

It is executed after the request is sent to a client. The throwable is mapped
to any unmapped exception thrown internally when processing a resume(). Otherwise, it is null.

package javax.ws.rs.container;

public interface ConnectionCallback {
	public void onDisconnect(AsyncResponse response);
}

To use callbacks, register them to responses:

response.register(MyCompletionCallback.class);
response.register(new MyConnectionCallback());

Callbacks are useful for processing stuff after resume() is called.

Use Cases for AsyncResponse:

Server-Side push:

one use of AsyncResponses is long-polling GET requests:

Client client = ClientBuilder.newClient();
final WebTarget target = client.target("http://quote.com/quote/RHT");
target.request().async().get(new InvocationCallback<String> {
	public void completed(String quote){
		System.out.println("RHT: " + quote);
		target.request().async().get(this);
	}

	public void failed(Throwable t) {}
});

The above is a model that allows for threads to handle multiple requests,
meaning we can have thousands upon thousands of requests.

This is the purpose of having suspended resources, where we have 
one thread writes the responses back.

An example of using the setup:

@Path("quote/RHT")
public class RHTQuoteResource {
	protected List<AsyncResponse> responses;

	@GET
	@Produces("text/plain")
	public void getQuote(@Suspended AsyncResponse response) {
		synchronized (responses) {
			responses.put(response);
		}
	}
}

This is to be combined with the background thread that is suspended
until it gets requests to run:

Executor executor = Executors.newSingleThreadExecutor();
final List<AsyncResponse> responses = ...;
final Ticker rhtTicker = nyse.getTicker("RHT");
executor.execute(new Runnable(){
	public void run(){
		while (true){
			String quote = ticker.await();
			synchronized (responses){
				for (AsyncResponse response : responses) response.resume(quote);
			}
		}
	}
});

The code is not complete, but the general idea is there.

Publish and Subscribe:

A simple example of a chat program: //This is a lacking example as messages can be lost for
clients that are repolling

@Path("chat")
public class CharResource {
	protected List<AsyncResponse> responses = new ArrayList<AsyncResponse>();

	@GET
	@Produces("text/plain")
	public synchronized void receive(@Suspended AsyncResponse response){
		responses.add(response);
	}

	@POST
	@Consume("text/plain")
	public synchronized void send(String message){
		for (AsyncResponse response : responses){
			response.resume(message);
		}
	}
}

Note: You're better off using SSE (Server Sent Events and WebSockets)

Priority Scheduling:

If we wish to make a QUeue system where we delegate one process to oen thread
explicitly (as per with CPU heavy calculations):

@Path("orders")
public class OrderResource {
	
	Executor executor;

	public OrderResource {
		executor = Executors.newSingleThreadExecutor();
	}

	@POST
	@Path("year_to_date_report")
	@Produces("application/json")
	public void ytdReport(final @FormParam("product") String product,
						  @AsyncResponse response){
		executor.execute(new Runnable(){
			public void run(){
				Report report = generateYTDReportFor(product);
				response.resume(report);
			}
		});
	}

	protected Report generateYTDReportFor(String product) {...}
}

The above structure enforces a single thread structure where we queue up stuff
that is being processed.

Deployment and Integration:

Deployment:

The deployment of Servlet-based apps are organized in WARs (Web archives).
The WARs contain Jar files and static data. 

The structure of a WAR is as follows:

<any static content>
WEB-INF/
		web.xml
		classes/
		lib/

Any files outside of the WEB-INF is accessible through HTTP. Put static content there, like HTML and 
images.

Classes is for java files, lib is for any third party dependancies.

the web.xml describes how the servlet container should initialize it.

How JAX-RS deploys within a servlet container varies between JAX-RS deployments,
ranging from Java EE app servers or standlone servlets 3.x like Tomcat

The Application Class:

The app class is the basis of deployment in JAX-RS. It tells JAX-RS
as to how to deploy things.

It looks as follows:

package javax.ws.rs.core;

import java.util.Collections;
import java.util.Set;

public abstract class Application {
	private static final Set<Object> emptySet = Collections.emptySet();

	public abstract Set<Class<?>> getClasses();

	public Set<Object> getSingletons(){
		return emptySet;
	}
}

The getSingleTons returns all of the preallocated JAX-RS web services and
providers. We need to set these ourselves. With these registered,
JAX-RS will also inject @Context annotated fields and setter methods.

A simple example of the Application class:

package com.restfully.shop.services;

import javax.ws.rs.core.Application;

public class ShoppingApplication extends Application {
	public ShoppingApplication() {}

	public Set<Class<?>> getClasses(){
		HashSet<Class<?>> set = new HashSet<Class<?>>();
		set.add(CustomerResource.class);
		set.add(OrderResource.class);
		set.add(ProduceResource.class);
		return set;
	}

	public Set<Object> getSingletons(){
		JsonWriter json = new JsonWriter();
		CreditCardResource service = new CreditCardResource();

		HashSet<Object> set = new HashSet();
		set.add(json);
		set.add(service);
		return set;
	}
}

As we can see, the classes we make are some resources based on the classes we want.

Where as of the singletons, are JSONWriters and a specific class.

Deployment Within a JAX-RS-Aware Container:

The Java EE (Enterprise Edition), defines a complete enterprise platform
that includes services like a servlet container, EJB, transaction manager (JTA),
messaging (JMS), connection pooling (JCA), database persistance (JPA), web framework (JSF),
and others.

for a standlone 3.X servlet, it is much akin to Java-EE, The only
difference is that they use a ServletContainerInitializer SPI and that
your WAR deployments need to include libs of your JAX-RS implementation.

Deploying JAX-RS in a JAX-RS aware servlet container is easy.
You need an empty xml file:

<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://java.sun.com/xml/ns/javaee"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
	http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
	version="3.0">
</web-app>

If we have at least one Application class implementation with @ApplicationPath,
the JAX-RS-aware container will automatically deploy that Application:

@ApplicationPath("/root")
public class ShoppingApplication extends Application {
	
	public ShoppingApplication() {}

	public Set<Class<?>> getClasses() {
		HashSet<Class<?>> set = new HashSet<Class<?>>();
		set.add(CustomerResource.class);
		set.add(OrderResource.class);
		set.add(ProduceResource.class);
		return set;
	}

	public Set<Object> getSingletons(){
		JsonWriter json = new JsonWriter();
		CreditCardResource service = new CreditCardResource();

		HashSet<Object> set = new HashSet();
		set.add(json);
		set.add(service);
		return set;
	}
}

The notation here makes the base path to whatever the WAR's context
root is, with root appended.

You can fully levrage the servlet class scanning abilities if you have both
getClasses() and getSingletons() return an empty set.

An example:

@ApplicationPath("/root")
public class ShoppingApplication extends Application{
	//complete
}

When scanning, the app server will look within WEB-INF/classes and any JAR
file within the WEB-INF/lib dir. It will add any class annotated with @Path
or @Provider to the list of dpeloyments.

You can deploy as many Application classes as you want, in a WAR.

Any App class that is not Annoted with @ApplicationPath, is ignored.

We can override the @ApplicationPath annotation via a simple 
servlet mapping within web.xml:

<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://java.sun.com/xml/ns/javaee"
	  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	  xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
	  					  http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
	  version="3.0">
	<servlet-mapping>
		<servlet-name>com.rest.ShoppingApplication</servlet-name>
		<url-pattern>/*</url-pattern>
	</servlet-mapping>
</web-app>

The servlet-name category contains the full name of the Application class.
With this config, you can ignore @ApplicationPath annotations.

Deployment Within a JAX-RS-Unaware Container:

If we run a Servlet earlier than 3.0, as in 2.x, we have to define the dependancies
in web.xml ourselves:

<?xml version="1.0"?>
<web-app>
	<servlet>
		<servlet-name>JAXRS</servlet-name>
		<servlet-class>
			org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher
		</servlet-class>
		<init-param>
			<param-name>
				javax.ws.rs.Application
			</param-name>
			<param-value>
				com.restfully.shop.services.ShoppingApplication
			</param-value>
		</init-param>
	</servlet>

	<servlet-mapping>
		<servlet-name>JAXRS</servlet-name>
		<url-pattern>/*</url-pattern>
	</servlet-mapping>
</web-app>

This above, is the same as we did with the other App class, where we put the root class to be the ShoppingApplication.

The param value is the shopping app, the servlet dispatcher is whatever servlet clas,
here we do a jboss rest easy, and the mapping goes to JAXRS and patch all things there.

Configuration:

Basic Configuration:

We can communicate with our XML in JAX-RS.

An example:

<?xml version="1.0"?>
<web-app>
	<context-param>
		<param-name>max-customers-size</param-name>
		<param-value>10</param-value>
	</context-param>
</web-app>

An example of reaching the param-value here, is: //The param value is the default for paginiation to the DB

@Path("/customers")
public class CustomerResource{
	protected int defaultPageSize = 5;

	@Context
	public void setServletContext(ServletContext context){
		String size = context.getInitParameter("max-customers-size");
		if (size != null){
			defaultPageSize = Integer.parseInt(size);
		}
	}

	@GET
	@Produces("application/xml")
	public String getCustomerList(){
		//Do stuff
	}
}

Another way we could do it, is use our Application class as a factory for 
our JAX-RS services. We could define or pull in config info through 
this class and use it to construct your JAX-RS service. 

Let us first rewrite our CustomerResource class to illustrate this technique:

@Path("/customers")
public class CustomerResource{
	protected int defaultPageSize = 5;

	public void setDefaultPageSize(int size){
		defaultPageSize = size;
	}

	@GET
	@Produces("application/xml")
	public String getCustomerList(){
		//Do stuff
	}
}

We then instead, make the depedency injection ino the Application class:

@ApplicationPath("/")
public class ShoppingApplication extends Application {
	public ShoppingApplication() {}

	public Set<Class<?>> getClasses() {
		return Collections.emptySet();
	}

	@Context
	ServletContext servletContext

	public Set<Object> getSingletons(){
		int pageSize = 0;

		try{
			InitialContext ctx = new InitialContext();
			Integer size = (Integer)ctx.getInitParameter("max-customers-size");
			pageSize = size.getValue();
		} catch (Exception ex) {
			//Handle it
		}

		CustomerResource custService = new CustomerResource();
		custService.setDefaultPageSize(pageSize);

		HashSet<Object> set = new HashSet();
		set.add(custService);
		return set;
	}
}

EJB Integration:

EJBs are for business logic. Security, transactions and presistence are put into them.

You are allowed to use JAX-RS annotations on local interfaces or no-interface beans
of stateless session or singleton beans. No other integration with other bean
types is supported.

If we use full scanning (run empty classes), just put the EJBs within the WAR, 
JAX-RS will find them.

Otherwise, you have to return each bean class of each JAX-RS EJB from your Application.getClasses()
method.

For example, assume:

@Stateless
@Path("/customers")
public class CustomerResourceBean implements CustomerResource{
	
}

If you are manually registering your resources via your App class, 
you must register the bean class of the EJB via the Application.getClasses()
method:

@ApplicationPath("/root")
public class ShoppingApplication extends Application {
	public Set<Class<?>> getClasses(){
		HashSet<Class<?>> set = new HashSet<Class<?>>();
		set.add(CustomerResourceBean.class);
		return set;
	}
}

Spring Integration:

To integrate into Spring, first setup your resource as per usual:

@Path("/customers")
public interface CustomerResource{
	@GET
	@Produces("application/xml")
	public String getCustomers();

	@GET
	@Produces("application/xml")
	@Path("{id}")
	public String getCustomer(@PathParam("id") int id);
}

We then go to make a ResourceBean that is annoted with the JAX-RS annotations.
This can be done by implementing the ResourceInterface:

public class CustomerResourceBean implements CustomerResource {
	
	public String getCustomers() {...}

	public String getCustomer(int id){...}
}

In terms of Spring, use interfaces.

We then declare it in a Spring xml file, calling it whateever, really:

//assume spring-beans.xml

<beans xmlns="http://www.springframework.org/schema/beans"
  <bean id="custService"
  		class="com.shopping.restful.services.CustomerResourceBean"/>
</beans>

Place this within your WAR's WEB-INF/classes dir 

OR

within a JAR within the WEB-INF/lib dir. 

Next, we write the web.xml. //Note, for this example, we put the Class into WEB-INF/classes dir.

<web-app>
	<context-param>
		<param-name>spring-beans-file</param-name>
		<param-value>META-INF/applicationContext.xml</param-value>
	</context-param>
</web-app>

We define the place in the param-value of the context-param, and so we can change it later.

Then we write the actual App class:

@ApplicationPath("/")
public class ShoppingApplication extends Application
{
	protected ApplicationContext springContext;

	@Context
	protected ServletContext servletContext;

	public Set<Object> getSingletons()
	{
		try
		{
			InitialContext ctx = new InitialContext();
			String xmlFile = (String)servletContext.getInitParameter
							 ("spring-beans-file");

			springContext = new ClassPathXmlApplicationContext(xmlFile);
		}
		catch (Exception ex)
		{
			throw new RuntimeException(ex);
		}
		HashSet<Object> set = new HashSet();
		set.add(springContext.getBean("customer"));
		return set;
	}
}

This is pretty self explanitory what it does.

It gets the context, gets the xml file, sets the springContext, makes a HashSet,
adds the context, returns it for registering.

Securing JAX-RS:

There are a few set of core security services and protocols in JAX-RS:

Authentication:

Granting access to the User to begin with

Authorization:

What rights the user has.

Encryption:

Crypthography akin to SSL.

A lot of the security application in practice, in JAX-RS, is application and configuring
annotation metadata.

beyond encryption of message bodies and signatures, and we might also use OAuth 
which allows us to make invocations on services on behalf of other users.

Authentication:

most Servlets in JAva, support Basic Auth, Digest Auth, and Auth using X.509 certificates.

Basic Auth:

Assume we make a GET request:

GET /customers/333 HTTP/1.1

If authentication requirement is present in terms of Basic Auth:

HTTP/1.1 401 Unauthorized
WWW-Authenticate: Basic realm="CustomerDB realm"

The realm attribute is the secured source. Basic is what protocol we are refering to.

Assume we would make a Get request with authorization against bburke:geheim, it would be encoded
as follows:

GET /customers/333 HTTP/1.1
Authorization: Basic YmJicmtlOmdlaGVpbQ==

We could use HTTPS to secure the transfer. Still, it's not a good idea to send
PW's across requests, cause they can be intercepted.

Digest Authentication:

Involves running MD5 hashes of values to send over HTTP requests.
Can still be middle-man attacked in HTTP standards, telling the Client
to use Basic Auth to aquire a PW.

Client Certificate Authentication:

HTTPS can be used for encryption and authorization.
By virtue of deligating a certificate to a Central Authority service,
like VeriSign. This protects against man in the middle attacks.

We can also have the Certificate securing in terms of having the
client send a certificate unique to the server, as well.

The only disadvantage is that it's a PITA.

Authorization:

Authorization occurs in the Servlet or the Server/App. It is done per role basis, akin to
Unix.

Authentication and Authorization in JAX-RS:

The authentication is enabled in the web.xml in WEB-INF in the respective WAR file.

We enable authorization through XML or by applying annotations to our JAX-RS
resource classes.

Assume we have a customer DB that allows creation of new customers by virtue
of XMLs.

An example of the respective XML implementation of allowing only admins to
create new customers:

<?xml version="1.0"?>
<web-app>
	<security-constraint>
		<web-resource-collection>
			<web-resource-name>customer creation</web-resource-name>
			<url-pattern>/services/customers</url-pattern>
			<http-method>POST</http-method>
		</web-resource-collection>
		<auth-constraint>
			<role-name>admin</role-name>
		</auth-constraint>
	</security-constraint>

	<login-config>
		<auth-method>BASIC</auth-method>
		<realm-name>jaxrs</realm-name>
	</login-config>

	<security-role>
		<role-name>admin</role-name>
	</security-role>
</web-app>

The Auth-method part defines what kind of authentication we wish to use. The possible values are:

BASIC, DIGEST or CLIENT_CERT. They corespond to Basic, Digest, and Client Certificate Auth.

the login-config does not turn on Authentication. To turn that on, we need to
specify the location and what kind of http-method we are securing.

In our case, the url we secure is /services/Customers and the Http-Method we
secure against is POST requests.

If weleave out the http-method, all http-methods are secured against.

Further more, we have the security-role that applies to the security-constraints.
Which means that this is the permissions we are setting for people, only allowing
admin to access it.

We can also define the role-name to be *, meaning all who can log-in.

For every role-name used in auth-constraints, we must have a coresponding
security-role in the deployment descriptor.

The url-pattern has some constrictions in terms of representations.
It does not allow for regex. At all. 

And the only legitimate wildcarding, is as follows:

/*  //anything that comes after the slash

/foo/* //anything that comes after /foo/

*.txt //Any URLs ending with txt file extensions

Enforcing Encryption:

To assert encryption of HTTPS connection, simply throw in a transport-guarantee 
within a <user-data-constraint> that has the value CONFIDENTIAL. An example:

<web-app>
	
	<security-constraint>
		<web-resource-collection>
			<web-resource-name>customer creation</web-resource-name>
			<url-pattern>/services/customers</url-pattern>
			<http-method>POST</http-method>
		</web-resource-collection>
		<auth-constraint>
			<role-name>admin</role-name>
		</auth-constraint>
		<user-data-constraint>
			<transport-guarantee>CONFIDENTIAL</transport-guarantee>
		</user-data-constraint>
	</security-constraint>
</web-app>

If one attempts to access a URL that has this format, with HTTP, they will be redirected
to a HTTPS based URL.

Authorization Annotations:

There are a few annotations that do specific interaction constraints in terms of Jax-RS:

@RolesAllowed:

If placed on a class, defiens all default access of the HTTP operations in said class,
to be the level of the role.

If applied to a method, it only counts for that method.

@PermitAll:

Allows for any logged in user. Scope works as per usual, if defined to class, spans all
HTTP related operations in said class, if defined for method, it applies to said method.

Let's look at an example:

@Path("/customers")
@RolesAllowed({"ADMIN", "CUSTOMER"})
public class CustomerResource{
	
	@GET
	@Path("{id}")
	@Produces("application/xml")
	public Customer getCustomer(@PathParam("id") int id) {...}

	@RolesAllowed("ADMIN")
	@POST
	@Consumes("application/xml")
	public void createCustomer(Customer cust) {...}

	@PermitAll
	@GET
	@Produces("application/xml")
	public Customer[] getCustomers() {}
}

In the above example, the default is ADMIN and CUSTOMER.

If there is a Role annotation, it will override the default, otherwise, it sticks to default.

The advantage of Annotation control, is how precise it is. It can allow for specification
of delimitation in access to data types that can be expensive to generate. An example:

@Path("/customers")
public class CustomerService{
	
	@GET
	@Produces("application/xml")
	@RolesAllowed("XML-USERS")
	public Customer getXmlCustomers() {}

	@GET
	@Produces("aplication/json")
	@RolesAllowed("JSON-USERS")
	public Customer getJsonCustomers() {}
}

Programmatic Security:

There is a API to help to get some info about secured requests. The interface
of javax.ws.rs.core.SecurityContext interface has a method for determining
the identity of the user making the secured HTTP invocation.

The interface is as:

public interface SecurityContext{
	public Principal getUserPrincipal();
	public boolean isUserInRole(String role);
	public boolean isSecure();
	public String getAuthenticationScheme();
}

The getUserPrincipal returns a javax.security.Principal security interface.
the Principal object represents the individual user who is currently invoking
the HTTP request.

The others are self explanitory, as for getAuthenticationScheme returns what
scheme was used, as in BASIC, DIGEST, CLIENT_CERT and FORM.

We can access he SecurityContext by injecting it into a field, setter method or
resource method param using the @Context annotation.

An example of using a security interface to access all loggings not done by
a ADMIN user:

@Path("/customers")
public class CustomerService{
	
	@GET
	@Produces("application/xml")
	public Customer[] getCustomers(@Context SecurityContext sec){
		if (sec.isSecure() && !sec.isUserInRole("ADMIN")){
			logger.log(sec.getUserPrincipal() + " accessed customer database.");
		}
	}
}

With filters, we can overwrite the default SecurityContext interface and override
the current request's SecurityContext via the ContainerRequestContext.setSecurityContext().

This means we can put in our own security protocols.

An example:

@PreMatching
public class CustomAuth implements ContainerRequestFilter {
	protected MyCustomProtocolHandler customProtocol = ...;

	public void filter(ContainerRequestContext requestContext) throws IOException
	{
		String authHeader = request.getHeaderString(HttpHeaders.AUTHORIZATION);
		SecurityContext newSecurityContext = customProtocol.validate(authHeader);
		requestContext.setSecurityContext(authHeader);
	}
}

Of course, there is a lot more available in terms of details.

Client Security:

To implement basic authentication, just do as follows:

import org.jboss.resteasy.client.jaxrs.BasicAuthentication;

Client client = Client.newClient();
client.register(new BasicAuthentication("username", "password"));

To use two-way SSL with client certificates, use java.security.KeyStore
as follows:

abstract class ClientBuilder {
	public ClientBuilder keyStore(final KeyStore keyStore, final String password)
}

The ClientBuilder also has methods to make our own SSLContext, but we won't cover
that here.

Verifying the Server:

We can verify our servers with our own KeyStore:

abstract class ClientBuilder {
	public abstract ClientBuilder trustStore(final KeyStore trustStore);
}

How to initialize and populate the keyStore, won't be covered here.

OAuth 2.0:

The process is as follows:

Redirect with a session cookie containing info such as client_id, state, and redirect_uri.

client_id is the Google username CNN has registered with Google.com,
State is the same as the one in the cookie,
the redirect_uri is the redirect after authentication.

Google asks you to grant permissions to CNN after logging in.

If yes, google makes a access code.

Redirection back with said access code is done.

CNN checks the State query param to see if it matches against the cookies.

CNN extracts the query param, sends it to Google, Google verifies it,
and a Access token is sent back to CNN.

CNN can now make requests to other Google services to obtain info it wants.
It does it by passing the token in an Authorization header with a value of
bearer and the token:

GET /contacts?user=billburke
Host: contacts.google.com
Authorization: Bearer <stuff>

Everyone uses their own spin of this, though. Same goes for OAuth.
It's a general guideline, not a Protocol set in stone.

There are frameworks to help with this, like Keycloak.

Signing and Encrypting Message Bodies:

To assure security in terms of Intermediate services (as per posting to say, Twitter and getting
a tweet through the Twitter REST API), we Digitally ensign or encrypt the representation itself.

Digital Signatures:

We use the Asymetrical key pair functionings to ensure encryption. Meaning one private key
and one public key, to which we hash and use algorithms on.

Hashing is just a String derived from the key you store that we use for quick indexing
and checking of addressing the data itself.

We will go through two methods, here:

DKIM/DOSETA:

DomainKeys Identified Mail(DKIM). 

Original used for mails, it is a signature contained in the header.

An example:

DKIM-Signature: v=1;
				a=rsa-sha256;
				d=example.com;
				s=burke;
				c=simple/simple;
				h=Content-Type;
				x=<value>;
				bh=<value>;
				b=<value>;

The values are as follows:

v: Protocol version

a: Algorithm used to hash and sign the message. RSA signing and SHA256 hashing
is the only supported algo at the moment by RESTEasy

d: Domain of the signer, used to identify the signer as well as discover the public
key to use to verify the signature.

s: Selector of the domain. Also used to identify the signer and discover the public key.

c: Canonical Algorithm. only simple/simple is supported. Allows for transformation of the 
message body before calculating the hash.

h: Semicolon-delimited list of headers that are included in the signature calculation.

x: Expiration of signature. Numeric long value of seconds since epoch. Allows a signer to control
when a signed message's signature expires.

t: Timestamp of signature. Signature expiration for verifier.

bh: Base 64 encoded hash of the message body

b: Base 64 encoded signature

What's cool about DKIM is that you can include individual headers within your 
digital signature of the message. Usually Content-Type is included.

To verify a signature, you need a public key. DKIM uses DNS text
records to discover a public key.

To find a public key, the verifier makes he following pattern:

s._domainKey.d //s and d are the s and d params, selector and domain

It then takse that string and does a DNS request to retreive a TXT record
under that entry.

In our previous example, burke._domainKey.example.com would be used as the 
lookup string.

If we wish, most DKIM frameworks allows us to discover our own public keys.

JOSE JWS:

JOSE JSON web signature.

A selfcontained signature format that contains both the digital signature and the 
message you want to sign.

it is a very compact 64-bit text format that concatenates the stuff with . delimiters.

An example:

HTTP/1.1 200 OK
Content-Type: application/jose+json

<JSON header that describes the message, encoded> //Usually contains alg and cty headers, algorithm and Content-Type
.
<Encoded actual content>
.
<Encoded digital signature> //Should use same alg as header

Since the whole thing is ASCII, you can just throw it in HTTP header values. Allows
sending any format of data, JSON or Binary etc, within HTTP headers quite easily.

Encrypting Representations:

While we can use HTTPS to encrypt the requests and responses, if we wish
to encrypt the body, we can use for example JOSE JSON Web Encryption (JWE).

It works akin to the earlier JOSE JSON web signature thing, running encryption 
on 5 delimeted 64 bit String pieces, you could say.

The first is a JSON header describing what is transmitted.

Second is encoded string that is a encrypted key used to encrypt
the message.

third is initialization vector used to encrypt the first block of bytes.

Fourth is actual encrypted message.

Fifth is extra metadata to validate the message.

An example of a full request:

HTTP/1.1 200 OK
Content-Type: application/jose+json

<stuff>.
<stuff>.
<stuff>. etc.

The encoded header,is as follows:

{
	"alg": "RSA1_5", //Algorithm for encrypting message
	"enc": "A128CBC-HS256", //encryption method
	"cty": "application/xml" //Content type of the message signed
}

The Algorithms come in two flavors, shared secret (pw) or public/secret key (Asymetric key pair)

The encoded parts is specific for the algorithm you are using. 

Again, this is pure ASCII, so you can just throw it in a HTTP header.
Meaning that if we wish to encrypt a HTTP value, this is a good way to do it.

Alternative Java Clients:

java.net.URL:

From a URL, you can create an HttpURLConnection that allows you to 
invoke specific requests. An example of doing a simple GET request:

URL url = new URL("http://example.com/customers/1");
connection = (HttpURLConnection) url.openConnection();
connection.setRequestMethod("GET");
connection.setRequestProperty("Accept", "application/xml");

if (connection.getResponseCode() != 200){
	throw new RuntimeException("Operation failed: " + connection.getResponseCode());
}

System.out.println("Content-Type: " + connection.getContentType());

BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));

String line = reader.readLine();
while (line != null){
	System.out.println(line);
	line = reader.readLine();
}
connection.disconnect();

Sending content via a PUT or POST is a little different. Here's an example of 
that:

URL url = new URL("http://example.com/customers");
HttpURLConnection connection = (HttpURLConnection) url.openConnection();
connection.setDoOutput(true);

connection.setInstanceFollowRedirects(false);
connection.setRequestMethod("POST");
connection.setRequestProperty("Content-Type", "application/xml");

OutputStream os = connection.getOutputStream();
os.write("<customer id='333'/>".getBytes());
os.flush();
if(connection.getResponseCode() != HttpURLConnection.HTTP_CREATED){
	throw new RuntimeException("Failed to create customer");
}

System.out.println("Location: " + connection.getHeaderField("Location"));
connection.disconnect();

Caching:

To turn of caching, just do: HttpURLConnection.setUseCaches(false); 
It is on by default.

Authentication:

The HttpURLConnection supports basic, digest, and client certificate auth.

Here's an example:

Authenticator.setDefault(new Authenticator(){
	protected PasswordAuthentication getPasswordAuthentication(){
		return new PasswordAuthentication ("username", "password".toCharArray());
	}
});

The problem with the default setDefault, is VM-Wide. So, it becomes problematic
for multithreaded environments. To resolve this, we can use ThreadLocalized things:

public class MultiThreadedAuthenticator extends Authenticator {
	private static ThreadLocal<String> username = new ThreadLocal<String>();
	private static ThreadLocal<String> password = new ThreadLocal<String>();

	public static void setThreadUsername(String user){
		username.set(user);
	}

	public static void setThreadPassword(String pwd){
		password.set(pwd);
	}

	protected PasswordAuthentication getPasswordAuthentication(){
		return new PasswordAuthentication(username.get(),
										  password.get().toCharArray());
	}
}

Using the class would be as follows:

Authenticator.setDefault(new MultiThreadedAuthenticator());

MultiThreadedAuthenticator.setThreadUsername("bill");
MultiThreadedAuthenticator.setThreadPassword("geheim");

Client Certificate Authentication:

Client Certificate Authentication is a bit different. First,
we must generate a client certificate using the keytool command-line utility
that comes with the JDK:

$ <JAVA_HOME>/bin/keytool -genkey -alias client-alias -keyalg RSA
-keypass changeit -storepass changeit -keystore keystore.jks

Next, you must export the certificate into a file so it can be imported
into a truststore:

$ <JAVA_HOME>/bin/keytool -export -alias client-alias -storepass
changeit -file client.cer -keystore keystore.jks

Finally, we create a truststore and import the created client certificate:

$ <JAVA_HOME>\bin\keytool -import -v -trustcacerts -alias
client-alias -file client.cer -keystore cacerts.jks
-keypass changeit -storepass changeit

Now that we have a truststore, we can create a javax.net.ssl.SSLSocketFactory
within our client code:

//imports

public class MyClient {
	public static SSLSocketFactory getFactory(File pKeyFile, String pKeyPassword) throws Exception{

		KeyManagerFactory KeyManagerFactory = KeyManagerFactory.getInstance("SunX509");

		KeyStore keyStore = KeyStore.getInstance("PKCS12");

		InputStream keyInput = new FileInputStream(pKeyFile);
		keyStore.load(keyInput, pKeyPassword.toCharArray());
		keyInput.close();

		keyManagerFactory.init(keyStore, pKeyPassword.toCharArray());

		SSLContext context = SSLContext.getInstance("TLS");
		context.init(keyManagerFactory.getKeyManagers(), null, new SecureRandom());

		return context.getSocketFactory();
	}

	//We can then use it:

	public static void main(String[] args) throws Exception{
		URL url = new URL("https://someurl");
		HttpsURLConnection con = (HttpsURLConnection) url.openConnection();
		con.setSSLSocketFactory(getFactory(new File("cacerts.jks"), "changeit"));
	}
}

We can then just make invocations to the url, as it has had the client cert
put into it.

Advantages and Disadvantages:

The advantage of the java.net API is that it is built in.

The disadvantages, are:

It's not JAX-RS-aware. We do our own processing of streams etc.

There is no preempetive authentication. Causing authentication required
places to double up on requests, as first will fail, and then retry with
the required format.

It cannot handle form params. We do the data parsing ourselves.

The framework only supports the HTTP methods of GET, POST, DELETE, PUT, TRACE, OPTIONS and HEAD.
Any other will make for an exception.

Apache HttpClient:

It can automatically handle cookies, preempetive Auth, and a few media types akin to
forms and multipart.

it is not JAX-RS-aware.

Some of the other features, are full interceptor model and pluggable authentication.

An example of using it:

import org.apache.http.*;
import org.apache.http.client.*;

public class MyClient {
	
	public static void main(String[] args) throws Exception {
		DefaultHttpClient client = new DefaultHttpClient();

		HttpGet get = new HttpGet("http://example.com/customers/1");
		get.addHeader("accept", "application/xml");

		HttpResponse response = client.execute(get);
		if (response.getStatusLine().getStatusCode() != 200){
			throw new RuntimeException("Operation failed: " + response.getStatusLine().getStatusCode());
		}

		System.out.println("Content-Type: " + response.getEntity().getContentType().getValue());

		BufferedReader reader = new BufferedReader(new InputStreamReader(response.getEntity()
																				 .getInputStream()));

		String line = reader.readLine();
		while (line != null) {
			System.out.println(line);
			line = reader.readLine();
		}

		client.getConnectionManager().shutdown();
	}
}

in the apache httpclient 4.x, the DefaultHttpClient is responsible for managing the connections.

It handles default authentication settings, pools and manages persistent HTTP connections (keepalive)
and any other default configuration settings.

To make a Post request, we have to do slightly different:

import org.apache.http.*;
import org.apache.http.client.*;
import org.apache.impl.client.*;

public class MyClient {
	public static main(String[] args) throws Exception {
		DefaultHttpClient client = new DefaultHttpClient();

		HttpPost post = new HttpPost("http://example.com/customers");
		StringEntity entity = new StringEntity("<customer id='333'/>");
		entity.setContentType("application/xml");

		post.setEntity(entity);
		HttpClientParams.setRedirection(post.getParams(), false);
		HttpResponse response = client.execute(post);

		if(response.getStatusLine().getStatusCode() != 201){
			throw new RuntimeException("Operation failed: " + 
					  response.getStatusLine().getStatusCode());
		}

		String location = response.getLastHeader("Location")
									.getValue();

		System.out.println("Object created at: " + location);
		System.out.println("Content-Type: " + response.getEntity().getContentType().getValue());

		BufferedReader reader = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));

		String line = reader.readLine();
		while (line != null){
			System.out.println(line);
			line = reader.readLine();
		}

		client.getConnectionManager().shutdown();
	}
}

Authentication:

To perform Basic or Digest authentication, we can do as follows:

DefaultHttpClient client = new DefaultHttpClient();
client.getCredentialsProvider().setCredentials(
	new AuthScope("example.com", 443),
	new UsernamePasswordCredentials("bill", "geheim");
);

The AuthScope defines the server and port. The UsernamPasswordCredentials is a Authentication object (kinda).

The Appache HttpClient does support preempetive authentication for basic and Digest protocols,
but it is not activated by default.

We won't show how to use it, here.

Client Certificate Authentication:

The Apache HttpClient also supports Client Certificate Authentication.
As with HttpsURLConnection, you have to load in a KeyStore that contains your 
client certificates.

we just spawn a SSLSocketFactory with a loaded KeyStore, and associate it
with the DefaultHttpClient.

An example:

//imports

public class MyClient {
	public final static void main(String[] args) throws Exception {
		DefaultHttpClient client = new DefaultHttpClient();

		KeyStore trustStore = KeyStore.getInstance(
								  KeyStore.getDefaultType());

		FileInputStream instream = new FileInputStream(
										new File("my.keystore"));

		try{
			trustStore.load(instream, "changeit".toCharArray());
		} finally {
			instream.close();
		}

		SSLSocketFactory socketFactory = new SSLSocketFactory(trustStore);

		Scheme scheme = new Scheme("https", socketFactory, 443);
		client.getConnectionManager()
			   .getSchemeRegistry().register(scheme);

		HttpGet httpget = new HttpGet("https://localhost/");

		//Proceed with the invocation
	}
}

Advantages and Disadvantages:

Apache HttpClient is a more complete solution and is better designed than
java.net.HttpURLConnection. Although you have to download it seperately from JDK.

The only disadvantage is that it is not inheritly jax-RS aware, but that can be
resolved by having it be as the default underlying HTTP client engine in differing
systems such as RESTEasy and other JAX-RS implementations.

RESTEasy Client Proxies:

The RESTEasy Client Proxy framework, has the idea of reusing the JAX-RS annotations
on the client side.

Normally, we use the JAX-RS annotations to turn them into method calls.

This framework, does the opposite. It turns method calls into HTTP requests.

We begin by writing a java interface for the client interface in regards to
the customer service application:

@Path("/customers")
public interface CustomerResource{
	
	@GET
	@Produces("application/xml")
	@Path("{id}")
	public Customer getCustomer(@PathParam("id") int id);

	@POST
	@Consumes("application/xml")
	public Response createCustomer(Customer customer);

	@PUT
	@Consumes("application/xml")
	@Path("{id}")
	public void updateCustomer(@PathParam("id") int id, Customer cust);
}

Through RESTEasy we can turn this interface into a Java object that can invoke
HTTP request.

We can use org.jboss.resteasy.client.jaxrs.ResteasyWebTarget interface:

Client client = ClientFactory.newClient();
WebTarget target = client.target("http://example.com/base/uri");
ResteasyWebTarget target = (ResteasyWebTarget) target;

CustomerResource customerProxy = target.proxy(CustomerResource.class);

to then interact with the WebTarget, all we do gotta do, is use the 
proxy(). it returns an instance of the CustomerResource interface that we can invoke on.

An example:

//Create a customer
Customer newCust = new Customer();
newCust.setName("bill");
Response response = customerProxy.createCustomer(newCust);

//Get a customer
Customer cust = customerProxy.getCustomer(333);

//Update a customer
cust.setName("burke");
customerProxy.updateCustomer(333, cust);

Above, we can see that we create a Customer instance and interact with the proxy,
in such a way that the proxy looks up the resource defined paths, annotations
and what not.

This allows us to easily streamline the process of unmarshalling, targetting,
type requests etc. Since the Annotations from the interface already are scanned
and interacted with.

Advantages and Disadvantages:

There are a lot of advantages to this. Skip boilerplate, clear documentation,
the disadvantage is that it is proprietary. (Someone owns it).

Installing RESTEasy and the Examples:

The RESTEasy dirs:

Dir 					Desc

docs/javadocs 			Generated Javadocs for both the JAX-RS APIs and RESTEasy

docs/userguide 			Reference guide for RESTEasy in both HTML and PDF format

examples 				Top-level dir containing all RESTEasy examples

examples/oreilly- 		Contains workbook example code for each workbook chapter
jaxrs-2.0-workbook

lib 					All the RESTEasy JARs and the third-party libraries they depend on

embedded-lib 			Optional JAR files used when you are running RESTEasy in embedded mode

resteasy-jaxrs.war 		Sample RESTEasy server deployment

The above is true for the download related to the book itself.

To run the examples, we need to have Maven.

The general code structure is as follows:

ex03_1 //Example
	src
		main
			java
			webapp
				WEB-INF
		test
			java

Maven uses a XML to generate it's dependancies and configs, in the book examples it exists
in the top-level dir of each example.

Environment Setup:

To setup Maven, you have to run the path command: //Setting the path 

Windows:

C:\> set PATH=\maven\bin;%PATH%

Unix:

$ export PATH=/home/username/maven/bin:$PATH

Build and Run the example Program:

Open the cmd prompt on the respective dir (ex03_1)

Make sure PATH is set corerctly

do maven install

The exact structure of the examples, will be as follows:

ex03_1
	pom.xml
	README.txt
	V src //This is a dir
		V main
			V java
				V com
					V restfully
						V shop
							V domain
								Customer.java
							V services
								CustomerResource.java
								ShoppingApplication.java
			V webapp
				V WEB-INF
					web.xml
		V test
			V java
				V com
					V restfully
						V shop
							V test
								CustomerResourceTest.java

An explonation of the dir structure is as follows:

dir 				desc

src 				Top-level dir that contains all source and config files

src/main 			Contains all java source code and config files that are used to create the package.
					In our case, we're making a WAR file.

src/main/java 		Contains server-side Java source code

src/main/webapp 	Contains servlet config files, specifically web.xml

src/test/java 		Contains java source code that will be used to run tests on the packaged archive.
					This code is not included in the WAR

Deconstructing pom.xml:

Maven will use the info in pom.xml to compile the code within src/main/java,
create a WAR file using the web.xml within the src/main/webapp, deploy the WAR file
using the Jetty-embedded servlet container, and run any test code that is within
the src/test/java dir.

A breakdown of the pom.xml:

<project xmlns="http://maven.apache.org/POM/4.0.0"
		 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		 xsi:schemaLocation="http://maven.apache.org/
		 				POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
	<parent> //Inherit attributes of the following things
		<groupId>com.oreilly.rest.workbook</groupId> //Lib dependancies location
		<artifactId>jaxrs-2.0-workbook-pom</artifactId> //Name of the project
		<version>1.0</version> //Version
		<relativePath>../pom.xml</relativePath> //relative path to the pom.xml
	</parent>
	<modelVersion>4.0.0</modelVersion>

	<packaging>war</packaging> //The type of package

	//Next we must define the dependancies:

	<dependencies>
		<dependency>
			<groupId>org.jboss.resteasy</groupId>
			<artifactId>resteasy-jaxrs</artifactId>
			<version>3.0.5.Final</version>
		</dependency>
		<dependency>
			<groupId>org.jboss.resteasy</groupId>
			<artifactId>resteasy-client</artifactId>
			<version>3.0.5.Final</version>
		</dependency>
		<dependency>
			<groupId>org.jboss.resteasy</groupId>
			<artifactId>async-http-servlet-3.0</artifactId>
			<version>3.0.5.Final</version>
		</dependency>
		<dependency>
			<groupId>org.jboss.resteasy</groupId>
			<artifactId>jaxrs-api</artifactId>
			<version>3.0.5.Final</version>
		</dependency>
		<dependency>
			<groupId>org.jboss.resteasy</groupId>
			<artifactId>resteasy-servlet-initializer</artifactId>
			<version>3.0.5.Final</version>
		</dependency>
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.1</version>
			<scope>test</scope>
		</dependency>
	</dependencies>

The dependancies are what we need to ru nthe project. Maven will search
for these in the target repos listed in the parent POM.

We can see that we need a number of dependancies, junit, jaxrs-api, resteasy-servlet, resteasy-client,
resteasy-jaxrs etc.

The transitive dependancies, the ones that have metadata related to them in the Remote repo,
will also be found and loaded. Assume for instance we load RESTEasy, and we get
all the dependencies for that as well.

Unless a scope is specified, all transitive dependancies are loaded.  and put into
the WAR's WEB-INF/lib dir when it is built.

With the test scope, we delimit so that we do not include all transitive libs.
It is not needed, cause the target servers already have the dependencies.

If the target environment have the relevant dependencies, just write:

<scope>provider</scope>

instead.

Carrying on with the pom.xml:

	<build>
		<finalName>ex03_1</finalName>

This names the WAR to be ex03_1.war

		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<configuration>
					<source>1.6</source>
					<target>1.6</target>
				</configuration>
			</plugin>

			//The above plugin is for compiling

			//next up, is the assurance test plugins

			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-surefire-plugin</artifactId>
				<configuration>
					<skip>true</skip>
				</configuration>
				<executions>
					<execution>
						<id>surefire-it</id>
						<phase>integration-test</phase>
						<goals>
							<goal>test</goal>
						</goals>
						<configuration>
							<skip>false</skip>
						</configuration>
					</execution>
				</executions>
			</plugin>

			//The above code is that we integrate the WAR to Jetty-embedded servlet and then run tests on it

			<plugin>
				<groupId>org.mortbay.jetty</groupId>
				<artifactId>jetty-maven-plugin</artifactId>
				<version>8.1.11.v20130520</version>
				<configuration>
					<webApp>
						<contextPath>/</contextPath>
					</webApp>
					<scanIntervalSeconds>10</scanIntervalSeconds>
					<stopKey>foo</stopKey>
					<stopPort>9999</stopPort>
				</configuration>
				<executions>
					<execution>
						<id>start-jetty</id>
						<phase>pre-integration-test</phase>
						<goals>
							<goal>run</goal>
						</goals>
						<configuration>
							<scanIntervalSeconds>0</scanIntervalSeconds>
							<daemon>true</daemon>
						</configuration>
					</execution>
					<execution>
						<id>stop-jetty<id>
						<phase>post-integration-test</phase>
						<goals>
							<goal>stop</goal>
						</goals>
					</execution>
				</executions>
			</plugin>

			//The above part launches Jetty as the embedded servlet container
			//It will boot under 8080 (Standard port) and stop port for 9999
			//We need to change these if we have services run on thoose already


Running the build:

To run the build, just run mvn install at the cmd prompt from the ex03_1 dir.

Maven will then install dependenicies, compile, deploy the WAR file to Jetty.

Examining the Source Code:

The only difference with this code, is that we use JUnit testing.

To allow Maven to do this, we just use a different annotation basically:

package com.restfully.shop.test;

import org.junit.Test;

import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.client.Entity;
import javax.ws.rs.core.Response;

public class CustomerResourceTest
{
	@Test
	public void testCustomerResource() throws Exception {

	}
}

The test class only has one annotation, @Test, which designates it as a JUnit test for 
Maven to find and use.

The next three examples, will be on how to define a new HTTP method called PATCH,
one that adds on Customer service DB example by adding some regex, the third being
a subresource locator.

Example ex04_1:HTTP Method Extension

Build and Run the example code:

Open the cmd prompt on the target dir

assure Path allocation

run mvn install

The Server Code:

An example of defining a PATCH annotation:

// src/main/java/org/ieft/annotations/PATCH.java

package org.ief.annotations;

@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@HttpMethod("PATCH")
public @interface PATCH
{
	
}

We then add the method to handle the patch annotation:

// src/main/java/com/restfully/shop/services/CustomerResource.java

@Path("/customers")
public class CustomerResource {
	@PATCH
	@Path("{id}")
	@Consumes("application/xml")
	public void patchCustomer(@PathParam("id") int id, InputStream is)
	{
		updateCustomer(id, is);
	}
}

All we do is delegate to update Customer.

The Client Code:

Some of the minor changes we have done to the PatchTest:

//imports

public class PatchTest
{
	private static Client client;

	@BeforeClass
	public static void initClient()
	{
		client = ClientBuilder.newClient();
	}

	@AfterClass
	public static void closeClient()
	{
		client.close();
	}
}

The rest of the class is akin to example 03_1, except these key differences:

String patchCustomer = "<customer>"
		+ "<first-name>William</first-name>"
		+ "</customer>";

response = client.target(location)
				 .request().method("PATCH", Entity.xml(patchCustomer));

if (response.getStatus() != 204)
	throw new RuntimeException("Failed to Update");
response.close();

To make the HTTP invokation, we just get the target based on location, access a request,
make the method to be Patch and insert the XML.

The next example, will showcase how to do @Paths with Regex:

Do the prerequisites of asserting path and running maven install

The Server Code:

The code is pretty similar to ex03_1, except a few modifications:

For example, we now only match against number IDs:

@Path("/customers")
public class CustomerResource {
	
	@GET
	@Path("{id : \\d+}")
	@Produces("application/xml")
	public StreamingOutput getCustomer(@PathParam("id") int id)
	{
		....
	}

	@PUT
	@Path("{id : \\d+}")
	@Consumes("application/xml")
	public void updateCustomer(@PathParam("id") int id, InputStream is)
	{
		....
	}
}

The next example, showcases only letters in the first and last name variables:

@GET
@Path("{first : + [a-zA-Z]+}-{last:[a-zA-Z]+}")
@Produces("application/xml")
public StreamingOutput getCustomerFirstLast(
								@PathParam("first") String first,
								@PathParam("last") String last)
{
	...	
}

The Client Code:

We just changed so that we match using getCustomerFirstLast.
It has been omitted.

Example ex04_3:Subresource Locators

The code is in src/test/java/com/restfully/shop/test/CustomerResourceTest.java:

public class CustomerResourceTest
{
	@Test
	public void testCustomerResource() throws Exception{
		...
	}

	@Test
	public void testFirstLastCustomerResource() throws Exception{
		...
	}
}

The code has been omitted. No point in explaining what they do without the actual code.

Example ex05_1: Injecting URI Information

The following example showcases Injection of URI information.

The Server Code:

The first we will look at is the Car resource:

src/main/java/com/restfully/shop/services/CarResource.java

	@Path("/cars")
	public class CarResource
	{
		public static enum Color
		{
			red,
			white,
			blue,
			black
		}

		@GET
		@Path("/matrix/{make}/{model}/{year}")
		@Produces("text/plain")
		public String getFromMatrixParam(
									@PathParam("make") String make,
									@PathParam("model") PathSegment car,
									@MatrixParam("color") Color color,
									@PathParam("year") String year)
		{
			return "A " + color + " " + year + " " + make + " " + car.getPath();
		}


		//The above example retrieves it by virtue of MatrixParam injection

		@GET
		@Path("/segment/{make}/{model}/{year}")
		@Produces("text/plain")
		public String getFromPathSegment(@PathParam("make") String make,
									@PathParam("model") PathSegment car,
								   @PathParam("year") String year)
		{
			String carColor = car.getMatrixParameters().getFirst("color");
			return "A " + carColor + " " + year + " " + make + " " + car.getPath();
		}

		//The above example retreives it by getting the pathsegment and retrieving matrixparams from it.

		@GET
		@Path("/segments/{make}/{model : .+}/year/{year}")
		@Produces("text/plain")
		public String getFromMultipleSegments(
								   @PathParam("make") String make,
								 @PathParam("model") List<PathSegment> car,
							   @PathParam("year") String year)
		{
			String output = "A " + year + " " + make;
			for (PathSegment segment : car)
			{
				output += " " + segment.getPath();
			}
			return output;
		}

		//The above example uses a Greedy quantifier to assert finding several parted model URIs.
		//meaning, in a /cars/segments/mercedes/e55/amg/year/2006, it would trigger on e55/amg

		//NOTE TO SELF: A thread is a Context of execution. It is a set of values for the processor
		//registers (for a single core). It includes isntruction pointers (Execution sequence)
		//and a Stack pointer (memory reference).

		//In other words, a Thread is a set of values for a processor register.

		//Also, a Daemon Thread is a Thread that is run in the background. It only stops
		//when the actual JVM stops. An example of a Daemon Thread is Garbage Collection.
		//We can create on by setDaemon(<value>) on a normal thread. Before it is run.
		//By default, a Thread inherits the Daemon status of it's parent thread.

		@GET
		@Path("uriinfo/{make}/{model}/{year}")
		@Produces("text/plain")
		public String getFromUriInfo(@Context UriInfo info)
		{
			String make = info.getPathParameters().getFirst("make");
			String year = info.getPathParameters().getFirst("year");
			PathSegment model = info.getPathSegments().get(3);

			String color = model.getMatrixParameters().getFirst("color");

			return "A " + color + " " + year + " " +
						make + " " + model.getPath();
		}

		//The above code retrieves the stuff by the UriInfo interface
		//We also showcase how to get the pathsegments, and target the matrix params and then color of that 
	}

The next example, is a CustomerResource that showcases defaulting cases in terms of retrieval from DBs:

@Path("/customers")
public class CustomerResource{
	
	@GET
	@Produces("application/xml")
	public StreamingOutput getCustomers(
				final @QueryParam("start") int start,
				final @QueryParam("size") @DefaultValue("2") int size)
	{

	}
}

The defaultvalue above, showcases how to default against Queries that do not
actually use the query params to handle their values.

The next example, does it programmaticaly using UriInfo:

@GET
@Produces("application/xml")
@Path("uriinfo")
public StreamingOutput getCustomers(@Context UriInfo info)
{
	int start = 0;
	int size = 2;
	if (info.getQueryParameters().containsKey("start"))
	{
		start = Integer.valueOf(info.getQueryParameters().getFirst("start"));
	}
	if (info.getQueryParameters().containsKey("size"))
	{
		size = Integer.valueOf(info.getQueryParameters().getFirst("size"));
	}
	return getCustomers(start, size);
}

The Client Code:

Mostly it's get requests:

src/test/java/com/restfully/shop/test/InjectionTest.java

The gets are:

GET http://localhost:8080/services/cars/matrix/mercedes/e55;color=black/2006
etc.

GET http://localhost:8080/services/customers
GET http://localhost:8080/services/customers?start=1&size=3
GET http://localhost:8080/services/customers/uriinfo?start=2&size=2

An example of using a Get request with queryParams put in programmatically:

list = client.target("http://localhost:8080/services/customers/uriinfo")
			 .queryParam("start", "2")
			 .queryParam("size", "2")
			 .request().get(String.class);

Example ex05_2: Forms and Cookies:

Showcases injections of data from cookies, forms and HTTP headers
using their annotations.

The Server Code:

//Note, these examples bases themselves on a Browser

The example starts off with a html form defined in src/main/webapp/index.html:

<html>
<body>
<form action="/rest/customers" method="post">
	First Name: <input type="text" name="firstname"/><br/>
	Last Name: <input type="text" name="lastname"/><br/>
	<INPUT type="submit" value="Send">
</form>

</body>
</html>

it is a simple form for creating a customer using our familiar CustomerResource service:

src/main/java/com/restfully/shop/CustomerResource.java

@Path("/customers")
public class CustomerResource {
	
	@POST
	@Produces("text/html")
	public Response createCustomer(@FormParam("firstname") String first, 
								   @FormParam("lastname") String last)
	{

	//The HTML form posts data to the createCustomer() method of CustomerResource when we click send

		Customer customer = new Customer();
		customer.setId(idCounter.incrementAndGet());

		customer.setFirstName(first);
		customer.setLastName(last);
		customerDB.put(customer.getId(), customer);

		System.out.println("Created customer " + customer.getId());

		String output = "Created customer <a href=\"customers/" + customer.getId() + "\"> + customer.getId()
				+ "</a>";

		String lastVisit = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.LONG).format(new Date());

		return Response.created(URI.create("/customers/" + customer.getId()))
					   .entity(output)
					   .cookie(new NewCookie("last-visit", lastVisit))
					   build();
	}

	//We make a response of that we created a customer, and we aquire the data with injections
	//in terms of FormParameters

	@GET
	@Path("{id}")
	@Produces("text/plain")
	public Response getCustomer(
						@PathParam("id") int id,
						 @HeaderParam("User-Agent") String userAgent,
						  @CookieParam("Last-visit") String date)
	{
		//We inject the parameter of the Cookie last visit and the type of browser

		final Customer customer = customerDB.get(id);
		if (customer == null){
			throw new WebApplicationException(Response.Status.NOT_FOUND);
		}

		String output = "User-Agent: " + userAgent + "\r\n";
		output += "Last visit: " + date + "\r\n\r\n";
		output += "Customer: " + customer.getFirstName() + " " + customer.getLastName();

		String lastVisit = DateFormat.getDateTimeInstance(
					DateFormat.SHORT, DateFormat.LONG).format(new Date());

		return Response.ok(output)
				.cookie(new NewCookie("last-visit", lastVisit))
				build();
	}
}

In the above logic, we update the date and time to the current time of doing. It outputs the User-Agent
header and last-visit cookie as plain text.

To build and run the example, we must do a bit more this time:

Cmd on the target dir

assert PATH assignments

type maven jetty:run to start the servlet

Example ex06_1:Using JAXB

The following example showcases exchange of XML over HTTP.

src/main/java/com/restfully/shop/domain/Customer.java

@XmlRootElement(name="customer")
public class Customer {
	private int id;
	private String firstName;
	private String lastName;
	private String street;
	private String city;
	private String state;

	private String zip;
	private String country;

	@XmlAttribute
	public int getId(){
		return id;
	}

	public void setId(int id){
		this.id = id;
	}

	@XmlElement(name="first-name")
	public String getFirstName(){
		return firstName;
	}

	public void setFirstName(String firstName){
		this.firstName = firstName;
	}

	@XmlElement(name="last-name")
	public String getLastName(){
		return lastName;
	}

	public void setLastName(String lastName){
		this.lastName = lastName;
	}

	@XmlElement
	public String getStreet(){
		return street;
	}
}

The JAXB annotations make a mapping between the XML and the Customer.

next is the Resource class:

src/main/java/com/restfully/shop/services/CustomerResource.java

@Path("/customers")
public class CustomerResource{
	private Map<Integer, Customer> customerDB = new ConcurrentHashMap<Integer, Customer>();

	private AtomicInteger idCounter = new AtomicInteger();

	public CustomerResource(){

	}

	@POST
	@Consumes("application/xml")
	public Response createCustomer(Customer customer){
		customer.setId(idCounter.incrementAndGet());
		customerDB.put(customer.getId(), customer);

		System.out.println("Created customer " + customer.getId());

		return Response.created(URI.create("/customers/" + customer.getId())).build();
	}

	@GET
	@Path("{id}")
	@Produces("application/xml")
	public Customer getCustomer(@PathParam("id") int id){
		Customer customer = customerDB.get(id);
		if (customer == null){
			throw new WebApplicationException(Response.Status.NOT_FOUND);
		}
		return customer;
	}

	@PUT
	@Path("{id}")
	@Consumes("application/xml")
	public void updateCustomer(@PathParam("id") int id,
											  Customer update){
		Customer current = customerDB.get(id);
		if (current == null)
			throw new WebApplicationException(Response.Status.NOT_FOUND);

		current.setFirstName(update.getFirstName());
		current.setLastName(update.getLastName());
		//Etc on setters with getters from Update


		}
}

The Client Code:

@Test
public void testCustomerResource() throws Exception
{
	System.out.println("*** Create a new Customer ***");
	Customer newCustomer = new Customer();
	newCustomer.setFirstName("Bill");
	//Set rest of attributes as well

	Response response = client.target("http://localhost:8080/services/customers")
							  .request().post(Entity.xml(newCustomer));

	if(response.getStatus() != 201){
		throw new RuntimeException("failed to create");
	}
}

We can see that the big difference is just that we can instantly apply to customer objects.

Changes to pom.xml:

The core RESTEasy does not contain JAXB handling. To implement it, inject
the dependency in the pom.xml:

<dependency>
	<groupId>org.jboss.resteasy</groupId>
	<artifactId>resteasy-jaxb-provider</artifactId>
	<version>1.2</version>
</dependency>

If we deploy our Java EE to servers like Wildfly or JBoss, we won't need this dependency.

To buil and run the example, just do the normal stuff:

cmd prompt on target folder

account for path

type maven install

Example ex06_2:Creating a Content Handler:

In this example, we are going to make a Java Object content handler for seinding
java objects over HTTP.

The Content Handler Code:

We begin with writing a class that is both a MessageBodyReader and a MessageBodyWriter:

src/main/java/com/restfully/shop/services/JavaMarshaller.java

@Provider
@Produces("application/example-java")
@Consumes("application/x-java-serialized-object") //can be written with application/example-java type as well
public class JavaMarshaller implements MessageBodyReader, MessageBodyWriter
{
	public boolean isReadable(Class type, Type genericType, Annotation[] annotations, MediaType mediaType)
	{
		return Serializable.class.isAssignableFrom(type);
	}

	public boolean isWritable(Class type, Type genericType, 
						Annotation[] annotations, MediaType mediaType)
	{
		return Serializable.class.isAssignableFrom(type);
	}

	public Object readFrom(Class type, Type genericType,
						Annotation[] annotations, MediaType mediaType,
							MultivaluedMap httpHeaders,
								InputStream is)
					throws IOException, WebApplicationException
	{
		ObjectInputStream ois = new ObjectInputStream(is);
		try
		{
			return ois.readObject();
		}
		catch (ClassNotFoundException e)
		{
			throw new RuntimeException(e);
		}
	}

	public void writeTo(Object o, Class type,
						 Type genericType, Annotation[] annotations,
						   MediaType mediaType,
						     MultivaluedMap httpHeaders, OutputStream os) throws IOException, WebApplicationException
	{
		ObjectOutputStream oos = new ObjectOutputStream(os);
		oos.writeObject(o);
	}

}

The resource class:

src/main/java/com/restfully/shop/services/CustomerResource.java

@Path("/customers")
public class CustomerResource
{
	
	@POST
	@Consumes("application/example-java")
	public Response createCustomer(Customer customer)
	{
		customer.setId(idCounter.incrementAndGet());
		customerDB.put(customer.getId(), customer);
		System.out.println("Created customer " + customer.getId());

		return Response.created(URI.create("/customers/" + customer.getId())).build();
	}
}

The rest of the code is omitted, since it's identical to the previous EX06_1,
the only difference being the example-java part in consumes

The Application Class:

src/main/java/com/restfully/shop/services/Shopping/Application.java

public class ShoppingApplication extends Application {
	private Set<Object> singletons = new HashSet<Object>();
	private Set<Class<?>> classes = new HashSet<Class<?>>();

	public ShoppingApplication(){
		singletons.add(new CustomerResource());
		classes.add(JavaMarshaller.class);
	}

	@Override
	public Set<Class<?>> getClasses(){
		return classes;
	}

	@Override
	public Set<Object> getSingletons(){
		return singletons;
	}
}

In the above example, we add the JavaMarshaller, to be able to handle the example-java class.

The Client Code:

The only difference in the Test section is that we changed the typing in the Test:

src/test/java/com/restfully/shop/test/CustomerResourceTest.java

public class CustomerResourceTest
{
	@Test
	public void testCustomerResource() throws Exception
	{
		Response response = client.target
				("http://localhost:8080/services/customers")
				.request().post(Entity.entity
								(newCustomer, "application/example-java"));
	}
}

The different is just that we pass along the entity as a different typing.

To build it and run it:

CMD on target map

PATH setup

perform maven install

Example ex07_1:ExceptionMapper

The following example is a slight modification from ex06_1 to show how we can use
ExceptionMappers.

Let us look at the CustomerResource class to see what is different:

src/main/java/com/restfully/shop/services/CustomerResource.java

@Path("/customers")
public class CustomerResource{
	@GET
	@Path("{id}")
	@Produces("application/xml")
	public Customer getCustomer(@PathParam("id") int id)
	{
		Customer customer = customerDB.get(id);
		if (customer == null)
		{
			throw new CustomerNotFoundException("Could not find customer " + id);
		}
		return customer;
	}

	@PUT
	@Path("{id}")
	@Consumes("application/xml")
	public void updateCustomer(@PathParam("id") int id,
								Customer update)
	{
		Customer current = customerDB.get(id);
		if(current == null)
			throw new CustomerNotFoundException("Could not find customer " + id);

		current.setFirstName(update.getFirstName());
		//Run rest of setters and getters
	}
}

What we do here, is that we define our own exception:

src/main/java/com/restfully/shop/services/CustomerNotFoundException.java

public class CustomerNotFoundException extends RuntimeException
{
	public NotFoundException(String s)
	{
		super(s);
	}
}

Albeit there is nothing special about this Exception, we will map this
to a Response, using a ExceptionMapper:

src/main/java/com/restfully/shop/services/CustomerNotFoundExceptionMapper.java

@Provider
public class NotFoundExceptionMapper implements ExceptionMapper<CustomerNotFoundException>
{
	public Response toResponse(NotFoundException exception)
	{
		return Response.status(Response.Status.NOT_FOUND)
					   .entity(exception.getMessage())
					   .type("text/plain").build();
	}
}

The above example will make it so that we will throw a RuntimeException on 404ing
the address. All we have to do now, is register the mapper in the Application class:

src/main/java/com/restfully/shop/services/ShoppingApplication.java

public class ShoppingApplication extends Application {
	private Set<Object> singletons = new HashSet<Object>();
	private Set<Class<?>> classes = new HashSet<Class<?>>();

	public ShoppingApplication()
	{
		singletons.add(new CustomerResource());
		classes.add(CustomerNotFoundExceptionMapper.class);
	}

	@Override
	public Set<Class<?>> getClasses()
	{
		return classes;
	}

	@Override
	public Set<Object> getSingletons()
	{
		return singletons;
	}
}

The Client Code:

It's simple, make a GET to a resource that does not exist:

src/test/java/com/restfully/shop/test/CustomerResourceTest.java

package com.restfully.shop.test;

import javax.ws.rs.NotFoundException;

...
	
	@Test
	public void testCustomerResource() throws Exception
	{
		try
		{
			Customer customer = client.target
										("http://localhost:8080/services/customers/1")
										.request().get(Customer.class);
			System.out.println("Should not get here!");
		}
		catch (NotFoundException e)
		{
			System.out.println("Caught error!");
			String error = e.getResponse().readEntity(String.class);
			System.out.println(error);
		}
	}

To run it, perform the usual steps.

CMD on target dir

assert PATH

type maven install

Example ex09_1: Conneg with JAX-RS

The following example will showcase how Accept can come to choose between alternatives for the 
most fitting one:

src/main/java/com/restfully/shop/services/CustomerResource.java

@Path("/customers")
public class CustomerResource {
	
	@GET
	@Path("{id}")
	@Produces({"application/xml", "application/json"})
	public Customer getCustomer(@PathParam("id") int id)
	{
		...
	}
}

We can also use the @Produces to direct to different resulting methods:

@GET
@Path("{id}")
@Produces("text/plain")
public Customer getCustomerString(@PathParam("id") int id)
{
	return getCustomer(id).toString();
}

This targets the same place, but directs to another method by virtue of having another produces
annotation.

The Client Code:

To get the different ones, the following example showcases specific targeting:

src/test/java/com/restfully/shop/test/CustomerResourceTest.java

public class CustomerResourceTest
{
	@Test
	public void testCustomerResource() throws Exception
	{
		//init code

		System.out.println("GET XML DOCUMENT");
		String xml = client.target(location).request()
								  .accept(MediaType.APPLICATION_XML_TYPE)
								  .get(String.class);

		System.out.println(xml);

		System.out.println("GET JSON DOCUMENT")
		String json = client.target(location).request()
			     .accept(MediaType.APPLICATION_JSON_TYPE)
			     .get(String.class);
		System.out.println(json);
	}
}

In the above example, the SyncInvoker accept is being called to set the Accept Header

To build and run it, just do he standard procedure:

CMD on target dir

assure PATH

maven install

Example ex09_2:Conneg via URL Patterns:

Browsers are mostly unable to use Accept Headers, so, instead,
we use a modification to target file extensions:

The Server Code:

@GET
@Path("{id}")
@Produces("text/html")
public String getCustomerHtml(@PathParam("id") int id)
{
	return "<h1>Customer As HTML</h1><pre>" + getCustomer(id).toString() + "</pre>";
}

Since we'll be interacting with this example in a browser, it would be nice
to have the data come back as HTML format.

The only thing we need to change as well, is the web.xml:

src/main/webapp/WEB-INF/web.xml

<web-app>
	<context-param>
		<param-name>resteasy.media.type.mappings</param-name>
		<param-value>
				html : text/html,
				txt : text/plain,
				xml : application/xml
		</param-value>
	</context-param>
</web-app>

In the above example, we just map file extensions to be against typings.
So if we get html, we just target text/html

To build and run it:

CMD on target dir

Set up PATH

type maven jetty:run //Since we are actively going against the server in a browser

To then showcase the process, just target different file extensions in terms of 
files:

http://localhost:8080/customers/1.txt or 1.xml or 1.html etc.

Example ex10_1: Atom Links

The following example, is a example showcasing Atom Links running queries
against DBs in the xml:

<customers>
	<customer id="3">
		...
	</customer>
	<customer id="4">
		...
	</customer>
	<link rel="next"
		  href="http://example.com/customers?start=5&size=2"
		  type="application/xml"/>
	<link rel="previous"
		  href="http://example.com/customers?start=1&size=2"
		  type="application/xml"/>
</customers>

The Server Code:

in the following example, we include adapters and links.

src/main/java/com/restfully/shop/domain/Customers.java

import javax.ws.rs.core.Link;
...

@XmlRootElement(name = "customers")
public class Customers
{
	protected Collection<Customer> customers;
	protected List<Link> links;

	@XmlElementRef
	public Collection<Customer> getCustomers()
	{
		return customers;
	}

	public void setCustomers(Collection<Customer> customers)
	{
		this.customers = customers;
	}

	@XmlElement(name="link")
	@XmlJavaTypeAdapter(Link.JaxbAdapter.class)
	public List<Link> getLinks()
	{
		return links;
	}

	public void setLinks(List<Link> links)
	{
		this.links = links;
	}

	@XmlTransient
	public URI getNext()
	{
		if (links == null) return null;
		for (Link link : links)
		{
			if ("next".equals(link.getRel())) return link.getUri();
		}
		return null;
	}

	@XmlTransient
	public URI getPrevious()
	{
		if (links == null) return null;
		for (Link link : links)
		{
			if ("previous".equals(link.getRel())) return link.getUri();
		}
		return null;
	}
}

In the above example, we have some simple get links, set links, and we have the get previous
and get next, which iterates through the relations of the links and returns respective
link if it matches

The final difference is the implementation of the GET /customers handling:

src/main/java/com/restfully/shop/services/CustomerResource.java

@Path("/customers")
public class CustomerResource
{
	@GET
	@Produces("application/xml")
	@Formatted
	public Customers getCustomers(@QueryParam("start") int start,
					@QueryParam("size") @DefaultValue("2") int size,
					@Context UriInfo uriInfo)
	{


The @Formatted formats XML. It's a plugin specific to RESTEasy.

Start and size are optional, the default of size is set to 2.

The uri Info injected, is used  to build URLs that define next and previous link relationships:

		UriBuilder builder = uriInfo.getAbsolutePathBuilder();
		builder.queryParam("start", "{start}");
		builder.queryParam("size", "{size}");

The builder acts as a template that we are building, where we populate the actual links later
on.

		ArrayList<Customer> list = new ArrayList<Customer>();
		ArrayList<Link> links = new ArrayList<Link>();
		synchronized (customerDB)
		{
			int i = 0;
			for (Customer customer : customerDB.values())
			{
				if (i >= start && i < start + size) 
					list.add(customer)
				i++;
			}

			//We do this synchronized to protect against concurrent access on the customerDB map.

			//next link
			if (start + size < customerDB.size())
			{
				int next = start + size;
				URI nextUri = builder.clone().build(next, size);
				Link nextLink = Link.fromUri(nextUri)
									.rel("next").type("application/xml").build();
				links.add(nextLink);
			}

			//Previous link
			if (start > 0)
			{
				int previous = start - size;
				if (previous < 0) previous = 0;
				URI previousUri = builder.clone().build(previous, size);

				Link previousLink = Link.fromUri(previousUri)
										.rel("previous")
										.type("application/xml").build();

				links.add(previousLink);
			}
		}

		//The above code just calculates to process the previous or next customers to
		//process for the final setting depending on direction we are going to

		Customers customers = new Customers();
		customers.setCustomers(list);
		customers.setLinks(links);
		return customers;
	}

//THe last part is just us returning the list of customers that are relevant

The Client Code:

The client initially gets the XML document from the /customers URL.
It then loops using the next link relationship as the URL to print out all
the customers in the DB:

public class CustomerResourceTest
{
	@Test
	public void testQueryCustomers() throws Exception
	{
		URI uri = new URI("http://localhost:8080/services/customers");
		while (uri != null)
		{
			WebTarget target = client.target(uri);
			String output = target.request().get(String class);
			System.out.println("** XML from " + uri.toString());
			System.out.println(output);

			Customers customers = target.request().get(Customers.class);
			uri = customers.getNext();
		}
	}
}

What occurs here, is that past the first url invocation, the atomic links
drive everything.

Build and Run:

Open a cmd on the target dir

Assert PATH config

maven install

Example ex10_2: Link Headers:

This example will showcase Link headers to navigate only needing one
published URL in the code.

The Server Code:

We add the Order and LineItem classes to marshal into the order entries in the system.
Won't be covered here.

OrderResource:

src/main/java/com/restfully/shop/services/OrderResource.java

@Path("/orders")
public class OrderResource
{
	private Map<Integer, Order> orderDB = new Hashtable<Integer, Order>();
	private AtomicInteger idCounter = new AtomicInteger();

	@POST
	@Consumes("application/xml")
	public Response createOrder(Order order, @Context UriInfo uriInfo)
	{
		order.setId(idCounter.incrementAndGet());
		orderDB.put(order.getId(), order);

		System.out.println("Created order " + order.getId());
		UriBuilder builder = uriInfo.getAbsolutePathBuilder();

		builder.path(Integer.toString(order.getId()));
		return Response.created(builder.build()).build();
	}

	@GET
	@Path("{id}")
	@Produces("application/xml")
	public Response getOrder(@PathParam("id") int id,
								@Context UriInfo uriInfo)
	{
		Order order = orderDB.get(id);
		if (order == null)
		{
			throw new WebApplicationException(Response.Status.NOT_FOUND);
		}
		Response.ResponseBuilder builder = Response.ok(order);
		if (!order.isCancelled()) addCancelHeader(uriInfo, builder);
		return builder.build();

		//If the order has not been cancelled, it is added to the Response header, where we
		//inform of where we can cancel the link
	}

	protected void addCancelHeader(UriInfo uriInfo,
									  Response.ResponseBuilder builder)
	{
		UriBuilder absolute = uriInfo.getAbsolutePathBuilder();
		URI cancelUrl = absolute.clone().path("cancel").build();
		builder.links(Link.fromUri(cancelUrl).rel("cancel").build());
	}

	//The cancelheader, simply adds the canceling link to the builder

	@HEAD
	@Path("{id}")
	@Produces("application/xml")
	public Response getOrderHeaders(@PathParam("id") int id,
									 @Context UriInfo uriInfo)
	{
		Order order = orderDB.get(id);
		if (order == null)
		{
			throw new WebApplicationException(Response.Status.NOT_FOUND);
		}

		Response.ResponseBuilder builder = Response.ok();
		builder.type("application/xml");
		if (!order.isCancelled()) addCancelHeader(uriInfo, builder);
		return builder.build();
	}

	//getOrderHeaders processes requests and returns a builder with said requests

	@POST
	@Path("{id}/cancel")
	public void cancelOrder(@PathParam("id") int id)
	{
		Order order = orderDB.get(id);
		if (order == null)
		{
			throw new WebApplicationException(Response.Status.NOT_FOUND);
		}
		order.setCancelled(true);
	}

	//The canceLorder simply returns the cancel link header with a empty body

	//users can cancel an order by posting an empty message to /orders/{id}/cancel

	@GET
	@Produces("application/xml")
	@Formatted
	public Response getOrders(@QueryParam("start") int start,
					  @QueryParam("size") @DefaultValue("2") int size,
					 @Context UriInfo uriInfo)
	{
		//Since it is similar to the getCustomers, we just highlight the differences
		Orders orders = new Orders();
		orders.setOrders(list);
		orders.setLinks(links);
		Response.ResponseBuilder responseBuilder = Response.ok(orders);

		addPurgeLinkHeader(uriInfo, responseBuilder);
		return responseBuilder.build;
	}

	protected void addPurgeLinkHeader(UriInfo uriInfo,
									  Response.ResponseBuilder builder)
	{
		UriBuilder absolute = uriInfo.getAbsolutePathBuilder();
		URI purgeUri = absolute.clone().path("purge").build();

		builder.links(Link.fromUri(purgeUri).rel("purge").build());
	}

	//The above is just to add a purge relation to link headers upon need

	@HEAD
	@Produces("application/xml")
	public Response getOrdersHeaders(@QueryParam("start") int start,
					  @QueryParam("size") @DefaultValue("2") int size,
					 @Context UriInfo uriInfo)
	{
		Response.ResponseBuilder builder = Response.ok();
		builder.type("application/xml");
		addPurgeLinkHeader(uriInfo, builder);
		return builder.build();
	}

	//The above is just yet another link relationship class between resources, convenience

	@POST
	@Path("purge")
	public void purgeOrders()
	{
		synchronized (orderDB)
		{
			List<Order> orders = new ArrayList<Order>();
			orders.addAll(orderDB.values());

			for (Order order : orders)
			{
				if (order.isCancelled())
				{
					orderDB.remove(order.getId());
				}
			}
		}
	}

	//The above is just the actual purging
}

StoreResource:

To showcase that we only need one hard URL to do pointing to stuff, what follows, is an 
example of that:

src/main/java/com/restfully/shop/services/StoreResource.java

@Path("/shop")
public class StoreResource
{
	@HEAD
	public Response head(@Context UriInfo uriInfo)
	{
		UriBuilder absolute = uriInfo.getBaseUriBuilder();

		URI customerUrl = absolute.clone().path(CustomerResource.class).build();
		URI orderUrl = absolute.clone().path(OrderResource.class).build();

		Response.ResponseBuilder builder = Response.ok();

		Link customers = Link.fromUri(customerUrl)
							 .rel("customers")
							 .type("application/xml").build();

		Link orders = Link.fromUri(orderUrl)
						  .rel("orders")
						  .type("application/xml").build();

		builder.links(customers, orders);
		return builder.build();
	}
}

The links above, points to the links generated by the Resources.

The Client Code:

The client code creates a new customer and order. It then cancels
the order, purges it, and finally relists the order entry DB.

All URLs are accessed via Link Headers or Atom Links:

public class OrderResourceTest
{
	@Test
	public void testCreateCancelPurge() throws Exception
	{
		String base = "http://localhost:8080/services/shop";
		Response response = client.target(base).request().head();

		Link customers = response.getLink("customers");
		Link orders = response.getLink("orders");
		response.close();

		//We then go to create a customet through said URL

		System.out.println("Create a customer through said URL: " + customers.getHref());

		Customer customer = new Customer();
		customer.setFirstName("Bill");
		customer.setLastName("Burke");
		customer.setStreet("10 Somewhere street");
		//etc on setters

		response = client.target(customers).request().post(Entity.xml(customer));
		Assert.assertEquals(201, response.getStatus());
		response.close();

		//We simply then send the xml based on the custom and assert that we got a accepted 
		//response code

		//next, we create a order and send it:

		Order order = new Order();
		order.setTotal("$199.99");
		order.setCustomer(customer);
		order.setDate(new Date().toString());

		LineItem item = new LineItem();
		item.setCost("$199");
		item.setProduct("iPhone");
		order.setLineItems(new ArrayList<LineItem>());

		order.getLineItems().add(item);

		System.out.println();
		System.out.println("Create an order through this url: " + orders.getUri().toString());

		response = client.target(orders).request().post(Entity.xml(order));
		Assert.assertEquals(201, response.getStatus());

		URI createdOrderUrl = response.getLocation();
		response.close();

		//Next we get the List of orders form the system to purge the cancelled stuff later

		System.out.println();
		System.out.println("New list of orders");
		response = client.target(orders).request().get();
		String orderList = response.readEntity(String.class);

		System.out.println(orderList);
		Link purge = response.getLink("purge");
		response.close();

		//Next we cancel the order from earlier

		response = client.target(createdOrderUrl).request().head();
		Link cancel = response.getLink("cancel");
		response.close();

		if(cancel != null)
		{
			System.out.println("Cancelling the order at URL: " + cancel.getUri().toString());
			response = client.target(cancel).request().post(null);
			Assert.assertEquals(204, response.getStatus());
			response.close();
		}

		//If there is a cancel to make, it posts an empty request to the said target to cancel
		//The order

		System.out.println();
		System.out.println("New list of orders after cancel: ");
		orderList = client.target(orders).request().get(String.class);
		System.out.println(orderList);

		//Makes a new get to showcase removal occured

		System.out.println();
		System.out.println("Purge cancelled orders at URL: " + purge.getUri().toString());

		response = client.target(purge).request().post(null);
		Assert.assertEquals(204, response.getStatus());
		response.close();

		System.out.println();
		System.out.println("New list of orders after Purge: ");
		orderList = client.target(orders).request().get(String.class);
		System.out.println(orderList);
	}

	//And with hte last segment, we purge the cancelled ones, and re-post the after purge list
}

Build and Run:

open a CMD prompt on target dir

Assert PATH

maven install

Example ex11_1: Caching and Concurrent Updates:

This example showcases caching, conditional GETs and conditional PUTs.

The Server Code:

src/main/java/com/restfully/shop/domain/Customer.java

@XmlRootElement(name = "customer")
public class Customer
{
	@Override
	public int hashCode()
	{
		int result = id;
		result = 31 * result + (firstName != null ? firstName.hashCode() : 0);

		result = 31 * result + (lastName != null ? lastName.hashCode() : 0);

		result = 31 * result + (street != null ? street.hashCode() : 0);

		result = 31 * result + (city != null ? city.hashCode() : 0);

		result = 31 * result + (state != null ? state.hashCode() : 0);

		result = 31 * result + (zip != null ? zip.hashCode() : 0);

		result = 31 * result + (country != null ? country.hashCode() : 0);

		return result;
	}
}

We use the above method to create a high probability unique (not absolutely unique, but high prob), hashcode
for our ETags.

We then go to expand the CustomerResource class to support conditional GETs and PUTs.
Let's look at the relevant piece of code:

src/main/java/com/restfully/shop/services/CustomerResource.java

@Path("/customers")
public class CustomerResource
{
	
	@GET
	@Path("{id}")
	@Produces("application/xml")
	public Response getCustomer(@PathParam("id") int id, 
								 @Context Request request) {
		Customer cust = customerDB.get(id);
		if (cust == null)
		{
			throw new WebApplicationException(Response.Status.NOT_FOUND);
		}

		if (sent == null) System.out.println("No ETag sent by client");

		EntityTag tag = new EntityTag(Integer.toString(cust.HashCode()));

		CacheControl cc = new CacheControl();
		cc.setMaxAge(5);

		Response.ResponseBuilder builder = request.evaluatePreconditions(tag);

		if (builder != null) {
			System.out.println("Revalidation on the server, was successful");

			builder.cacheControl(cc);
			return builder.build();
		}

		//If the preconditions was not met, i.e there i no value to begin with,
		//then we create one 

		cust.setLastViewed(new Date().toString());
		builder = Response.ok(cust, "application/xml");
		builder.cacheControl(cc);
		builder.tag(tag);
		return builder.build();
	}

	@Path("{id}")
	@PUT
	@Consumes("application/xml")
	public Response updateCustomer(@PathParam("id") int id,
									@Context Request request,
									 Customer update) {
		Customer cust = customerDB.get(id);

		if(cust == null)
			throw new WebApplicationException(Response.Status.NOT_FOUND);

		EntityTag tag = new EntityTag(Integer.toString(cust.hashCode()));

		Response.ResponseBuilder builder = request.evaluatePreconditions(tag);

		if (builder != null){	
			//Preconditions not met
			return builder.build();
		}

		//Preconditions met

		cust.setFirstName(update.getFirstName());
		//Set rest of attributes

		builder = Response.noContent();
		return builder.build();
	}
}

The update becomes performed.

The Client Code:

We do a conditional GET to see that the object is not modified:

public class CustomerResourceTest
{
	@Test
	public void testCustomerResource() throws Exception
	{
		WebTarget customerTarget = client.target("http://localhost:8080/services/customers/1");

		Response response = customerTarget.request().get();
		Assert.assertEquals(200, response.getStatus());

		Customer cust = response.readEntity(Customer.class);

		EntityTag etag = response.getEntityTag();
		response.close();

		System.out.println("doing a conditional GET with Etag: " + etag.toString());

		response = customerTarget.request()
								 .header("If-None-Match", etag).get();

		//Assert that we get not modified returned
		Assert.assertEquals(304, response.getStatus());
		response.close();


		//Update and send a bad etag with conditional PUT

		cust.setCity("Bedford");
		response = customerTarget.request()
				.header("If-Match", "JUNK")
				.put(Entity.xml(cust));

		Assert.assertEquals(412, response.getStatus());
		response.close();
	}
}

We expect to get a precondition not met on the second attempted update.

I do not know why we make the bad request tho.

We can just run this with the normal setup.

Alternative, we can run it with Jetty (maven jetty:run) to refresh
and see if the browser performs the get or not.

Example ex12_1: ContainerResponseFilter and DynamicFeature

We use the previously defined MaxAge annotation in this example.

src/main/java/com/restfully/shop/services/CustomerResource

@GET
@Path("{id}")
@Produces("application/xml")
@MaxAge(500)
public Customer getCustomer(@PathParam("id") int id)
{
	Customer customer = customerDB.get(id);
	if(customer == null)
	{
		throw new WebApplicationException(Response.Status.NOT_FOUND);
	}
	return customer;
}

By adding the MaxAge, we bind a CacheControlFilter with a max age of 500 seconds,
bound to this method upon execution. The filter adds a Cache-Control header
to the HTTP response with a max age of 500 seconds.

Let's look at how they are registered:

src/main/java/com/restfully/shop/services/ShoppingApplication.java

@ApplicationPath("/services")
public class ShoppingApplication extends Application
{
	private Set<Object> singletons = new HashSet<Object>();
	private Set<Class<?>> classes = new HashSet<Class<?>>();

	public ShoppingApplication()
	{
		singletons.add(new CustomerResource());
		classes.add(MaxAgeFeature.class);
	}

	@Override
	public Set<Class<?>> getClasses()
	{
		return classes;
	}

	@Override
	public Set<Object> getSingletons()
	{
		return singletons;
	}
}

In this example, we only register the MaxAge annotation, which binds the 
CacheControlFilters when we annotate with @MaxAge

The Client Code:

The client code has not really changed much. We create a Customer on the
server, and then do a GET to get that customer, checking for 
the Cache-Control header generated by the CacheControlFilter on 
the server side:

src/test/java/com/restfully/shop/test/CustomerResourceTest.java

...
	
	System.out.println("GET created Customer");
	response = client.target(location).request().get();
	CacheControl cc = CacheControl.valueOf(response.getHeaderString(HttpHeaders.CACHE_CONTROL));

	System.out.println("Max age: " + cc.getMaxAge());

The only thing that is interesting here is that we create a CacheControl from a String in the response.

Buil and run is as per usual.

CMD on target dir

Set up PATH directives

perform build with maven install

Example ex12_2: implementing a WriterInterceptor:

We are going to implement support for a Content-MD5 header that can
be used for seeing mutations through proxies and what not.

We really only do this to showcase how to support it with a WriterInterceptor:

public class ContentMD5Writer implements WriterInterceptor
{
	@Override
	public void aroundWriteTo(WriterInterceptorContext context) 
						throws IOException, WebApplicationException
	{
		MessageDigest digest = null;
		try
		{
			digest = MessageDigest.getInstance("MD5");
		}
		catch (NoSuchAlgorithmException e)
		{
			throw new IllegalArgumentException(e);
		}

		//We start off by making a MD5 MessageDigest, which
		//will allow us to make a MD5 hash of the entity we're marshalling

		ByteArrayOutputStream buffer = new ByteArrayOutputStream();
		DigestOutputStream digestStream = new DigestOutputStream(buffer, digest);

		OutputStream old = context.getOutputStream();
		context.setOutputStream(digestStream);

		//We make a ByteArrayOUtputStream, wrap it around in the MD5 digest
		//save the old output stream and then assign the MD5 digest hash stream

		//the ByteArray acts as a Buffer for the digest stream, which we need to put the encrypted data into

		//And by having replaced the outputstream, we changed who does the marshalling.

		try
		{

			//We proceed with the interceptor chain until we underlying MessageBodyWriter is invoked.
			//We then obtain the hash for the MessageDigest, and then base64 encode it.
			context.proceed();

			byte[] hash = digest.digest();
			String encodedHash = Base64.encodeBytes(hash);

			//Then we assign the Content-MD5 hash
			context.getHeaders().putSingle("Content-MD5", encodedHash);

			//We convert the buffer and then write it out on the original output stream

			byte[] content = buffer.toByteArray();
			old.write(content);
		}
		finally
		{
			//After we are done intercepting, re-assign the old output stream as 
			//The one we use. This is to assert that we don't use the interceptors
			//, so it's basically cleanup.
			context.setOutputStream(old);
		}
	}
}

The Client Code:

It's basically the same as ex12_1 except we are viewing the returned Content-MD5 header:

src/test/java/com/restfully/shop/test/CustomerResourceTest.java

@Test
public void testCustomerResource() throws Exception
{
	...
	System.out.println("Get created customed");
	response = client.target(location).request().get();
	String md5 = response.getHeaderString("Content-MD5");
	System.out.println("Content MD5: " + md5);
}

BUil and run it as per usually:

Target dir with cmd

assert path

type maven install

Example ex13_1:Chat REST Interface

The following example will share a URL to both send and receive chat messages.
The service will work akin to Twitter, if one user posts a chat, anybody listening
for chats will see it.

Posting a chat is a simple HTTP POST request:

POST /chat HTTP/1.1
Host: localhost:8080
Content-Type: text/plain

Hello everybody

All we gotta do is send the POST request with the text, and everyone will see it.

To receive chat messages, clients make a blocking GET request to the chat server:

GET /chat HTTP/1.1
Host: localhost: 8080

When a chat becomes available, this GET request returns with the next chat
message. Additionaly, a next Link header is sent back with the HTTP response:

HTTP/1.1 200 OK
Content-Type: text/plain
Link: <chat?current=1>; rel=next

Hello Everybody

The next link is a PH into the list of messages that are posted to the server.
After displaying the chat message, the client will do a new GET request to the server
using the URL contained within the next Link header:

GET /chat?current=1 HTTP/1.1
Host: localhost:8080

The next links URI contains a query param identifying the last message the client
read. The server uses this index to obtain the next message so that the client
sees all messages in order. The new GET request will either block again, or immideatly
return a queued chat message.

The pattern repeats, the response contains a new text Link header with a new pointer
into the message queue:

HTTP/1.1 200 OK
Content-Type: text/plain
Link: </chat?current=2>; rel=next

What's up?

The server will buffer the last 10 chat messages in a linked list, so that it
can easily find the next message a particular chat client needs.

This is an example of HATEOAS (HTTP As the Engine of Application State) flow,
where the client transitions its state using a link passed back from the server.

The Client Code:

The client is a console program that takes input from the cmd line and prints
out the current message. 

To run it, you must specify name to chat with.

src/main/java/ChatClient.java

public class ChatClient
{
	public static void main(String[] args) throws Exception
	{
		String name = args[0];

		final Client client = new ResteasyClientBuilder()
							.connectionPoolSize(3)
							.build();

		WebTarget target = client.target("http://localhost:8080/services/chat");

		//By default, RESTEasy defaults to 1 connection, here we put a 
		//connection pool size of 3

		//NExt, we use the JAX-RS client asynch callback API to set up a loop
		//to pull chat messages from the server

		target.request().async().get(new InvocationCallback<Response>()
		{
			@Override
			public void completed(Response response)
			{
				Link next = response.getLink("next");
				String message = response.readEntity(String.class);
				System.out.println();

				System.out.print(message); //+ "\r"

				System.out.println();
				System.out.print("> ");

				//Register the current invocationCallBackResponse class to the upcoming request
				client.target(next).request().async().get(this);
			}

			@Override
			public void failed(Throwable throwable)
			{
				System.err.println("FAILURE!");
			}
		});


		//After the receive loop,we need a loop for sending chat messages:

		while (true)
		{
			System.out.print("> ");
			BufferedReader br = new BufferedReader(
									  new InputStreamReader(System.in));

			//Simply wait for the person to press enter before sending
			String message = br.readLine(); //read the message

			//post it
			target.request().post(Entity.text(name + ": " + message));
		}

	}
}

The Server Code:

src/main/java/com/restfully/shop/services/CustomerChat.java

@Path("chat")
public class CustomerChat
{
	class Message //Simple inner class to keep reference of next message and data for current one
	{
		String id;
		String message;
		Message next;
	}

	protected Message first;
	protected Message last; //keep track of the first and last message

	protected int maxMessages = 10;
	protected LinkedHashMap<String, Message> messages = new LinkedHashMap<String, Message>() //make a linked hashmap

	{
		@Override
		protected boolean removeEldestEntry(Map.Entry<String, Message> eldest)
		{
			boolean remove = size() > maxMessages;
			if (remove) first = eldest.getValue().next;
			return remove;
		}
	};

	//We use a LinkedHashMap for allow easy lookup of messages

	//By virtue of triggering remove, we overwrite the first value by accessing
	//the next. So we overwrite the oldst entry

	//We then make a AtomicLong counter to generate message IDs

	protected AtomicLong counter = new AtomicLong(0);

	//We then assign a LinkedList of Asynch Responses of waiting chat clients

	LinkedList<AsyncResponse> listeners = new LinkedList<AsyncResponse>();

	//By keeping just one thread, we can scale this a lot easier.
	//The idea is that, while we could spawn and keep up 1-2k threads on a modern
	//OS, the problem is that all the context switching for the OS causes
	//performance hits. Thus, just keeping the design to one thread
	//is a lot better.

	ExecutorService writer = Executors.newSingleThreadExecutor();

	//Next, we will look at how we post new messages:

	@Context
	protected UriInfo uriInfo; //Proxy uriInfo for delegating info to the real writer thread

	@POST
	@Consumes("text/plain")
	public void post(final String text)
	{
		final UriBuilder base = uriInfo.getBaseUriBuilder();
		writer.submit(new Runnable();

		//The thread trick that we do here, is that we use the
		//UriBuilder as a proxy, since we are doing things
		//concurrently.  If the writer background thread
		//were to invoke on the proxy, it would get an error. Cause the data is not transferred across threads.

		//The trick is that we use a underlying ThreadLocal that are present in most
		//JAX-RS vendor implementations. 

		{
			@Override
			public void run()
			{
				synchronized (messages)
				{
					Message message = new Message();
					message.id = Long.toString(counter.incrementAndGet());
					message.message = text;

					//BY virtue of synchronizing the messages map, we serialize access to it.

					//We then just make the messages as we go

					if (messages.size() == 0)
					{
						first = message; //It is the first message ever
					}
					else
					{
						last.next = message; //otherwise assign the tail of the last message to be the 
						//one we just process
					}

					messages.put(message.id, message); //Assign the message to the map
					last = message; //the last message being the message we are processing

					for (AsyncResponse async : listeners)
					{
						try
						{
							//Send the message to everyone listening
							send(base, async, message);
						}
						catch (Exception e)
						{
							e.printStackTrace();
						}
					}
					//Clear them, we sent to everyone
					listeners.clear();
				}
			}
		});
	}

	//Handle the GET requests from chat clients

	@GET
	//We inject the current id from the queryParam and we decouple HTTP response processing
	//From this request thread, by virtue of the @Suspended injection
	public void receive(@QueryParam("current") String id,
						 @Suspended AsyncResponse async)
	{
		final UriBuilder base = uriInfo.getBaseUriBuilder();
		Message message = null;
		synchronized (messages)
		{
			//Aquire the id
			Message current = messages.get(id);
			//its allowed to be null cuz being the first
			if (current == null) message = first;
			//otherwise, the incoming message is the next in regards to teh current one
			else message = current.next;

			//if the message is empty, queue up the response to await the next incoming request
			if (message == null){
				queue(async);
			}
		}

		//Do this outside of synched block to reduce lock hold time
		if (message != null) send(base, async, message);
	}

	protected void queue(AsyncResponse async)
	{
		//Just add the async response to the listeners so the writer thread can detect it
		listeners.add(async);
	}

	protected void send(UriBuilder base, AsyncResponse async, Message message)
	{
		//Just populates the response we are to send with the id, based on the path 
		URI nextUri = base.clone().path(CustomerChat.class)
				.queryParam("current", message.id).build();


		//assign the next element as being a built of the next uri with a next relation
		Link next = Link.fromUri(nextUri).rel("next").build();

		//The actual response, populate it with everything needed
		Response response = Response.ok(message.message, MediaType.TEXT_PLAIN_TYPE)
									.links(next).build();

		//resume with the built response
		async.resume(response);
	}
}

Build and Run the example:

CMd target dir

assert Path

perform and run build by maven jetty:run

This starts the jax-RS. To actually use it:

keep CMD of target dir

run the chat client by maven exec:java -Dexec.mainClass=ChatClient
-Dexec.args="<your username>"

Repeat the process in another console to run the second client.

You can now use it.

Example ex14_1: EJB and JAX-RS

This will show how we can use JAX-RS with EJB and JPA. (Java Persistance API, assignment to a relational DB)

Project Structure:

We will use Wildfly 8.0 Application Server to deploy the example.

It is the community version of JBoss app server. It is Java EE 7 compliant,
so JAX-RS 2.0 is already built in.

To support this, we must change the dependencies in the pom.xml:

<dependencies>
	<dependency>
		<groupId>org.jboss.resteasy</groupId>
		<artifactId>resteasy-jaxrs</artifactId>
		<version>3.0.5.Final</version>
		<scope>provided</scope>
	</dependency>
</dependencies>

Because JAX-RS 2.0 is built in, we do not have to add all the RESTEasy third-party
dependencies to our WAR file. The provider Scope is used to tell Maven that the
JAR dependencies are needed only for compilation and not to include them with the WAR.

	<plugins>
		<plugin>
			<groupId>org.jboss.as.plugins</groupId>
			<artifactId>jboss-as-maven-plugin</artifactId>
			<version>7.1.1.Final</version>
			<executions>
				<execution>
					<id>jboss-deploy</id>
					<phase>pre-integration-test</phase>
					<goals>
						<goal>deploy</goal>
					</goals>
				</execution>
				<execution>
					<id>jboss-undeploy</id>
					<phase>post-integration-test</phase>
					<goals>
						<goal>undeploy</goal>
					</goals>
				</execution>
			</executions>
		</plugin>
	</plugins>

The jboss-as-maven-plugin is configed to run after the WAR is built, but before
the unit tests are run.

It uses the Wildfly remote deployment interface to automatically deploy our
WAR to the Wildfly app server.

The EJBs:

The EJB code is similar to ex10_2 from Chapter 24, except it has been expanded
to save created entires into a DB.

The JPA classes, are defined in a seperate package, com.resfully.shop.persistence,
was created for the JPA classes.

They are almost carbon copies of the JAXB ones, except they are using JPA annotations
to map to a DB.

You could use JAXB and JPA annotations within one class hierarchy, but
it is not the best idea. 

The first problem, is how JPA works. Objects like OrderEntity have relations
to other classes like LineItemEntity, ProductEntity, CustomerEntity..

In JPA, it is common to lazy-load themas their object graphs are traversed.

This can save on DB access time. The problem where JAX-RS is concerned,
is that JAX-RS runtime will usually turn the Java object into an XML
document outside the scope of an EJB request.

This might cause lazy-load exceptions when JAXB tries to traverse 
the entire object graph.

We could write out code to avoid lazy-load exceptions, but there 
is one other problem.

Older versions of XML need to be handeled seperately.

The best way to handle this, is to seperate the code into
two class hierarchies, allowing the XML to develop one one 
hand and the DB on the other.

A lot of the details will be skipped on this one.

ejb/src/main/java/com/restfully/shop/services/CustomerResource.java

@Path("/customers")
public interface CustomerResource
{
	@POST
	@Consumes("application/xml")
	Response createCustomer(Customer customer, @Context UriInfo uriInfo);

	@GET
	@Produces("application/xml")
	@Formatted
	Customers getCustomers(@QueryParam("start") int start,
					@QueryParam("size") @DefaultValue("2") int size,
					@QueryParam("firstName") String firstName,
					@QueryParam("lastName") String lastName,
					@Context UriInfo uriInfo);

	@GET
	@Path("{id}")
	@Produces("application/xml")
	Customer getCustomer(@PathParam("id") int id);
}

for a non-JAX-RS-aware EJB container to work with JAX-RS, you need to define
your JAX-RS annotations on the EJB's business interface.

The CustomerResource does just this.

Our EJB business logic is defined in the CustomerResourceBean class:

ejb/src/main/java/com/restfully/shop/services/CustomerResourceBean.java

@Stateless //Belongs to EJB
public class CustomerResourceBean implements CustomerResource
{
	@PersistenceContext
	private EntityManager em; //Will put the stuff into a DB

	public Response createCustomer(Customer customer, UriInfo uriInfo)
	{
		//An unmarshalled XML entity of Customer
		CustomerEntity entity = new CustomerEntity();

		domain2entity(entity, customer);
		em.persist(entity);
		em.flush();

		//URL that populates the value of the Location header that is 
		//sent back with the HTTP response

		System.out.println("Created customer " + entity.getId());
		UriBuilder builder = uriInfo.getAbsolutePathBuilder();
		builder.path(Integer.toString(entity.getId()));
		return Response.created(builder.build()).build();
	}

	//Serves GET /customers/<id> requests
	public Customer getCustomer(int id)
	{
		CustomerEntity customer = em.getReference(CustomerEntity.class, id);

		return entity2domain(customer); //transforms DB entity into Customer class
	}

	public static void domain2entity(CustomerEntity entity, Customer customer)
	{
		entity.setId(customer.getId());
		//Setters
	}

	public static Customer entity2domain(CustomerEntity entity)
	{
		Customer cust = new Customer();
		cust.setId(entity.getId()); //Setters and getters
		//etc.
		return cust;
	}

	//The Entity2Domain and domain2entity just convert between JAXB and JPA class hierarchies

	public Customers getCustomers(int start,
								  int size,
								  String firstName,
								  string lastName,
								  UriInfo uriInfo)
	{
		UriBuilder builder = uriInfo.getAbsolutePathBuilder();
		
		builder.queryParam("start", "{start}");
		builder.queryParam("size", "{size}");

		ArrayList<Customer> list = new ArrayList<Customer>();
		ArrayList<Link> links = new ArrayList<Link>();

		//In this class, we add firstName and lastName to allow for searching
		//in the DB.

		Query query = null;
		if (firstName != null && lastName != null)
		{
			query = em.createQuery(
					"select c from Customer c where c.firstName=:first and c.lastName=:last");
			query.setParameter("first", firstName);
			query.setParameter("last", lastName);
		}
		else if (lastName != null)
		{
			query = em.createQuery(
					"select c from Customer c where c.lastName=:last");
			query.setParameter("last", lastName);
		}
		else{
			query = em.createQuery("select c from Customer c");
		}

		//THe Queries allows us to search the DB for stuff

		List customerEntities = query.setFirstResult(start)
				.setMaxResults(size)
				.getResultList();

		//The above just sets the staring index and size of entries, returning the list

		for (Object obj : customerEntities)
		{
			CustomerEntity entity = (CustomerEntity) obj;
			list.add(entity2domain(entity));
		}

		//next link
		//if the size returned is equal then assume there is a next
		if (customerEntities.size() == size)
		{
			int next = start + size;
			URI nextUri = builder.clone().build(next, size);
			Link nextLink = Link.fromUri(nextUri)
								.rel("next")
								.type("application/xml").build();
			links.add(nextLink);
		}

		//previous link
		if (start > 0)
		{
			int previous = start - size;
			if (previous < 0) previous = 0;
			URI previousUri = builder.clone().build(previous, size);
			Link previousLink = Link.fromUri(previousUri)
									.rel("previous")
									.type("application/xml").build();
			links.add(previousLink);
		}

		Customers customers = new Customers();
		customers.setCustomers(list);
		customers.setLinks(links);
		return customers;
	}
}

The Remaining Server Code:

The ExceptionMappers:

If we were to use the above, we'd get a 500 error if we tried to get a 
object that is unknown. To help assert that we get 404, we do the ExceptionMappers:

ejb/src/main/java/com/restfully/shop/services/EntityNotFoundExceptionMapper.java

@Provider
public class EntityNotFoundExceptionMapper implements ExceptionMapper<EntityNotFoundException>
{
	public Response toResponse(EntityNotFoundException exception)
	{
		return Response.status(Response.Status.NOT_FOUND).build();
	}
}

This will catch the 500 error and return 404.

Changes to App class:

Because we use EJB, there is no special registration we need to do
in our Application class. Here's what it looks like now:

war/src/main/java/com/restfully/shop/services/ShoppingApplication.java

@ApplicationPath("/services")
public class ShoppingApplication extends Application
{
	
}

Wildfly will scan for all JAX-RS annoted classes, to which our JAX-RS services
are EJBs and contained in the WEB-INF/classes folder of our WAR.

The Client Code:

war/src/test/java/com/restfully/shop/test/ShoppingTest.java

protected void populateDB() throws Exception
{
	Response response = client.target("http://localhost:8080/ex14_1/services/shop")
							  .request().head();
	Link products = response.getLink("products");
	response.close();

	System.out.println("Populate products");

	Product product = new Product();
	product.setName("iPhone");
	//etc on set attributes

	response = client.target(products).request().post(Entity.xml(product));
	Assert.assertEquals(201, response.getStatus());
	response.close();

	//Repeat for each product
}

@Test
public void testCreateOrder() throws Exception
{
	//Populates the DB
	populateDB();

	//Aquire customers, products, orders
	Response response = client.target
		("http://localhost:8080/ex14_1/services/shop").request().head();

	Link customers = response.getLink("customers");
	Link products = response.getLink("products");
	Link orders = response.getLink("orders");
	response.close();

	System.out.println("Buy an Iphone for Bill Burke");
	system.out.println();
	system.out.println("First see if Bill Burke exists as a customer");

	Customers custs = client.target(customers)
							.queryParam("firstName", "Bill")
							.queryParam("lastName", "Burke")
							.request().get(Customers.class);

	Customer customer = null;
	if (custs.getCustomers().size() > 0)
	{
		System.out.println("Found a bill burke in the DB, using that");
		customer = custs.getCustomers().iterator().next();
	}
	else
	{
		system.out.println("could not fill a bill in DB, making one");

		customer = new Customer();
		customer.setFirstName("Bill");
		//Set attributes

		//Make a customer
		response = client.target(customers)
						 .request()
						 .post(Entity.xml(customer));

		//Assert that its the right one
		Assert.assertEquals(201, response.getStatus());

		//Get the URI
		URI uri = response.getLocation();
		response.close();

		//target the uri with a request, get the customer we created
		customer = client.target(uri).request().get(Customer.class);
	}

	System.out.println();
	System.out.println("Search for iPhone in the Product DB");
	Products prods = client.target(products)
						   .queryParam("name", "iPhone")
						   .request()
						   .get(Products.class);

	Product product = null;
	if (prods.getProducts().size() > 0)
	{
		System.out.println(" Found iphone in DB");
		product = prods.getProducts().iterator().next();
	}
	else
	{
		throw new RuntimeException("Failed to find an iphone in the DB");
	}

	//Create an order

	System.out.println();
	System.out.println("Create order for iphone");
	LineItem item = new LineItem();

	item.setProduct(product);
	item.setQuantity(1);

	Order order = new Order();
	order.setTotal(product.getCost());
	order.setCustomer(customer);

	order.setDate(new Date().toString());
	order.getLineItems().add(item);

	response = client.target(orders).request().post(Entity.xml(order));
	Assert.assertEquals(201, response.getStatus());

	response.close();

	System.out.println();
	System.out.println("Show all orders");
	String xml = client.target(orders).request().get(String.class);
	System.out.println(xml);

}

Build and Run example Program:

To run this, is a bit different.

Download Wildfly 8.0 App Server from http://www.wildfly.org/download/

Unzip Wildfly to any dir

Open a cmd prompt, go to the wildfly-8.0.0.Final/bin dir

You must start firefly first, execute standalone.bat (windows) or standalone.sh (Unix)

Open another cmd prompt and change to target dir for example

assert PATH is setup

type maven install

After the WAR is deployed, the client test code is executed. Following this,
the WAR is undeployed from JBoss by Maven.

Example ex14_2: Spring and JAX-RS:

The differences aren't that many in using Spring. We can remove the @Stateless
annotations to begin with.

We change the web.xml as well:

src/main/webapp/WEB-INF/web.xml

<web-app>
	<context-param>
		<param-name>spring-beans-file</param-name>
		<param-value>META-INF/applicationContext.xml</param-value>
	</context-param>
</web-app>

We add the spring beans in this xml.

Next up, we configure the Spring XML file:

src/main/resources/applicationContext.xml

<beans xmlns="http://www.springframework.org/schema/beans"
	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	   xmlns:tx="http://www.springframework.org/schema/tx"
	   xsi:schemaLocation="
	   	http://www.springframework.org/schema/beans
	   	http://www.springframework.org/schema/beans/spring-beans.xsd
	   	http://www.springframework.org/schema/tx
	   	http://www.springframework.org/schema/tx/spring-tx.xsd"
	   default-autowire="byName">

	<bean id="entityManagerFactory"
		class="org.springframework.orm.jpa.
						LocalContainerEntityManagerFactoryBean">
		<property name="jpaVendorAdapter">
			<bean class="org.springframework.orm.jpa.vendor
									.HibernateJpaVendorAdapter">
				<property name="showSql" value="false"/>
				<property name="generateDdl" value="true"/>
				<property name="databasePlatform"
						  value="org.hibernate.dialect.HSQLDialect"/>
			</bean>
		</property>
	</bean>

	<bean id="dataSource"
		  class="org.apache.commons.dbcp.BasicDataSource"
		  destroy-method="close">
		  <property name="driverClassName"
		  			value="org.hsqldb.jdbcDriver"/>
		  <property name="url" value="jdbc:hsqldb:test/db/myDB"/>
		  <property name="username" value="sa"/>
		  <property name="password" value=""/>
	</bean>

	<bean id="transactionManager"
		  class="org.springframework.orm.jpa.JpaTransactionManager"/>
	<tx:annotation-driven/>

	//The above part is just used for integrating JPA with spring

	<bean class="org.springframework.orm
			.jpa.support.PersistenceAnnotationBeanPostProcessor"/>
	<bean id="customer" class="com.restfully.shop.services
											.CustomerResourceBean"/>
	<bean id="product" class="com.restfully.shop.services
											.ProductResourceBean"/>
	<bean id="order" class="com.restfully.shop.services
											.OrderResourceBean"/>
	<bean id="store" class="com.restfully.shop.services
											.StoreResourceBean"/>
</beans>

The rest is just JAX-RS resource beans

The spring XML is loaded and registered with the JAX-RS runtime by the 
ShoppingApplication class:

src/main/java/com/restfully/shop/services/ShoppingApplication.java

@ApplicationPath("/services")
public class ShoppingApplication extends Application
{
	private Set<Class<?>> classes = new HashSet<Class<?>>();

	public ShoppingApplication()
	{
		classes.add(EntityNotFoundExceptionMapper.class);
	}

	public Set<Class<?>> getClasses()
	{
		return classes;
	}

	protected ApplicationContext springContext;

	@Context
	protected ServletContext servletContext;

	public Set<Object> getSingletons()
	{
		try
		{
			InitialContext ctx = new InitialContext();
			String xmlFile = (String)servletContext.getInitParameter("spring-beans-file");
			springContext = new ClassPathXmlApplicationContext(xmlFile);
		}
		catch (Exception ex)
		{
			ex.printStackTrace();
			throw new RuntimeException(ex);
		}

		HashSet<Object> set = new HashSet();
		set.add(springContext.getBean("customer"));

		set.add(springContext.getBean("order"));
		set.add(springContext.getBean("product"));
		set.add(springContext.getBean("store"));
		return set;
	}
}

The above just initializes a context, assigns the xml, gets a spring context based on the xml,
makes a hashset of all the beans, adds them, and returns the set

To build and run it:

cmd on target dir

Assert PATH

maven install

Example ex15_1:Custom Security:

One-Time Password Authentication:

The first feature, is a OTP. A password that is generated once per minute, based on a hash
of the current time combined with a static password.

it will be sent in:

GET /customers HTTP/1.1
Authorization: <username> <generated_password>

The server Code:

We will enforce OTP on @OTPAuthenticated annotation:

src/main/java/com/restfully/shop/features/OTPAuthenticated.java

@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@NameBinding
public @interface OTPAuthenticated
{
	
}

When declared on a method, this will trigger the binding of a ContainerRequestFilter
that implements the OTP algorithm using the @NameBinding technique.

With the custom annotation defined, let's look at the filter that implements
the OTP algo:

src/main/java/com/restfully/shop/features/OneTimePasswordAuthenticator.java

//Apply the annotation we made
@OTPAuthenticated

//apply the highest priority to run before other filters
@Priority(Priorities.AUTHENTICATION)
public class OneTimePasswordAuthenticator implements ContainerRequestFilter
{
	protected Map<String, String> userSecretMap;

	public OneTimePasswordAuthenticator(Map<String, String> userSecretMap)
	{
		this.userSecretMap = userSecretMap;
	}

	//We will use a single ton as a filter, and we begin with a map
	//The key will be the username, the value will be the secret pw 
	//used to create one-time passwords

	@Override
	public void filter(ContainerRequestContext requestContext) throws IOException
	{
		String authorization = requestContext.getHeaderString(
														HttpHeaders.AUTHORIZATION);
		if (authorization == null) throw new NotAuthorizedException("OTP");

		String[] split = authorization.split(" ");
		final String user = split[0];
		String otp = split[1];

		//We split the authorization header to get the values

		String secret = userSecretMap.get(user);
		if (secret == null) throw new NotAuthorizedException("OTP");

		String regen = OTP.generateToken(secret);
		if (!regen.equals(otp)) throw new NotAuthorizedException("OTP");

		//if the values do not match up, we say that we don't have authorization

		final SecurityContext securityContext = requestContext.getSecurityContext();

		requestContext.setSecurityContext(new SecurityContext()
		{
			@Override
			public Principal getUserPrincipal()
			{
				return new Principal()
				{
					@Override
					public String getName()
					{
						return user; //Return with the delegated name
					}
				};
			}

			@Override
			public boolean isUserInRole(String role);
			{
				return false;
			}

			@Override
			public boolean isSecure()
			{
				return securityContext.isSecure();
			}

			@Override
			public String getAuthenticationScheme()
			{
				return "OTP";
			}
		});
	}
}

After the user is authenticated, the filter() method creates a custom
SecurityContext implementation within a lambda class.

We then delegate a new one to the request Context.

Other JAX-RS code can now inject this custom SecurityContext to find out who
the user principal is.

The algo for generating a one-time password is as follows:

src/main/java/com/restfully/shop/features/OTP.java

public class OTP
{
	public static String generateToken(String secret)
	{
		long minutes = System.currentTimeMillis() / 1000 / 60;
		String concat = secret + minutes;

		MessageDigest digest = null;
		try
		{
			digest = MessageDigest.getInstance("MD5");
		}
		catch (NoSuchAlgorithmException e)
		{
			throw new IllegalArgumentException(e);
		}

		byte[] hash = digest.digest(concat.getBytes(Charset.forName("UTF-8")));
		return Base64.encodeBytes(hash);
	}
}

The hash is a simple one, what with MD5 message digest on a 64 bit base

We then apply the @OTPAuthenticated annotation to two methods in Customer:

src/main/java/com/restfully/shop/services/CustomerResource.java

@GET
@Path("{id}")
@Produces("application/xml")
@OTPAuthenticated
public Customer getCustomer(@PathParam("id") int id)
{
	....
}

@PUT
@Path("{id}")
@Consumes("application/xml")
@OTPAuthenticated
@AllowedPerDay(1)
public void updateCustomer(@PathParam("id") int id, Customer update)
{
	...
}

Allowed-per-Day Access policy:

The next thing we're doing is access per day modification.

src/main/java/com/restfully/shop/features/AllowedPerDay.java

@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@NameBinding
public @interface AllowedPerDay
{
	int value();
}

To then do the actual binding to a given annotation, we must fix it
with a filter allocation:

src/main/java/com/restfully/shop/features/PerDayAuthorizer.java

@AllowedPerDay(0)
@Priority(Priorities.AUTHORIZATION)
public class PerDayAuthorizer implements ContainerRequestFilter
{
	//We use the priority of Authorization to be after authentication but before the app runs
	//By annotating the AllowedPerDay, we refer back to the name binding of the AllowedPerDay

	@Context //Aquire the context to see what the current method being invoked is
	ResourceInfo info;

	public void filter(ContainerRequestContext requestContext) throws IOException
	{
		SecurityContext sc = requestContext.getSecurityContext();
		if (sc == null) throw new ForbiddenException();
		Principal principal = sc.getUserPrincipal();

		if (principal == null) throw new ForbiddenException();
		String user = principal.getName();

		//If  the context is null or the user principal is null, we return 403

		if (!authorized(user))
		{
			throw new ForbiddenException();
		}
	}

	//If the user is not authorized, we just send back a ForbiddenException

	protected static class UserMethodKey
	{
		String username;
		Method method;

		public UserMethodKey(String username, Method method)
		{
			this.username = username;
			this.method = method;
		}

		@Override
		public boolean equals(Object o)
		{
			if (this == o) return true;
			if (o == null || getClass() != o.getClass()) return false;

			UserMethodKey that = (UserMethodKey) o;

			if (!method.equals(that.method)) return false;

			if (!username.equals(that.username)) return false;

			return true;
		}

		@Override
		public int hashCode()
		{
			int result = username.hashCode();
			result = 31 * result + method.hashCode();
			return result;
		}
	}

	protected Map<UserMethodKey, Integer> count =
							   new HashMap<UserMethodKey, Integer>();

	//We just save the used methodkey in a map and amount of times we use it

	protected long today = System.currentTimeMillis();

	protected synchronized boolean authorized(String user, AllowedPerDay allowed)
	{
		if (System.currentTimeMillis() > today + (24 * 60 * 60 * 1000))
		{
			today = System.currentTimeMillis();
			count.clear();
		}

		//We check to see if more than one day has elapsed, and reset the timer map
		//if it has

		UserMethodKey key = new UserMethodKey(user, info.getResourceMethod());
		Integer counter = count.get(user);
		if (counter == null)
		{
			counter = 0;
		}

		//We check to see if the user is already listening

		AllowedPerDay allowed = info.getResourceMethod().getAnnotation(AllowedPerDay.class);
		if (allowed.value() > counter)
		{
			count.put(user, counter + 1);
			return true;
		}

		//If we still have attempts remaining, allow passage and increment counter,
		//otherwise, return false
		return false;
	}
}

We then just apply the annotation:

src/main/java/com/restfully/shop/services/CustomerResource.java

@PUT
@Path("{id}")
@Consumes("application/xml")
@OTPAuthenticated
@AllowedPerDay(1)
public void updateCustomer(@PathParam("id") int id, Customer update)
{
	...
}

The last thing we need to do, is initialize our deployment:

src/main/java/com/restfully/shop/services/ShoppingApplication/java

@ApplicationPath("/services")
public class ShoppingApplication extends Application
{
	private Set<Object> singletons = new HashSet<Object>();

	public ShoppingApplication()
	{
		singletons.add(new CustomerResource());
		HashMap<String, String> userSecretMap = new HashMap<String, String>();
		userSecretMap.put("bburke", "geheim");
		singletons.add(new OneTimePasswordAuthenticator(userSecretMap));
		singletons.add(new PerDayAuthorizer());
	}

	@Override
	public Set<Object> getSingletons()
	{
		return singletons;
	}
}

We just initialize the singletons and populate them.

The Client Code:

We have to implement a ClientRequestFilter that sets up the Authorization
header that we send:

src/main/java/com/restfully/shop/features/OneTimePasswordGenerator.java

public class OneTimePasswordGenerator implements ClientRequestFilter
{
	protected String user;
	protected String secret;

	public OneTimePasswordGenerator(String user, String secret)
	{
		this.user = user;
		this.secret = secret;
	}

	@Override
	public void filter(ClientRequestContext requestContext) throws IOException
	{
		String otp = OTP.generateToken(secret);
		requestContext.getHeaders().putSingle(HttpHeaders.AUTHORIZATION, user + " " + otp);
	}
}

We generate a token from the secret pw, and put the authorization header to be user and the
encoded secret PW.

The client test code is the same as ex06_1 except that we set it up to use OTP authentication.

src/test/java/com/restfully/shop/test/CustomerResourceTest.java

@Test
public void testCustomerResource() throws Exception
{
	System.out.println("Create a new customer");
	Customer newCustomer = new Customer();
	newCustomer.setFirstName("Bill");
	newCustomer.setLastName("Burke");

	newCustomer.setStreet("256 Clarendon Street");
	newCustomer.setCity("Boston");
	newCustomer.setState("MA");

	//Etc on setters

	Response response = client.target(
			"http://localhost:8080/services/customers")
			.request().post(Entity.xml(newCustomer));

	if (response.getStatus() != 201) throw new RuntimeException 
		("Failed to create");

	String location = response.getLocation().toString();
	System.out.println("Location: " + location);
	response.close();

	System.out.println("Get Created Customer");
	Customer customer = null;
	WebTarget target = client.target(location);
	try
	{
		customer = target.request().get(Customer.class);
		Assert.fail(); //Should have thrown an exception
	}
	catch (NotAuthorizedException e)
	{
	}

	//THe above code will fail, due to us not having set up the
	//OTP filter yet

	target.register(new OneTimePasswordGenerator("bburke", "geheim"));

	//After having registered our OTP generator, we can access it

	customer = target.request().get(Customer.class);
	System.out.println(customer);

	//To showcase the once per day annotation, we try to update a customer twice

	customer.setFirstName("William");
	response = target.request().put(Entity.xml(customer));
	if (response.getStatus() != 204)
		throw new RuntimeException("Failed to Update");

++++
<?hard-pagebreak?>
++++
	
	//Show the update

	System.out.println("After update");
	customer = target.request().get(Customer.class);
	System.out.println(customer);

	//Only allowed to update once per day 
	customer.setFirstName("Bill");
	response = target.request().put(Entity.xml(customer));

	Assert.assertEquals(Response.Status.FORBIDDEN, response.getStatusInfo());
}

//The second invocation will fail, cause of the once per day limitation

Build and Run the example:

cmd target dir

assert PATH

maven install

Example ex15_1: JSON Web Encryption:

Here, we will showcase usage of JWE (Json Web Encryption) so that
chat clients use a shared secret to encrypt and decrypt the messages.

Chat clients that know the secret can see the decrypted message,
the rest, will only see the encoding.

src/main/java/ChatClient.java

public class ChatClient
{
	public static void main(String[] args) throws Exception
	{
		String name = args[0];
		final String secret = args[1];

		final Client client = new ResteasyClientBuilder()
							.connectionPoolSize(3)
							.build();

		WebTarget target = client.target("http://localhost:8080/services/chat");

		target.request().async().get(new InvocationCallback<Response>()
		{
			@Override
			public void completed(Response response)
			{
				Link next = response.getLink("next");
				String message = response.readEntity(String.class);
				try
				{
					JWEInput encrypted = new JWEInput(message);
					message = encrypted.decrypt(secret).readContent(String.class);
				}
				catch (Exception ignore)
				{
					//e.printStackTrace();
				}

				System.out.println();
				System.out.print(message);
				System.out.println();
				System.out.print("> ");
				client.target(next).request().async().get(this);
			}

			@Override
			public void failed(Throwable throwable)
			{
				System.err.println("FAILURE!");
			}
		});

		//If we can decrypt it, we print out the decrypted one, otherwise
		//we just send out the encrypted message

		while (true)
		{
			System.out.print("> ");
			BufferedReader br = new BufferedReader
								(new InputStreamReader(System.in));

			String message = name + ": " + br.readLine();

			String encrypted = new JWEBuilder()
										  .contentType(MediaType.TEXT_PLAIN_TYPE)
										  .content(message)
										  .dir(secret);
			target.request().post(Entity.text(encrypted));
		}

		//WE just make a BufferedReader, accept a InputStream reader where we type
		//And then send the message in a post request with the message
	}
}

Build and Run example:

change to target dir

assert PATH

maven jetty:run

Open another console window

change to target dir

maven exec:java -Dexec.mainClass=ChatClient -Dexec.args="your-name your-secret"

Replace the name and secret designations.

Repeat the process in a second console window to run a second chat client.