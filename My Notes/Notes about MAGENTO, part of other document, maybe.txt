Notification messages

Magento implements the notification message mechanism via the Messages module. The messages module conforms to \Magento\Framework\Message\ManagerInterface.
Though the interface itself does not impose any session relation, an implementation adds interface-defined types of messages to a session and
allows access to those messages later.

In the app/etc/di.xml file, there is a preference defined for \Magento\Framework\Message\ManagerInterface towards the Magento\Framework\Message\Manager class

Message\ManagerInterface specifies four types of messages, namely error, warning, notice and success.

The types of messages are followed by several key methods in the Message\Manager class, such as addSuccess, addNotice, addWarning, addError, and addException.

The addException method is basically a wrapper for addError that accepts an exception object as a parameter.

Let's try to run the following code in the execute method of app/code/Foggyline/Office/Controller/Test/Crud.php:

$resultPage =
$this->resultPageFactory->create();

$this->messageManager->addSuccess('Success-1');
$this->messageManager->addSuccess('Success-2');
$this->messageManager->addNotice('Notice-1');

$this->messageManager->addNotice('Notice-2');
$this->messageManager->addWarning('Warning-1');
$this->messageManager->addWarning('Warning-2');

$this->messageManager->addError('Error-1');
$this->messageManager->addError('Error-2');

return $resultPage;

Once this code is executed, the result as follows, will be shown in the page of the browser:

//basically coloured tabs with Denotions of what they are will appear stacked in a list

Notification messages appear both in frontend and admin area.

The frontend layout vendor/magento/module-theme/view/frontend/layout/default.xml file defines it as follows:

<page layout="3columns"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-
instance" xsi:noNamespaceSchemaLocation=
"../../../../../../../lib/internal/Magento/Framework/View/Layout
/etc/page_configuration.xsd">
	<update handle="default_head_blocks"/>
	<body>
		<!-- ... -->
		<referenceContainer
name="column.top">
			<container name="page.messages"
htmlTag="div" htmlClass="page messages">
				<block
class="Magento\Framework\View\Element
\Messages" name="messages" as="messages"
template="Magento_Theme::messages.phtml"/>
			</container>
		</referenceContainer>
		<!-- ... -->
	</body>
</page>

The template file that renders the messages is view/frontend/templates/messages.phtml in the Magento_Theme module. By looking at the
Magento\Framework\View\Element\Messages class, you will see that the _toHtml method branches into if-else statements, depending on wether 
template is set or not.

In case the template is not set, _toHtml interally calls the _renderMessagesByType method, which renders messages in the HTML format
that are grouped by type.

The view/adminhtml/layout/default.xml admin layout file in the Magento_AdminNotification module defines it as follows:

<page xmlns:xsi="http://www.w3.org
/2001/XMLSchema-instance"
xsi:noNamespaceSchemaLocation="urn:magento:
framework:View/Layout
/etc/page_configuration.xsd">
	<body>
		<referenceContainer
name="notifications">
			<block
class="Magento\AdminNotification\Block
\System\Messages" name="system_messages"
as="system_messages" before="-" template=
"Magento_AdminNotification::system/messages.p
html"/>
		</referenceContainer>
	</body>
</page>

The template file that renders the messages is
view/adminhtml/templates/system
/messages.phtml in the Magento_AdminNotification
module. When you look at the Magento\AdminNotification\Block\System\Messages class,
we will see that it's _toHtml is calling the \Magento\Framework\View\Element\Template class.

This means that the output is relying on the view/adminHtml/templates/system/messages.phtml file in the
Magento_AdminNotification module.

Sessions in Magento conform to Magento\Framework\Session\SessionManagerInterface. In the app/etc/di.xml file,
there is a definition preference for the SessionManagerInterface class which points to the Magento\Framework\Session\SessionManager
class, which in turn implements the SessionManagerInterface class.

There is one important object that gets instansiated in the SessionManager instance that conforms to \Magento\Framework\Session\Config\ConfigInterface.

On looking at app/etc/di.xml file, we can see a preference for ConfigInterface pointing to a Magento\Framework\Session\Config class type.

To fully understand the session behavior in Magento, we should study the inner workings of both the SessionManager and Session\Config classes.
Magento uses cookies to keep track of a session. These cookies have a default lifetime of 3,600 seconds. When a session
is established, a cookie with the name of PHPSESSID is created in the browser.

The value of the cookie equals the session name. By default, sessions are stored in files in the var/session dir of Magento's root Install.

If you have a look at these session files, you will see that session information is being stored in serialized strings that are divided into groupings
such as _session_validator_data, _session_hosts, default, customer_website_1, and checkout as follows:

_session_validator_data
	|a:4:{s:11:"remote_addr";s:9:"127.0.0.1";s:8:
_session_hosts
	|a:1:{s:12:"magento2.loc";b:1;}
default
	|a:3:{s:9:"_form_key";s:16:"u3sNaa26Ii21nveV"
customer_website_1
	|a:0:{}
checkout
	|a:0:{}

This is not the finite list of grouping. Modules that implement their own session handling bits can add their own groups.

We can store and retrieve information in a session by simply using expressions like the following ones:

$this->sessionManager->setFoggylineOfficeVar1
('Office1');
$this->sessionManager->getFoggylineOfficeVar1
();

The preceeding expressions will create and get an entry from the session under the default group.
We can get the entire content of the default session group simply by using the $this->sessionManager->getData() expression,
which will return an array of data that is similar to the following one:

array(3) {
	["_form_key"] => string(16)
"u3sNaa26Ii21neV"
	["visitor_data"] => array(14) {
		["last_visit_at"] => string(19)
"2015-08-19 07:40:03"
		["session_id"] => string(26)
"8p82je0dkqq1o00lanlr6bj6m2"
		["visitor_id"] => string(2) "35"
		["server_addr"] => int(213076433)
		["remote_addr"] => int(213076433)
		["http_secure"] => bool(false)
		["http_host"] => string(12)
"magento2.loc"
		["http_user_agent"] => string(121)
"Mozaill/5.0 ..."
		["http_accept_language"] => string(41)
"en-US, en;"
		["http_accept_charset"] => string(0) ""
		["first_visit_at"] => string(19)
"2015-08-19 07:40:03"
		["is_new_visitor"] => bool(false)
	}
	["foggyline_office_var_1"] => string(7)
"Office1"
}

As you can see, the foggyline_office_var_1 value is right there among other session values.
There are several useful methods of ConfigInterface that we can use to fetch session configuration information; a few
of these methods are as follows:

getCookieSecure

getCookieDomain

getCookieHttpOnly

getCookieLifetime

getName

getSavePath

getUseCookies

getOptions

Here's a result example of the getOptions method call on the Session\Config instance:

array(9) {
	["session.save_handler"] => string(5)
"files"
	["session.save_path"] => string(39) "/Users
/branko/www/magento2/var/session/"
	["session.cookie_lifetime"] => int(3600)
	["session.cookie_path"] => string(1) "/"
	["session.cookie_domain"] => string(12)
"magento2.loc"
	["session.cookie_httponly"] => bool(true)
	["session.cookie_secure"] => string(0) ""
	["session.name"] => string(9) "PHPSESSID"
	["session.use_cookies"] => bool(true)
}

Cookies often go hand in hand with sessions. Besides being used to link to a certain session, cookies are often
used to store some information on the client side, thus tracking or identifying the return users and customers.

Besides the pure PHP approach with the setcookie function, we can manage cookies in Magento through an instance
of Magento\Framework\Stdlib\CookieManagerInterface. When you look at app/etc/di.xml file, you will see
that the preference for CookieManagerInterface points to a class of the Magento\Framework\Stdlib\Cookie\PhpCookieManager type

The following restrictions are worth noting when it comes to Magento cookies:

We can set maximum of 50 cookies in the system. Otherwise, Magento will throw an Unable to send the cookie. Maximum number of cookies would be exceeded exception.
We can store a cookie with a maximum size of 4096 bytes. Otherwise, Magento will throw an Unable to send the cookie. Size of \'%name\' is %size bytes exception.

By imposing these restrictions, Magento ensures that we are compatible with most browsers.

The CookieManagerInterface class, among other things, specifies the setSensitiveCookie method requirement. This method sets a value
in a private cookie with the given $name $value pairing. Sensitive cookies have HttpOnly set to true and thus cannot be accessed by JS.

As we will soon demonstrate in the following examples, to set a public or private cookie, we can help ourselves by using instances of the following:

\Magento\Framework\Stdlib\Cookie\CookieMetadataFactory

\Magento\Framework\Stdlib\CookieManagerInterface

\Magento\Framework\Session\Config\ConfigInterface

We can set public cookies in the following way:

$cookieValue = 'Just some value';
$cookieMetadata =
$this->cookieMetadataFactory
	->createPublicCookieMetadata()
	->setDuration(3600)

->setPath($this->sessionConfig->getCookiePath())

->setDomain($this->sessionConfig->getCookieDomain())

->setSecure($this->sessionConfig->getCookieSecure())

->setHttpOnly($this->sessionConfig->getCookieHttpOnly());

$this->cookieManager
	->setPublicCookie('cookie_name_1', 
$cookieValue, $cookieMetadata);

The preceeding code will result in a cookie, that is HttpOnly.

We can also set private cookies, as follows:

$cookieValue = 'Just some value';

$cookieMetadata =
$this->cookieMetadataFactory
	->createSensitiveCookieMetadata()
	->setPath($this->sessionConfig->getCookiePath())

	->setDomain($this->sessionConfig->getCookieDomain());

$this->cookieManager
	->setSensitiveCookie('cookie_name_2',
$cookieValue, $cookieMetadata);

This will result in a private cookie. Interestingly, both the public and private cookies in the preceeding example show that HttpOnly is checked off
because by default, a Magento admin has Stores | Settings | Configuration | General | Web | Default Cookie Settings | Use HTTP Only set to yes.

Since we are using the setHttpOnly method in the public cookie example, we simply picked up the config value via $this->sessionConfig->getCookieHttpOnly() and 
passed it on. If we comment out that line, we will see that public cookie does not really set HttpOnly by default.

Magento supports the messages logging mechanism via its \Psr\Log\LoggerInterface class. The LoggerInterface class has a preference defined
within app/etc/di.xml file for the Magento\Framework\Logger\Monolog class type. The actual crux of implementation is actually in
the Monolog parent class named Monolog\Logger, which comes from the Monolog vendor.

The LoggerInterface class uses the following eight methods to write logs to the eight RFC 5424 levels:

debug

info

notice

warning

error

critical

alert

emergency

To use a logger, we need to pass the LoggerInterface class to a constructor of a class from within we want to use it
and then simply make one the following method calls:

$this->logger->log(\Monolog\Logger::DEBUG,
'debug msg');
$this->logger->log(\Monolog\Logger::INFO,
'info msg');
$this->logger->log(\Monolog\Logger::NOTICE,
'notice msg');
$this-logger->log(\Monolog\Logger::WARNING,
'warning msg');
$this->logger->log(\Monolog\Logger::ERROR,
'error msg');
$this-logger->log(\Monolog\Logger::CRITICAL,
'critical msg');
$this->logger->log(\Monolog\Logger::ALERT,
'alert msg');
$this->logger->log(\Monolog
\Logger::EMERGENCY, 'emergency msg');

Alternatively, the preferred shorter version through individual log level type methods is as follows:

$this->logger->debug('debug msg');
$this->logger->info('info msg');
$this->logger->notice('notice msg');
$this->logger->warning('warning msg');
$this->logger->error('error msg');
$this->logger->critical('critical msg');
$this->logger->alert('alert msg');
$this->logger->emergency('emergency msg');

Both approaches result in the same two log files being created in Magento, which are as follows:

var/log/debug.log

var/log/system.log

The debug.log file contains only the debug level type of the log,
while the rest are saved under system.log

Entries within these logs will then look as follows:

[2015-11-21 09:42:18] main.DEBUG: debug msg
{"is-exception":false} []
[2015-11-21 09:42:18] main.INFO: info msg [] []
[2015-11-21 09:42:18] main.NOTICE: notice msg [] []
[2015-11-21 09:42:18] main.WARNING: warning msg [] []
[2015-11-21 09:42:18] main.ERROR: error msg [] []
[2015-11-21 09:42:18] main.CRITICAL: critical msg [] []
[2015-11-21 09:42:18] main.ALERT: alert msg [] []
[2015-11-21 09:42:18] main.EMERGENCY: emergency msg [] []

Each of these logger methods can accept an entire array of arbitrary data called context, as follows:

$this->logger->info('User logged in.', ['user'=>'Branko', 'age'=>32]);

The preceeding expression will produce the following entry in system.log:

[2015-11-21 09:42:18] main.INFO: User logged in. {"user":"Branko", "age":32} []

We can manually delete the log files from var/log dir, and Magento will automatically create it again when needed.

Magento also has another logging mechanism in place, where it logs the following actions in log_* tables in a DB:

log_customer

log_quote

log_summary

log_summary_type

log_url

log_url_info

log_visitorz

log_visitor_info

log_visitor_online

It is worth noting that this DB logging is not related in anyway to the Psr logger taht was described previously. While Psr logger
serves developers within the code to group and log certain messages according to the Psr standard, the DB logging logs
the live data that is result of user/customer interaction in the browser.

By default, Magento keeps DB logs for around 180 days. This is a config option that can be controlled in the Magento admin
area under the Stores | Settings | Configuration | Advanced | System | Log Cleaning tab with other related log options.

There we can set frequency, duration of save, log cleaning, start times, error email recipients, error email senders, error email templates.

These config options, only bare meaning OS cron is triggering Magento cron. (i.e, they only take effect if the OS cron uses the Magento Cron)

We can execute two commands on terminal: php bin/magento log:status to get the current state information about log tables and php bin/magento log:clean
to force the cleaning of tables

Magento has a built-in profiler that can be used to identify performance problems on the server side. In a nutshell,
the profiler can tell us the execution time of certain chunks of code. There is nothing that great with its behavior.

We can only get the execution time of code blocks or individual expressions that have been wrapped by the profiler's start
and stop methods. On its own, Magento calls for the profiler extensively across its code. However,
we cant see it in effect as the profiler output is disabled by default.

Magento supports three profiler outputs, namely html, csvfile and firebug.

To enable the profiler, we can edit .htaccess and add one of the following expressions:

SetEnv MAGE_PROFILER "html"

SetEnv MAGE_PROFILER "csvfile"

SetEnv MAGE_PROFILER "firebug"

The HTML type of profiler will show its output into the footer area of a page that we open in the browser, as shown in the following illustration:

Timer id 					Time 		Avg 		Cnt 	Emalloc 	RealMem

cache_frontend_create 		0.046384	0.023192	2 		1,479,184 	1,572,864

cache_load 					0.014226 	0.004742 	3 		454.796 	524,288

magento 					0.168286 	0.168286  	1 		4,086,732 	3,670,016

. cache_load 				0.013186 	0.001884 	7 		430,260 	524,288

. store.resolve 			0.080572 	0.080572 	1 		2,132,144 	2,097,152

. . EVENT:model_load_before 0.002523 	0.002523 	1 		133,904 	0

. . . cache_load 			0.00193 	0.0000967 	2 		40,436 		0

The csv file type of profiler will output into var/log/profiler.csv as shown:

cache_frontend_create,0.056334,0.028267, 2, "1,479,196", "1,572,864"
etc.
magento->cache_load,0.010538, etc.
magento->store.resolve->EVENT:model_load_before etc.

The profiler outputs, are as follows:

Time profiler shows the time spent from Profiler::start to Profiler::stop

Avg profiler shows the average time spent from Profiler::start to Profiler::stop for cases
where Cnt is greater than one

Cnt profiler shows the integer value of how many times we have started the profiler with the same timer name.
For example, if we have caled \Magento\Framework\Profiler::start('foggyline:office'); twice, somewhere in the code,
cnt will have been set to 2.

Emalloc profiler stands for amount of memory allocated to PHP. It is a mix of the core PHP memory_get_usage function
without the true parameter passed to it and the timer values.

RealMem profiler also stands for the amount of memory allocated to PHP whose final value is also obtained
via the memory_get_usage function minus the timer values, but this time with the true parameter passed to it.

We can easily add our own Profiler::start calls anywhere in the code. Every Profiler::start should be followed by
some code expressions and then finalized with a Profiler::stop call, as follows:

\Magento\Framework\Profiler::start('foggyline:office');
sleep(2); /* Code block or single expression here */
\Magento\Framework\Profiler::stop('foggyline:office');

Depending on where we call the profiler in the code, the resulting output should be similar to the one shown in the following
formatting:

. . CONTROLLER_ACTION:foggyline_office_test_crud 	2.077258 2.077258  1  239,732 	262,144
. . . action_body 									- II -    - II -  -II- -II-       -II-
. . . . foggyline:office 							2.000966  2.000966 1  1,308 	 	0
. . . . postdispatch 								0.052955  0.52955  1  55,952        0

Magento implements the observer pattern through \Magento\Framework\Event\ManagerInterface.
In app/etc/di.xml, there is a preference for MagentoInterface that points to the Magento\Framework\Event\Manager\Proxy class type.

The Proxy class further extends the \Magento\Framework\Event\Manager class that implements the actual event dispatch method.
Events are dispatched by calling a dispatch method on the instance of the Event\Manager class and passing the name
and some data, which is optional, to it. Here's an example of a Magento core event:

$this->eventManager->dispatch(
	'customer_customer_authenticated',
	['model' => 
$this->getFullCustomerObject($customer),
'password' => $password]
);

The $this->eventManager is an instance of the previously mentioned Event\Manager class. In this case, the event name
equals to customer_customer_authenticated, while the data passed to the event is the array with two elements.

The preceding event is fired when the authenticate method is called on \Magento\Customer\Model\AccountManager, that is,
when a customer logs in.

Dispatching an event only makes sense if we expect someone to observe it and execute their code when the event is
dispatched. Depending on the area from which we want to observe events, we can define observers in one of the following XML files:

app/code/{vendorName}/{moduleName}/etc/events.xml

app/code/{vendorName}/{moduleName}/etc/frontend/events.xml

app/code/{vendorName}/{moduleName}/etc/adminhtml/events.xml

Let's define an observer that will log an e-mail adress of an authenticated user into a var/log/system.log file. We 
can use the Foggyline_Office module and add some code to it. As we are interested in the storefront, it makes sense to
put the observer in the etc/frontend/events.xml module

Let's define the app/code/Foggyline/Office/etc/frontend/events.xml file with the contents as follows:

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:noNamespaceSchemaLocation="urn:magento:framework:Event/etc/events.xsd">
	<event
name="customer_customer_authenticated">
		<observer
name="foggyline_office_customer_authenticated
" instance="Foggyline\Office\Observer\LogCustomerEmail" />
	</event>
</config>

here, we are specifying a foggyline_office_customer_authenticated observer for the customer_customer_authenticated
event. The observer is defined in the LogCustomerEmail class that is placed in the Observer module dir. The Observer 
class has to implement the Magento\Framework\Event\ObserverInterface class. The Observer interface defines a single
execute method.

The execute method hosts the observer code and is executed when the customer_customer_authenticated event is dispatched.
Let's go ahead and define the Foggyline\Office\Observer\LogCustomerEmail class in the app/code/Foggyline/Office/Observer/LogCustomerEmail.php file as follows:

namespace Foggyline\Office\Observer;

use Magento\Framework\Event\ObserverInterface;

class LogCustomerEmail implements ObserverInterface
{
	protected $logger;

	public function __construct(
		\Psr\Log\LoggerInterface $logger
	)
	{
		$this->logger = $logger;
	}

	/**
	 * 	@param \Magento\Framework\Event\Observer $observer
	 *  @return self
	 */

	public function execute(\Magento
\Framework\Event\Observer $observer)
	{
		//$password = 
$observer->getEvent()->getPassword();
		$customer = 
$observer->getEvent()->getModel();

$this->logger->info('Foggyline\Office: ' . 
$customer->getEmail());
		return $this;
	}
}

The execute method takes a single parameter called $observer of the \Magento\Framework\Event\Observer type.
The event that we are observing is passing two pieces of data within the array, namely the model and password.
We can access this by using the $observer->getEvent()->get{arrayKeyName} expression.

The $customer object is an instance of the Magento\Customer\Model\Data\CustomerSecure class, which
contains properties such as email, firstname, lastname and so on. Thus, we can extract the e-mail address from it and pass it
to logger's info method.

Now that we know how to observe existing events, let's see how we can dispatch our own events. We can dispatch events 
from almost anywhere in the code, with or without data, as shown in the following example:

$this->eventManager->dispatch('foggyline_office_foo');
// or
$this->eventManager->dispatch(
	'foggyline_office_bar',
	['var1'=>'val1', 'var2'=>'val2']
);

It is worth noting that there are two types of events; we can group them in the following way according to the way their
name is assigned.

Static:
$this->eventManager->dispatch('event_name', ...)

Dynamic:
$this->eventManager->dispatch({expression}.'_event_name', ...)

The static events have a fixed string for a name, while the dynamic ones have a name that is determined during the runtime.
Here's a nice example of core Magento functionality from afterLoad method that is defined under lib/internal/Magento/Framework/Data/AbstractSearchResult.php,
which showcases how we use both type of events:

protected function afterLoad()
{
	$this->eventManager->dispatch
('abstract_search_result_load_after',
['collection' => $this]);
	if ($this->eventPrefix && $this->eventObject) {
		$this->eventManager->dispatch($this->eventPrefix . '_load_after', [$this->eventObject => $this]);
	}
}

We can see a static event (abstract_search_result_load_after) and a dynamic event ($this->eventPrefix . '_load_after'). The $this->eventPrefix is an
expression that gets evaluated during the runtime. We should be careful when using dynamic events as they are triggered under multiple situations.
Some interesting dynamic events are the one defined on classes like the following ones:

Magento\Framework\Model\AbstractModel
	$this->_eventPrefix . '_load_before'
	$this->_eventPrefix . '_load_after'
	$this->_eventPrefix . '_save_commit_after'
	$this->_eventPrefix . '_save_before'
	$this->_eventPrefix . '_save_after'

	$this->_eventPrefix . '_delete_before'
	$this->_eventPrefix . '_delete_after'
	$this->_eventPrefix . '_delete_commit_after'
	$this->_eventPrefix . '_clear'

\Magento\Framework\Model\ResourceModel\Db\Collection\AbstractCollection
	$this->_eventPrefix . '_load_before'
	$this->_eventPrefix . '_load_after'

\Magento\Framework\App\Action\Action
	'controller_action_predispatch_' .
	$request->getRouteName()

	'controller_action_predispatch_' .
	$request->getFullActionName()

	'controller_action_postdispatch_' .
	$request->getFullActionName()

	'controller_action_postdispatch_' .
	$request->getRouteName()

Magento\Framework\View\Result\Layout
	'layout_render_before_' .
	$this->request->getFullActionName()

These events are fired on the model, collection, controller and layout classes, which are probably among the most used
backend elements that often require observing and interacting. Even though we can say that the full event name is known during
the runtime along with the dynamic event, this can be assumed even before the runtime.

For example, assuming that we want to observe 'controller_action_predispatch_' . $request->getFullActionName() for the
Foggyline_Office module's Crud controller action, the actual full event name will be 'controller_action_predispatch_foggyline_office_test_crud',
given that $request->getFullActionName() will resolve to foggyline_office_test_crud during the runtime.

Magento has eleven-out-of-the-box cache types, according to the following list. These are used across many levels within the system:

Configuration: Various XML configurations that were collected across modules and merged

Layouts: Layouts building instructions

Blocks HTML output: Page blocks HTML

Collections data: Collection data files

Reflection data: API interfaces reflection data

Database DDL operations: Results of DLL queries, such as descrbing tables or indexes

EAV types and attributes: Entity types declaration cache

Page cache: Full page caching

Translations: Translation files

Integrations configuration: Integration configuration file

Integrations API configuration: Integrations API configuration file

Web services configuration: REST and SOAP configurations, generated WSDL file.

There is also Additional Cache Management that manages the cache for the following files:

Previously generated product image files

Themes Javascript and CSS files combined to one file

Preprocessed view files and static files

Each of these caches can be cleared seperately.

We can easily define our own cache type, we can do so by first creating an app/code/Foggyline/Office/etc/cache.xml file with content:

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:noNamespaceSchemaLocation="urn:magento:framework:Cache/etc/cache.xsd">
	<type name="foggyline_office"
			instance="Foggyline\Office\Model\Cache">
		<label>Foggyline Office Example</label>
		<description>Example cache from Foggyline office module.</description>
	</type>
</config>

When defining a new Cache type, we need to specify its name and instance attributes. The name attribute of the type
element should be set to foggyline_office and should be unique across Magento. This value should match the
TYPE_IDENTIFIER constant value on the Foggyline\Office\Model\Cache class, which will be created soon.

The instance attribute holds the class name that we will use for caching.

Then, we will define the Foggyline\Office\Model\Cache class in the app/code/Foggyline/Office/Model/Cache.php file:

namespace Foggyline\Office\Model;

class Cache extends \Magento\Framework\Cache\Frontend\Decorator\TagScope
{
	const TYPE_IDENTIFIER = 'foggyline_office';

	const CACHE_TAG = 'OFFICE';

	public function __constuct(
		\Magento\Framework\App\Cache\Type\FrontendPool $cacheFrontendPool
	)
	{
		parent::__construct(
			$cacheFrontEndPool->get(self::TYPE_IDENTIFIER), self::CACHE_TAG);
	}
}

The Cache class extends from the TagScope and specifies its own values for TYPE_IDENTIFIER and CACHE_TAG, passing them along
to the parent constructor in the __construct method. With these two files (cache.xml and Cache), we have basically
defined a new cache type.

Once we have specified the cache.xml file and referenced cache class, we should be able to see our cache type in Magento
admin under the System | Tools | Cache Management menu.

on its own, simply defining a new cache does not mean that it will get filled and used by Magento.

If you would like to use the cache anywhere within your code, you can do so by first passing the instance of the cache class
to the constructor, as follows:

protected $cache;

public function __construct(
	\Foggyline\Office\Model\Cache $cache
)
{
	$this->cache = $cache;
}

Then you can execute a chunk of code, as follows:

$cacheId = 'some-specific-id';
$objInfo = null;
$_objInfo = $this->cache->load($cacheId);

if ($_objInfo) {
	$objInfo = unserialize($_objInfo);
} else {
	$objInfo = [
		'var1' => 'val1',
		'var2' => 'val2',
		'var3' => 'val3'
	];
	$this->cache->save(serialize($objInfo), $cacheId);
}

The preceeding code shows how we first try to load the value from the existing cache entry, and if there is none, we save to it.

If the cache type is set to disabled under the Cache Management menu, then the preceeding code will never save and pull data from the cache,
as it is not in effect. If you take a look at the var/cache folder of Magento at this point, you will see something similar to what's shown
in the following folder structure:

var
	cache
		mage--9
			mage---a8a_DESIGN_CHANGE_<stuff>
		mage--d
			mage---a8a_ADMIN_NOTIFICATIONS_LASTCHECK
		mage--e
			mage---a8a_CONFIGURATION_FILE_ACCESS_LEVEL_VERIFICATION
		mage--f
			mage---a8a_SOME_SPECIFIC_ID
		mage-tags
			mage---a8a_CORE_DESIGN
			mage---a8a_MAGE
			mage---a8a_OFFICE

Magento created two cache entries for us, namely var/cache/mage-tags/mage---a8a_OFFICE and var/cache/mage--f/mage---a8a_SOME_SPECIFIC_ID.

The mage---a8a_OFFICE file has only a single line of entry in this specific case, and the entry is the a8a_SOME_SPECIFIC_ID string, which obviously point
to the other file. The mage---a8a_SOME_SPECIFIC_ID file contains the actual serialized $objInfo array

The a8a_prefix and other prefixes in the cache file names are not really relevant to us: This is something that Magento adds on its own. What is relevant
to us in passing of the proper individual cache tags to the chunks or variables that we want to cache, like in the preceeding example,
and the TYPE_IDENTIFIER and CACHE_TAG tags that we set for the Cache class.

Magento provides support for widgets. Though the word "widget" might imply frontend development skills and activites, we will look at them
as part of the backend development flow because creating useful and robust widgets requires a significant amount of backend knowledge.

Magento provides several out-of-the-box widgets; Some of them are as follows:

CMS page link

CMS static block

Catalog category link

Catalog new products list

Catalog product link

Catalog products list

Orders and returns

Recently compared products

Recently viewed products

To create a fully custom widget, we start by defining app/code/Foggyline/Office/etc/widge.xml with content:

<widgets xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Widget:etc/widget.xsd">
	<widget id="foggyline_office"
		class="Foggyline\Office\Block\Widget\Example"

	placeholder_image="Magento_Cms"::images/widget_block.png">
		<label translate="true">Foggyline Office</label>
		<description translate="true">Example widget</description>
		<parameters>
			<parameter name="var1"
xsi:type="select" visible="true"
source_model"Magento\Config\Model\Config\Source\Yesno">
				<label
translate="true">Yes/No var1</label>
			</parameter>
			<parameter name="var2"
xsi:type="text" required="true"
visible="true">
				<label
translate="true">Number var2</label>
				<depends>
					<parameter name="var1"
value="1"/>
				</depends>
				<value>5</value>
			</parameter>
		</parameters>
	</widget>
</widgets>

The id widget has been set to foggyline_office, while the class powering widget has been set to 
Foggyline\Office\Block\Widget\Example. the widget class is basically a block class that extends from 
\Magento\Framework\View\Element\AbstractBlock and implements \Magento\Widget\Block\BlockInterface. The label
and description element set values appear under the Magento admin when we select the widget for use.

The parameters of a widget are its configurable options that translate into HTML form elemens, depending on the type
and source_model options that we have selected. In the following example, we will demonstrate the usage of 
select and text elements to retrieve input from a user.

Let's proceed by creating the actual Widget\Example class in the app/code/Foggyline/Office/Block/Widget/Example.php file:

namespace Foggyline\Office\Block\Widget;

class Example extends \Magento\Framework\View\Element\Text implements \Magento\Widget\Block\Blockinterface
{
	protected function _beforeToHtml()
	{
		$this->setText(sprintf(
			'example widget: var1=%s, var2=%s',
			$this->getData('var1'),
			$this->getData('var2')
		));

		return parent::_beforeToHtml();
	}
}

What is happening here, is that we are using Element\Text as a block type and not Element\Template because
we want to simplify the example, as Element\Template will require the phtml template to be defined as well.

By using Element\Text, we can simply define _beforeHtml and call the setText method to set the text string of the block's
output. We will build the output string by picking up the var1 and var2 variables, which were passed as parameters to the block.

Now, if we open the Magento admin area, go to Content | Elements | Pages, and select Home Page to edit, we 
should be able to click on the Insert Frontend App button and add our widget to the page. Alternatively, if 
we are not editing the page in the WYSIWYG mode, we can also add the widget manually to the page by using
the following stuff:

{{widget type="Foggyline\\Office\\Block\\Widget\\Example" var1="1" var2="5"}}

Finally, we should see the example widget: var1=1, var2=5 string in the browser visiting the home page of the storefront.

We can use frontend apps to create highly configurable and embedded widgets that users can easily assign to a CMS page or block.

Variables are a handy little feature of a core Magento_Variable module. Magento allows you to create custom variables
and then use them in e-mail templates, the WYSIWYG editor, or even code expressions.

The following steps outline how we can create a new variable manually:

1. In the Magento admin area, navigate to System | Other Settings | Custom Variables.

2. Click on the Add New Variable button.

3. While keeping in mind the Store View switcher, fill in the required Variable Code and Variable Name
options, and preferably one of the optional options, either Variable HTML Value or Variable Plain Value.

4. Save

Now that we have created the custom variable, we can use it in an e-mail template or the WYSIWYG editor by calling it
using the following expression:

{{customVar code=foggyline_hello}}

The preceeding expression will call for the value of the custom variable with code foggyline_hello.

Variables can be used within various code expressions, though it is not recommended to rely on the existence of an
individual variable, as an admin user can delete it at any point. The following example demonstrates how we can use
an existing variable in the code:

$storeId = 0;

$variable =
$this->_variableFactory->create()->setStoreId(
	$storeId
)->loadByCode(
	'foggyline_hello'
);

$value = $variable->getValue(
	\Magento\Variable\Model
\Variable::TYPE_HTML
);

The $this->variableFactory is an instance of \Magento\Variable\Model\VariableFactory

If used in the right way, variables can be useful. Storing information such as phone numbers or specialized 
labels that are used in CMS pages, blogs, and e-mail templates is a nice example of using custom variables.

i18n is the shorthand for internalization. Magento adds i18n support out of the box, thus adapting to
various languages and regions without application changes. Within app/functions.php, there is a __() translation
function, which is defined as follows:

function __()
{
	$argc = func_get_args();

	$text = array_shift($argc);
	if (!empty($argc) && is_array($argc[0]))
	{
		$argc = $argc[0];
	}

	return new \Magento\Framework\Phrase($text, $argc);
}

This translation function accepts a variable number of arguments and passes them to a constructor of the
\Magento\Framework\Phrase class and returns its instance. The Phrase class has the __toString method,
which then returns the translated string.

Here are a few examples of how we can use the __() function:

__('Translate me')

__('Var1 %1, Var2 %2, Var %3', time(), date('Y'), 32)

__('Copyright %1 <a href="%2">Magento</a>', date('Y'), 'http://magento.com')

Strings passed through the translation function are expected to be found under the local CSV files, such
as app/code/{vendorName}/{moduleName}/i18n/{localeCode}.csv.

Let's imagine for a moment that we have two different store views defined in the Magento admin area under Stores | Settings
| All Stores.

One store has Store | Settings | Configuration | General | Locale Options | Locale set to English (United Kingdom) and other one to 
German (Germany). The local code for English (United Kingdom) is en_GB, and for German(Germany), it is de_DE.

For the de_DE locale, we will add translation entries in the app/code/Foggyline/Office/i18n/de_DE.csv file, as follows:

"Translate me", "de_DE Translate me"
"Var1 %1, Var2 %2, Var %3", "de_DE Var1 %1, Var2 %2, Var %3"
"Copyright %1 <a
href=""%2"">Magento</a>","de_DE Copyright %1 <a href=""%2"">Mangeto</a>"

For the en_GB locale, we will add translation entires in the app/code/Foggyline/Office/i18n/en_GB.csv file, as follows:

"Translate me", "en_GB Translate me"
"Var1 %1, Var2 %2, Var %3", "en_GB Var1 %1, Var2 %2, Var %3"
"Copyright %1 <a
href=""%2"">Magento</a>","en_GB Copyright %1 <a href=""%2"">Magento</a>"

Looking at the two CSV files, a pattern emerges. We can see that the CSV files function in the following way:

Individual translation strings are provided according to every line of CSV

Each line further comprises two individual strings that are seperated by a comma

Both individual strings are surrounded by quotes

If a string contains quotes, it is escaped by a double quote
so that it does not break translation

The %1, %2, %3..%n pattern is used to mark variable placeholders that we provided during
application runtime through the code

Magento supports several commands related to its bin/magento console tool:

i18n
	i18n:collect-phrases 	Discovers phrases
in the codebase
	i18n:pack 				Saves language
package
	i18n:uninstall 			Uninstalls
language packages

If we execute a console command as follows, Magento will recursively look for translatable expressions within PHP,
PHTML or XML files that have phrases to translate:

php bin/magento i18n:collect-phrases -o
"/Users/branko/www/magento2/app/code/Foggyline/Office/
i18n/en_GB.csv" /Users/branko/www/magento2/app/code/Foggyline/Office

The output of the preceding comand will basically overwrite the app/code/Foggyline/Office/i18n/en_GB.csv file, 
which has all the Foggyline/Office module translatable phrases. This is a nice way of aggregating all the translatable
phrases into appropiate locale files, such as en_GB.csv in this case.

The translation CSV files can also be placed under the individual theme. For example, let's imagine
a situation where we add content to app/design/frontend/Magento/blank/i18n/en_GB.csv as follows:

"Translate me", "Theme_en_GB Translate me"
"Var1 %1, Var2 %2, Var %3", "Theme_en_GB Var1
%1, Var2 %2, Var %3"
"Copyright %1 <a href=""%2"">Magento</a>", "Theme_en_GB
Copyright %1 <a href=""%2"">Magento</a>"

Now, a Translate me string output of the storefront for the en_GB locale would resolve to Theme_en_GB Translate me
and not to the en_GB Translate me string.

Theme CSV translations take higher precedence than module CSV translations, thus enabling developers to override
individual module translations.

Along with CSV translation files, Magento also supports a feature called inline translation. We can activate 
the inline translation in the Magento admin area by navigating to Store | Settings | Configuration | Advanced | Developer | Translate Inline

This feature can be turned on seperately for Admin and Storefront.

As shown in the preceeding screenshot, when a feature is activated, red dotted borders appear around the HTML elements.
Hovering over an individual element shows a little book icon near the individual element at the bottom left corner.
Clicking on the book icon opens a popup with info.

It is important to know, that these red dotted borders and the book icon will only appear for strings that we passed through the __() translate function.

Here we can see various pieces of information about the string, such as the Shown, Translated, and Original string. There is also an input field
called Custom, where we can add a new translation. Inline translation strings are stored in the translation table in the DB.

NOTE: Inline translation takes higher predecence than theme CSV translation files.

Indexing is the process of transforming data by reducing it to flattened data with less DB tables. This process is run
for products, categories, and so on in order to improve the performance of a web store. Since data constantly changes,
this is not a one-time process. Rather, it's done in periods.

The Magento_Indexer module is a base of the Magento Indexing functionality.

The Magento console tool supports the following indexer commands.

indexer
	indexer:info 		Shows allowed
Indexers
	indexer:reindex 	Reindexes Data
	indexer:set-mode 	Sets index mode type
	indexer:show-mode 	Shows index mode
	indexer:status 		Shows status of Indexer

On running php bin/magento indexer:info, you will get a list of all the Magento indexers. The default ones are as
follows:

catalog_category_product 	Category Products
catalog_product_category 	Product
Categories
catalog_product_price 		Product Price
catalog_product_attribute 	Product EAV
foggyline_office_employee 	Employee flat
Data
cataloginventory_stock 		Stock
catalog_rule 				Catalog Rule
Product
catalogrule_product 		Catalog Product
Rule
catalogsearch_fulltext 		Catalog Search

You will see all the indexers listed in the Magento admin in the System | Tools | Index Management menu.

From within the admin area, we can only change the indexer mode. There are two modes of indexers:

Update on Save: Index tables are updated right after the dictionary data is changed

Update by Schedule: Index tables are updated by cron jobs according to the configured schedule

Since indexers cannot be run manually from admin, we have to rely on their manual execution or the cron execution.

Manual execution is done via the following console command:

php bin/magento indexer:reindex

The preceding command will run all the indexers at once. We can fine-tune it further to execute individual indexes
by running a console command that is similar to the following line of code:

php bin/magento indexer:reindex
catalogsearch_fulltext

Cron-executed indexers are defined via the Magento_Indexer module, as follows:

indexer_reindex_all_invalid: This will execute every minute of every hour every day. It runs the
reindexAllInvalid method on an instance of the Magento\Indexer\Model\Processor class.

indexer_update_all_views: This will execute every minute of every hour everyday. It runs the
updateMview method on an instance of the Magento\Indexer\Model\Processor class.

indexer_clean_all_changelogs: This will execute the 0th minute of every hour every day. it runs 
the clearChangelog method on an instance of the Magento\Indexer\Model\Processor class.

These cron jobs use an operating system cron job setup in such a way that the Magento cron job is triggered
every minute.

The following three statuses is what an indexer can have:

valid: The data is synchronized and no re-indexing is required

invalid: The original data was changed and the index should be updated

working: The index process is running

While we won't go into the details of actually creating a custom indexer within this chapter,
it is worth noting that Magento defines it's indexers in the vendor/magento/module-*/etc/indexer.xml file

This might come in handy for cases where we want a deeper understanding of the inner workings of an individual indexer. For example,
the catalog_product_flat indexer is implemented via the Magento\Catalog\Model\Indexer\Product\Flat class, as defined within
the vendor/magento/module-catalog/etc/indexer.xml file.

By studying the Flat class implementation in depth, you can learn how data is taken from EAV tables and flattened into a simplified structure.

The next part, is about Frontend development. 

Frontend development, is mostly tied to HTML, CSS and JS for websites or web apps.

Interchangably, it adresses accessibility, usability and performance towards reaching a satisfying user experience.
Various levels of customization we want to apply to our web store require different development skill levels.

We can make relativily simple changes to our store using just CSS. These would be the changes where we accept the
structure of the store and focus only on visuals like changing colors and images. This might be a good starting point
for less experienced devs, and those new to Magento.

A more involved approach would be to make changes to the output generated by Magento modules. This usually means tiny bits of PHP knowledge,
mostly copy-paste modify of existing code fragments. A skill level above this one would imply knowledge of making structural 
changes to our store.

This usually means mastering Magento's moderately sophisticated layout engine, where we make changes through XML definitions.
The final and highest skill level of Magento frontend, implies development of existing or new custom functionality development.

Throughout this chapter, we will take a deep dive through the following sections:

Rendering flow

View elements

Block architechture and life cycle

Templates

XML Layouts

Themes

JS

CSS

The Magento application entry point is its index.php file. All of the HTTP requests go through it.
Let's analyze the (trimmed) version of the index.php file as follows:

require __DIR__ . '/app/bootstrap.php';

$bootstrap = \Magento\Framework\App\Bootstrap::create(BP, $_SERVER);

$app => $bootstrap -> createApplication('Magento\Framework\App\Http');

$bootstrap->run($app);

Thus, we begin by including /app/bootstrap.php into the code. What happens inside the bootstrap is the inclusion of app/autoload.php
and app/functions.php. These functions file contains a single __() function, used for translation purposes, returning an instance of
the \Magento\Framework\Phrases object. 

Without going into the details of the auto-load file, it is suffice to say it handles the auto-loading of all our class files across Magento.

The second step, is simply a static create method call to obtain the instance of the \Magento\Framework\App\Bootstrap object,
storing it into the $bootstrap variable.

The third step, is calling createApplication method on the $bootstrap object. What is happening within createApplication
is nothing more than using object manager to create and return the object instance of the class we are passing to it.

Since we are passing the \Magento\Framework\App\Http class name to the createApplication method, our $app variable becomes
the instance of that class. What this means, effectively, is that our web store app is an instance of Magento\Framework\App\Http.

The last step, is to call the run method on $bootStrap object, passing it the instance of the Magento\Framework\App\Http class.
Although it looks like a simple line of code, this is where stuff gets complicated, as we will see soon.

Let's analyze the trimmed version of the \Magento\Framework\Bootstrap -> run method as follows:

public function run(\Magento\Framework\AppInterface $application)
{
	//PART 2-1
	$this->initErrorHandler();
	$this->initObjectManager();
	$this->assertMaintenance();
	$this->assertInstalled();

	//PART 2-2
	$response = $application->launch();

	//PART 2-3
	$response->sendResponse();
}

Part 2-1, handles the sort of housekeeping bits. It initializes the custom error handler,
intializes the object manager, checks if our app is in maintnance mode, and checked that its installed.

Part 2-2, we call the launch() method on $application, which is the Magento\Framework\App\Http instance.
Without going into the inner workings of the launch method for the moment, let's just say it returns the instance
of Magento\Framework\App\Response\Http\Interceptor class defined under var/generation/Magento/Framework/App/Response/Http/Interceptor.php

Note that this is an automatically generated wrapper class, extending the \Magento\Framework\App\Response\Http class.

Effectively, ignoring the interceptor, we can say that $response is an instance the \Magento\Framework\App\Response\Http class.

Finally, Part 2-3 calls the sendResponse method on $response. Though $response is an instance of the \Magento\Framework\App\Response\Http class,
the actual sendResponse method is found further down the parent tree on the \Magento\Framework\HTTP\PhpEnvironment\Response class.

The sendResponse method calls another parent class method called send. The send method can be found under the Zend\Http\PhpEnvironment\Response class.
It triggers the sendHeaders and sendContent methods. This is where the actual output gets sent to the browser, as the sendHeaders methods
is using PHP's header function and echo construct to push the output.

To reiterate on the preceeding, the flow of execution as we understand it, comes down to the following:

index.php

\Magento\Framework\App\Bootstrap->run
\Magento\Framework\App\Http->launch
\Magento\Framework\App\Response\Http->sendResponse

Though we have just made it to the end of the bootstrap's run method, it would be unfair to say we covered the rendering flow,
as we barely touched it.

We need to take a step back and take a detailed look at PART 2-2, the inner workings of the launch method. Let's take a look at the
(trimmed) version of the \Magento\Framework\App\Http->launch method as follows:

public function launch()
{
	//Part 3-1
	$frontController =
$this->_objectManager->get
('Magento\Framework\App\FrontControllerInterface');

	//Part 3-2
	$result =
$frontController->dispatch($this->_request);
	
	if ($result instanceof \Magento\Framework\Controller\ResultInterface) {
		//part 3-3

$result->renderResult($this->_response);
	} elseif ($result instanceof \Magento\Framework\App\Response\HttpInterface) {
		$this->_response = $result;
	} else {
		throw new \InvalidArgumentException('Invalid return type');
	}
	
	//part 3-4
	return $this->_response;
}

Part 3-1 creates the instance of the object whose class conforms to \Magento\Framework\App\FrontControllerInterface.
If we look under app/etc/di.xml, we can see there is a prefernce for FrontControllerInterface in favor of the \Magento\Framework\App\FrontController class.

However, if we were to debug the code and check for the actual instance class, it would show Magento\Framework\App\FrontController\Interceptor.
This is Magento adding an interceptor wrapper that then extends \Magento\Framework\App\FrontController, which we expected from the di.xml
prefernce entry.

Now that we know the real class behind the $frontController instance, we know where to look for the dispatch method. The dispatch method 
is another important step in understanding the rendering flow process. We will look into its inner workings in a bit more detail later
on.

For now, let's focus back on the $result variable of part-3-2. If we were to debug the variable, the direct class behind it would show as
Magento\Framework\View\Result\Page\Interceptor, defined under the dynamically created var/generation/Magento/Framework/View/Result/Page/Interceptor.php file.

interceptor is the wrapper of the \Magento\Framework\View\Result\Page class. Thus, it is safe to say that our $result variable is an
instance of the Page class.

The Page class extends \Magento\Framework\View\Result\Layout, which further extends \Magento\Framework\Controller\AbstractResult and implements
\Magento\Framework\Controller\ResultInterface. Quite a chain we have here, but it is important to understand it.

Notice part 3-3. Since our $result is an instance of \Magento\Framework\Controller\ResultInterface, we fall into the first if condition
that calls the renderResult method. the renderResult method itself is declared within the \Magento\Framework\View\Result\Layout class.

Without going into the details of renderResult, suffice to say that it adds HTTP headers, and content to the $this->_response object
passed to it. That same response object is what the launch method returns, as we described before in Part 2-2.

Though part-3-3 does not depict any return value, the expression $result->renderResult($this->_response) does not do any
output on its own. It modifies $this->_response that we finally return from the launch method as shown in part-3-4

To reiterate on the preceeding, the flow of execution as we understand it comes down to the following:

index.php

\Magento\Framework\App\Bootstrap->run

\Magento\Framework\App\Http->launch

\Magento\Framework\App\FrontController->dispatch

\Magento\Framework\View\Result\Page->renderResult

\Magento\Framework\App\Response\Http->sendResponse

As we mentioned while explaining Part-3-2, the dispatch method is another important step 
in the rendering flow process. Let's take a look at the (trimmed) version of the \Magento\Framework\App\FrontController->dispatch method as follows:

public function dispatch(\Magento\Framework\App\RequestInterface $request)
{
	//PART 4-1
	while (!$request->isDispatched() && $routingCycleCounter++ < 100) {
		//Part 4-2
		foreach ($this->_routerList as $router)
		{
			try {
				//PART 4-3
				$actionInstance = $router->match($request);
				if ($actionInstance) {
					$request->setDispatched(true);
											//PART 4-4
											$result =
				$actionInstance->dispatch($request);
											break;
										}
									} catch (\Magento\Framework\Exception\NotFoundException $e) {}
				
			
		}
	}

	//part 4-4 
	return $result;
}

//NOTE: Indention error on some level of where we have not found the pattern correctly

Part-4-1 and PART-4-2 in the preceeding code shows (almost) the entire dispatch method body contained within a loop.
The loop does 100 iterations, further looping through all available router types, thus giving each router 100 times to find a router match.

The router list loop includes routers of the following class types:

Magento\Framework\App\Router\Base

Magento\UrlRewrite\Controller\Router

Magento\Cms\Controller\Router

Magento\Framework\App\Router\DefaultRouter

All of the list routers implement \Magento\Framework\App\RouterInterface, making them all have the implementations of the match method.

A module can further define new routers if they choose so. As an example, imagine if we are developing a blog module. We would want our module
catching all requests on a URL that starts with a /blog/ part. This can be done by specifying the custom router, which would then show up
on the preceeding list.

Part-4-3 shows the $actionInstance variable storing the result of the router match method call. As per RouterInterface
requirements, the matcher method is required to return an instance whose class implements \Magento\Framework\App\ActionInterface. Let's
imagine we are now hitting the URL /foggyline_office/test/crud/ from the module we wrote in chaper 4.

in this case, our $router class would be \Magento\Framework\App\Router\Base and our $actionInstance would be of the class \Foggyline\Office
\Controller\Test\Crud\Interceptor.

Magento automatically adds Interceptor, through the dynamically generated var/generation/Foggyline/Office/Controller/Test/Crud/Interceptor.php file

This Interceptor class further extends our module \Foggyline\Office\Controller\Test\Crud class file.
The Crud class extends \Foggyline\Office\Controller\Test, which further extends \Magento\Framework\App\Action\Action, which implements
\Magento\Framework\App\ActionInterface. After a lengthy parent-child tree, we finally got to ActionInterface, which is what 
our match method is required to return.

Part-4-4 shows the dispatch method being called on $actionInstance. This method is implemented within \Magento\Framework\App\Action\Action, and is
expected to return an Object that implements \Magento\Framework\App\ResponseInterface. Internal to dispatch, the execute method is called,
thus running the code within our Crud controller action execute method.

Assuming our Crud controller action execute method does not return nothing, the $result object becomes an instance of Magento\Framework\App\Response\Http\Interceptor,
which is wrapped around \Magento\Framework\App\Response\Http.

Let's imagine our Crud class has been defined as follows:

/**
  * @var \Magento\Framework\View\Result\Pagefactory
  */

protected $resultPageFactory;

public function __construct( \Magento\Framework\App\Action\Context $context, \Magento\Framework\View\Result\PageFactory $resultPageFactory)
{
	$this->resultPageFactory = $resultPageFactory;
	return parent::__construct($context);
}

public function execute()
{
	$resultPage = $this->resultPageFactory->create();
	//...
	return $resultPage;
}

Debugging the $result variable now shows it's an instance of \Magento\Framework\View\Result\Page\Interceptor. This Interceptor
gets dynamically generated by Magento under var/generation/Magento/Framework/View/Result/Page/Interceptor.php
and is merely a wrapper for \Magento\Framework\View\Result\Page. This Page class further extends the \Magento\Framework\View\Result\Layout class,
and implements \Magento\Framework\App\ResponseInterface.

Finally, PART-4-4 shows the $result object of type \Magento\Framework\View\Result\Page being returned from the FrontController dispatch method.
To reiterate on the preceeding, the flow of execution as we understand it comes down to the following:

index.php

\Magento\Framework\App\Bootstrap->run

\Magento\Framework\App\Http->launch

\Magento\Framework\App\FrontController->dispatch

\Magento\Framework\App\Router\Base->match

\Magento\Framework\App\Action\Action->dispatch

\Magento\Framework\View\Result\Page->renderResult

\Magento\Framework\App\Response\Http->sendResponse

In a nutshell, what we as a frontend dev should know is that returning the Page type object from our controller
action will automatically call the renderResult method on that object. Page and Layout is where all the theme translations, layout and template loading
are triggering.

Magento's primary view elements are its UI components, containers and blocks. The following is a brief overview of each of them.

Under the vendor/magento/framework/View/Element/ folder, we can find UiComponentInterface and UiComponentFactory.
The full set of Ui components is located under the vendor/magento/framework/View/Element/ dir.

Magento implements UiComponent through a seperate module called Magento_Ui. Thus, the components themselves are 
located under the vendor/magento/module-ui/Component/ dir.

Components implement UiComponentInterface, which is defined under the vendor/magento/framework/View/Element/UiComponentInterface.php file as follows:

namespace Magento\Framework\View\Element;

use Magento\Framework\View\Element\UiComponent\ContextInterface;

interface UiComponentInterface extends BlockInterface
{
	public function getName();
	public function getComponentName();
	public function getConfiguration();
	public function render();
	public function addComponent($name, UiComponentInterface $component);
	public function getComponent($name);
	public function getChildComponents();
	public function getTemplate();
	public function getContext();
	public function renderChildComponent($name);
	public function setData($key, $value = null);
	public function getData($key = '', $index = null);
	public function prepare();
	public function prepareDataSource(array & $dataSource);
	public function getDataSourceData();
}

Notice how BlockInterface extends BlockInterface, whereas BlockInterface defines only one method requirement as follows:

namespace Magento\Framework\View\Element;

interface BlockInterface
{
	public function toHtml();
}

Since Block is an element of the interface, UiComponent can be looked at as an advanced block. Let's take a quick look
at the _renderUiComponent method of the \Magento\Framework\View\Layout class (partially) as follows:

protected function _renderUiComponent($name)
{
	$uiComponent = $this->getUiComponent($name);

	return $uiComponent ? $uiComponent->toHtml() : '';
}

This shows that UiComponent is rendered the same way as block, by calling the toHtml method on the component.
The vendor/magento/module-ui/view/base/ui_component/etc/definition.xml file contains an extensive list of several
UiComponents as follows:

dataSource:Magento\Ui\Component\DataSource

listing:Magento\Ui\Component\Listing

paging:Magento\Ui\Component\Paging

filters:Magneto\Ui\Component\Filters

container:Magento\Ui\Component\Container

form:Magento\Ui\Component\Form

price:Magento\Ui\Component\Form\Element\DataType\Price

image:Magento\Ui\Component\Form\Element\DataType\Media

nav:Magento\Ui\Component\Layout\Tabs\Nav

and more!

These components are mostly used to construct a listing and filters in the admin area.
If we do a string search for uiComponent across the entire Magento, we would mostly
find entries like the one in vendor/magento/module-cms/view/adminhtml/layout/cms_block_index.html, with stuff like:

<page xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:noNamespaceSchemaLocation="urn:magento:framework:View/Layout/etc/page_configuration.xsd">
	<body>
		<referenceContainer name="content">
			<uiComponent name="cms_block_listing"/>
		</referenceContainer>
	</body>
</page>

The value cms_block_listing of uiComponent's name attribute refers to the name of the vendor/magento/module-cms/view/adminhtml/ui_component/
cms_block_listing.xml file. Within the cms_block_listing.xml file, we have a listing component defines across more than
a few hundred lines of XML. Listing component then dataSource, container, bookmark, filterSearch, filters and so on. We will not
go into the details of these declarations, as our focus here is on more general frontend bits.

We cannot create instances of containers because they are an abstract concept, whereas we can create instances of Blocks.

Containers are rendered via the _renderContainer method of the Magento\Framework\View\Layout class, defines as follows:

protected function _renderContainer($name)
{
	$html = '';
	$children = $this->getChildNames($name);
	foreach ($children as $child) {
		$html .=
$this->renderElement($child);
	}
	if ($html == '' ||
!$this->structure->getAttribute($name, Element::CONTAINER_OPT_HTML_TAG)) {
		return $html;
}

	$htmlId =
$this->structure->getAttribute($name, Element::CONTAINER_OPT_HTML_ID);
	if ($htmlId) {
		$htmlId = ' id="' . $htmlId . '"';
	}

	$htmlClass =
$this->structure->getAttribute($name, Element::CONTAINER_OPT_HTML_CLASS);
	if ($htmlClass) {
		$htmlClass = ' class="' . $htmlClass . '"';
	}

	$htmlTag =
$this->structure->getAttribute($name, Element::CONTAINER_OPT_HTML_TAG);

	$html =
sprintf('<%1$s%2$s%3$s>%4$s</%1$s>',
$htmlTag, $htmlId, $htmlClass, $html);
	
	return $html;
}

Containers support the following extra attributes: htmlTag, htmlClass, htmlId and label. To make a little
demonstration of a container in action, let us make sure we have a module from Chapter 4. Models and Collections in
place, and then create the view/frontend/layout/foggyline_office_test_crud.xml file within the
module root folder app/code/Foggyline/Office/ with content as follows:

<page xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" layout="1column"

xsi:noNamespaceSchemaLocation="urn:magento:framework:View/Layout/etc/page_configuration.xsd">
	<head>
		<title>Office CRUD #layout</title>
	</head>
	<body>
		<container name="foobar" htmlTag="div" htmlClass="foo-bar">
			<block class="Magento\Framework\View\Element\Text" name="foo">
				<action method="setText">
					<argument name="text"
xsi:type="string"> <![CDATA[<p>The Foo</p>]]>
</argument>
				</action>
			</block>
			<block class="Magento\Framework\View\Element\Text" name="bar">
															<action method="setText">
																<argument name="text" 
xsi:type="string"> <![CDATA[<p>The bar</p>]]>
</argument>
															</action>
														</block>
													</container>
												</body>
											</page>


NOTE: Error in Indentions

The preceding XML defines a single container named foobar, and within the container there are two block
elements named foo and bar. It should kick in when we open http://{our-shop-url}/index.php/foggyline_office/test/crud/ in the browser.

Notice how the container itself is not nested within any other element, rather directly into the body. We could have
easily nested into some other container as shown:

<body>
	<referenceContainer name="content">
		<container name="foobar" htmlTag="div" htmlClass="foo-bar">

Either way, we should see the srings The Foo and The Barshown in the browser, with a full-page layout loaded, as shown
in the following screenshot.

Although containers determine the layout of the page, they do not contain actual content directly. Pieces that contain the
content and are nested within containers are called blocks. Each block can contain any number of child content blocks or
child containers. Thus, mostly every web page in Magento is formed as a mix of blocks and containers. Layout defines a
sequence of blocks on the page, not their location.

The look and feels of the blocks is determined by CSS and how the Page is rendered. When we speak of Blocks,
we almost always implicitly refer to templates as well. Templates are the thing that actually draw elements within
a page. Blocks are the thing that contain the Data. In other words, templates are PHTML or HTML files pulling data
through variables or methods sent on a linked PHP block class.

Magento defines Magento\Framework\View\Result\Page type under app/etc/di.xml as follows:

<type name="Magento\Framework\View\Result\Page">
	<arguments>
		<argument name="layoutReaderPool" 
xsi:type="object">pageConfigRenderPool</argument>
		
		<argument name="generatorPool"
xsi:type="object">pageLayoutGeneratorPool</argument>

		<argument name="template"
xsi:type="string">Magento_Theme::root.phtml</argument>	
	</arguments>
</type>

Notice the template argument is set to Magento_Theme::root.phtml. Whem Page gets 
initialized, it picks up the vendor/magento/module-theme/view/base/templates/root.pthml file.

root.phtml is defined as follows:

<!doctype Html>
<html <?php echo $htmlAttributes ?>>
	<head <?php echo $headAttributes ?>>
		<?php echo $requireJs ?>
		<?php echo $headContent ?>
		<?php echo $headAdditional ?>
	</head>
	<body data-container="body" data-mage-init='{"loaderAjax": {}, "loader": { "icon": "<?php echo $loaderIcon; ?>"}}'
	<?php echo $bodyAttributes ?>>
		<?php echo $layoutContent ?>
	</body>
</html>

Variables within root.phtml are assigned during the Magento\Framework\View\Result\Page render method call as (partially) shown:

protected function render(ResponseInterface $response)
{
	$this->pageConfig->publicBuild();

	if ($this->getPageLayout()) {
		$config = $this->getConfig();
		$this->addDefaultBodyClasses();
		$addBlock = 
$this->getLayout()->getBlock('head.additional');
		$requireJs = $this->getLayout-getBlock('require.js');
		$this->assign([
			'requireJs' => $requireJs ? $requireJs->toHtml() : null,
			'headContent' => $this->pageConfigRenderer->renderHeadContent(),
			'headAdditional' => $addBlock ? $addBlock->toHtml() : null,
			'htmlAttributes' => $this->pageConfigRenderer->renderElementAttributes($config::ELEMENT_TYPE_HTML),
			'headAttributes' => $this->pageConfigRenderer->renderElementAttributes($config::ELEMENT_TYPE_HEAD),
			'bodyAttributes' => $this->pageConfigRenderer->renderElementAttributes($config::ELEMENT_TYPE_BODY),
			'loaderIcon' => $this->getViewFileUrl('images/loader2.gif'), ]);

			$output = $this->getLayout()->getOutput();
			$this->assign('layoutContent', $output);
			$output = $this->renderPage();

			$this->translateInline->processResponseBody($output);
			$response->appendBody($output);
	} else {
		parent::render($response);
	}

	return $this;
}

The expression $this->assign is what assigns variables like layoutContent to the root.phtml template.
layoutContent is generated based on base layouts, together with all layout updates for the current page.

Whereas base layouts include the following XMLs within vendor/magento/module-theme/view/:

base/page_layout/empty.xml

frontend/page_layout/1column.xml

frontend/page_layout/2columns-left.xml

frontend/page_layout/2columns-right.xml

frontend/page_layout/3columns.xml

The expression $this->getLayout()->getOutput() is what gets all blocks marked for output. It basically finds
elements in a layout, renders them, and returns the string with its output. Along the way, the event core_layout_render_elements gets fired,
giving us one possible way of affecting the output result. At this point, most of the elements on the page are rendered.

This is important because blocks play a big role here. The rendering system will take empty.xml into account, as it too consists of a list of
containers, and every container has some blocks attached to it by other layout updates.

In a nutshell, each container has blocks assigned to it. Each block usually (but not always) renders a template. The template itself
may or may not call call other blocks, and so on. Blocks are rendered when they are called from the template.

Blocks are another one of the primary view elements 

//CONTINUATION FROM 191 IN RELATIVITY TO DESKTOP

Javascript resources can be specified as follows:

Library level for all libraries in the Magento code base (lib/web).

Module level for all libraries in a module (app/code/{vendorName}/{moduleName}/view/{area}/web).

Theme for all libraries in a theme (app/design/{area}/{vendorName}/{theme}/{vendorName}_{moduleName}/web).

All libraries in a theme (app/design/{area}/{vendorName}/{theme}/web). Though possible,
 it is not recommended using this level to specify JS resources.

 It is recommended to specify JS resources in the templates rather than in the layout updates. This way,
  we ensure processing of the resource through RequireJS.

  To work with the RequireJS lib, specify the mapping of JS resources, that is, assign
  the aliases to resources, Use requires-config.js to create the mapping.

  To make our configurations more precise and specific for different modules/themes,
  we can identify mapping in the require-config.js file at several levels depending on our needs.
  Configurations are collected and executed in the following order:

  Library Configs

  Configs at Module level

  Configs at theme module level for the ancestor theme

  Config at the theme module level for a current theme

  Configs at the theme level for the ancestor themes

  Configs at the theme level for the current theme

  When we speak of JS in Magento, we can hear various terms like componen and widget.
  We can easily divide those terms by describing the type of JS in Magento as per following list:

  JS Component (JS Component): This can be any single JS file decorated as an AMD (short for Asynch Module Def) module

  Ui Component: A JS component located in the Magento_Ui module

  jQuery UI widget: a JS component/widget provided by the jQuery UI library used in Magento

  jQuery widget: A custom widget created using jQuery UI Widget Factory and decorated as an AMD module

  There are two ways we can initialize a JS component in template files:

  Using the data-mage-init attribute

  Using the <script> tag

  The data-mage-init attribute is parsed on a DOM ready event. Since it is initialized on a certain
  element, the script is called only for that particular element, and is not automatically
  initialized for other elements of the same type on the page.

  An example of data-mage-init usage would be something like the following:

  <div data-mage-init='{"<componentName>":{...}}'></div>

  The <script> tag initialization is done without relation to any specific element or in relation
  to a specific element but no direct access to the element. The script tags has to have an
  attribute, type="text/x-magento-init". An example of <script> tag initialization would be something
  like the following:

  <script type="text/x-magento-init">
  	//Specific element but no direct access to the element
  	"<element selector>": {
  		"<jsComponent1>": ...,
  		"<jsComponent2>": ...
  	},
  	//Without relation to any specific element
  	"*": {
  		"<jsComponent3">: ...
  	}
  </script>

  Depending on the situation and desired level of expressiveness, we can either opt for
  usage of data-mage-init or attribute or <script> tag

  To create a custom component in JS:

  Let's go through a practical example of creating a JS component within our Foggyline_Office module
  in a form of the jQuery widget as follows:

  First we add our entry to app/code/Foggyline/Office/view/frontend/require-js-config.js, as shown:

  var config = {
  	map: {
  		'*': {
  			foggylineHello: 'Foggyline_Office/js/foggyline-hello'
  		}
  	}
  };

  Then we add the actual JS app/code/Foggyline/Office/view/frontend/web/js/foggyline-hello.js with content as follows:

  define([
  	"jquery",
  	"jquery/ui"],
  	function($){
  		"use strict";

  		$.widget('mage.foggylineHello', {
  			options: {
  			},
  			_create: function () {	
  				alert(this.options);
  				//my code here
  			}
  		});

  		return $.mage.foggylineHello;
  	});

  Finally, we call our JS component within some PHTML template, let's say app/code/Foggyline/Office/view/frontend/templates/office/hello.phtml, as show:

  <div data-mage-init='{"foggylineHello": {"myVar1": "myValue1", "myVar2": "myValue2"}}'>Foggyline</div>

  Once we refresh the frontend, we should see the result of alert(this.options) in the browser showing
  myVar1 and myVar2.

  The data-mage-init part basically triggers as soon as the page loads. It is not triggered via some click
  or similar event on top of the div element; it is triggered on page load.

  If we don't see the desired result in the browser, we might need to fully clear the cache in the admin area.

  Magento uses a PHP port of the official LESS processor to parse .less files into .css files. LESS is a CSS
  preprocessor that extends the CSS language by adding various features to it, like variables, mixins and functions.

  All of this makes CSS more maintainable, extendable and easier to theme. Frontend devs are thus expected
  to write LESS files that Magento then converts to appropiate CSS variants.

  It is worth running find {MAGENTO-DIR}/-name\*.less > less-list.txt on the console to get a full
  list of each and every LESS file in Magento. Spending a few minutes glossing over the list 
  might serve as a nice future memo when working with style sheet bits in Magento.

  We can customize the storefront looks and feel through one of the following approaches:

  Override the default LESS files - only if our theme inherits from the default
  or any other theme, in which case we can override the actual LESS files

  Create our own LESS files using the built-in LESS preprocessor

  Create our own CSS files, optionally having compiled them using a third-party CSS preprocessor

  Within the individual frontend theme dir, we can find style sheets at the following locations:

  {vendorName}_{moduleName}/web/css/source/

  {vendorName}_{moduleName}/web/css/source/module/

  web/css/

  web/css/source/

  CSS files can be included in a page through templates and layout files. A recommended way is
  to include them through layout files. If we want our style sheets to be available
  through all pages on the frontend, we can add using the default_head_blocks.xml file.

  If we look at the blank theme, it uses vendor/magento/theme-frontend-blank/Magento_Theme/layout
  /default_head_blocks.xml defined as follows:

  <page xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:noNamespaceSchemaLocation="urn:magento:framework:View/Layout/etc/page_configuration.xsd">
  	<head>
  		<css src="css/styles-m.css"/>
  		<css src="css/styles-l.css"/
 media="screen and (min-width: 768px)"/>
 		<css src="css/print.css"
 media="print"/>
 	</head>
 </page>

 All it takes for us to copy this file in the same location under our custom theme; assuming it's
 the jupiter theme from the preceding examples, that would be app/design/frontend/Foggyline/jupiter/Magento_Theme/layout/default_head_blocks.xml 

 Then we simply modify the file to include our CSS

 When run, Magento will try to find the included CSS file. If a CSS file  is not found, it then searches
 for the same filenames with a .less extension. This is part of the built-in preprocessing mechanism.

 Throughout previous chapters, we learned how to use some of the backend components
 so that storeowners can manage and manipulate the data such as customers, products, categories,
 orders and so on. Sometimes this is not enough, like when we are pulling data in or out from third-party
 systems. In cases like these, the Magento Web API framework makes it easy to call Magento services through
 REST or SOAP.

 In this chapter, we will cover the following topics:

 User Types

 Authenticating methods

 REST versus SOAP

 Hands-on with token-based authentication

 Hands-on with OAuth-based authentication

 OAuth-based Web API calls

 Hands-on with session-based authentication

 creating custom Web APIs

 Search Criteria Interface for list filtering

 Before we can start making Web API calls, we must authenticate
 our identity and have the necessary permissions (authoriziation) to access the API resource.
 Authentication allows Magento to identify the caller's user type. Based on the 
 user's (administrator, integration, customer or guest) access rights, the API's calls' resource
 accessibility is determined.

 The list of resources that we can access depends on our user type and is defined within our module
 webapi.xml config file.

 There are three types of users known to API, listed as follows:

Administrator or integration: Resources for which administrators or integrators are authorized.
For example, if administrators are authorized for the Magento_Cms::page resource, they can make a
POST /V1/cmsPage call.

Customer: Resources for which customers are authorized. These are resources with anonymous or self permission.

Guest users: Resources for which guests are authorized. These are the resources with anonymous permission.

Two files play a crucial role toward defining an API: our module acl.xml and webapi.xml files.

acl.xml is where we define our module access control list (ACL). It defines an available set of permissions
to access the resources. The acl.xml files across all Magento modules are consolidated to build an
ACL tree that is used to select allowed admin resources or third-party integration's access (System | Extensions | Integrations | Add New Integration | Available APIs)

webapi.xml is where we define Web API resources and their permissions. When we create
webapi.xml, the permissions definen in acl.xml are referenced to create access rights for each
API resource.

Let's take a look at the following (truncated) webapi.xml from the core Magento_Cms module:

<routes xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Webapi:etc/webapi.xsd">
	...
	<route url="/V1/cmsPage" method="POST">
		<service class="Magento\Cms\Api\PageRepositoryInterface" method="save" />
		<resources>
			<resource ref="Magento_Cms::page"/>
		</resources>
	</route>
	...
	<route url="/V1/cmsBlock/search" method="GET">
		<service class="Magento\Cms\Api\BlockRepositoryInterface" method="getList" />
		<resources>
			<resource ref="Magento_Cms::block" />
		</resources>
	</route>
	...
</routes>

In the preceeding webapi.xml file for the CMS page API, only a user with Magento_Cms::page authorization
can access POST /V1/cmsPage or GET /V1/cmsBlock/search.

We will get back to a more detailed explonation of route later on in our examples; for the moment,
our focus is on resource. We can assign multiple child resource elements under resources. In cases like these,
it would be sufficient for a user to have any of those ACLs assigned to be able to make an API call.

The actual authorization is then granted to either an admin or integration, defined in the Magento admin,
with full group or a specific resource selected in the ACL tree as shown in the following SS:

//pic of role resources

Given that webapi.xml and acl.xml go hand in hand, let's take a look at the (truncated) acl.xml file from
the core Magento_Cms module:

<resources>
	<resource id="Magento_Backend::admin">
		<resource
id="Magento_Backend::content">
			<resource
id="Magento_Backend::content_elements">
				<resource
id="Magento_Cms::page" ...>
					....
				</resource>
			</resource>
		</resource>
	</resource>
</resource>

Notice how the position of the Magento_Cms::page resource is nested under Magento_Backend::content_elements,
which in turn is nested under Magento_Backend::content, which is further nested under Magento_Backend::admin

This tells Magento where to render the ACL under Magento admin when showing the Roles Resources tree as shown
in the previous screenshot. This does not mean that the user authorized against Magento_Cms::page resource
won't be able to access the API if all those parent Magento_Backend resources are granted to him as well.

Authorizing against a resource is sort of a flat thing. There is no tree check when authorizing. Thus,
each resource is required to have unique id attribute value on a resource element when defined 
under acl.xml

The resources just defined are what we listed before as resources for which admins or integrators are authorized.

The customer, on the other hand, is assigned a resource named anonymous or self. If we were to do a full
<resource ref="anonymous" /> string search across all Magento core modules, several occurences would show up.

Let's take a look at the (truncated) core module vendor/magento/module-catalog/etc/webapi.xml file:

<route url="/V1/products" method="GET">
	<service class="Magento\Catalog\Api\ProductRepositoryInterface" method="getList"/>
	<resources>
		<resource ref="anonymous"/>
	</resources>
</route>

The preceeding XML defines an API endpoint path with a value of /V1/products, available via the
HTTP GET method. It further defines a resource called anonymous, which means either the currently
logged-in customer or guest user can call this API endpoint.

This basically means that each resource has a "access level", that it defines, which defines who can access things via GET or POST.

anonymous is a special permission that does not need to be defined in acl.xml. As such, it will not show up
in the permissions tree under Magento admin. This simply means that the current resource in webapi.xml can be
accessed without the need for authentication.

Finally, we take a look at the self resource, whose example we can find under the (truncated) vendor/magento/module-customer/etc/webapi.xml as follows:

<route url="/V1/customers/me" method="PUT">
	<service class="Magento\Customer\Api\CustomerRepositoryInterface" method="save"/>
	<resources>
		<resources ref="self"/>
	</resources>
	<data>
		<parameter name="customer.id"
force="true">%customer_id%</parameter>
	</data>
</route>

self is a special kind of access that enables a user to access resources they own, assuming
we already have an authenticated session with the system. For example, GET /V1/customers/me fetches
the logged-in customer's details. This is something that is typically useful for JS-based components/widgets.

Mobile apps, third-party apps and JS components/widgets (storefront or admin) are the three
main types of clients as seen by Magento. Though a client is basically everything communicating with our
APIs, each type of client has a preffered authentication method.

Magento supports three types of authentication methods, listed as follows:

Token-based authentication

OAuth-based authentication

Session-based authentication

Token-based authentication is most suitable for mobile apps, where a token acts like an electronic key
providing access to the Web API's. The general concept behind a token-based auth system is relativily simple.

The user provides a username and password during initial authentication in order to obtain a time-limited token
from the system. If a token is succesfully obtained, all subsequent API calls are then made with that token.

OAuth-based authentication is most suitable for third-party apps that integrate with Magento. Once an
app is authorized through the OAuth 1.0a handshake process, it gains access to Magento Web APIs.
There are three key terminlogoies we must understand here: user(resource owner), client (consumer) and
server(service provider).

The user or resource owner is the one who is being asked to allow access to its protected resource. Imagine a
customer as a user (resource owner) allowing access to its orders to some third-party apps. In such a case,
this third-party app would be the client (consumer), whereas Magento and its Web API would be the server (Service provider).

Session-based authentication is probably the simplest one to grasp. As a customer, you log in to the
Magento storefront with your customer credentials. As an admin, you log in to the Magento admin with your
admin creds. 

The Magento Web API framework uses your logged-in session info to verify your identity and authorize access
to the requested resource.

Magneto supports both SOAP (short for Simple Object Access Protocol) and REST (short for Representational
State Transfer) types of communication with the Web API. Authentication methods themselves are not really 
bound to any of them. We can use the same authentication method and Web API method calls with both SOAP and REST.

Some of the REST specifics we might outline as follows:

We run REST Web API calls through cURL commands or a REST client.

Requests support HTTP verbs: GET, POST, PUT or DELETE.

A HTTP header requires an authorized parameter, specifying the authentication token with the Bearer HTTP authorization scheme, Authorization: Bearer <TOKEN>. <TOKEN> is then authentication token returned by the Magento token service.

We can use the HTTP header Accept: application/<FORMAT>, where <FORMAT> is either JSON or XML.

We run SOAP Web API calls through cURL commands or a SOAP client.

A Web Service Definition Language (WSDL) file is generated only for services that we request.
There is no one big merged WSDL file for all services.

The Magento Web API uses WSDL 1.2, compliant with WS-I 2.0 Basic Profile.

Each Magento service interface that is part of a service contract is represented as a separate service in the 
WSDL.

Consuming several services implies specifying them in the WSDL endpoint URL in a comma-separated manner,
for example:

http://<magento.host>/soap/<optional_store_code>?wsdl&services=<service_name_1>,<service_name_2>.

We can get a list of all available services by hitting a URL  like:

http://<SHOP-URL>/soap/default?wsdl_list in the browser.

The following REST and SOAP examples will make extensive use of cURL, which is essentialy
a program that allows you to make HTTP requests from the cmd line or different
language implementations (such as PHP). We can further describe cURL as the console browser,
or our view source tool for the web.

Anything we can do with various fancy REST and SOAP libs, we can do with cURL as well: it is just considered
to be a more low-level approach.

Doing SOAP requests with cURL or anything else that does not have WSDL/XML parsing implemented internally is cumbersome. Thus, using PHP SoapClient or something more robust is a must. SoapClient is an integrated,
actively maintained part of PHP, and is thus generally available.

With negative points being pointed, we will still present all of our API calls with console cURL, PHP cURL and
PHP SoapClient examples. Given that libs abstract so much functionality, it is absolutely essential
that a dev has a solid understanding of cURL, even for making SOAP calls.

The crux of token-based auth is as follows:

Client requests access with a username and PW

Application validates credentials

App provides a signed token to the client

The following code example demonstrates the console cURL REST-like request for the customer user:

curl -X POST "http://magento2.ce/rest/V1/integration/customer/token"\
	-H "Content-Type:application/json"\
	-d '{"username":"john@change.me", "password": "abc123"}'

The following code example demonstrates the PHP cURL REST-like request for the customer user:

$data = array('username' => 'john@change.me', 'password' => 'abc123');
$data_string = json_encode($data); //Just JSON encode the data object

$ch = curl_init('http://magento2.ce/rest/V1/integration/customer/token'); //initiate the curl on the token
	curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'POST'); //make a custom post request
	curl_setopt($ch, CURLOPT_POSTFIELDS, $data_string); //the post fields is the JSON 
	curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); //return the transfer result
	curl_setopt($ch, CURLOPT_HTTPHEADER, array('Content-Type: application/json', 'Content-Length: ' . strlen($data_string)) //the http header is an array assigning type and content length of the data_string
);

$result = curl_exec($ch); //Execute the curl object and store the result

The following code example demonstrates the console cURL SOAP-like request for the customer user:

curl -X POST -H 'Content-Type: 
application/soap+xml;
charset=utf-8; action="integrationCustomerTokenServiceV1CreateCustomerAccessToken"' //Make a post request with the 
//header defined as a soap/xml request with charset utf 8, make the action to be creating a custom token service
-d @request.xml http://magento2.ce/index.php/soap/default?services=integrationCustomerTokenServiceV1 //pass the xml ///data as POST body data

Notice the -d @request.xml part. Here, we are saying to the curl command to take the content of the request.xml
file and pass it on as POST body data where the content of the request.xml file for the preceeding curl command is
defined as follows:

<?xml version="1.0" encoding="UTF-8"?> //version 1.0 of xml with utf 8 coding
<env:Envelope xmlns:env="http://www.w3.org/2003/05/soap-envelope" //define the xmlns url to be a soap envelope
xmlns:nsl="http://magento2.ce/index.php/soap/default? //Dfine the nsl to be the relevant module we are using
services=integrationCustomerTokenServiceV1">
	<env:Body> //Define the body
<nsl:integrationCustomerTokenServiceV1CreateCustomer AccessTokenRequest> //Define the contents of the nsl
<username>john@change.me</username> //Username
			<password>abc123</password> //pw
</nsl:integrationCustomerTokenServiceV1CreateCustomer AccessTokenRequest> //end of NSL
	</env:Body> //End of body
</env:Envelope> //End of Envelope

The following code example demonstrates the PHP cURL SOAP-like request for the customer user:

$data_string = file_get_contents('request.xml'); //get the contents of the request.xml

$ch = curl_init('http://magento2.ce/index.php/soap/default?services=integrationCustomerTokenServiceV1'); /initialize //curl
	curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'POST'); //Set options, make a customrequest, a POST one
	curl_setopt($ch, CURLOPT_POSTFIELDS, $data_string); //make the postfield be the xml file
	curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); //return the transfer data
	curl_setopt($ch, CURLOPT_HTTPHEADER, array( //define the header of the HTTP request
	'Content-type: application/soap+xml; //the type is soap+xml
charset=utf-8; //charset utf-8
action="integrationCustomerTokenServiceV1 CreateCustomerAccessToken"', //Create a CustomerAccessToken
	'Content-Length: ' . strlen($data_string)) //define the length
);

$result = curl_exec($ch); //Save the results from executing the POSt request against the SOAP structure

The following code example demonstrates the usage of PHP SoapClient to make a Web API call:

$request = new SoapClient( //make a SoapClient request
	'http://magento2.ce/index.php
/soap/default?wsdl&services=
integrationCustomerTokenServiceV1', //Run the soap request against the tokenService
	array('soap_version' => SOAP_1_2, 'trace' => 1) //array of values
);

$token = 
$request->integrationCustomerTokenServiceV1Create CustomerAccessToken(array('username' => 
'john@change.me', 'password' => 'abc123')); //make a request against the integration of creating CustomerAccessToken

The API call for admin user authentication is nearly identical, and depends on which one of three approaches we take. The difference is merely in using https://magento2.ce/rest/V1/integration/admin/token as the endpoint URL in the case of REST, and using http://magento2.ce/index.php/soap/default?services=integrationCustomerTokenServiceV1.

Additionally, for a SOAP call, we are calling integrationAdminTokenServiceV1CreateAdminAccessToken on the
$request object.

In the case of successful authentication, for both the customer and admin API call, the response would be
a random-looking-32-characters-long string that we call token. This token is further saved to 
the oauth_token table in the DB, under the token column.

This might be a bit confusing with regard to what the oauth_token table has to do with token authentication.

If we think about it, token-based authentication can be looked at as a simplified version of OAuth, where the user
would authenticate using a username and PW and then give the obtained time-expiring token to some
third-party app to use it.

In case of failed auth, the server returns HTTP 401 Unauthorized, with a body containing a JSON message:

{"message":"Invalid login or password:"}

Notice how we are able to call the API method, though we are not already authenticated?
This means we must be calling an API defined by the anonymous type of resource. A quick look at 
the API endpoint gives us a hint to the location of its definition. Looking under the vendor/magento/module-integration/etc/webapi.xml file, we can see the following (truncated) XML:

<route url="/V1/integration/admin/token" method="POST">
	<service class="Magento\Integration\Api\AdminTokenServiceInterface" method="createAdminAccessToken"/>
	<resources>
		<resource ref="anonymous"/>
	</resources>
</route>

<route url="/V1/integration/customer/token" method="POST">
	<service class="Magento\Integration\Api\CustomerTokenServiceInterface" method="createCustomerAccessToken"/>
	<resources>
		<resource ref="anonymous"/>
	</resources>
</route>

We can clearly see how even token-based authentication itself is defined as API, using the 
anonymous resource so that everyone can access it. In a nutshell, token-based auth is a feature
of the Magento\Integration module.

Now that we have our auth token, we can start making other API calls. Remember, tokens simply
means we have been authenticated against a given username and PW. It does not mean we get full access
to all Web API methods. This further depends on wether our customer or user has the proper access role.

OAuth-based authentication is the most complex, yet most flexible one supported by Magento. Before we get
to use it, the merchant must register our external application as integration with the Magento instance.
Placing ourselves in the role of the merchant, we do so in the Magento admin area under
System | Extensions | Integrations. Clicking on the Add New Integration button opens the screen
as shown in the following SS:

The value External Book App is the freely given name of our external app. If we were connecting it with
Twitter, we could have easily put its name here. Next to Name, we have the Email, Callback URL, and Identity Link URL fields. The value of e-mail is not really that important.

The callback URL and identity link URL define the external app endpoint that recieves OAuth creds.
The values of these links point to external app that stands as the OAuth client. We will come back to it 
in a moment.

In the API tab under the Available APIs pane, we set Resource Access to the value of All or Custom.
If set to Custom, we can further fine-tune the resources in the Resources option we want to 
allow access to this integration as shown in the following SS:

//STUff

We should always give the minimal required resources to the external App we are using. This way,
we minimize possible security risks. The preceeding SS shows us defining only Sales, Products, Customer and
Marketing resources to the integration. This means that the API user would not be able to use content resources,
such as save or delete pages.

If we click the Save button now, we should be redirected back to the System | Extensions | Integrations screen as
shown in the following SS:

//Stuff

There are three things to focus our attention on here. First, we are seeing an Integration not secure
message. This is because when we defined our callback URL and identity link URL, we use HTTP and not HTTPS protocol. When doing real-world connections, for security reasons, we need to be sure to use HTTPS. Further, we notice how the Status column still says Inactive.

The Active link, to the right of the Status column, is the preceding steps before the two-legged OAuth handshake
starts. Only an Admin with access to integration listing in the backend can initiate this.

At this point, we need to pull the entire PHP code behind the External Book App OAuth client from here,
https://github.com/ajzele/B05032-BookAppOauthClient and place it into the root of our Magento installation
under the pub/external-book-app/ folder as shown in the SS:

//Stuff

The function of these files is to simulate our own mini-OAuth client. We will not go into much detail
about the content of these files. It is more important to look at it as an external OAuth client app.
The callback-url.php and identity-link-url.php files will execute when Magento triggers the callback and
identity link URL's as configed under the output image on the previous page.

Once the OAuth client file are in place, we go back to our integrations listing. Here, we click
on the Activate link. This opens a modal box, asking us to approve access to the API resources
as shown in the following SS:

//STUFF

Notice how API resources listed here match those few we set under the API tab when creating integration.
There are only two actions we can do here really: either click Cancel or Allow to start the two-legged OAuth handshake. Clicking the Allow button does two things in parallel.

First, it instantly posts the credentials to the endpoint (callback URL) specified when creating
the External Book App integration. The HTTP POST from Magento to the callback URL contains parameters
with values similar to the following:

Array(
	[oauth_consumer_key] => //stuff
	[oauth_consumer_secret] => //stuff
	[store_base_url] => http://magento2-merchant.loc/index.php/
	[oauth_verifier] => //stuff
)

Basically, a HTTP POST request is hitting the callback-url.php file whose content as follows:

session_id('BookAppOAuth');
session_start();

$_SESSION['oauth_consumer_key'] = $_POST['oauth_consumer_key'];
$_SESSION['oauth_consumer_secret'] = $_POST['oauth_consumer_secret'];
$_SESSION['store_base_url'] = $_POST['store_base_url'];
$_SESSION['oauth_verifier'] = $_POST['oauth_verifier'];

session_write_close();

header('HTTP/1.0 200 OK');

echo 'Response';

We can see that params passed by Magento are stored into an external
app session named BookAppOAuth. Later on, within the check-login.php file, these params will
be used to instansiate the BookAppOAuthClient, which will further be used to get a request token,
which is a pre-authorized token.

Parallel to Callback URL HTTP POST, we have a popup window opening as shown in the following SS:

//STUFF

The login form we see in the popup is just some dummy content we placed under the identity-link-url.php file.
Magento passes two values to this file via HTTP GET.
These are consumer_id and success_call_back. The consumer_id value is the ID of our integration
we created in the admin area.

It is up to the OAuth client app to decide if it wants to do anything with this value or not.
The success_call_back URL points to our Magento adminintegration/loginSuccessCallback path.

If we take a look at the code of the identity-link-url.php file, we can see form is set to do the POST action
on the URL like check-login.php?consumer_id={$consumerId}&callback_url={$callbackUrl}.

If we not click the Login button, the form will POST data to the check-login.php file passing it consumer_id and callback_url within the URL as GET parameters.

The content of check-login.php is defined as follows: //All of these are partial

require '../../vendor/autoload.php';

$consumer = $_REQUEST['consumer_id'];
$callback = $_REQUEST['callback_url'];

session_id('BookAppOAuth');
session_start();

$consumerKey = $_SESSION['oauth_consumer_key'];
$consumerSecret = $_SESSION['oauth_consumer_secret'];

$magentoBaseUrl = rtrim($_SESSION['store_base_url'], '/');
$oauthVerifier = $_SESSION['oauth_verifier'];

define('MAGENTO_BASE_URL', $magentoBaseUrl);

$credentials = new \OAuth\Common\Consumer\Credentials($consumerKey, $consumerSecret,
$magentoBaseUrl);

$oAuthClient = new BookAppOauthClient($credentials);

$requestToken = $oAuthClient->requestRequestToken();

$accessToken = $oAuthClient->requestAccessToken($requestToken->getRequestToken(), $oauthVerifier, 
$requestToken->getRequestTokenSecret()
);

header('Location: '. $callback);

To keep thing simple, we have no real user login check here. We might have added
one above the OAuth-related calls, and then authenticate the user against some username and
password before allowing it to use OAuth. However, for simplicitys sake, we omitted this part
from our sample OAuth client app.

Within the check-login.php file, we can see that based on the previously stored session params
we perform the following:

Instansiate the \OAuth\Common\Consumer\Credentials object passing it the oauth_consumer_key,
oauth_consumer_secret, store_base_url stored in the session

Instansiate the BookAppOauthClient object passing its constructor the entire credentials object

Use the OauthClient object to get the request token

Use the request token to get a long-lived access token

If everything executes successfully, the popup window closes and we get redirected back to the integrations
listing. The difference now is that looking at the grid, we have an Active status and next to it
we have a Reauthorize link.

What we are really after at this point are Access Token and Access Token Secret. We can see those
if we edit the External Book App integration. These values should now be present on the Integration 
Details tab.

Access Token is the key to all of our further API calls, and with it we successfully finish our
auth bits of OAuth-based authentication.

Once we have obtained OAuth access token, from the preceeding steps, we can start making
Web API calls to other methods. Even though the Web API coverage is the same for both
REST and SOAP, there is a significant difference when making method calls.

For the purpose of giving a more robust example, we will be targeting the customer group save method,
(partially) defined in the vendor/magento/module-customer/etc/webapi.xml as follows:

<route url="/V1/customerGroups" method="POST">
	<service class="Magento\Customer\Api\GroupRepositoryInterface" method="save"/>
	<resources>
		<resource ref="Magento_Customer::group"/>
	</resources>
</route>

To use the access token to make Web API calls, like POST /V1/customerGroups, we need to include
these request parameters in the authorization request header in the call:

oauth_consumer_key, available from the Magento admin area, under the integration edit screen.

oauth_nonce, random value, uniquely generated by the application for each request

oauth_signature_method, name of the signature method used to sign the request.
Valid values are: HMAC-SHA1-RSA-SHA1, and PLAINTEXT.

Even though the Outh protocol supports PLAINTEXT, Magento does not. We will be using HMAC-SHA1

oauth_timestamp, integer value. Unix-like timestmap.

oauth_token, available from the Magento admin area, under the integration edit screen.

oauth_version, Magento supports Oauth 1.0a, thus we use 1.0

oauth_signature, generated signature value, omitted from the signature generation process.

To generate an OAuth 1.0a HMAC-SHA1 signature or a HTTP request takes focused effort,
if done manually.

We need to determine the HTTP method and URL of the request, which equals to POST
http://magento2-merchant.loc/rest/V1/customerGroups. It is important to use
the correct protocol here, so make sure that the https:// or http:// portion of the URL
matches the actual request sent to the API.

We then gather all of the parameters included in the request. There are two such locations
for these additional params: the URL (as part of the query string) and the request body.

In the HTTP request, the params are URL encoded, but we need to collect the raw values.
In addition to the request parameters, every oauth_* param needs to be included
in the signature, except the oauth_signature itself.

The params are normalized into a single string as follows:

Params are sorted by name, using lexicographical byte value ordering. If two or more
params share the same name, they are sorted by their value. 

Params are concatenated in their sorted order into a single string.
For each param, the name is seperated from the corresponding value by an = character (ASCII code 61),
even if the value is empty. Each name-value pair is seperated by an & char (ASCII code 38).

Further, we define the signing key as a value of {Consumer Key}+{&}+{Access Token Secret}.

Once we apply the string normalization rules to params and determine the signing key,
we call hash_hmac('sha1', $data, {Signing Key}, true) to get the final oauth_signature value.

This should get us the oauth_signature as a random 28-chars long string.

Understanding how to generate the signature string is important, but getting it right every
time is tedious and time consuming. We can help ourselves by instansiating the objects
of the built-in \OAuth\Common\Consumer\Credentials and \OAuth\OAuth1\Signature\Signature classes,
as partially shown:

$credentials = new \OAuth\Common\Consumer\Credentials($consumerKey, $consumerSecret, $magentoBaseUrl);
$signature = new \OAuth\OAuth1\Signature\Signature($credentials);

$signature->setTokenSecret($accessTokenSecret);
$signature->setHashingAlgorithm('HMAC-SHA1');

echo $signature->getSignature($uri, array('oauth_consumer_key' => $consumerKey,
	'oauth_nonce' => 'per-request-unique-token',
	'oauth_signature_method' => 'HMAC-SHA1',
	'oauth_timestamp' => '1437319569',
	'oauth_token' => $accessToken,
	'oauth_version' => '1.0',
), 'POST');

Now that we have the oauth_signature value, we are ready to do our console curl REST example. It comes down
to running the following on a console:

curl -X POST http://magento2.ce/rest/V1/customerGroups -H 'Content-Type: application/json'
	-H 'Authorization: OAuth oauth_consumer_key="<stuff>",
	oauth_nonce="per-request-token-by-app-1",
	oauth_signature_method="HMAC-SHA1",
	oauth_timestamp="143719569",
	oauth_token="<stuff>",
	oauth_version="1.0",
	oauth_signature="<stuff>"'

	-d '{"group": {"code": "The Book Writer", "tax_class_id": "3"}}'

Note that the previous command is merely visually broken into new lines. It should all be
a single line on a console. Once executed, the API call will create a new customer group
called The Book Writer. A logical question one might ask looking at the curl
command is how come we did not normalize the POST data passed as JSON via the -d flag switch.

This is because the parameters in the HTTP POST request body are only taken into consideration
for signature generation if content-type is application/x-www-form-urlencoded.

The console cURL SOAP requests do not require usage of the OAuth signature. We can execute a 
SOAP request passing Authorization: Bearer { Access Token value } into the request header,
like shown in the following example:

curl -x POST http://magento2.ce/index.php/soap/default?services=customerGroupRepositoryV1 -H 'Content-Type:
application/soap+xml; charset=utf-8; action="customerGroupRepositoryV1Save"' -H 'Authorization: Bearer
<some value>' -d @request.xml

Where request.xml is as follows:

<?xml version="1.0" encoding="UTF-8"?>
<env:Envelope xmlns:env="http://www.w3.org/2003/05/soap_envelope"
xmlns:nsl="http://magento2.ce/index.php/soap/default?services=customerGroupRepositoryV1">
	<env:Body>
	<ns1:customerGroupRepositoryV1SaveRequest>
				<group>
					<code>The Book Writer</code>
					<taxClassId>3</taxClassId>
				</group>
	</ns1:customerGroupRepositoryV1SaveRequest>
	</env:Body>
</env:Envelope>

NOTE: MIght be someerror in terms of indention

The following code example demonstrates the PHP cURL SOAP-like request for the
customer group save method call:

$request = new SoapClient('http://magento2.ce/index.php/soap/?wsdl&services=customerGroupRepositoryV1',
	array(
		'soap_version' => SOAP_1_2,
		'stream_context' => =>
stream_context_create(array(
			'http' => array(
				'header' => 'Authorization: Bearer <something>')
			)
		)
	)
);

$response = $request->customerGroupRepositoryV1Save(array
(
	'group' => array(
		'code' => 'The Book Writer',
		'taxClassId' => 3
	)
));

Notice how the method name customerGroupRepositoryV1Save actually comprises
service name customerGroupRepositoryV1, plus the Save name of the actual method
within the Service.

We can get a list of all services defined by opening a URL like 
http://magento2.ce/soap/default?wsdl_list in the browser (Depending on Magento installation)

Session-based authentication is the third and most simple type of authentication in Magento.
We do not have any complexities of token-passing here. As the customer, we log in to the
Magento storefront with our customer credentials. As an admin, we log in to the 
Magento admin with our admin credentials. 

Magento uses a cookie named PHPSESSID to track the session where our login state is stored.
The Web API framework uses our logged-in session information to verify our identity
and authorize access to the requested resource.

Customers can access resources that are configured with anonymous or self-permission in the webapi.xml
config file, like GET /rest/V1/customers/me.

If we try to open the http://magento2.ce/rest/V1/customers/me URL while in the browser, but not logged
in as the customer, we would get a response as follows:

<response>
	<message>Consumer is not a authorized to access %resources</message>
	<parameters>
		<resources>self</resources>
	</parameters>
</response>

If we log in as a customer and then try to open that same URL, we would get a response as follows:

<response>
	<id>2</id>
	<group_id>1</group_id>
	<created_at>2015-11-22 14:15:33</created_at>
	<created_in>Default Store View</created_in>
	<email>john@change.me</email>
	<firstname>John</firstname>
	<lastname>Doe</lastname>
	<store_id>1</store_id>
	<website_id>1</website_id>
	<adresses/>
	<disable_auto_group_change>0</disable_auto_group_change>
</response>

Admin users can access resources that are assigned to their Magento admin profile.

Magento comes with a solid number of API methods that we can call. However, sometimes
this is not enough, as our business needs dictate additional logic, and we need to be able to
add our own methods to the Web API.

The best part of creating our own API's is that we do not have to be concerned about making them
REST or SOAP. Magento abstracts this so that our API methods are automatically available for 
REST or SOAP calls.

Adding new API's conceptually evolves around two things: defining business logic through various classes,
and exposing it via the webapi.xml file. However, as we will soon see, there is a lot of boilerplate to it.

Let's create a miniature module called Foggyline_Slider, on which we will demonstrate create (POST), update (PUT),
delete (DELETE) and list (GET) method calls.

Create a module registration file, app/code/Foggyline/Slider/registration.php, with content (partial)
as follows:

\Magento\Framework\Component\ComponentRegistrar::register(\Magento\Framework\Component\ComponentRegistrar::MODULE,
	'Foggyline_Slider',
	__DIR__
);

Create a module config file, app/code/Foggyline/Slider/etc/module.xml with content as follows:

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:Module /etc/module.xsd">
	<module name="Foggyline_Slider" setup_version="1.0.0"/>
</config>

Create an install script where our future models will persist module data. We do so by creating
the app/code/Foggyline/Slider/Setup/InstallSchema.php file with content as follows:

namespace Foggyline\Slider\Setup;

use Magento\Framework\Setup\InstallSchemaInterface;
use Magento\Framework\Setup\ModuleContextInterface;
use Magento\Framework\Setup\SchemaSetupInterface;

class InstallSchema implements InstallSchemaInterface
{
	public function install(SchemaSetupInterface $setup, ModuleContextInterface $context)
	{
		$installer = $setup;
		$installer->startSetup();

		/** Create table 'foggyline_slider_slide' */

		$table = $installer->getConnection()->newTable($installer->getTable('foggyline_slider_slide'))
			->addColumn(
				'slide_id',
				\Magento\Framework\DB\Ddl\Table::TYPE_INTEGER,
				null,
				['identity' => true,
'unsigned' => true, 'nullable' => false,
'primary' => true],
				'Slide Id'
			)
			->addColumn(
				'title',
				\Magento\Framework\DB\Ddl\Table::TYPE_TEXT,
				200,
				[],
				'Title'
		)
		->setComment('Foggyline Slider Slide');

$installer->getConnection()->createTable($table);
		...
		$installer->endSetup();


	}
}

Now we specify our ACL for our resources. Our resources are going to be CRUD
actions we do on our module entities. We will structure our module in a way that slide
and image are separate entities, where one slide can have mutliple image entities linked to it.

Thus, we would like to be able to control access to save and delete actions separately for each
entity. We do so by defining the app/code/Foggyline/Slider/etc/acl.xml file as follows:

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:noNamespaceSchemaLocation="urn:magento:framework:Acl/etc/acl.xsd">
	<acl>
		<resources>
			<resource id="Magento_Backend::admin">
				<resource id="Magento_Backend::content">
					<resource id="Magento_Backend::content_elements">
						<resource id="Foggyline_Slider::slider" title="Slider" sortOrder="10">
							<resource id="Foggyline_Slider::slide" title="Slider Slide" sortOrder="10">
								<resource id="Foggyline_Slider::slide_save" title="Save Slide" sortOrder="10" />
								<resource id="Foggyline_Slider"::slide_delete" title="Delete Slide" sortOrder="20" />
							</resource>
							<resource id="Foggyline_Slider::image" title="Slider Image" sortOrder="10">
								<resource id="Foggyline_Slider::image_save" title="Save Image" sortOrder="10" />
								<resource id="Foggyline_Slider::image_delete" title="Delete Image" sortOrder="20" />
							</resource>
						</resource>
					</resource>
				</resource>
			</resource>
		</resource>
	</acl>
</config>

As we can see, the XML is driven in a hierarchy matter akin to HTML with accessing of classes and functions, to which
they have sort orders and they have titles, ids, identifiers etc.

Generally, all xmlns is defined to be what kind of a instance of something iti s (XMLSchema etc.)
and it then also checks for the location in the xsi, to which it refers to either being a no namespace schema location, or it refers to a namespace one by virtue of dir pathing

Now that the ACL has been set, we define our Web API resources within the app/code/Foggyline/Slider/etc/webapi.xml (partial) as follows:

<routes xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:noNamespaceSchemaLocation=
"urn:magento:module:Magento_Webapi:etc/webapi.xsd">
	<route url="/V1/foggylineSliderSlide/:slideId" method="GET">
		<service class="Foggyline\Slider\Api\
			<resources>
				<resource
		ref="Foggyline_Slider::slide" />
			</resources>
		</route>
		//NOTE: Error due to unclosed service enclosure???
		<route url="/V1/foggylineSliderSlide/search" method="GET">
			<service class="Foggyline\Slider\Api\SlideRepositoryInterface" method="getList" />
			<resources>
				<resource ref="anonymous" />
			</resources>
		</route>
		<route url="/V1/foggylineSliderSlide" method="POST">
			<service class="Foggyline\Slider\Api\SlideRepositoryInterface" method="save" />
			<resources>
				<resource
		ref="Foggyline_Slider::slide_save" />
			</resources>
		</route>
		<route url="/V1/foggylineSliderSlide/:id" method="PUT">
			<service class="Foggyline\Slider\Api\SlideRepositoryInterface" method="save" />
			<resources>
				<resource
		ref="Foggyline_Slider::slide_save" />
			</resources>
		</route>
		<route url="/V1/foggylineSliderSlide/:slideId" method="DELETE">
			<service class="Foggyline\Slider\Api\SlideRepositoryInterface" method="deleteById"/>
			<resources>
				<resource ref="Foggyline_Slider::slide_delete" />
			</resources>
		</route>
		<route url="/V1/foggylineSliderImage/:imageId" method="GET">
			<service class="Foggyline\Slider\Api\ImageRepositoryInterface" method="getById" />
			<resources>
				<resource />
			</resources>
		</route>
		<route url="/V1/foggylineSliderImage/search" method="GET">
			<service class="Foggyline\Slider\Api\ImageRepositoryInterface" method="getList" />
			<resources>
				<resource
		ref="Foggyline_Slider::image" />
			</resources>
		</route>
		<route url="/V1/foggylineSliderImage" method="POST">
			<service class="Foggyline\Slider\Api\ImageRepositoryInterface" method="save" />
			<resources>
				<resource
		ref="Foggyline_Slider::image_save" />
			</resources>
		</route>
		<route url="/V1/foggylineSliderImage/:id" method="PUT">
			<service class="Foggyline\Slider\Api\ImageRepositoryInterface" method="save" />
				<resources>
					<resource
		ref="Foggyline_Slider::image_save" />
				</resources>
			</route>
			<route url="/V1/foggylineSliderImage/:imageId" method="DELETE">
				<service class="Foggyline\Slider\Api\ImageRepositoryInterface" method="deleteById" />
				<resources>
					<resource
		ref="Foggyline_Slider::image_delete" />
				</resources>
			</route>
		</routes>

//NOTE: THe above structure is a bit wonky due to inconsistency on level of the book, but generally the 
structure is the same.

Notice how each of those service class attributes point to the interface, not the class.
This is the way we should build our exposable services, always having an interface definition
behind them. As we will soon see, using di.xml, this does not mean Magento will try
to create object from these interfaces directly.

In the /etc/di.xml, partially:

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:noNamespaceSchemaLocation="urn:magento:framework:ObjectManager/etc/config.xsd">

	<preference for="Foggyline\Slider\Api\Data\SlideInterface"
	type="Foggyline\Slider\Model\Slide"/>

	<preference for="Foggyline\Slider\Api\SlideRepositoryInterface" type="Foggyline\Slider\Model\SlideRepository"/>
	...
</config>

What is happening here is that we are telling Magento something like, "hey, whenever you need to
pass around an instance that conforms to the Foggyline\Slider\Api\Data\SlideInterface interface,
preferably use the Foggyline\Slider\Model\Slide class for it."

At this point, we still do not have any of those interfaces or model classes created. 
When creating APIs, we should first start by defining interfaces, and then our models
should extend from those interfaces.

Interface Foggyline\Slider\Api\Data\SliderInterface is defined within the app/code/Foggyline/Slider/Api/Data/SliderInterface.php as follows:

namespace Foggyline\Slider\Api\Data;

/**
* @api
*/

interface SlideInterface
{
	const PROPERTY_ID = 'slide_id';
	const PROPERTY_SLIDE_ID = 'slide_id';
	const PROPERTY_TITLE = 'title';

	/**
	* Get Slide entity 'slide_id' property value
	* @return int|null
	*/

	public function getId();

	/**
	* Set Slide entity 'slide_id' property value
	* @param int $id
	* @return $this
	*/
	public function setId($id);

	/**
	* Get Slide entity 'slide_id' property value
	* @return int|null
	*/
	public function getSlideId();

	/**
	* Set Slide entity 'slide_id' property value
	* @param int $slideId
	* @return $this
	*/
	public function setSlideId($slideId);

	/**
	* Get Slide entity 'title' property value
	* @return string|null
	*/
	public function getTitle();
	
	/**
	* Set Slide entity 'title' property value
	* @param string $title
	* @return $this
	*/

	public function setTitle($title);
}

We are going for ultimate simplification here. Our Slide entity only really has
ID and title values. The id and slide_id point to the same field in the DB and the
implementation of their getters and setters should yield the same result.

Although API/Data/*.php interfaces become blueprint requirements
for our data models, we also have Api/*RepositoryInterface.php files. The idea here is to
extract create, update, delete and search and similar data-handling logic away
from the data model class into its own class.

This way, our model classes become more pure data and business logic classes while the rest
of persistence and search-related logic moves into these repo classes.

Our Slide Repository Interface is defined within the 
app/code/Foggyline/Slider/Api/SliderRepositoryInterface.php file as follows:

namespace Foggyline\Slider\Api;

/**
* @api
*/

interface SlideRepositoryInterface
{
	/**
	* Retrieve slide entry.
	* @param int $slideId
	* @return  \Foggyline\Slider\Api\Data\SlideInterface
	* @throws \Magento\Framework\Exception\NoSuchEntityException If slide with the 
	specified id does not exist. 
	* @throws \Magento\Framework\Exception\LocalizedException

		*/
		public function getById($slideId);

		/**
		* Save slide
		* @param \Foggyline\Slide\Api\Data\SlideInterface $slide
		* @return \Foggyline\Slider\Api\Data\SlideInterface
		* @throws \Magento\Framework\Exception\LocalizedException
		*/

		public function save(\Foggyline\Slider\Api\Data\SlideInterface $slide);

		/**
		* Retrieve slides matching the specified criteria.
		* @param \Magento\Framework\Api\SearchCriteriaInterface $searchCriteria
		* @return \Magento\Framework\Api\SearchResultsInterface
		* @throws \Magento\Framework\Exception\LocalizedException
		*/

		public function getList(\Magento\Framework\Api\SearchCriteriaInterface $searchCriteria);

		/**
		* Delete slide by ID.
		* @param int $slideId
		* @return bool true on success
		* @throws \Magento\Framework\Exception\LocalizedException
		*/

		public function deleteById($slideId);
}

With interfaces in place, we can move on to model class. In order to persist and fetch
data in a DB, our Slide entity really needs three files under the Model dir.
These are called data model, resource class and collection class.

The data model class is defined under the app/code/Foggyline/Slider/Model/Slide.php as follows:

namespace Foggyline\Slider\Model;

class Slide extends \Magento\Framework\Model\AbstractModel implements \Foggyline\Slider\Api\Data\SlideInterface{
	/** 
	* Initialize Foggyline Slide Model
	*
	* @return void
	*/
	protected function _construct()
	{
		/* _init($resourceModel) */
		$this->_init('Foggyline\Slider\Model\ResourceModel\Slide');
	}

	/**
	* Get Slide entity 'slide_id' property value
	*
	* @api
	* @return int|null
	*/

	public function getId()	
	{
		return $this->getData(self::PROPERTY_ID);
	}

	/**
	* Set Slide entity 'slide_id' property value
	*
	* @api
	* @param int $id
	* @return $this
	*/
	public function setId($id)
	{
		$this->setData(self::PROPERTY_ID, $id);
		return $this;
	}

	/**
	* Get Slide entity 'slide_id' properety value
	*
	* @api
	* @return int|null
	*/
	public function getSlideId()
	{
		return $this->getData(self::PROPERTY_SLIDE_ID);
	}

	/**
	* Set Slide entity 'slide_id' property value
	*
	* @api
	* @param int $slideId
	* @return $this
	*/

	public function setSlideId($slideId)
	{
		$this->setData(self::PROPERTY_SLIDE_ID, $slideId);
		return $this;
	}

	/**
	* Get Slide entity 'title' property value 
	*
	* @api
	* @return string|null
	*/

	public function getTitle(){
		return
$this->getData(self::PROPERTY_TITLE);
	}

	/**
	* Set Slide entity 'title' property value
	*
	* @api
	* @param string $title
	* @return $this
	*/

	public function setTittle($title)
	{
		$this->setData(self::PROPERTY_TITLE,
		$title);
	}
}

Following the model data class is the model resource class, defined in the app/code/Foggyline/Slider/Model/ResourceModel/Slide.php file:

namespace Foggyline\Slider\Model\ResourceModel;

/**
* Foggyline Slide resource
*/

class Slide extends \Magento\Framework\Model\ResourceModel\Db\AbstractDb
{
	/**
	* Define main table
	*
	* @return void
	*/
	protected function _construct()
	{
		/* _init($mainTable, $idFieldName) */

	$this->_init('foggyline_slider_slide', 'slide_id');
	}
}

Finally, the third bit, is the model collection class, defined in the 
app/code/Foggyline/Slider/Model/ResourceModel/Slide/Collection.php file as follows:

namespace Foggyline\Slider\Model\ResourceModel\Slide;

/**
* Foggyline slides collection
*/
class Collection extends \Magento\Framework\Model\ResourceModel\Db\Collection\AbstractCollection
{
	/**
	* Define resource model and model 
	*
	* @return void
	*/
	protected function _construct()
	{
		/* _init($model, $resourceModel) */
		$this->_init('Foggyline\Slider\Model\Slide', 'Foggyline\Slider\Model\ResourceModel\Slide');
	}
}

If we were to manually instansiate the model data class now,
we would be able to persist the data in the DB. To complete the
di.xml requirements, we still lack one more final ingridient - the Model/SlideRepository class file.

Let us go and create the app/code/Foggyline/Slider/Model/SlideRepository.php file with
content as follows:

namespace Foggyline\Slider\Model;

use Magento\Framework\Api\DataObjectHelper;
use Magento\Framework\Api\SearchCriteriaInterface;
use Magento\Framework\Exception\CouldNotDeleteException;
use Magento\Framework\Exception\CouldNotSaveException;
use Magento\Framework\Exception\NoSuchEntityException;
use Magento\Framework\Reflection\DataObjectProcessor;

class SlideRepository implements \Foggyline\Slider\Api\SlideRepositoryInterface
{
	/**
	* @var \Foggyline\Slider\Model\ResourceModel\Slide
	*/

	protected $resource;

	/**
	* @var \Foggyline\Slider\Model\SlideFactory
	*/

	protected $slideFactory;

	/**
	* @var \Foggyline\Slider\Model\ResourceModel\Slide\CollectionFactory
	*/
	protected $slideCollectionFactory;

	/**
	* @var \Magento\Framework\Api\SearchResultsInterface
	*/

	protected $searchResultsFactory;

	/**
	* @var \Magento\Framework\Api\DataObjectHelper
	*/
	protected $dataObjectHelper;

	/**
	* @var \Magento\Framework\Reflection\DataObjectProcessor
	*/

	protected $dataObjectProcessor;

	/**
	* @var \Foggyline\Slider\Api\Data\SlideInterfaceFactory
	*/

	protected $dataSlideFactory;

	/**
	* @param ResourceModel\Slide $resource
	* @param SlideFactory $slideFactory
	* @param ResourceModel\Slide\CollectionFactory $slideCollectionFactory
	* @param \Magento\Framework\Api\SearchResultsInterface $searchResultsFactory
	* @param DataObjectHelper $dataObjectHelper
	* @param DataObjectProcessor $dataObjectProcessor
	* @param \Foggyline\Slider\Api\Data\SlideInterfaceFactory $dataSlideFactory

	public function __construct(
		\Foggyline\Slider\Model\ResourceModel\Slide $resource,
		\Foggyline\Slider\Model\SlideFactory $slideFactory,
		\Foggyline\Slider\Model\ResourceModel\Slide\CollectionFactory $slideCollectionFactory,
		\Magento\Framework\Api\SearchResultsInterface $searchResultsFactory,
		\Magento\Framework\Api\DataObjectHelper $dataObjectHelper,
		\Magento\Framework\Reflection\DataObjectProcessor $dataObjectProcessor,
		\Foggyline\Slider\Api\Data\SlideInterfaceFactory $dataSlideFactory
	)
	{
		$this->resource = $resource;
		$this->slideFactory = $slideFactory;
		$this->slideCollectionFactory = $slideCollectionFactory;
		$this->searchResultsFactory = $searchResultsFactory;
		$this->dataObjectHelper = $dataObjectHelper;
		$this->dataObjectProcessor = $dataObjectProcessor;
		$this->dataSlideFactory = $dataSlideFactory;
	}
	...
}

It might appear that there is a lot going on here, but really,
we are just passing on some class and interface names to the constructor
in order to instansiate the objects we will use across individual service
methods defined in the webapi.xml file.

The first service method on our list is getById, defined within SlideRepository.php as follows:

/**
* Retrieve slide entity
*
* @api
* @param int $slideId
* @return \Foggyline\Slider\Api\Data\SlideInterface
* @throws \Magento\Framework\Exception\LocalizedException
*/
public function getById($slideId)
{
	$slide = $this->slideFactory->create();
	$this->resource->load($slide, $slideId);
	if (!$slide->getId()) {
		throw new NoSuchEntityException(__('Slide with id %1 does not exist.', $slideId))<
	}
	return $slide;
}

Then we have the save method, defined within SlideRepository.php as follows:

/**
* Save slide.
*
* @param \Foggyline\Slider\Api\Data\SlideInterface $slide
* @return \Foggyline\Slider\Api\Data\SlideInterface
* @throws \Magento\Framework\Exception\LocalizedException
*/
public function save(\Foggyline\Slider\Api\Data\SlideInterface $slide)
{
	try {
		$this->resource->save($slide);
	} catch (\Exception $exception) {
		throw new CouldNotSaveException(__($exception->getMessage()));
	}
	return $slide;
}

The save method addresses both POST and PUT requests 
defined in webapi.xml, thus effectively handling the creation
of new slides or update of existing ones.

Going further, we have the getList method, defined within SlideRepository.php as follows:

/**
* Retrieve slides matching the specified criteria.
*
* @param \Magento\Framework\Api\SearchCriteriaInterface $searchCriteria
* @return \Magento\Framework\Api\SearchResultsInterface
* @throws \Magento\Framework\Exception\LocalizedException
*/
public function getList(\Magento\Framework\Api\SearchCriteriaInterface $searchCriteria)
{
	$this->searchResultsFactory->setSearchCriteria($searchCriteria);

	$collection = $this->slideCollectionFactory->create();

	foreach
	($searchCriteria->getFilterGroups() as $filterGroup){
		foreach($filterGroup->getFilters() as $filter) {
			$condition = $filter->getConditionType() ?: 'eq';

			$collection->addFieldToFilter($filter->getField(), [$condition => $filter->getValue()]);
		}
	}

	$this->searchResultsFactory->setTotalCount($collection->getSize());
	$sortOrders = $searchCriteria->getSortOrders();
	if($sortOrders) {
		foreach($sortOrders as $sortOrder) {
			$collection->addOrder($sortOrder->getField(),
(strtoupper($sortOrder->getDirection()) === 'ASC') ? 'ASC' : 'DESC'
		);
		}
	}

$collection->setCurPage($searchCriteria->getCurrentPage());

$collection->setPageSize($searchCriteria->getPageSize());
	$slides = [];
	/** @var \Foggyline\Slider\Model\Slide $slideModel */
	foreach ($collection as $slideModel){
		$slideData = $this->dataSlideFactory->create();
		$this->dataObjectHelper->populateWithArray(
			$slideData,
			$slideModel->getData(),
			'\Foggyline\Slider\Api\Data\SlideInterface');
		$slides[] = $this->dataObjectProcessor->buildOutputDataArray(
			$slideData,
			'\Foggyline\Slider\Api\Data\SlideInterface'
			);
	}

	$this->searchResultsFactory->setItems($slide);
	return $this->searchResultsFactory;
}

Finally, we have the deleteById method, defined within SlideRepository.php as follows:

/**
* Delete Slide
*
* @param \Foggyline\Slider\Api\Data\SlideInteface $slide
* @return bool
* @throws CouldNotDeleteException
*/
public function delete(\Foggyline\Slider\Api\Data\SlideInterface $slide)
{
	try {
		$this->resource->delete($slide);
	} catch (\Exception $exception) {
		throw new CouldNotDeleteException(__($exception->getMessage()));
	}
	return true;
}

/**
* Delete slide by an ID.
*
* @param int $slideId
* @return bool true on success
* @throws \Magento\Framework\Exception\NoSuchEntityException
* @throws \Magento\Framework\Exception\LocalizedException
*/
public function deleteById($slideId)
{
	return $this->delete($this->getById($slideId));
}

Keep in mind that we have only covered the Slide entity
in the preceeding partial example,w hich is enough to preceed with other API call examples.

Since all of our defined API's are resource protected, we first need to
authenticate as the admin user, assuming the admin user has access to all our custom
resources that encompass the ones we defined. For simplicity sake, we will use the token-based
auth method, examples of which are given previously in the chapter. Once authenticated,
we should have a 32 random chars long token.

Once the token has been obtained, we will test the following API calls using console
cURL, PHP cURL, PHP SoapClient, and console SOAP style cURL examples.

GET /V1/foggylineSliderSlide/:slideId, calls the getById service method, requires
the Foggyline_Slider::slide resource

GET /V1/foggylineSliderSlide/search, calls the getList service method, requires the
Foggyline_Slider::slide resource

POST /V1/foggylineSliderSlide, calls the save service method, requires the Foggyline_Slider::slide_save resource

PUT /V1/foggylineSliderSlide/:id, calls the save service method, requires the Foggyline_Slider::slive_save resource

DELETE /V1/foggylineSliderSlide/:slideId, calls the deleteById service method, requires the
Foggyline_Slider::slide_delete resource

The console cURL style for executing GET /V1/foggylineSliderSlide/:slideId is done as follows:

curl -X GET -H 'Content-type: application/json' \ -H 'Authorization: Bearer <token>' \
http://magento2.ce/rest/V1/foggylineSliderSlide/1

The PHP cURL style for executing GET /V1/foggylineSliderSlide/:slideId is done as follows:

$ch = curl_init('http://magento2.ce/rest/V1/foggylineSliderSlide/1');
curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'GET');
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
curl_setopt($ch, CURLOPT_HTTPHEADER, array('Content-Type: application/json',
	'Authorization: Bearer <token>'));

$result = curl_exec($ch);

The response for console and PHP cURL style should be a JSON string similar
to the following one:

{"slide_id":1, "title":"Awesome stuff #1"}

The PHP SoapClient style for executing GET /V1/foggylineSliderSlide/:slideId is done as follows:

$request = new SoapClient('http://magento2.ce/index.php/soap/?wsdl&services=foggylineSliderSlideRepositoryV1',
	array('soap_version' => SOAP_1_2, 'stream_context' => stream_context_create(array('http' => array(
		'header' => 'Authorization: Bearer <token>'))
		)
	)
);

$response = $request->foggylineSliderSlideRepositoryV1GetById(array('slideId'=>1));

The response for PHP SoapClient style should be the stdClass PHP obj as follows:

object(stdClass) #2 (1) {
	["result"] => object(stdClass) #3 (2) {
		["slideId"] => int(1)
		["title"] => string(16) "Awesome stuff #1"
	}
}

The console SOAP style cUrl for executing GET /V1/foggylineSliderSlide/:slideId is done as follows:

curl -X POST -H 'Content-Type: application/soap+xml;
	charset=urf-8;
	action="foggylineSliderSlideRepositoryV1GetById"'
	-H 'Authorization: Bearer <token>' -d @request.xml\ http://magento2.ce/index.php
	/soap/default?services=foggylineSliderSlideRepositoryV1

Where request.xml is as follows:

<?xml version="1.0" encoding="UTF-8"?>
<env:Envelope xmlns:env="http://www.w3.org/2003/05/soap-envelope"
xmlns:ns1="http://magento2.ce/index.php/soap/default?services=\
foggylineSliderSlideRepositoryV1">
	<env:Body>

<ns1:foggylineSliderSlideRepositoryV1GetByIdRequest>
		//Since the ns1 is based on normal indention
		//we are practically 2 steps into indention
			<slideId>1</slideId>
		</ns1:foggylineSliderSlideRepositoryV1GetByIdRequest>
	</env:Body>
</env:Envelope>

Notice how we did not really do a GET, rather a POST type of request.
Also, the URL to which we are pointing our POST is not really the same as
with previous requests. This is because Magento SOAP requests are always
POST (or PUT) type, as the data is submitted in a XML format. 

XML format in return specifies the service, and the request header action
specifies the method to be called on the service.

The response for console SOAP style cURL should be an XML as follows:

<?xml version="1.0" encoding="UTF-8"?>
<env:Envelope xmlns:env="http://www.w3.org/2003/05/soap-envelope"
xmlns:ns1="http://magento2.ce/index.php/soap/default?
services=foggylineSliderSlideRepositoryV1">
	<env:Body>
		<ns1:foggylineSliderSlideRepositoryV1GetByIdResponse>
			<result>
				<slideId>1</slideId>
				<title>Awesome stuff #1</title>
			</result>
		</ns1:foggylineSliderSlideRepositoryV1GetByIdResponse>
	</env:body>
</env:Envelope>

The console cURL style for executing GET/V1/foggylineSliderSlide/search is done as follows:

curl -X GET -H 'Content-type: application/json' \
-H 'Authorization: Bearer <token>' \
"http://magento2.ce/rest/V1/foggylineSliderSlide/search?search_criteria%5Bfilter_groups
//In reality, a lot of repetition of the % comparators follows here, but they are so many
//that i will not write them here, as it is just repetition ad infinitum"

The PHP cURL style for executing GET/V1/foggylineSliderSlide/search is done as follows:

$searchCriteriaJSON = '{
	"search_criteria": {
		"filter_groups": [
			{
				"filters": [
					{
						"field": "title",
						"value": "%some%",
						"condition_type": "like"
					}
				]
			}
		],
		"current_page": 1,
		"page_size": 10,
		"sort_orders": [
			{
				"field": "slide_id",
				"direction": "ASC"
			}
		]
	}
}';

$searchCriteriaQueryString = 
http_build_query(json_decode($searchCriteriaJSON));

$ch = curl_init('http://magento2.ce/rest/V1/foggylineSliderSlide/search?' .
$searchCriteriaQueryString);

curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'GET');
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
curl_setopt($ch, CURLOPT_HTTPHEADER, array(
	'Content-Type: application/json',
	'Authorization: Bearer <token>'
));

$result = curl_exec($ch);

The response for console and PHP cURL style should be a JSON string
similar to the following one:

{"items":[{"slide_id":2,"title":"Just some other slider"}, {"slide_id":1, "title": "Awesome
Stuff #1"}], "search_criteria": {"filter_groups": [{"filters": [{"field":"title", "value":"%some%",
"condition_type":"like"}]}], "sort_orders": [{"field":"slide_id", "direction":"-1"}],
"page_size":10,"current_page":1}, "total_count:2"}

The PHP SoapClient style for executing GET /V1/foggylineSlidersSlide/search is done as follows:

$searchCriteria = [
	'searchCriteria' =>
		[
			'filterGroups' =>
				[
					[
						'filters' =>
							[
								[
									'field' => 'title',
									'value' => '%some%',
									'condition_type' => 'like',
								],
							],
					],
				],
			'currentPage' => 1,
			'pageSize' => 10,
			'sort_orders' => 
				[
					[
						'field' => 'slide_id',
						'direction' => 'ASC',
					],
				],
		],
];

$request = new SoapClient('http://magento2.ce/index.php/soap/?wsdl&services=
foggylineSliderSlideRepositoryV1',
	array(
		'soap_version' => SOAP_1_2,
		'trace'=>1,
		'stream_context' => stream_context_create(array('http' => array( 'header' => 'Authorization: Bearer <token>')
			)
		)
	)	
);

$response => $request->foggylineSliderSlideRepositoryV1GetList($searchCriteria);

The response for PHP SoapClient style should be the stdClass PHP object as follows:

object(stdClass)#2 (1) {
	["result"]=>object(stdClass)#3 (3) {
		["items"]=>
		object(stdClass)#4 (0) {
		}
		["searchCriteria"]=>object(stdClass)#5 (3) {
			["filterGroups"]=>object(stdClass)#6 (1) {
				["item"]=>object(stdClass)#7 (1) {
					["filters"]=>object(stdClass)#8 (1) {
						object(stdClass)#9 (2) {
							["field"]=>string(5) "title"
							["value"]=>string(6) "%some%"
						}
					}
				}
			}
			["pageSize"]=>int(10)
			["currentPage"]=>int(1)
		}
		["totalCount"]=>int(0)
	}
}

The console SOAP style cURL for executing GET /V1/foggylineSliderSlide/search is done as follows:

curl -X POST \
-H 'Content-Type: application/soap+xml; charset=utf-8; action="foggylineSliderSlideRepositoryV1GetList"' \
-h 'Authorization: Bearer <token>' \ 
-d @request.xml \
http://magento2.ce/index.php/soap/default?services=foggylineSliderSlideRepositoryV1

Where request.xml has content as follows:

<?xml version="1.0" encoding="UTF-8"?>
<env:Envelope xmlns:env="http://www.w3.org/2003/05/soap-envelope" xmlns:ns1="http://magento2.ce/index.php/soap
/default?services=foggylineSliderSlideRepositoryV1">
	<env:Body>
		<ns1:foggylineSliderSlideRepositoryV1GetListRequest>
			<searchCriteria>
				<filterGroups>
					<item>
						<filters>
							<item>
								<field>title</field>
								<value>%some%</value>
							</item>
						</filters>
					</item>
				</filterGroups>
				<pageSize>10</pageSize>
				<currentPage>1</currentPage>
			</searchCriteria>
		</ns1:foggylineSliderSlideRepositoryV1GetListRequest>
	</env:Body>
</env:Envelope>

Notice we did not really do GET, rather POST. Also, the URL
to which we are pointing our POST is not really the same as the previous requests.
This is because Magento SOAP requests are always POST type, as the data is submitted
XML format. XML format in return specifies the service and the request header action specifies
the method to be called on the service.

The response for console SOAP style cURL should be an XML as follows:

<?xml version="1.0" encoding="UTF-8"?>
<env:Envelope xmlns:env="http://www.w3.org/2003/05/soap-envelope"
xmlns:ns1="http://magento2.ce/index.php/soap/default?services=foggylineSliderSlideRepositoryV1">
	<env:Body>
		<ns1:foggylineSliderSlideRepositoryV1GetListResponse>
			<result>
				<items/>
					<searchCriteria>
						<filterGroups>
							<item>
								<filters>
									<item>
										<field>title</field>
										<value>%some%</value>
									</item>
								</filters>
							</item>
						</filterGroups>
						<pageSize>10</pageSize>
					<currentPage>1</currentPage>
					</searchCriteria>
				<totalCount>0</totalCount>
			</result>
		</ns1:foggylineSliderSlideRepositoryV1GetListResponse>
	</env:Body>
</env:Envelope>

The save (as new) service method call example:

The console cURL for executing POST /V1/foggylineSliderSlide is done as follows:

curl -X POST -H 'Content-type: application/json' \
-H 'Authorization: Bearer <token>' \
-d '{"slide": {"title": "API test"}}' \
http://magento2.ce/rest/V1/foggylineSliderSlide/

The PHP cURL style for executing POST /V1/foggylineSliderSlide is done as follows:

$slide = json_encode(['slide' => ['title' => 'API test']]);

$ch = curl_init('http://magento2.ce/rest/V1/foggylineSliderSlide');
curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'POST');
curl_setopt($ch, CURLOPT_POSTFIELDS, $slide);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
curl_setopt($ch, CURLOPT_HTTPHEADER, array(
	'Content-Type: application/json',
	'Content-Length: ' . strlen($slide),
	'Authorization: Bearer <token>'
));

$result = curl_exec($ch);

The response for console and PHP cURL style should be a JSON string similar
to the following one:

{"slide_id": 4, "title":"API test"}

The PHP SoapClient style for executing POST /V1/foggylineSliderSlide is done as follows:

$slide = ['slide'=>['title'=> 'API test']];

$request = new SoapClient('http://magento2.ce/index.php/soap?wsdl&services=foggylineSliderSlideRepositoryV1',
	array(
		'soap_version' => SOAP_1_2,
		'trace'=>1,
		'stream_context' => stream_context_create(array(
			'http' => array(
				'header' =>
					'Authorization: Bearer <token>')
			)
		)
	)	
);

$response = $request->foggylineSliderSlideRepositoryV1Save($slide);

The response for PHP SoapClient style should be the stdClass PHP object as follows:

object (stdClass) #2 (1) { //The # denotes argv length
	["result"]=>object(stdClass)#3 (2) {
		["slideId"]=>int(6)
		["title"]=>string(8) "API Test"
	}
}

The console SOAP style cURL for executing POST/V1/foggylineSliderSlide is done as follows:

curl -X POST \
-H 'Content-Type: application/soap+xml; charset=utf-8;
action="foggylineSliderSlideRepositoryV1Save"'\
-H 'Authorization: Bearer <token>'\
-d @request.xml http://magento2.ce/index.php/soap/default?services=foggyline
SliderSlideRepositoryV1

Where request.xml has content as follows:

<?xml version="1.0" encoding="UTF-8"?>
<env:Envelope xmlns:env="http://www.w3.org/2003/05/soap-envelope" xmlns:ns1="http://magento2.ce/index.php
/soap/default?services=foggylineSliderSlideRepositoryV1">
	<env:Body>
		<ns1:foggylineSliderSlideRepositoryV1SaveRequest>
			<slide>
				<title>API test</title>
			</slide>
		</ns1:foggylineSliderSlideRepositoryV1SaveRequest>
	</env:Body>
</env:Envelope>

The response for console SOAP style cURL should be an xml as follows:

<?xml version="1.0" encoding="UTF-8"?>
<env:Envelope xmlns:env="http://www.w3.org/2003/05/soap-envelope" xmlns:ns1="http://magento2.ce/index.php/soap
/default?services=foggylineSliderSlideRepositoryV1">
	<env:Body>
		<ns1:foggylineSliderSlideRepositoryV1SaveResponse>
			<result>
				<slideId>8</slideId>
				<title>API test</title>
			</result>
		</ns1:foggylineSliderSlideRepositoryV1SaveResponse>
	</env:Body>
</env:Envelope>

The save (as update) service method call examples

The console cURL style for executing PUT /V1/foggylineSliderSlide/:id is done as follows:

curl -X PUT -H 'Content-type: application/json' \
-H 'Authorization: Bearer <token>'\
-d '{"slide": {"slide_id":2, "title": "API update test"}}' \
http://magento2.ce/rest/V1/foggylineSliderSlide/2

The PHP cURL style for executing PUT /V1/foggylineSliderSlide/:id is done as follows:

$slideId = 2;
$slide = json_encode(['slide' => ['slide_id' => $slideId, 'title'=> 'API update test']]);

$ch = curl_init('http://magento2.ce/rest/V1/foggylineSliderSlide/' . $slideId);
curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'PUT');
curl_setopt($ch, CURLOPT_POSTFIELDS, $slide);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
curl_setopt($ch, CURLOPT_HTTPHEADER, array('Content-Type: application/json', 
'Content-Length: ' . strlen($slide), 'Authorization: Bearer <token>'
));

$result = curl_exec($ch);

The response for console and PHP cURL style should be a JSON string similar to the following one:

{"id":2, "slide_id":2, "title":"API update test"}

The PHP SoapClient style for executing PUT /V1/foggylineSliderSlide/:id is done as follows:

$slideId = 2;
$slide = ['slide'=>['slideId' => $slideId, 'title' => 'API update test']];

$request = new SoapClient('http://magento2.ce/index.php/soap/?wsdl&services=foggylineSlider
SlideRepositoryV1', 
	array(
		'soap_version' => SOAP_1_2,
		'trace'=>1,
		'stream_context' => stream_context_create(array(
			'http' => array(
				'header' => 'Authorization: Bearer <token>')
			)
		)
	)
);

$response $request->foggylineSliderSlideRepositoryV1Save($slide);

The response for PHP SoapClient style should be the stdClass PHP object as follows:

object(stdClass)#2 (1) {
	["result"]=>
	object(stdClass)#3 (2) {
		["slideId"]=>
		int (2)
		["title"]=>
		string (15) "API update test"
	}
}

The console SOAP style cURL for executing PUT /V1/foggylineSliderSlide/:id is done as follows:

curl -X PUT \
-H 'Content-Type: application/soap+xml; charset=utf-8; action="foggylineSlideRepositoryV1Save"'
-H 'Authorization: Bearer <token>' \
-d @request.xml http://magento2.ce/index.php/soap/default?services=
foggylineSliderSlideRepositoryV1

where request.xml has content as follows:

<?xml version="1.0" encoding="UTF-8"?>
<env:Envelope xmlns:env="http://www.w3.org/2003/05/soap-envelope" 
xmlns:ns1="http://magento2.ce/index.php/soap/default?services=foggylineSliderSlideRepositoryV1">
	<env:Body>
		<ns1:foggylineSliderSlideRepositoryV1SaveRequest>
			<slide>
				<slideId>2</slideId>
				<title>API update test</title>
			</slide>
		</ns1:foggylineSliderSlideRepositoryV1SaveRequest>
	</env:Body>
</env:Envelope>

The response for console SOAP style cURL should be an xml as follows:

<?xml version="1.0" encoding="UTF-8"?>
<env:Envelope xmlns:env="http://www.w3.org/2003/05/soap-envelope" 
xmlns:ns1="http://magento2.ce/index.php/soap/default?services=foggylineSliderSlideRepositoryV1">
	<env:Body>
		<ns1:foggylineSliderSlideRepositoryV1SaveResponse>
			<result>
				<slideId>2</slideId>
				<title>API Update Test</title>
			</result>
		</ns1:foggylineSliderSlideRepositoryV1SaveResponse>
	</env:Body>
</env:Envelope>

The deleteById service method call examples

The console cURL style for executing DELETE /V1/foggylineSliderSlide/:slideId is done as follows:

curl -X DELETE -H 'Content-type: application/json' \
-H 'Authorization: Bearer <token>' \
http://magento2.ce/rest/V1/foggylineSliderSlide/3

the PHP cURL style for executing DELETE /V1/foggylineSliderSlide/:slideId is done as follows:

$slideId = 4;

$ch = curl_init('http://magento2.ce/rest/V1/foggylineSliderSlide/' . $slideId);
curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'DELETE');
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
curl_setopt($ch, CURLOPT_HTTPHEADER, array(
	'Content-Type: application/json',
	'Authorization: Bearer <token>'
));

$result = curl_exec($ch);

The response for console and PHP cURL style should be a JSON string similar to the following one:

true

The PHP SoapClient style for executing DELETE /V1/foggylineSliderSlide/:slideId is done as follows:

$slideId = 2;

$request = new SoapClient(
	'http://magento2.ce/index.php/soap/?wsdl&services=foggylineSliderSlideRepositoryV1',
		array(
			'soap_version' => SOAP_1_2,
			'trace'=>1,
			'stream_context' => stream_context_create(array(
					'http' => array(
						'header' => 
		'Authorization: Bearer <token>')
					)
			)
	)
); //Indention error somewhere here

$response => $request->
foggylineSliderSlideRepositoryV1DeleteById(array('slideId' => $slideId));

The response for PHP SoapClient style should be the stdClass PHP object as follows:

object (stdClass)#2 (1) {
	["result"]=>bool(true)
}

The console SOAP style cURL for executing DELETE /V1/foggylineSliderSlide/:slideId is done as follows:

curl -X POST \
-H 'Content-Type: application/soap+xml; charset=utf-8;
action="foggylineSliderSlideRepositoryV1DeleteById"' \
-H 'Authorization: Bearer <token>' \
-d @request.xml
http://magento2.ce/index.php/soap/default?services=foggylineSliderSlideRepositoryV1

Where request.xml has contents as follows:

<?xml version="1.0" encoding="UTF-8"?>
<env:Envelope xmlns:env="http://www.w3.org/2003/05/soap-envelope" xmlns:ns1="http://magento2.ce/index.php
/soap/default?servicesfoggylineSliderSlideRepositoryV1">
	<env:Body>
		<ns1:foggylineSliderSlideRepositoryV1DeleteByIdRequest>
			<slideId>5</slideId>
		</ns1:foggylineSliderSlideRepositoryV1DeleteByIdRequest>
	</env:Body>
</env:Envelope>

The response for console SOAP style cURL should be an xml as follows:

<?xml version="1.0" encoding="UTF-8"?>
<env:Envelope xmlns:env="http://www.w3.org/2003/05/soap-envelope"
xmlns:ns1="http://magento2.ce/index.php/soap/default?services=
foggylineSliderSlideRepositoryV1">
	<env:Body>
		<ns1:foggylineSliderSlideRepositoryV1DeleteByIdResponse>
			<result>true</result>
		</ns1:foggylineSliderSlideRepositoryV1DeleteByIdResponse>
	</env:Body>
</env:Envelope>

The preceeding API call examples cover all of our custom-defined APIs for the Slide entity.

Looking back at the $searchCriteria variable, we used the GET type of HTTP method,
passing the entire variable as a query string. If we think about it, we could have
specified POST during the Web API resource definition and packed the 
content of the $searchCriteria variable into the request body.

Although the GET method approach might look a bit dirtier, imagine if we assigned
the anonymous or self role to the resource: We would be able to simply open a lengthy URL
in the browser and have the search results. Think of a possible widget use,
where a widget would simply do an AJAX request to the URL and fetch the results for the guests
or the customer.

The full module source code can be found here: <url>
Aside from the Slide entity, the full module code indludes the
Image entity as well. Since each slide can contain multiple
images, we can further test the Image API calls analogous to the preceeding calls.

Search Criteria Interface for list filtering:

Knowing how to do a proper list filtering to fetch the entities
that match a certain lookup is essential for the effective use of
getList services across core Magento and possibly custom-coded API's.

An example is fetching the list of customers registered within the last 24 hours for the
latest added product.

Let's take a look back at our app/code/Foggyline/Slider/etc/webapi.xml file, the bit where
we defined the service method="getList". The service class is defined as Foggyline\Slider\
Api\SlideRepositoryInterface, which is defined as a preference for the Foggyline\Slider\Model\
SlideRepository class.

Finally, within the SlideRepository class, we have the actual getList Method getList is defined
as follows:

getList(\Magento\Framework\Api\SearchCriteriaInterface $searchCriteria);

We can see that the getList method takes only one parameter, object instance,
that compiles with SearchCriteriaInterface called $searchCriteria.

What this means is we already have the (incomplete) JSON object of the following type to 
pass to the getList method:

{
	"search_criteria": {

	}
}

In order to further understand the inner workings of search_criteria, we need to understand
SearchCriteriaInterface, which is (partially) defined as follows:

interface SearchCriteriaInterface
{
	/* @param \Magento\Framework\Api\Search\FilterGroup[] $filterGroups */
	public function setFilterGroups(array $filterGroups = null);

		/* @param \Magento\Framework\Api\SortOrder[] $sortOrders */

	public function setSortOrders(array $sortOrders = null);

	/* @param int $pageSize */
	public function setPageSize($pageSize);

	/* @param int $currentPage */
	public function setCurrentPage($currentPage);
}

Every interface getter and setter method expects the values to be found in 
passed API parameters. What this means,is that the getPageSize() and setPageSize()
methods would expect search_criteria to have an integer type page_size property on it.

Similarly, the getFilterGroups() and setFilterGroups() methods would expect
search_criteria to have an array of \Magento\Framework\Api\Search\FilterGroup passed to it.

These insights bring us to an incomplete JSON objecto f the following type to pass to the 
getList method:

{
	"search_criteria": {
		"filter_groups": [
		],
		"current_page": 1,
		"page_size": 10,
		"sort_orders": []
	}
}

Now we have got to the point where we need to determine what goes into filter_groups
and sort_orders, since these are not simple types but compound values.

Looking further into \Magento\Framework\Api\Search\FilterGroup, we see the 
definition of the getFilters() and setFilters() methods that work with an array
of \Magento\Framework\Api\Filter objects. 

What this means is that filter_groups has a property filter that is 
an array of individual filter objects defined as \Magento\Framework\Api\Filter.

With this in mind, we are now down to the following form of the search_criteria JSON
object:

{
	"search_criteria": {
		"filter_groups": [
			{
				"filters": [
				]
			}
		],
		"current_page": 1,
		"page_size": 10
		"sort_orders": [
		]
	}
}

Looking further into individual \Magento\Framework\Api\Filter, through it's getters
and setters it defines we can conclude properties like field, value and condition_type.

This brings us one step further to finalizing our search_criteria JSON object,
which is now structured as follows:

{
	"search_criteria": {
		"filter_groups": [
			{
				"filters":[
					{
						"field": "title",
						"value": "%some%",
						"condition_type": "like"
					}
				]
			}
		],
		"current_page": 1,
		"page_size": 10,
		"sort_orders": [
		]
	}
}

Let us take a look at sort_orders as the last outstanding bit. sort_orders
is of type \Magento\Framework\Api\SortOrder, which has getters and setters
for the field and direction properties. Knowing this, we are able to fully
construct our search_criteria JSON object (or array) that we would be passing
to the getList() service method call as follows:

{
	"search_criteria": {
		"filter_groups": [
			{
				"filters": [
					{
						"field": "title",
						"value": "%some%",
						"condition_type": "like"
					}
				]
			}
		],
		"current_page": 1,
		"page_size": 10,
		"sort_orders": [
			{
				"field": "slide_id",
				"direction": -1
			}
		]
	}
}

What happens when we define multiple entries under filter_groups, filters, or sort_orders?
The logical expectation would be that these break into AND and OR operators in SQL
when they hit the DB. Surprisingly, this is not always the case, at least not with our preceeding example.
Since the actual implementation of the getList method is left for us to handle, we can decide how
we want to handle the filter groups and filters.

Looking back at our getList method, as (partially) shown next, we are not doing anything to imply an
OR operator, so everything ends up with an AND condition on the DB:

foreach ($searchCriteria->getFilterGroups() as $filterGroup) {
	foreach ($filterGroup->getFilters() as $filter){
	$condition = $filter->getConditionType() ?: 'eq';

	$collection->addFieldToFilter($filter->getField(), [$condition => $filter->getValue()]);
	}
}

The preceeding code simply loops through all filter groups, pulling in all filters
within the group and calling the same addFieldToFilter method for everything.
Similar behavior is implement across core Magento modules. Although
the filtering itself follows the \Magento\Framework\Api\SearchCriteriaInterface interface,
there is no unified Magento-wide approach to force AND and OR operators in filtering.

However, Magento core API's like GET products do implement both AND and OR conditions.
In cases like these, filter groups result in OR and filters within the group result in
AND conditions.

Following best practices, we should make sure our modules that implement search criteria do
so respecting the filter_groups/filters and OR/AND relationship.

In this chapter, we covered a lot of ground relating to Magento API's. There is much more left to be
said, but the steps outlined here should be enough to get us started even with more advanced
API usage. We started the chapter with learning about types of users and the authentication methods
supported.

Strong emphasis was placed on making several types of API calls, like console cURL, PHP cURL, PHP
SoapClient, and console cURL SOAP. This was to encourage developers to understand the inner 
workings of API calls more deeply than just using high-level libraries.

Throughout the next chapter, we will look into some of the major sections of Magento.

THE MAJOR FUNCTIONAL AREAS

The Magento platform comprises various modules that deliver various bits of functionality.
Developers are often more in touch with one group of functionality than others.
Examples of some of the most commonly used functionalities include those related to
CMS blocks and pages, categories, products, customers, imports, custom product types,
custom payment, and shipping modules.

This is not to say that other functionalities are less important. In this chapter,
we will take a quick look at the functionalities in the Magento admin area,
PHP code, and API calls. The chapter is divided into the following sections:

CMS Management 

Catalog Management

Customer Management

Products and customer import

Custom product types

Custom offline shipping methods

The intention is not to go into the details of each functional
area. Rather, the aim is to show the admin interface and the corresponding
programmatic and API approach towards basic management.

Content is what helps differentiate one store from another.
Quality content can boost a store's visibility on search engines,
provides informative insight to the customers who buy products,
and provide credibility and trust. Magento provides a solid content
management system, which can be used to create rich content for a store.

We can use it to manage blocks and pages too.

A CMS block is a small modular unit of content that can be positioned
almost anywhere on a page. They can even be called into another blocks.
Blocks support HTML and JavaScript as it's content. Therefore, they are able
to display static information such as text, images and embedded video as well
as dynamic information.

Blocks can be created via an admin interface, APIs or Code.

The following steps outline the block creation process from within an admin interface:

1. Log in to the Magento admin area.

2. In the Content | Elements | Blocks menu, click on Add New Block. This opens
a screen that is similar to the following one:

<SS>

Fill in some values for the required fields (Block Title, Identifier, Store View, Status, and Content)
and click on the Save Block button.

Once the block is saved, you will see the You saved the block. success message in the browser.
CMS blocks are stored in the cms_block and cms_block_store tables in a DB.

The Identifier value is probably the most interesting aspect here.
We can use it in a CMS page, another CMS block, or some code to fetch the block
that we have just created.

Assuming that we have created a block with the Identifier value of foggyline_hello,
we can call it in the CMS page or another block by using the following expression:

{{widget type="Magento\\Cms\\Block\\Widget\\Block" template="widget/static_block/default.phtml"
block_id="foggyline_hello"}}

We can also pass the actual integer ID value of a block to the preceeding expression,
as follows:

{{widget type="Magento\\Cms\\Block\\Widget\\Block" template="widget/static_block/default.phtml" block_id="2"}}

However, this approach requires us to know the actual integer ID of a block.

The preceeding expressions show that blocks are included in a page or another block via a widget,
which is also known as a frontend app. A widget of the Magento\Cms\Block\Widget\Block class
type is using the widget/static_block/default.phtml template file to render the
actual CMS block.

Besides the manual creation of blocks via the admin interface, we can create CMS blocks by using
code, as shown in the following code snippet:

$model = $this->_objectManager->create('Magento\Cms\Model\Block');
$model->setTitle('Test Block');
$model->setIdentifier('test_block');
$model->setContent('Test Block!');
$model->setIsActive(true);
$model->save();

Here, we used the instance manager to create a new model instance of the
Magento\Cms\Model\Block class. Then, we set some properties through defined
methods and finally called the save method.

We can load and update the existing blocks using a code snippet that is similar
to the following code:

$model = $this->_objectManager->create('Magento\Cms\Model\Block');
//$model->load(3);
$model->load('test_block');
$model->setTitle('Updated Test Block');
$model->setStores([0]);
$model->save();

The block's load method accepts either an integer value of a block ID or
a string value of a block identifier.

Finally, we can manage the creation and updating of blocks through the available
APIs method. The following code snippet shows how a CMS block is created via a console 
cURL REST API call:

curl -X POST "http://magento2.ce/index.php/rest/V1/cmsBlock" \
	-H "Content-Type:application/json" \
	-H "Authorization: Bearer <token>" \
	-d '{"block": {"identifier": "test_api_block", "title": "Test API Block",
	"content": "API Block Content"}}'

The bearer string is just a login token that we obtain by first
running the authentication API call, as described in the previous chapter.
Once we have the authentication token, we can make V1/cmsBlock POST request, passing a JSON
object as data.

Managing blocks via API

We can get the newly created CMS block through an API by
executing a snippet of code that looks like this:

curl -X GET "http://magento2.ce/index.php/rest/V1/cmsBlock/4" \
	-H "Content-Type:application/json" \
	-H "Authorization: Bearer <token>"

We can update the existing CMS block by using an API and executing a snippet of 
code that is similar to this:

curl -X PUT "http://magento2.ce/index.php/rest/V1/cmsBlock/4" \
	-H "Content-Type:application/json" \
	-H "Authorization: Bearer <token>" \
	-d '{"block": {"title": "Updated Test API Block"}}'

Here, we used the HTTP PUT method and passed the integer 4 as part of the 
V1/cmsBlock/4 URL. The number 4 represents the ID value of the block in the DB.

CMS pages are robust content units unlike CMS blocks, which are simply
embedded into certain pages. The CMS page can have it's own URL. Examples of CMS
pages are pages such as 404 Not Found, Home page, Enable Cookies, and Privacy and Cookie Policy.
The idea, when it comes to dealing with CMS pages, is that we can control the 
content area of a page without affecting site-wide elements such as header, footer, or sidebars.

Magento does not really comes with many out-of-the-box CMS pages other than the ones
that were listed previously.

Like blocks, pages can also be created via the admin interface, APIs or code.

The following steps outline the page creation process from within the admin interface:

1. Log in to Magento admin area.

2. In the Content | Elements | Pages menu, click on Add New Page. This opens a screen
that is similar the one shown in the SS:

<ss>

3. Fill in some values for the required fields (Page Title, Store View, Status and Content) and click
on the Save Block button.

Once the page is saved, you will see the You saved this page. success message in the browser.
CMS pages are stored in the cms_page and cms_page_store tables in the DB.

Assuming that we have created a page with Page Title value Info, we can access this page in a 
browser via a URL such as http://magento2.ce/info. Though we could have to specify
the URL Key value in the New Page edit screen, Magento automatically assigns URL Key
that matches Page Title.

Managing pages via code

Besides the manual creation through the admin interface, we can create CMS pages via code,
as shown in the following code snippet:

$model =
$this->_objectManager->create('Magento\Cms\Model\Page');
$model->setTitle('Test page');
$model->setIdentifier('test-page');
$model->setPageLayout('1column');

$model->setContent('Test page!');
$model->setIsActive(true);
$model->setStores([0]);
$model->save();

Here, we used the instance manager to create a new model instance of the
Magento\Cms\Model\Page class. Then, we set some properties through 
the defined methods and finally called the save method. The URL Key that we set through
the admin Interface is actually an identifier that we set via the setIdentifier method call.

We can load and update the existing pages by using a code snippet that is similar to the following one:

$model = 
$this->_objectManager->create('Magento\Cms\Model\Page');
//$model->load(6);
$model->load('test-page');
$model->setContent('Updated Test page!');
$model->save();

The page model load method accepts either an integer ID value of a page identifier (URL Key).

Finally, we can manage the creation and updating of pages through the available APIs method.
The following code snippet shows how a CMS page is created via a console cURL REST API call:

curl -X POST "http://magento2.ce/index.php/rest/V1/cmsPage" \
	-H "Content-Type:application/json" \
	-H "Authorization: Bearer <token>" \
	-d '{"page": {"identifier": "test-api-page", "title": "Test API Page",
	"content": "API Block Content"}}'

Once we have the authentication token, we can make a V1/cmsPage POST request, passing on the
JSON object as data.

We can get the newly created CMS page through an API by executing a snippet of code that is similar
to the following one:

curl -X GET "http://magento2.ce/index.php/rest/V1/cmsPage/7" \
	-H "Content-Type:application/json" \
	-H "Authorization: Bearer <token>"

We can update the existing CMS page through an API by executing a snippet of code that is similar
to the following one:

curl -X PUT "http://magento2.ce/index.php/rest/V1/cmsPage/7" \
	-H "Content-Type:application/json" \
	-H "Authorization: Bearer <token>" \
	-d '{"page": {"content": "Updated Test API Page", "identifier": "updated-page"}}'

Here, we used the HTTP PUT method, passing the integer 7 as a part of the V1/cmsPage/7 URL
The number 7 represents the ID value of the page in the DB.

The Magento_Catalog module is one of the backbones of the entire Magento platform. It
provides robust support for the inventory management of various product types.
This module is what manages products, categories and their attributes, the display on the frontend
and many more things.

We can access the catalog functionality within the Magento admin area by navigating to Products |
Inventory | Catalog or Products | Inventory | Category.

If we start with a blank Magento installation, we will probably
start with categories as one of the first entities to be created.
We can manually create categories by performing the following steps:

1. Log in to the Magento admin area.

2. Go to the Products | Inventory | Category menu.
This opens a screen that is similar to the one shown in the following SS:

<ss>

On the left-hand side of the screen, click on Default Category. Then, when the page reloads,
click on the Add Subcategory button.

Though it may seem that nothing has happened, as the screen does not change, we should now
fill in the required options in the General Information tab, setting Name to some string value and
Is Active to Yes.

Finally, click on the Save Category button.

The new category should now be created. To the left screen area,
if you click on the name of the newly created category, you will see its ID value
above the General Information tab, as shown in the following SS:

Knowing the Category ID enables you to directly test it on a storefront simply by opening
a URL such as http://magento2.ce/index.php/catalog/category/view/id/3 in the browser, where the number
3 is the ID of the category. You will see a loaded category page that probably shows the
We can't find products matching teh selection message, which is good, as we haven't assigned
products to a Category.

Though we will not go into its details, it is worth noting that we have simply scratched
the surface here, as categories enable us to provide many additional options using the
Display Settings, Custom Design tabs.

Given that categories are EAV entities, their data is stored across several tables in the DB,
as follows:

catalog_category_entity

catalog_category_entity_datetime

catalog_category_entity_decimal

catalog_category_entity_int

catalog_category_entity_text

catalog_category_entity_varchar

There are a few additional tables that link categories to products:

catalog_category_product

catalog_category_product_index

catalog_category_product_index_tmp

catalog_url_rewrite_product_category

Besides the manual creation through the admin interface, we can create
categories via code, as shown in the following code snippet:

$parentId = \Magento\Catalog\Model\Category::TREE_ROOT_ID;

$parentCategory = $this->_objectManager->create('Magento\Catalog\Model\Category')->load($parentId);

$category = $this->_objectManager->create('Magento\Catalog\Model\Category');

$category->setPath($parentCategory->getPath());
$category->setParentId($parentId);
$category->setName('Test');
$category->setIsActive(true);

$category->save();

What is specific here is that when creating a new category, we first created a 
$parentCategory instance, which represents the root category object. We used
the Category model TREE_ROOT_ID constant as the ID value of a parent category ID.

Then, we created an instance of the category, set its path, parent_id, name, and is_active value.

We can further manage category creation through the available APIs method. The following code snippet
shows category creation via the console cURL REST API call:

curl -X POST "http://magento2.ce/index.php/rest/V1/categories" \
	-H "Content-Type:application/json" \
	-H "Authorization: Bearer <token>" \
	-d '{"category": {"parent_id": "1", 
"name": "Test API Category", "is_active": true}}'

The bearer string is just a login token that we obtain by first running the authentication API call,
as described in the previous chapter. Once we have the authentication token, we can make a /V1/categories POST
request, passing a JSON object as data.

We can get the newly created category as a JSON object through an API by executing a snippet
of code that looks like the following one:

curl -X GET "http://magento2.ce/index.php/rest/V1/categories/9" \
	-H "Content-Type:application/json" \
	-H "Authorization: Bearer <token>"

Now, let's look at how to create a new product. We can manually create products
by performing the following steps:

Log in to the Magento admin area.

In the Products | Inventory | Catalog menu, click on the Add Product button. This opens a screen
similar to the one shown in the following SS:

<ss>

Now, fill in the required options on the Product Details tab.

Finally, click on the save button.

If it is successfully saved, the page reloads and shows the You saved the product, mesage.

Like categories, we have barely scratched the surface of products here.
Looking at the other available tabs, there are a large number of additional options
that can be assigned to a product. Simply assigning the required options should be
enough for us to see the product on the store's frontend on a URL such
as http://magento2.ce/index.php/catalog/product/view/id/4, where the number 4 is
the ID value of a product.

Products are also EAV entities, whose data is stored across several tables in a DB, as follows:

catalog_product_entity

catalog_product_entity_datetime

catalog_product_entity_decimal

catalog_product_entity_gallery

catalog_product_entity_group_price

catalog_product_entity_int

catalog_product_entity_media_gallery

catalog_product_entity_media_gallery_value

catalog_product_entity_text

catalog_product_entity_tier_price

catalog_product_entity_varchar

There are also a large number of other table referencing products such as
catalog_product_bundle_selection, but these are mostly used to link bits of
functionalities.

Besides the manual creation through the admin interface, we can create products via code,
as shown in the following code snippet:

$catalogConfig = $this->_objectManager->create('Magento\Catalog\Model\Config');

$attributeSetId = $catalogConfig->getAttributeSetId(4, 'Default');

$product = $this->_objectManager->create('Magento\Catalog\Model\Product');

$product->setTypeId(\Magento\Catalog\Model\Product\Type::TYPE_SIMPLE)
		->setAttributeSetId($attributeSetId)

		->setWebsiteIds([$this->storeManager->getWebsite()->getId()])
		->setStatus(\Magento\Catalog\Model\Product\Attribute\Source\Status::STATUS_ENABLED)
		->setStockData(['is_in_stock' => 1, 'manage_stock' => 0])
		-setStoreId(\Magento\Store\Model\Store::DEFAULT_STORE_ID)
		->setVisibility(\Magento\Catalog\Model\Product\Visibility::VISIBILITY_BOTH);

$product
	->setName('Test API')
	->setSku('test-api')
	->setPrice(19.99);

$product->save();

The following example uses the REST API to create a new simple product:

curl -X POST "http://magento2.ce/index.php/rest/V1/products" \
	-H "Content-Type:application/json" \
	-H "Authorization: Bearer <token>" \
	-d '{"product": {"sku": "test_api_1", "name":"Test API #1", "attribute_set_id":4, "price":19.99,
	"status":1,
	"visibility":4, "type_id":"simple", "weight":1}}'

The Bearer token should have been previously obtained by using an authentication request.
The response should be a JSON object that contains all the exposed product data.

We can get the existing product as information through an API that executes a snippet of code,
as follows:

curl -X GET "http://magento2.ce/index.php/rest/V1/products/product_dynamic_125" \
	-H "Content-Type:application/json"

The product_dynamic_125 part inn the preceeding URL stands for this specific products
SKU value. The response is a JSON object that contains all the exposed product data.

The entire list of the available catalog APIs can be seen in the vendor/magento/module-catalog/etc/webapi.xml file.

Managing customers is another important aspect of the Magento platform. Most of the time,
customer creation is something that is left for a new customer to do. A new 
customer who visits a store initiates the registration process and finishes
up with a customer account being created.

Once registered, customers can then further edit their account details on the storefront
under the My Account page, which is usually available on a link such as 
http://magento2.ce/index.php/customer/account/index/.

As a part of this section, we are interested in the possibility of managing
customer accounts by using the admin area, code, and API.

The following steps outline the customers account creation process from within the admin interface:

1. Log in to Magento admin area.

2. In the Customer | All Customers menu, click on the Add New Customer button.
	This opens a screen that looks similar to the one shown in the following
	ss:
<ss>

Fill in some values for the required fields (Associate to Website, Group, First Name, Last Name, and
Email) and click on the Save Customer button.

Once the customer is saved, you will see the You saved the customer. success message in the browser.
The associate to Website value is probably the most important value for cases like this one,
where customer accounts are being indirectly created by a user who's not a customer.

Since Magento supports the setting up of multiple websites, customer accounts can be set
to either the Global or Per Website value, depending on the Stores | Settings | Configuration |
Customers | Customer Configuration | Account Sharing Option | Share Customer Accounts option.

Thus, if the Share Customer Accounts options has been set to Per Website, it is of the 
utmost importance to point the Associate the Website value to the proper website.
Otherwise, a customer account will be created but the customer won't be able to log
in to it on the storefront.

The Magento_Customer module uses the EAV structure to store customer data. Thus,
there is no single table that stores customer information. Rather, multiple table
exist depending on the customer property and it's data type.

The following list comprises tables that store customer entity:

customer_entity

customer_entity_datetime

customer_entity_decimal

customer_entity_int

customer_entity_text

customer_entity_varchar

Customer accounts will not really be completed without a customer address. The address
can be added via the Addresses tab under the customer edit screen in the admin area, as shown
in the following SS:

<ss>

Note that Magento enables us to set one of the addresses as Default Shipping Address and Default
Billing Address.

Like the customer entity, the customer address entity also uses the EAV structure to store its data.
The following list comprises tables that store the customer address entity:

customer_address_entity

customer_address_entity_datetime

customer_address_entity_decimal

customer_address_entity_int

customer_address_entity_text

customer_address_entity_varchar

Besides the manual creation via the admin interface, we can create
customers via code, as shown in the following code snippet:

$model = $this->_objectManager->create('Magento\Customer\Model\Customer');
$model->setWebsiteId(1);
$model->setGroupId(1);
$model->setFirstName('John');
$model->setLastName('Doe');
$model->setEmail('john.doe@mail.com');
$model->save();

Here, we are using the instance manager to create a new model instance of the
Magento\Customer\Model\Customer class. We can then set some properties through
the defined methods and finally call the save method.

We can load and update an existing customer by using a code snippet that is similar
to the following one:

$model = $this->_objectManager->create('Magento\Customer\Model\Customer');
$model->setWebsiteId(1);
//$model->loadByEmail('john.doe@mail.com');
$model->load(1);
$model->setFirstName('Updated John');
$model->save();

We can use either the load or loadByEmail method call. The load method accepts the integer ID
value of the existing customer entity, while loadByEmail accepts a string e-mail address.
It is worth noting that setWebsiteId has to be called prior to any of the load methods.
Otherwise, we will get an error message that says A customer website ID must be specified
when using the website scope.

Finally, we can manage the creation and updating of customer information using the available
API method. The following code snippet shows how to create a customer via a
console cURL REST API call:

curl -X POST "http://magento2.ce/index.php/rest/V1/customers" \
	-H "Content-Type:application/json" \
	-H "Authorization: Bearer <token>" \
	-d '{"customer": {"website_id": 1, "group_id": 1, "firstName": "John", "lastName": "Doe",
	"email": "john.doe@mail.com"}, "password":"abc123"}'

Once we have the authentication token, we can make a V1/customers POST request, passing a JSON
object as data.

We can get the newly created customer via an API by executing a snippet of code that is similar
to the following one:

curl -X GET "http://magento2.ce/index.php/rest/V1/customers/24" \
	-H "Content-Type:application/json" \
	-H "Authorization: Bearer <token>"

We can update an existing customer through an API by executing a snippet of code that is similar
to the following one:

curl -X PUT "http://magento2.ce/index.php/rest/V1/customers/24" \
	-H "Content-Type:application/json" \
	-H "Authorization: Bearer <token>" \
	-d '{"customer": {"id":24, "website_id": 1, "firstName": "John Updated", "lastname": "Doe",
	"email": "john2@mail.com"},
	"password_hash": "<a hash>:1"}'

Here, we used the HTTP PUT method, passing the integer 24 as a part of the V1/customers/24 and as part
of the body URL. The number 24 represents the ID value of a customer in the DB. Also, note the
password_hash value; without it, the update will fail.

Similar to customers, we can create a customer address using code, as shown in the following
code snippet:

$model = $this->_objectManager->create('Magento\Customer\Model\Address');
//$model->setCustomer($customer);
$model->setCustomerId(24);
$model->setFirstName('John');
$model->setLastName('Doe');
$model->setCompany('Foggyline');
$model->setStreet('Test street');
$model->setCity('London');
$model->setCountryId('GB');
$model->setPostcode('GU22 7PY');
$model->setTelephone(<number>);
$model->setIsDefaultBilling(true);
$model->setIsDefaultShipping(true);
$model->save();

Here, we used the instance manager to create a new model instance of the Magento\Customer\Model\Address
class. We then set some properties through the defined methods and finally called the save method.

We can load and update the existing customer address by using a code snippet that is similar
to the following one:

$model = $this->_objectManager->create('Magento\Customer\Model\Address');
$model->load(22);
$model->setCity('Update London');
$model->save();

Here, we used the load method to load an existing address by its ID value. Then,
we called the setCity method passing it the updated string. After the save method is executed,
the address should reflect the change.

Surprisingly, a customer address cannot be created or updated directly via an API call, as there is no
POST or PUT REST API defined. However, we can still get the existing customer address information by using
an API, as follows:

curl -X GET "http://magento2.ce/index.php/rest/V1/customers/addresses/22" \
	-H "Content-Type:application/json" \
	-H "Authorization: Bearer <token>"

The entire list of available customer APIs can be seen in the vendor/magento/module-customer/etc/webapi.xml
file.

Magento provides an out-of-the-box mass import and export function via the following modules:

AdvancedPricingImportExport

BundleImportExport

CatalogImportExport

ConfigurableImportExport

CustomerImportExport

GroupedImportExport

ImportExport

TaxImportExport

The heart of the import functionality actually lies in the ImportExport module,
while other modules provide individual import and export entities through the 
vendor/magento/module-{partialModuleName}-import-export/etc/import.xml and
vendor/magento/module-{partialModuleName}-import-export/etc/export.xml

These functionalities can be accessed from the Magento admin area from the System | Data Transfer
menu. They enable us to export and import several entity types, such as Advanced Pricing,
Products, Customers Main File, and Customer Addresses.

The following SS shows the Entity Type options for the Import Settings screen.

<ss>

Next to Import Settings, when we select Entity Type for import, the Import Behavior section
appears, as shown in the following SS:

<ss>

Most entity types have similar options for Import Behavior. Most of the time, we will be
interested in the Add/Update behavior.

Since importing is a bit more complicated process than exporting, we will focus
on importing and the CSV file format. More specifically, our focus is on Products,
Customers Main File, and Customer Addresses imports.

When working with a clean Magento installation, the following columns are required during the product
import in order to make the product visible on the storefront afterwards:

sku (for example: "test-sku"): This can have almost any value as long as it is unique across Magento.

attribute_set_code(for example, "Default"): This can have any of the values found in a DB
when the SELECT DISTINCT attribute_set_name FROM eav_attribute_set; query is executed.

product_type(for example, "simple"): This can have the value of simple, configurable, grouped,
virtual, bundle or downloadable. Additionally, if we create or install a third-party
module that adds a new product type, we can use that one as well.

categories(for example, "Root/Shoes"): Create a full category path using the "Root category name/Child
category name/Child child category name" syntax. If there are multiple categories, then a pipe
("|") is used to seperate them. An example of this is "Root category name/Child category name/Child child
category name| Root category name/Child_2 category name".

product_websites (for example, "base"): This can have the values found in 
a DB when the SELECT DISTINCT code FROM store_website; query is executed.

name (for example: "Test"): This can have almost any value.

product_online (for example: "1"): This can be either 1 for visible or 0 for not visible.

visibility (For example, "Catalog Search"): This can have the values of
"Not Visible Individually", "Catalog", "Search", or "Catalog, Search".

price (for example "9.99"): This can be an integer or a decimal value.

qty (for example, "100"): This can be an integer or a decimal value.

Though the products will get imported just with the preceeding list that comprises a set of columns,
we usually would like to assign additional information to them, such as descriptions and images.
We can do so with the help of the following columns:

description (for example, "The description"): This can have any string value. HTML and JS 
are supported.

short_description (for example, "The short description"): This can have any string value. HTML 
and JS are supported.

base_image (for example, butterfly.jpg): This is the final import image name.

small_image (for example, galaxy.jpg)

thumbnail_image (for example, serenity.jpg) 

Regarding the import of images, we need only to provide the final image name as long as the
Images File Dir path is set during the import. We can use a relative path for the Magento installation,
such as var/export, var/import and var/export/some/dir

Once the import is finished, it is suggested to run the php bin/magento indexer:reindex command
via the console. Otherwise, the products won't be visible on the storefront until the
indexer is run.

Once the reindexing is done, we can try opening storefront URL, which looks like http://magento2.ce/index.php/catalog/product/view/id/1. The number 1 in this case is a newly imported product ID.

When working with a clean Magento installation, the following columns are required during a customer's
main file import in order for our customer to be able to successfully log in to the store afterwards:

email (for example, <john.doe@fake.mail>): an e-mail as a string

_website(for example, base): This can have any of the values found in the DB when the
SELECT DISTINCT code FROM store_website; query is executed

firstname(for example, John): a string value

lastName(for example, Doe): a string value

group_id(for example, 1): This can have any of the values found
in the database when the SELECT customer_group_id code FROM customer_group WHERE customer_group_id != 0;
query is executed

Though a customer will be able to log in to the storefront with just the previously listed set of columns,
we usually would like to assign other relevant pieces of info. We can do so with the help of the following columns:

gender (for example, Male): This can be either Male or Female

taxvat (for example, <token number>): any valid VAT number, though an import will accept
even the invalid ones

dob (for example, 1983-01-16): date of birth

prefix (for example, Mr): any string value

middlename (for example, the dev guy): Any string

suffix (for example, engineer): any string value

password (for example, 123abc): Any string value that
has a minimum length of 6 characters, as defined via
\Magento\CustomerImportExport\Model\Import\Customer::MIN_PASSWORD_LENGTH

We need to pay special attention to the password column. This is a clear
text password. Therefore, we need to be careful not to distribute a
CSV file in a nonsecure manner. Ideally, we can provide the password_hash
column instead of password. However, entries under the password_hash
column will need to be hashed via the same algorithm as the one that was
called within the hashPassword method of the Magento\Customer\Model\Customer class.

This further calls the getHash method on an instance of the Magento\Framework\Encryption\Encryptor
class, which finally resolves to the md5 or sha256 algorithm.

When working with a clean Magento installation, the following columns are
required during the customer address import in order for our customers to be able to
successfully use the addresses on the storefront afterwards:

_website (for example, base): This can have any of the values found in the database
when the SELECT DISTINCT code FROM store_website; query is executed.

_email (for example, john@change.me) : an e-mail adress as a string value

_entity_id

firstname (for example, John): any string value

lastname (for example, Doe): any string value

street (for example, Ashton Lane): any string

city (for example, Austin): Any string

telephone (for example, 00 385 91 111 000): Any string value

country_id (for example, GB): the country code in the ISO-2 format

postcode (for example, TX 78753): any string value

Though a customer will be able to use the addresses on the storefront with just
a listed set of columns, we usually would like to assign other relevant pieces of information.

We can do so with the help of the following columns:

region (For example, California): This can be blank, a free form string,
or a specific string that matches any of the values found in the DB when the SELECT
DISTINCT default_name FROM directory_country_region; query is executed.

On running SELECT DISTINCT country_id FROM directory_country_region;, 13 different
country codes that have entries within the directory_country_region table are shown-
AT, BR, CA, CH, DE, EE, ES, FI, FR, LT, LV, RO, US. This means that countries with
that code need to have a proper region name assigned.

company (for example, Foggyline): This can be any string value.

fax (for example, 00 385 91 111 000): this can be any string value

middlename (for example, the developer): this can be any string value

prefix (for example, Mr): This can be any string value

suffix (for example, engineer): This can be any string value

vat_id (for example, HR33311122299): This can be any valid VAT number, though import
will accept even the non-valid ones

_address_default_billing_ (for example, "1"): This can be either "1" (logical yes) or "0" (Logical no),
to flag the address as being the default billing address.

_address_default_shipping_ (for example, "1"): This can be either "1" as yes or "0" as no, to flag the
address as being default billing address.

While CSV imports are a great and relatively fast way to mass import products, customers and 
their addresses, there are some limitations to it. CSV is simply flat data. We cannot
apply any logic to it. depending on how clean and valid the data is, the CSV import
might do just fine.

Otherwise, we might want to opt for APIs. We need to keep in mind that a CSV import is much
faster than the API creation of products and customers because CSV imports work directly
by bulk inserting on the DB, while APIs instansiate full models, respect the event observer,
etc.

Magento provides the following six out-of-the-box product types:

Simple products

Configurable Products

Grouped products

Virtual products

Bundle products

Downloadable products

Each product has its specifics. For example, the virtual and downloadable products do not have 
the weight attribute. Therefore, they are excluded from the standard shipping calculations.
With custom coding around built-in product types, by using observers and plugins we can achieve
almost any functionality.

However, this is not enough sometimes or there is no solution to the requirement. In cases such 
as thoose, we might need to create our own product type that will match the project requirements
in a more streamlined way. 

Let's create a miniature module called Foggyline_DailyDeal that will add a new product type to Magento.

Start by creating a module registration file named app/code/Foggyline/DailyDeal/registration.php
that has the following partial content:

\Magento\Framework\Component\ComponentRegistrar::register(\Magento\Framework\Component\Component\
ComponentRegistrar::MODULE, 'Foggyline_DailyDeal', __DIR__);

Then create an app/code/Foggyline/DailyDeal/etc/module.xml with the following content:

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:noNamespaceSchemaLocation="urn:magento:framework:Module/etc/module.xsd">
	<module name="Foggyline_DailyDeal" setup_version="1.0.0">
		<sequence>
			<module name="Magento_Catalog"/>
		</sequence>
	</module>
</config>

Now, create an app/code/Foggyline/DailyDeal/etc/product_types.xml file that has the following
content:

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:
Magento_Catalog:etc/product_types.xsd">
	<type name="foggylinedailydeal"
		label="Daily Deal"
		modelInstance="Foggyline\DailyDeal\Model\Product\Type\DailyDeal"
		composite="false"
		isQty="true"
		canuseQtyDecimals="false">
		<priceModel instance="Foggyline\DailyDeal\Model\Product\Price"/>
		<indexerModel instnace="Foggyline\DailyDeal\Model\ResourceModel\Indexer\Price"/>
		<stockIndexermodel instance="Foggyline\DailyDeal\Model\ResourceModel\Indexer\Stock"/>
		<!-- customAttributes parsed by Magento\Catalog\Model\ProductTypes\Config -->
		<customAttributes>
			<attribute name="is_real_product" value="true"/>					
			<attribute name="refundable" value="false"/>
			<attribute name="taxable" value="true"/>
		</customAttributes>
	</type>
</config>

the customAttributes element is parsed by vendor/magento/module-catalog/Model/ProductTypes/Config.php.

Create an app/code/Foggyline/DailyDeal/Model/Product/Type/DailyDeal.php file with the partial
content as follows:

namespace Foggyline\DailyDeal\Model\Product\Type;

class DailyDeal extends \Magento\Catalog\Model\Product\Type\AbstractType
{
	const TYPE_DAILY_DEAL = 'foggylinedailydeal';

	public function deleteTypeSpecificData(\Magento\Catalog\Model\Product $product)
	{
		//TODO: Implement deleteTypeSpecificData() method.
	}
}

Now, create an app/code/Foggyline/DailyDeal/Model/Product/Price.php with the partial
content as follows:

namespace Foggyline\DailyDeal\Model\Product;

class Price extends \Magento\Catalog\Model\Product\Type\Price
{
	
}

After htis is done, create an app/code/Foggyline/DailyDeal/Model/ResourceModel/Indexer/Price.php
file with partial content as follows:

namespace Foggyline\DailyDeal\Model\resourceModel\Indexer;

class Price extends \Magento\Catalog\Model\ResourceModel\Product\Indexer\Price\DefaultPrice
{
	
}

Then, create an app/code/Foggyline/DailyDeal/Model/ResourceModel/Indexer/Stock.php file with
partial content as follows:

namespace Foggyline\DailyDeal\Model\ResourceModel\Indexer;

class Stock extends \Magento\CatalogInventory\Model\ResourceModel\Indexer\Stock\DefaultStock
{
	
}

Finally, create an app/code/Foggyline/DailyDeal/Setup/InstallData.php file with content as follows:

namespace Foggyline\DailyDeal\Setup;

class InstallData implements \Magento\Framework\Setup\InstallDataInterface
{
	private $eavSetupFactory;

	public function __consturct(\Magento\Eav\Setup\EavSetupFactory $eavSetupFactory)
	{
		$this->eavSetupFactory = $eavSetupFactory;
	}

	public function install(
		\Magento\Framework\Setup\ModuleDataSetupInterface $setup,
		\Magento\Framework\Setup\ModuleContextInterface $context)
	{
		//The "foggylinedailydeal" type specifics
	}
}

Extend the install method from within the InstallData class by adding the following
foggylinedailydeal type specifics to it:

$eavSetup = $this->eavSetupFactory->create(['setup' => $setup]);
$type = \Foggyline\DailyDeal\Model\Product\Type\DailyDeal::TYPE_DAILY_DEAL;

$fieldList = ['price', 
			'special_price',
			'special_from_date',
			'minimal_price',
			'cost',
			'tier_price',
			'weight',
];

//make these attributes applicable to foggylinedailydeal products
foreach ($fieldList as $field) {
	$applyTo = explode(',', //explode the list and run them as being what is being applied to
						$eavSetup->getAttribute(\Magento\Catalog\Model\Product::ENTITY, $field,
						'apply_to')
	);

	if (!in_array($type, $applyTo)) { //if the type is not int he array
		$applyTo[] = $type; //the applyTo array is the $type
		$eavSetup->updateAttribute(\Magento\Catalog\Model\Product::ENTITY,
			$field,
			'apply_to',
			implode(',', $applyTo) //update the attribute by accessing the product entity
			//and imploding it into the list 
		);
	}
}

Now, run the php bin/magneto setup:upgrade from the console.

If you now open the Products | Inventory | Catalog menu in the admin area and click
on the dropdown ion next to the Add Product button, you will see the Daily Deal product
type on the list, as shown in the following SS:

<ss>

Clicking on the Daily deal product type in the dropdown list should open the product
edit page, as shown in the following SS:

<ss>

There is no noticable difference between the custom product type edit screen and one of the
built-in product types.

Assuming that we have named the product Daily Deal Test Product and saved it,
we should be able to see it on the storefront, as shown in the following SS:

<ss>

If we add the product to the cart and perform a checkout, an order should be created just as with any other
product type. Within the admin area, on the order view page, under Items Ordered, we should be able
to see the Product on the list, as shown in the following ss:

<ss>

Again, there is no noticable difference between the custom product type and the built-in product type
that is rendering under the Items Ordered section.

Finally, we should run the php bin/magento indexer:reindex command on the console. Even though
we haven't really implemented any code within the indexers, this is just to ensure that none
of the existing indexers broke.

The entire module can be downloaded from https://github.com/ajzele/B05032-Foggyline_DailyDeal.

Magento provides several out-of-the-box offline shipping methods, such as Flatrate, Freeshipping,
Pickup and Tablerate. We can see those in the vendor/magento/module-offline-shipping/Model/Carrier
dir.

However, project requirements quite often are such that we need a custom code shipping method where
a special business logic is applied. Thus, the shipping price calculation can be 
controlled by us. In such cases, knowing how to code our own offline shipping method might come in ahdny.

Let's go ahead and create a small module called Foggyline_Shipbox that provides Magento an extra 
offline shipping method.

Start by creating a module registration file named app/code/Foggyline/Shipbox/registration.php 
with partial content as follows:

\Magento\Framework\Component\ComponentRegistrar::register(
	\Magento\Framework\Component\ComponentRegistrar::MODULE,
		'Foggyline_Shipbox',
		__DIR__
);

Then, create an app/code/Foggyline/Shipbox/etc/module.xml file with the following content:

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magneto:framework:Module/etc/module.xsd">
	<module name="Foggyline_Shipbox" setup_version="1.0.0">
		<sequence>
			<module name="Magento_OfflineShipping"/>
		</sequence>
	</module>
</config>

Now, create an app/code/Foggyline/Shipbox/etc/config.xml with content as follows:

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:
module:Magento_Store:etc/config.xsd">
	<default>
		<carriers>
			<shipbox>
				<active>0</active>
				<sallowspecific>0</sallowspecific>
				<model>Foggyline\Shipbox\Model\Carrier\Shipbox</model>
				<name>Shipbox</name>
				<price>4.99</price>
				<title>Foggyline Shipbox</title>
				<specificerrmsg>This shipping method is not available. To use this
				shipping method, please contact us.</specificerrmsg>
			</shipbox>
		</carriers>
	</default>
</config>

After this is done, create an app/code/Foggyline/Shipbox/etc/adminhtml/system.xml file
with content as follows:

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Config:etc/system_file.xsd">
	<system>
		<section id="carriers">
			<group id="shipbox" translate="label" type="text" sortOrder="99"
			showInDefault="1" showInWebsite="1" showInStore="1">
				<label>Foggyline Shipbox</label>
				<field id="active" translate="label" type="select" sortOrder="1" 
				showInDefault="1" showInWebsite="1" showInStore="0">
					<label>Enabled</label>
					<source_model>Magento\Config\Model\Source\Yesno</source_model>
				</field>
				<field id="name" translate="label" type="text" sortOrder="3" 
				showInDefault="1" showInWebsite="1" showInStore="1">
					<label>Method Name</label>
				</field>
				<field id="price" translate="label" type="text" sortOrder="5" 
				showInDefault="1" showInWebsite="1"
				showInStore="0">
					<label>Price</label>
					<validate>validate-number validate-zero-or-greater</validate>
				</field>
				<field id="title" translate="label" type="text" sortOrder="2"
				showInDefault="1" showInWebsite="1"
				showInStore="1">
					<label>Title</label>
				</field>
				<field id="sallowspecific" translate="label" type="select"
				sortOrder="90" showInDefault="1" showInWebsite="1" showInStore="0">
					<label>Ship to Applicable Countries</label>
					<frontend_class>shipping-applicable-country</frontend_class>
					<source_model>Magento\Shipping\Model\Config\Source\AllSpecificcountries</source_model>
				</field>
				<field id="specificcountry" translate="label" type="multiselect"
				sortOrder="91" showInDefault="1" showInWebsite="1" showInStore="0">
					<label>Ship to Specific Countries</label>
					<source_model> Magento\Directory\Model\Config\Source\Country</source_model>
					<can_be_empty>1</can_be_empty>
				</field>
			</group>
		</section>
	</system>
</config>

Now, create an app/code/Foggyline/Shipbox/Model/Carrier/Shipbox.php file with partial content as follows:

namespace Foggyline\Shipbox\Model\Carrier;

use Magento\Quote\Model\Quote\Address\RateRequest;

class Shipbox extends \Magento\Shipping\Model\Carrier\AbstractCarrier implements \Magento\Shipping\Model\
Carrier\CarrierInterface
{
	protected $_code = 'shipbox';
	protected $_isFixed = true;
	protected $ _rateResultFactory;
	protected $ _rateMethodFactory;

	public function __construct(
		\Magento\Framework\App\Config\ScopeConfigInterface $scopeConfig,
		\Magento\Quote\Model\Quote\Address\RateResult\ErrorFactory $rateErrorFactory,
		\Psr\Log\LoggerInterface $logger,
		\Magento\Shipping\Model\Rate\ResultFactory $rateResultFactory,
		\Magento\Quote\Model\Quote\Address\RateResult\MethodFactory $rateMethodFactory,
		array $data = []
	)
	{
		$this->_rateResultFactory = $rateResultFactory;
		$this->_rateMethodFactory = $rateMethodFactory;
		parent::__construct($scopeConfig, $rateErrorFactory, $logger, $data);
	}

	public function collectRates(RateRequest $request)
	{
		//implements business logic
	}

	public function getAllowedMethods()
	{
		return ['shipbox' => $this->getConfigData('name')];
	}
}

Extend the collectRates method in the Carrier\Shipbox class as follows:

public function collectRates(RateRequest $request)
{
	if (!$this->getConfigFlag('active')){
		return false;
	}

	//Do some filtering of items in cart
	if ($request->getAllItems()) {
		foreach ($request->getAllItems() as $item)
		{
			//$item->getQty();
			//$item->getFreeShipping()
			//$item->isShipSeparately()
			//$item->getHasChildren()
			//$item->getProduct()->isVirtual()

			//...
		}
	}
	//After filtering, start forming final price
	//Final price does not have to be fixed like below

	$shippingPrice = $this->getConfigData('price');
	$result = $this->_rateResultFactory->create();

	$method = $this->_rateMethodFactory->create();

	$method->setCarrier('shipbox');
	$method->setCarrierTitle($this->getConfigData('title'));

	$method->setMethod('shipbox');
	$method->setMethodTitle($this->getConfigData('name'));

	$method->setPrice($shippingPrice);
	$method->setCost($shippingPrice);

	$result->append($method);

	return $result;
}

In the Magento admin area, if you now look under Stores | Settings | Configuration | Sales | Shipping Methods,
you will see Foggyline Shipbox on the list, as shown in the following SS:

<ss>

Set the Enabled option to Yes and click the Save Config button.

If you now run the SELECT * FROM core_config_data WHERE path LIKE "%shipbox%"; query on
the MySQL server, you will see results that are similar to the ones shown in the following SS:

<ss>

Note how there is no direct code within the code snippets in the preceeding screenshots that is related to
Ship to Applicable Countries and Ship to Specific Countries option, because the handling of these options
is built into the parent AbstractCarrier class. Thus, simply by adding the sallowspecific option
in config.xml and system.xml, we enabled a feature where the shipping method can be shown or hidden
from certain countries.

The crux of the implementation comes down to the collectRates method. This is where we implement
our own business logic that should calculate the shipping price based on the items in the cart.
We can use the $request->getAllItems() in the collectRates method to fetch the collection
of all the cart items, traverse through them, form a final shipping price based on various 
conditions and so on.

Now, let's go ahead and jump to the storefront in order to test the checkout. We should be able 
to see our method on the checkout, as shown in the following ss:

<ss>

If we complete one order, we should further see the shipping method details on the order itself.
Within the admin area, under Sales Operations | Orders, if we View our order in the Payment & Shipping Method
section, we should see the shipping method, as shown in the following ss:

<ss>

Similarly, in the Order Totals section, we should see the shipping amount in Shipping & Handling, as shown
in the following content:

<ss>

With this, we conclude our custom offline shipping method module. The full module can be found at
https://github.com/ajzele/B05032-Foggyline_Shipbox.

Magento provides several out-of-the-box offline payment methods, such as Banktransfer, Cashondelivery,
Checkmo and Purchaseorder. You can see them in the vendor/magento/module-offline-payments/Model dir.

When it comes to payment methods, it is more common to use an online payment provider (gateway) , such as Paypal
or Braintree. Sometimes, project requirements may be such that we may need a custom coded payment method.

You will need to think of programmatic product import and order creation script that might specialize
in some specifically labeled payment method. Thus, the payment process will be controlled by us.

In such cases, knowing how to code our own offline payment method might come in handy. It is worth noting
that while we can make an offline payment that will grab a user's credit card info, it is not really
advisable to do so unless our infrastructure is PCI-compliant.

Let's go ahead and create a small module called Foggyline_Paybox that provides Magento an extra offline payment method.

Start by creating a module registration file named app/code/Foggyline/Paybox/registration.php with partial
content as follows:

\Magento\Framework\Component\ComponentRegistrar::register(\Magento\Framework\Component\ComponentRegistrar::MODULE,
	'Foggyline_Paybox',
	__DIR__
);

Then, create an app/code/Foggyline/Paybox/etc/module.xml file with the following content:

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework
:Module/etc/module.xsd">
	<module name="Foggyline_Paybox" setup_version="1.0.0">
		<sequence>
			<module name="Magento_OfflinePayments"/>
		</sequence>
	</module>
</config>

After this is done, create an app/code/Foggyline/Paybox/etc/config.xml file with the following
content:

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instnace" xsi:noNamespaceSchemaLocation="urn:magento:
module:Magento_Store:etc/config.xsd">
	<default>
		<payment>
			<paybox>
				<active>0</active>
				<model>Foggyline\Paybox\Model\Paybox</model>
				<order_status>pending</order_status>
				<title>Foggyline Paybox</title>
				<allowspecific>0</allowspecific>
				<group>Offline</group>
			</paybox>
		</payment>
	</default>
</config>

Then, create the app/code/Foggyline/Paybox/etc/payment.xml file with the following content:

<payment xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:
Magento_Payment:etc/payment.xsd">
	<methods>
		<method name="paybox">
			<allow_multiple_address>1</allow_multiple_address>
		</method>
	</methods>
</payment>

Now, create an app/code/Foggyline/Paybox/etc/adminhtml/system.xml file with the following content:

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:
Magento_Config:etc/system_file.xsd">
	<system>
		<section id="payment">
			<group id="paybox" translate="label" type="text" sortOrder="30"
showInDefault="1" showInWebsite="1"
showInStore="1">
				<label>Paybox</label>
				<field id="active" translation="label" type="select" sortOrder="1" showInDefault="1"
showInWebsite="1" showInStore="0">
					<label>Enabled</label>
					<source_model> Magento\Config\Model\Config\Source\Yesno</source_model>
				</field>
				<field id="order_status" translate="label" type="select" sortOrder="20" showInDefault="1"
showInWebsite="1" showInStore="0">
					<label>New Order Status</label>
					<source_model>Magento\Sales\Model\Config\Source\Order\Status\NewStatus</source_model>
				</field>
				<field id="sort_order" translate="label" type="text" sortOrder="100" showInDefault="1" 
showInWebsite="1" showInStore="0">
					<label>Sort Order</label>
					<frontend_class>validate-number</frontend_class>
				</field>
				<field id="title" translate="label" type="text" sortOrder="10" showInDefault="1"
showInWesbtei="1" showInStore="1">
					<label>Titlte</label>
				</field>
				<field id="allowspecific" translate="label" type="allowspecific"
sortOrder="50" showInDefault="1" showInWebsite="1" showInStore="0">
					<label>Payment from Applicable Countries </label>
					<source_model>Magento\Payment\Model\Config\Source\Allspecificcountries</source_model>
				</field>
				<field id="specificcountry" translate="label" type="multiselect" sortOrder="51" showInDefault="1"
showInWebsite="1" showInStore="0">
					<label>Payment from Specific Countries</label>
					<source_model>Magento\Directory\Model\Config\Source\Country</source_model>
					<can_be_empty>1</can_be_empty>
				</field>
				<field id="payable_to" translate="label" sortOrder="61" showInDefault="1"
showInWebsite="1" showInStore="1">
					<label>Make Check Payable to</label>
				</field>
				<field id="mailing_address" translate="label" type="textarea" sortOrder="62"
showInDefault="1" showInWebsite="1" showInStore="1">
					<label> Send check to</label>
				</field>
				<field id="min_order_total" translate="label" type="text" sortOrder="98"
showInDefault="1" showInWebsite="1" showInStore="0">
					<label>Minimum Order Total</label>
				</field>
				<field id="max_order_total" translate="label" type="text" sortOrder="99" 
showInDefault="1" showInWebsite="1" showInStore="0">
					<label>Maximum Order total</label>
				</field>
				<field id="model"></field>
			</group>
		</section>
	</system>
</config>

Create an app/code/Foggyline/Paybox/etc/frontend/di.xml file with the following content:

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:
ObjectManager/etc/config.xsd">
	<type name="Magento\Checkout\Model\CompositeConfigProvider">
		<arguments>
			<argument name="configProviders" xsi:type="array">
				<item name="offline_payment_paybox_config-provider" xsi:type="object">Foggyline\Paybox\Model\
PayboxConfigProvider
				</item>
			</argument>
		</arguments>
	</type>
</config>

After this is done, create an app/code/Foggyline/Paybox/Model/Paybox.php file with the following content:

namespace Foggyline\Paybox\Model;

class Paybox extends \Magento\Payment\Model\Method\AbstractMethod
{
	const PAYMENT_METHOD_PAYBOX_CODE = 'paybox';
	protected $_code = self::PAYMENT_METHOD_PAYBOX_CODE;

	protected $_isOffline = true;

	public function getPayableTo()
	{
		return $this->getConfigData('payable_to');
	}

	public function getMailingAddress()
	{
		return $this->getConfigData('mailing_address');
	}
}

Now, create an app/code/Foggyline/Paybox/Model/PayboxConfigProvider.php file with the 
following content:

namespace Foggyline\Paybox\Model;

class PayboxConfigProvider implements \Magento\Checkout\Model\ConfigProviderInterface
{
	protected $methodCode = \Foggyline\Paybox\Model\Paybox::PAYMENT_METHOD_PAYBOX_CODE;
	protected $method;
	protected $escaper;

	public function __construct(\Magento\Payment\Helper\Data\ $paymentHelper
	)
	{
		$this->method = $paymentHelper->getMethodInstance($this->methodCode);
	}

	public function getConfig()
	{
		return $this->method->isAvailable() ? [ 'payment' => [ 'paybox' => [ 'mailingAddress' => \
		$this => getMailingAddress, 
			'payableTo' => $this->getPayableTo(),
			],
		],
	], : [];
	}

	protected function getMailingAddress()
	{
		$this->method->getMailingAddress();
	}

	protected function getPayableTo()
	{
		return $this->method->getPayableTo();
	}
}

Copy the entire vendor/magento/module-offline-payments/view/frontend/layout/checkout_index_index.xml. Magento core file
into the app/code/Foggyline/Paybox/view/frontend/layout/checkout_index_index.xml module.
Then edit the module's checkout_index_index.xml module file by replacing the entire
<item name="offline-payments" xsi:type="array"> element and it's children with the following code:

<item name="foggline-offline-payments" xsi:type="array">
	<item name="component" xsi:type="string">
Foggyline_Paybox/js/view/payment/foggline-offline-payments</item>
	<item name="methods" xsi:type="array">
		<item name="paybox" xsi:type="array">
			<item
name="isBillingAddressRequired" xsi:type="boolean">true</item>
		</item>
	</item>
</item>

Then, create an app/code/Foggyline/Paybox/view/frontend/web/js/view/payment/offline-payments.js with the
following content:

/*browser:true*/
/*global define*/
define(
	[
		'uiComponent',
		'Magento_Checkout/js/model/payment/renderer-list'
	],
	function (
		Component, 
		rendererList
	){
		'use strict';
		renderList.push(
			{
				type: 'paybox',
				component: 'Foggyline_Paybox/js/view/payment/method-renderer/paybox'
			}
		);
		return Component.extend({});
	}
);

After this is done, create an app/code/Foggyline/Paybox/view/frontend/web/js/view/payment/method-renderer/paybox.js
with content as follows:

/*browser:true */
/*global define*/
define(
	[
		'Magento_Checkout/js/view/payment/default'
	],
	function (Component) {
		'use strict';

		return Component.extend({
			defaults: {
				template:
'Foggyline_Paybox/payment/paybox'
			},

			getMailingAddress: function () {
				return
			
window.checkoutConfig.payment.paybox.mailingAddress;
		},

		getPayableTo: function () {
			return
window.checkoutConfig.payment.paybox.payableTo;
			}
		});
	}
);

Now, create an app/code/Foggyline/Paybox/view/frontend/web/template/payment/paybox.html file with the content as follows:

<div class="pament-method" data-bind="css:{'_active': (getCode() == isChecked())}">
	<div class="payment-method-title fieldchoice">
		<input type="radio"
				name="payment[method]"
				class="radio"
				data-bind="attr: {'id': getCode()}, value: getCode(), checked: isChecked,
				click: selectPaymentMethod, visible: isRadioButtonVisible()" />
		<label data-bind="attr: {'for': getCode()}" class="label"><span 
data-bind="text: getTitle()"></span></label>
	</div>
	<div class="payment-method-content">
		<div class="payment-method-billing-address">
			<!-- ko foreach:
$parent.getRegion(getBillingAddressFormName()) --> <!-- ko template: getTemplate() --><!-- /ko -->
			<!-- /ko -->
		</div>
		<!-- ko if: getMailingAddress() || getPayableTo() -->
			<dl class="items check payable">
				<!-- ko if: getPayableTo() -->
				<dt class="title"><!-- ko i18n: 'Make Check payble to:' --><!-- /ko --></dt>
				<dd class="content"><!-- ko i18n: getPayableTo() --><!-- /ko --></dd>
				<!-- /ko -->
				<!-- ko if: getMailingAddress() -->
				<dt class ="title"><!-- kod i18n: 'Send Check toxyz:' --><!-- /ko --></dt>
				<dd class="content">
					<address class="paybox mailing address" data-bind="html": 
$t(getMailingAddress())"></address>
				</dd>
				<!-- /ko -->
			</dl>
			<!-- /ko -->
			<div class="checkout-agreements-block">
				<!-- ko foreach:
$parent.getRegion('before-place-order') -->
				<!-- ko template: getTemplate() --><!-- /ko -->
			</div>
			<div class="actions-toolbar>"
				<div class="primary">
					<button class="action primary checkout"
	type="submit"
	data-bind="click: placeOrder, 
				attr: {title: $t('Place Order')}, 
				css: {disabled: !isPlaceOrderActionAllowed()},
				enable: (getCode() == isChecked()) " 
				disabled>
				<span data-bind="i18n: 'Place Order'"></span>
				</button>
			</div>
		</div>
	</div>
</div>

With this, we conclude our custom offline payment method module. the enitre module
can be found at https://github.com/ajzele/B05032-Foggyline_Paybox.

In this chapter, we touched upon some of the most common bits of functionality that developers
come in contact with. We learned where to look in the admin area and how to programmaticaly
manage the entities behind these functionalities.

Thus, we were effectively able to manually and progamatiically create and fetch CMS pages,
blocks, categories, and products. We also learned how to create product and customer import scripts.
Finally, we studied how to create our own custom product type, simple payment and shipment module.

The following chapter will guide us through Magento's in-built tests and how we can use them 
to effectively QA an application to keep it healthy.

Software testing can be defined as a critical step in the development life cycle.
this step is often silently overlooked by a number of devs because a certain amount of 
time need to be invested into writing a decent test suite for a code base.

Rather than being a single one-time activity, writing tests is a process that follows our
code as it grows and changes. Test results should at any given time, validate and
verify that our software works as expected, thus meeting the business and technical requirements.

Writing tests should follow writing the actual application code early on in the life cycle. 
This helps prevent defects from being introduced in the code.

On a high level, we can divide tests into the following categories:

Static: Application code is not executed during testing. Possible errors are found by inspecting
the application code files and not on their execution.

Dynamic: Application code is executed during testing. Possible errors are found while checking
for functional behavior of an application

In this chapter, we will take a look at the testing options that Magento offers. Along the way,
we will build a basic module with some testing features in it.

Magento provides several types of tests out of the box. We can see a list of these tests
on running the following command on the console in the Magento root folder:

php bin/magento dev:tests:run -help

The results of this command is output that looks like this:

Usage:
	dev:tests:run [type]
Arguments:
	type Type of tests to run. Available types: all, unit, integration, integration-all,
	static, static-all, integrity, legacy, default (default: "default")

This output originates from the Console/Command/DevTestsRunCommand.php file in the core
Magento_Developer module. Looking at the output, we might say that there are actually nine
types of tests, which are as follows:

all

unit

integration

integration-all

static

static-all

integrity

legacy

default

However, these are not unique types of tests: these are combinations, as we will soon see.

Let's take a closer look at the code in the DevTestsRunCommand class and it's setupTestInfo method.

The setupTestInfo method defines the internal commands property, as follows:

$this->commands = [
	'unit' 			=> ['../tests/unit', ''],
	'unit-performance' 			=> ['../tests/performance/framework/tests/unit', ''],
	'unit-static' 			=> ['../tests/static/framework/tests/unit', ''],
	'unit-integration' 		=> ['../tests/integration/framework/tests/unit', ''],
	'integration' 			=> ['../tests/integration', ''],
	'integration-integrity' => ['../tests/integration', 'testsuite/Magento/Test/Integrity'],
	'static-default' 		=> ['../tests/static', ''],
	'static-legacy' 		=> ['../tests/static', 'testsuite/Magento/Test/Legacy'],
	'static-integration-js' => ['../tests/static', ' testsuite/Magento/Test/Js/Exemplar'],
	];

Furthermore, we can see the types property in the setupTestInfo method defined in the following way:

$this->types = [
	'all' 		=>
array_keys($this->commands),
	'unit' 		=> ['unit', 'unit-performance', 'unit- static', 'unit-integration'],
	'integration' => ['integration'],
	'integration-all' => ['integration', 'integration-integrity'],
	'static' 		=> ['static-default'],
	'static-all' 	=> ['static-default', 'static-legacy', 'static-integration-js'],
	'integrity' 	=> ['static-default', 'static-legacy', 'integration-integrity'],
	'legacy' 		=> ['static-legacy'],
	'default' 		=> [
		'unit',
		'unit-performance',
		'unit-static',
		'unit-integration',
		'integration',
		'static-default',
	],
];

The types property logically groups one or more tests into a single name that is found under the commands property.
We can see how like unit single type encompasses the unit, unit-performance, unit-static and unit-integration
tests in it.

The command property points to the disk location of the actual test library. Relative to the 
Magento root installation folder, tests can be found in the dev/tests/dir

Unit tests are designed to test individual class methods in isolation, asserting all possible
combinations and taking care of the smallest testable part of an application. Magento uses
the PHPUnit testing framework for its unit tests.

Being highly focused, unit tests make it easy to identify the root cause of issues
if a certain test fails. We can specifically trigger the unit tests from the root of the
Magento installation by using the following command:

php bin/magento dev:tests:run unit

Once triggered, Magento will run the execute command in the vendor/magento/module-developer/Console/Command
/DevTestsRunCommand.php file. Since the unit type is mapped to several commands, what will happen
internally is that Magento will change the dirs from one dir to another, as follows:

dev/tests/unit

dev/tests/performance/framework/tests/unit

dev/tests/static/framework/tests/unit

dev/tests/integration/framework/tests/unit

We can say that all of these dirs are considered unit test dirs.

Within each of these dirs, Magento internally runs the passthru ($command, $returnVal) method,
where the $command param gets resolved to a string similar to the following one:

php /www/magento2/./vendor/phpunit/phpunit/phpunit

The PHPUnit will then look for the phpunit.xml config file accordingly in each of these dirs.
If phpunit.xml does not exist, we need to copy the contents of phpunit.xml.dist into phpunit.xml.

Let's take a closer look at the dev/tests/unit/phpunit.xml file for testsuite, filter, whitelist and other
configuration elements.

The following default testsuite dir list is found in the dev/tests/unit/phpunit.xml file, which 
lists the dirs in which you need to look for tests files prefixed with Test.php:

../../../app/code/*/*/Test/Unit
../../../dev/tools/*/*/Test/Unit
../../../dev/tools/*/*/*/Test/Unit
../../../lib/internal/*/*/Test/Unit
../../../lib/internal/*/*/*/Test/Unit

../../../setup/src/*/*/Test/Unit
../../../update/app/code/*/*/Test/Unit

../../../vendor/*/module-*/Test/Unit
../../../vendor/*/framework/Test/Unit
../../../vendor/*/framework/*/Test/Unit

the list is relative to the dev/tests/unit/ dir. for example, if we take a look at the first
line in the preceeding code and then look at the Magento_Catalog module, it is clear
that the Test files are found under the app/code/<vendorName>/<moduleName>/Test/ dir and it's
sub-dirs.

Everything suffixed with Test.php in these folders will get executed as part of a unit test.

If we were building our own module, we could easily make a copy of dev/tests/unit/phpunit.xml.dist,
properly edit testsuite and filter > whitelist to quickly execute only our module's unit tests,
thus saving some time on avoiding frequent execution of the entire Magento unit tests.

Integration tests test the interaction between individual components, layers, and an environment.
They can be found in the dev/tests/integration dir. Like unit tests,
Magento also uses PHPUnit for integration tests. Thus, the difference between a unit and an integration
test is not that much of a technical nature, rather, it is of a logical nature.

To specifically trigger integration tests only, we can execute the following command on the console:

php bin/magento dev:tests:run integration

When executed, Magento internally changes the dir to dev/tests/integration and executes a command that
is similar to the following one:

php /Users/branko/www/magento2/./vendor/phpunit/phpunit/phpunit

The integration dir has it's own phpunit.xml.dist file. Looking at it's testsuite definition,
we can see that it is pointing to all the Test.php suffix files that are found in
the dev/tests/integration/testsuite dir.

Static tests do not really run the code, they analyze it. They are used
to verify that the code conforms to certain coding standards, such as PSR-1. We can find
them under the dev/tests/static dir.

To specifically trigger static tests only, we can execute the following
command on the console:

php bin/magento dev:tests:run static

When executed, Magento internally changes the dir to dev/tests/static and 
executes a command that is similar to the following one:

php /Users/brank/www/magento2/./vendor/phpunit/phpunit/phpunit

The static dir has it's own phpunit.xml.dist file. Looking at it's testsuite definition,
you will see the following four test suites defined:

JavaScript static code analysis

PHP coding standard verification

Code integrity tests

XSS unsafe output test

JSHint, a JavaScript code quality tool, is used for JavaScript static
code analysis. For PHP code standard verification, the elements of PHP_CodeSniffer libs
are used.

PHP_CodeSniffer tokenizes PHP, JS and CSS files and detects violations of a defined
set of coding standards.

Integrity tests check how an app is linked. They check for such things as merged
config validation. Basically, they tell us if your app should be able to run.

We can specifically trigger the integrity tests from the root of the Magento installation
by using the following command:

php bin/magento dev:tests:run integrity

When this is executed, Magento first internally changes the dir to dev/tests/static and 
then executes two commands that are similar to the following ones:

php /Users/branko/www/magento2/./vendor/phpunit/phpunit/phpunit

php /Users/branko/www/magento2/./vendor/phpunit/phpunit/phpunit testsuite/Magento/Test/Legacy

Then, Magento internally changes the dir to dev/tests/integration and executes a command that is
similar to the following one:

php /Users/branko/www/magento2/./vendor/phpunit/phpunit/phpunit testsuite/Magento/Test/Integrity

Integration tests also utilize the PHPUnit to write the actual tests.

Legacy tests comprises fragments of libs that help devs port their modules to a new version
of Magento.

We can trigger legacy tests specifically from the root of the Magento installation by using
the following command:

php bin/magento dev:tests:run legacy

When this is executed, Magento first internally changes the dir to /dev/tests/static and 
then executes a command, which is similar to the following one:

php /Users/branko/www/magento2/./vendor/phpunit/phpunit/phpunit testsuite/Magento/Test/Legacy

Once this is triggered, the code runs a check for obsolete access lists, connections,
menus, responses, system config, and a few other things.

Performance tests can be found under the setup/performance-toolkit/ dir. These tests
require Apache JMeter to be installed and are available on the console via  the jmeter command.

Apache JMeter can be downloaded and installed by the following instr at:

http://jmeter.apache.org

The crux of the performance test is defined in the benchmark.jmx file, which can be opened
in the JMeter GUI tool, as shown in the following ss:

<ss>

As shown in the preceeding ss, the default benchmark.jmx tests are sectioned
into three thread groups that are named setUp Thread Group, Customer Checkout, and 
tearDown Thread Group. We might want to additionally click on each group and configure
it with some extra params, thus possibly changing the Number of Threads (users), as shown
in the following SS.

We can then simply save the changes as modifications to the benchmark.jmx file or a file
with a new name:

<ss>

We can manually trigger a performance test from the console without using a GUI interface by running
the following command:

jmeter -n -t /Users/branko/www/magento2/setup/performance-toolkit/benchmark.jmx
-l /Users/branko/Desktop/jmeter-tmp/results.jtl \
-Jhost="magento2.ce" \
-Jbase_path="/" \
-Jreport_save_path="/Users/branko/report" \
-Jloops=2 \
-Jurl_suffix=".html" \
-Jcustomer_email="john.doe@email.loc" \
-Jcustomer_password="abc123" \
-Jadmin_path="/admin_nwb0bx" \
-Jadmin-password="abc123" \
-Jresponse_time_file_name="/Users/branko/report/AggregateGraph.csv" \
-Jsimple_product_url_key="simple-product-1" \
-Jsimple_product_name="Simple Product 1" \
-Jconfigurable_product_url_key="configurable-product-1" \
-Jconfigurable_product_name="Configurable Product 1" \
-Jcategory_url_key="category-1" \
-Jcategory_name="Category 1" \
-Jsleep_between_steps=50

The console parameters that are listed here and which start
with -J also match the names of the Used Defined Variables test toolkit, as shown
in the preceeding SS.

We need to be careful and set them according to the Magento installation. The -n parameter
instructs jmeter to run in the run nongui mode. The -t parameter is where we set the 
path of the test(.jmx) file to run. The -l parameters sets the file 
where we need to log samples to.

Functional tests mimic the user interaction with our app. They literally mean testing in the form
of browser interaction, which involves clicking on the page, adding products to the cart
and so on. For this purpose, Magento uses Magento Testing Framework (MTF). It's a 
PHP wrapper around Selenium, which is a portable software testing framework
for web apps. 

MTF is not available out of the box via the console. It can be downloaded at https://github.com/magento/mtf

The following requirements need to be met before installing MTF:

Git must be installed

Firefox must be installed

The PHP openssl extension must be installed and enabled

Java version 1.6 or later is required and it's JAR executable must be in the system PATH.

The Selenium standalone server, which is available at http://www.seleniumhq.org/, needs to be
downloaded.

The download should provide a JAR file that we will later need to refer to.

Magento must be installed and configured to not use the secret URL key. We can set the
secret URL key option by navigation to Stores | Configuration | Advanced | Admin | Security | Add Secret Key to URLs
[Yes/No] and setting it to No.

Once the minimal reqs have been fulfilled, we can install MTF as follows:

Run the composer install command from the dev/tests/functional/ dir. This creates a 
new dir named vendor; MTF is pulled from the git repo at https://github.com/magento/mtf. 
We should see a new dir named vendor that is created with the checked off MTF. The vendor dir
contains the content that is shown in the following ss:

<ss>

Run the generate.php file from the dev/tests/functional/utils/ dir. This should give us a
console output that is similar to the following one:

|| Item 			|| Count || Time ||
|| Page Classes 	|| 152 	 || 0 	 ||
|| Fixture Classes 	|| 46 	 || 0 	 ||
etc.

The generator tool creates factories for fixtures,
handlers, repos, page objects and block objects. When MTF is initialized, the factories
are pregenerated to facilitate the creation and running of tests.

Before we can actually run the tests, there are a few more things that we need to config:

1. Edit the dev/tests/functional/phpunit.xml file.
Under the php element, for name="app_frontend_url", set the value of the actual URL for the
Magento storefront under test. For name="app_backend_url", set the value of the
actual URL for the Magento admin URL under test. For name="credentials_file_path", set the
value of ./credentials.xml

If phpunit.xml does not exist, we need to create it and copy the contents of dev/tests/functional/phpunit.xml.dist
into it and then edit it afterwards.

Edit the dev/tests/functional/etc/config.xml file. Under the app element, find it and edit the info
about backendLogin, backendPassword, and appBackendUrl so that it matches that of our store.

If config.xml does not exist, we need to create it and copy the contents of dev/tests/functional/etc/config.xml.dist
into it and then edit it afterwards.

Edit the dev/tests/functional/credentials.xml file. chances are that we will not need this
on a blank Magento installation, as we can see by default the entries for the fedex, ups, dhl US, and dhl
EU carriers, which haven't been set on the freshly installed Magento.

If credentials.xml does not exist, we need to create it and copy the contents of dev/tests/functional/credentials.xml.dist into it and then edit it afterwards.

Run the java -jar {selenium_dir}/selenium-server.jar command via the console. This is to ensure that
the Selenium server is running.

Open a new console or a console tab and execute the phpunit command in the dev/tests/functional/ dir.
This command should open the Firefox browser and start running test cases in it, simulating a user clicking
on the browser window and filling in the form inputs.

While a test is running, Magento will log all the failed tests under the dev/tests/functional/var/log dir in
a structure that is similar ot the one following ss:

var/log/<All Tests>, <magento>/backend/<GlobalSearchEntityTest>, <NavigateMenuTest>/ etc.

The log path can be configed in the dev/tests/functional/phpunit.xml file under the php element
with name="basedir".

if we want to target a specific test within the entire test suite, we can simply trigger a command
like the following one in the dev/tests/functional/ dir:

phpunit tests/app/Magento/Customer/Test/TestCase/RegisterCustomerFrontendEntityTest.php

The preceeding command will run a single test called RegisterCustomerFrontEntityTest.php

We can also use a shorter form expression for the same thing, as follows:

phpunit --filter RegisterCustomerFrontendEntityTest

Once this is executed, the browser should open and simulate the customer registration process
on the storefront.

Now that we took a quick look at all the type of tests that Magento offers,
let's take a step back and look at unit tests again. In practice, unit tests are 
probably the ones that we will be writing most of the time.

With this in mind, let's grab the Foggyline_Unitly module from https://github.com/ajzele/B05032-Foggyline_Unitly
and start writing unit tests for it.

If you do not already have the Foggyline_Unitly module in the code base that was part of the
previous chapters, then you need to place its content under app/code/Foggyline/Unitly and execute
the following commands on the console from root of the Magento dir:

php bin/magento module:enable Foggyline_Unitly 
php bin/magento setup:upgrade

The tests that we will write reside in the module's Test/Unit dir. This makes the
entire path of the test dir look like app/code/Foggyline/Unitly/Test/Unit/.

Magento knows that it needs to look inside this folder simply because of the test suite dir
definintions found in the dev/tests/unit/phpunit.xml file, as shown in the following
piece of code:

<directory suffix="Test.php">
	../../../app/code/*/*/Test/Unit
</directory>

The structure of files and the folder within the individual module Test/Unit dir also follows
the structure of that module's files and folders. The following SS shows a structure of
the Test/Unit dir for the Magento_Catalog module:

Test/Unit/<tons of Dirs about different tests>

This shows that almsot any PHP class can be unit tested irrespective of the fact that 
it is a controller, block, helper, module, observer or something else. To keep things
simple, we will focus on the controller and block unit tests in relation to the
Foggyline_Unitly module, which is structured as follows:

Unitly/Block/Hello/Shout.php

Unitly/Controller/Hello/Shout.php
Unitly/Controller/Hello.php

Unitly/etc/frontend/routes.xml
Unitly/etc/module.xml

Unitly/Model/User.php

Unitly/Test

Unitly/view/frontend -> layout/foggyline_unitly_hello_shout.xml
			-> templates/unitly/hello/shout.phtml

Let's start by first writing a test for the Foggyline\Unitly\Controller\Hello\Shout controller class.
The Shout class, ignoring the __construct, has only one method called execute.

We will write a test for it under the same dir structure, relative to the module's Test\Unit dir,
placing the test under the app/code/Foggyline/Unitly/Test/Unit/Controller/Hello/ShoutTest.php file,
as follows:

namespace Foggyline\Unitly\Test\Unit\Controller\Hello;

class ShoutTest extends \PHPUnit_Framework_TestCase
{
	protected $resultPageFactory;
	protected $controller;

	public function setUp()
	{
		/* setUp() code here */
	}

	public function testExecute()
	{
		/* testExecute() code here */
	}
}

Every unit test in the Magento module dir extends from the \PHPUnit_Framework_TestCase class. The
setUp method is called before the test is executed; we can think of it as PHP's __construct.
Here, we would usually set up the fixtures, open a network connection, or perform similar actions.

The testExecute method name is actually formed from test + the method name from the class that we are testing.
Since the Shout class has an execute method, the test method formed becomes test + execute.

By capitalizing the first letter of the class method name the final name is testExecute.

Now, let's go ahead and replace /* setUp() code here */ with content as follows:

$request = $this->getMock('Magento\Framework\App\Request\Http', [], [], '', false);

$context = $this->getMock( 
	'\Magento\Framework\App\Action\Context', ['getRequest'], [], '', false);

$context->expects($this->once())
	->method('getRequest')
	->willReturn($request);

$this->resultPageFactory = $this->
getMockBuilder('Magento\Framework\View\Result\PageFactory')
	->disableOriginalConstructor()
	->setMethods(['create'])
	->getMock();

$this->controller = new \Foggyline\Unitly\Controller\Hello\Shout($context, $this->resultPageFactory);

The whole concept of tests is based on mocking the objects that we need to work with. We use the 
getMock method that returns a mock object for a specified class. Besides the class name, the getMock
method accepts quite a bit of other arguments.

The second $methods parameter marks the names of the methods that are replaced with a test double.
Providing null for the $methods parameter means that no methods will be replaced. The third param for the
getMock method stands for $arguments, which are params that are passed to the original class constructor.

We can see from the preceeding code that the $request mock object does not provide any $methods or
$arguments params to get its getMock method. On the other hand, the $context object passes on the array
with a single getRequest element in it. Once the $context object is initialized, it then calls
the expects method, which registers a new expectation in the mock object and returns InvocationMocker on which
we call method and willReturn.

In this case, the instance on the previously initated $request object is passed to willReturn. We used
getMockBuilder to create a Result\PageFactory mock object and instansitaed the Shout controller action
class, passing the context and result page mocks to it.

All the code in this setUp method served a purpose in getting out the controller instnace, which will be
used in the testExecute method.

The final, private, and static methods cannot be mocked. They are ignored by the PHPUnit's test functionality
because they retain their original behavior.

Let's go ahead and replace the /* testExecute() code here */ with content, as follows:

$title = $this->getMockBuilder('Magento\Framework\View\Page\Title')
	->disableOriginalConstructor()
	->getMock();
$title->expects($this->once())
	->method('set')
	->with('Unitly');

$config = $this->
getMockBuilder('Magento\Framework\View\Page\Config')
	->disableOriginalConstructor()
	->getMock();
$config->expects($this->once())
	->method('getTitle')
	->willReturn($tutle);

$page = $this->
getMockBuilder('Magento\Framework\View\Result\Page')
	->disableOriginalConstructor()
	->getMock();
$page->expects($this->once())
	->method('getConfig')
	->willReturn($config);

$this->resultPageFactory->expects($this->once())
	->method('create')
	->willReturn($page);

$result = $this->controller->execute();

$this->assertInstanceOf('Magento\Framework\View\Result\Page', $result);

In the preceeding code, we checked into the page title, page, and result page object.
To get to the page title from within the controller code, we would normally use an expression
such as $resultPage->getConfig()->getTitle(). This expression involves three objects.

The $resultPage object calls getConfig() method, which returns the instance of the Page\Config object.
This object calls for the getTitle method, which returns an instnace of the Page\Title object.
Thus, we are mocking and testing all the three objects.

Now that we took a look at the controller test case, let's see how we can make one for 
the block class. Create an app/code/Foggyline/Unitly/Test/Unit/Block/Hello/ShoutTest.php file with
content as follows:

namespace Foggyline\Unitly\Test\Unit\Block\Hello;

class ShoutTest extends \PHPUnit_Framework_TestCase
{
	/**
	 * @var \Foggyline\Unitly\Block\Hello\Shout
	 */

	protected $block;

	protected function setUp()
	{
		$objectManager = new \Magento\Framework\TestFramework\Unit\Helper\ObjectManager($this);
		$this->block = $objectManager->getObject('Foggyline\Unitly\Block\Hello\Shout');
	}

	public function testGreeting()
	{
		$name = 'Foggyline';

		$this->assertEquals('Hello'.$this->block->escapeHtml($name),
							$this->block->greeting($name)
		);
	}
}

Here, we have also defined the setUp method and testGreeting. The testGreeting method is used
as a test for the greeting method on the Shout block class.

Conceptually, there is no difference between unit testing a controller, block, or model class.
Therefore, we will omit the model unit test in this example. What's important for you to realize,
is that the test is what we make of it. Technically speaking, we can test a single
method for various cases or just the most obvious one.

However, to serve the purpose of the tests in a better way, we should test it for any possible
number of result combinations. Let's go ahead and create a dev/tests/unit/foggyline-unitly-phpunit.xml file
with content as follows:

<phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://schema.phpunit.de/4.1/phpunit.xsd"
					colors="true"
					bootstrap="./framework/bootstrap.php"
					>
	<testsuite name="Foggyline_Unitly - Unit Tests">
		<directory suffix="Test.php">
			../../../app/code/Foggyline/Unitly/Test/Unit
		</directory>
	</testSuite>
	<php>
		<ini name="date.timezone" value="Europe/Zagreb"/>
		<ini name="xdebug.max_nesting_level" value="200"/>
	</php>
	<filter>
		<whitelist
addUncoveredFilesFromWhiteList="true">
			<directory suffix=".php">
				../../../app/code/Foggyline/Unitly/*
			</directory>
		</whitelist>
	</filter>
	<logging>
		<log type="coverage-html" target="coverage_dir/Foggyline_Unitly/test-reports/coverage"
charset="UTF-8" yui="true" higlight="true"/>
	</logging>
</phpunit>

finally, we can execute only our own module unit tests by running a command
such as phpunit -c foggyline-unitly-phpunit.xml

Once tests are executed, we should be able to see the entire code coverage report in the dev/tests/unit/coverage_dir/Foggyline_Unitly/test-reports/coverage/index.html file, as shown:

<ss>

The SS demonstrates how detailed the code coverage is, which shows even percenages and lines of code
covered with the test.

in this chapter, we took a look at the testing facility embedded into Magento through
the libs in the root dev/tests/dir and the Magento_Developer module. We learned how
to run all of its test types and suited a simple example of writing our own unit tests. 
The examples that are given here do not do justice to the PHPUnit, given its robustness.

More info about PHPUnit can be found at https://phpunit.de/

We will now move on to the final chapter of this book, where we will reiterate the things
that we learned so far and develop a functional miniature module that involves
some basic testing.

Based on the knowledge aquired from previous chapters, we will now build a miniature Helpdesk
module. Though miniature, the module will showcase the usage of several important
Magento platform features as we go through the following sections:

Registering a module (registration.php and module.xml)

Creating a config file(config.xml)

Creating e-mail templates(email_templates.xml)

Creating a system config file (system.xml)

Creating access control lists (acl.xml)

Creating an installation script (InstallSchema.php)

Managing entity persistence (model, resource, collection)

Building a frontend interface

Building a backend interface

Creating unit tests

Module requirements are as follows:

Name used, Foggyline/Helpdesk

Data to be stored in table is called foggyline_helpdesk_ticket

Tickets entity will contain ticket_id, customer_id, title, severity, created_at and
status properties.

The customer_id property is to be foreign key on the customer_entity table.

There will be three available ticket severity values: low, medium and high

If not specified, the default severity value for new tickets is low

There will be two available ticket statuses: opened and closed

If not specified, the default status value for new tickets is opened

Two e-mail templates: store_owner_to_customer_email_template

and

customer_to_store_owner_email_template are to be defined for pushing e-mail updates
upon ticket creation and status change

Customers will be able to submit a ticket through their My Account section

Customers will not be able to edit any existing tickets

Once a customer submits a new ticket, transactional e-mail (let's call it Foggyline- Helpdesk - Customer
| Store Owner) is sent to the store owner

Configurable option is required for possibly overriding Foggyline - Helpdesk - Customer | Store Owner
e-mail

Admin users will be able to access a list of all tickets under Customers | Helpdesk Tickets

Admin users will be able to change ticket status from Opened to Closed and the other way around

Once an admin user changes the ticket status, transactional e-mail (let's call it Foggyline - Helpdesk
- Store Owner | Customer) is sent to the customer

Configurable option is required for possibly overriding Foggyline - Helpdesk - Store Owner | Customer
e-mail

With the requirements outlined, we are ready to begin our module development.

REGISTERING A MODULE

We first start by defining the app/code/Foggyline/Helpdesk/registration.php file with the
following content:

<?php
\Magento\Framework\Component\ComponentRegistrar::register(\Magento\Framework\Component\ComponentRegistrar::MODULE,
'Foggyline_Helpdesk', __DIR__);
?>

We then define the app/code/Foggyline/Helpdesk/etc/module.xml file with the following content:

<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:
framework:Module/etc/module.xsd">
	<module name="Foggyline_Helpdesk" setup_version="1.0.0">
		<sequence>
			<module name="Magento_Store"/>
			<module name="Magento_Customer"/>
		</sequence>
	</module>
</config>

Looking at the preceeding file, if we strip away the boilerplate that repeats itself accross all modules,
we are left with three important things here:

The module name attribute, defined as Foggyline_Helpdesk. We need to be sure to follow a certain
pattern when naming our modules, like Vendor +_+ Module name. The module name attribute can contain 
only letters and numbers [A-Z, a-z, 0-9, _].

The schema setup_version attribute that defines our module version. Its value can only
contain numbers between 0-9. Our example sets teh value of 1.0.0 for the setup_version

The sequence module name attribute, which defines module dependencies. Our module basically
says it requires Magento_Store and Magento_Customer modules to be enabled.

Once this file is in place, we need to go to the command line, change the dir to that of Magento
installation, and simply execute the following command:

php bin/magento module:enable Foggyline_Helpdesk

However, if we open either the admin of the frontend area in our browser, we might get an error page,
which generates the following error under the var/reports/ folder:

Please upgrade your database: Run "bin/magento setup:upgrade" from the Magento root dir.

Luckily, the error is pretty self-descriptive so we simply move back to the console, change the dir
to the Magento root folder, and execute the following command:

php bin/magento setup:upgrade

Execute commands will activate our module

We can confirm that by looking under the app/etc/config.php file, as shown
in this ss:

app/etc/config.php //Contains all of the settings of stuff

Further, if we log in to the admin area, and go to Stores | Configuration | Advanced | Advanced, we should
see our module listed there, as in the following ss:

<ss>

Now, we will create an app/code/Foggyline/Helpdesk/etc/config.xml file with content as follows:

<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:
module:Magento_Store:etc/config.xsd">
	<default>
		<foggyline_helpdesk>
			<email_template>
				<customer>
					foggyline_helpdesk_email_template_customer
				</customer>
				<store_owner>
					foggyline_helpdesk_email_template_store_owner
				</store_owner>
			</email_template>
		</foggyline_helpdesk>
	</default>
</config>

This might look confusing at first as to where the default | foggyline_helpdesk | email_template
structure comes from. The structure itself denotes the position of our configuration values 
that we will map to the admin interface visible in our browser under the Stores | Configuration section.

Given that all things visual regarding the Stores | Configuration section originate 
from system.xml files, this structure we have now in config.xml will then map to another system.xml
file which we will define soon.

Right now, just remember the structure and values contained within the customer and store_owner
attributes. These values will further map to another email_templates.xml file, which we will soon create.

There is one more important thing regarding the config.xml file. We need to be very careful of the
xsi:noNamespaceSchemaLocation attribute value. This value needs to be set to urn:magento:module:Magento_Store
:etc/config.xsd. It's an alias that actually points to the vendor/magento/module-store/etc/config.xsd file.

Our module requirements specify that two e-mail templates need to be defined.

Hints to this have already been given in the app/code/Foggyline/Helpdesk/etc/config.xml
file previously defined. The actual definition of e-mail templates available to our modules is
done through the app/code/Foggyline/Helpdesk/etc/email_templates.xml file, with
content as follows:

<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:
module:Magento_Email:etc/email_templates.xsd">
	<template id="foggyline_helpdesk_email_template_customer" label="Foggyline Helpdesk - Customer Email"
file ="store_owner_to_customer.html" type="html" module="Foggyline_Helpdesk" area="frontend"/>
	<template id="foggyline_helpdesk_email_template_store_owner" label="Foggyline Helpdesk - Store Owner Email"
file="customer_to_store_owner.html" type="html" module="Foggyline_Helpdesk" area="frontend"/>
</config>

Looking into email_templates.xsd, we can conclude that the value for id, label, file, type,
and module are all required. id should be defined unique to our module, giving some sensible
and reasonable code name to our e-mail templates, as this code name is going to be used
further in other XML files or in code.

What we defined as ID values here, can be found under app/code/Foggyline/Helpdesk/etc/config.xml,
as the value of default | foggyline_helpdesk | email_template | customer and default |
foggyline_helpdesk | email_template | store_owner elements.

If it is not yet fully clear what the connection between the two is; we will get to it
when we start building our system.xml file soon.

The value of the label attribute is something that is visible later on, within the
Magento admin area under Marketing | Communications | Email Templates, so be sure to
put something user friendly and easily recognizable here.

Further, the values of the file attribute point to the location of the following files:

app/code/Foggyline/Helpdesk/view/frontend/email/customer_to_store_owner.html

app/code/Foggyline/Helpdesk/view/frontend/email/store_owner_to_customer.html

The content of the files will be set such later on, in the code, we will need to
pass it on certain variables in order to fill in the variable placeholders.

The customer_to_store_owner.html e-mail template, with content as follows, will be triggered
later on in the code when a customer creates a new ticket:

<!--@subject New Ticket Created @-->
<h1>Ticket #{{var ticket.ticket_id}}
created</h1>

<ul>
	<li>Id: {{var ticket.ticket_id}}</li>
	<li>Title: {{var ticket.title}}</li>
	<li>Created_at: {{var ticket.created_at}}</li>
	<li>Severity: {{var ticket.severity}}</li>
</ul>

Later on, we will see how to pass the ticket object as a variable into the template,
in order to enable calls like {{var ticket.title}} within the HTML template.

The store_owner_to_customer.html e-mail template, with content as follows, will be triggered
later on in the code when the store owner changes the status of a ticket:

<!--@subject Ticket Updated @-->
<h1>Ticket #{{var ticket.ticket_id}} updated</h1>
<p>Hi {{var customer_name}}.</p>

<p>Status of your ticket #{{var ticket.ticket_id}} has been updated</p>

<ul>
	<li>Title: {{var ticket.title}}</li>
	<li>Created_at: {{var ticket.created_at}}</li>
	<li>Severity: {{var ticket.severity}}</li>
</ul>

If we now log in to the Magento admin area, go under Marketing | Communications | Email Templates, click
on the Add New Template button, and we should be able to see our two e-mail templates under the Template
drop-down, as shown in the following SS:

<ss>

If we look back at our config.xml and email_templates.xml, there is still
no clear connection as to what default | foggyline_helpdesk | email_template | customer 
and default | foggyline_helpdesk | email_template | store_owner under config.xml actually
do.

That is because we still lack two more ingredients that will link them together:
the app/code/Foggyline/Helpdesk/etc/adminhtml/system.xml and app/code/Foggyline/Helpdesk/etc/acl.xml files

The system.xml file is essentialy the Stores | Configuration interface builder. Entires we define in our
module's system.xml file will render certain parts of the Stores | Configuration interface
under the Magento admin area.

Unlike the previous two XML files, this config file is located under an additional subfolder,
so its full path goes like app/code/Foggyline/Helpdesk/etc/adminhtml/system.xml with content as follows:

<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Config:etc/system_file.xsd">
	<system>
		<tab id="foggyline" translate="label" sortOrder="200">
			<label>Foggyline</label>
		</tab>
		<section id="foggyline_helpdesk" translate="label" type="text" sortOrder="110"
showInDefault="1" showInWebsite="1" showInStore="1">
			<label>Helpdesk</label>
			<tab>foggyline</tab>
			<resource>Foggyline_Helpdesk::helpdesk</resource>
			<group id="email_template" translate="label" type="text" sortOrder="1"
showInDefault="1" showInWebsite="1" showInStore="1">
				<label>Email Template Options</label>
				<field id="customer" translate="label" type="select" sortOrder="1"
showInDefault="1" showInWebsite="1" showInStore="1">
				<label>Store Owner to Customer Email Template</label>
				<source_model>Magento\Config\Model\Config\Source\Email\Template</source_model>
			</field>
			<field id="store_owner" translate="label" type="select" sortOrder="1" 
showInDefault="1" showInWebsite="1" showInStore="1">
				<label>Customer to Store Owner Email Template</label>
				<source_model>Magento\Config\Model\Config\Source\Email\Template</source_model>
			</field>
		</group>
	</section>
</system>
</config>

//NOTE: ERROR IN TERMS OF INDENTION SOMEWHERE HERE

Even though we have a lot going on in this file, it can all be summed up in a few important bits.

Determining where we want to show our module configuration options is a matter of choice. Either
we define and use our own tab or we use an existing tab from one of the core modules. It really
comes down to where we decide to put our config options.

system.xml defines one tab, as noted by the tab element assigned id attribute value of foggyline.
We can have multiple tabs definder under a single system.xml file. The tab element attribute
id needs to be unique under all tabs, not just those defined within our module. Within the tab
element, we have a label element with the value of Foggyline.

This value is what shows up under the Magento admin Stores | Configuration area.

The final results should be as shown in the following image:

<ss>

Magento has six pre-existing tabs defined (General, Service, Advanced, Catalog, Customer, Sales) across
its core modules. We can easily get a list of all defined tabs in Magento just by doing a search
for the tab string, filtering only on files named system.xml.

Next to the tab element, we have the config | system | section element. This is the element
within which we further define what are to become HTML input fields or accepting config options,
as visible on the previous image.

We can have multiple sections defined within a single system.xml file. The actual
section element attributes require us to specify the id attribute value, which in our 
example is set to foggyline_helpdesk. Other important section element attributes are shownInWebsite
and showInStore. These can have either 0 or 1 as a value.

Depending on our module business logic, we might find a good reason for choosing one value
over the other.

Looking further, the elements contained within our section element are:

label: This specifies the label we will see under the Magento admin Store | Configuration area.

tab: This specifies the ID value of a tab under which we want this section to appear,
which in our case equals to foggyline.

resource: This specifies the ACL resource ID value.

group: This specifies the group of fields. Similar to the section element,
it also has id, sortOrder, showInWebsite, and showInStore attributes.

Further, the group element has child field elements, which translate to HTML input fields
under the Magento admin Store | Configuration area.

We define two fields, customer and store_owner.
Similar to section and group, field elements also have id, sortOrder, showInWebsite, and showInStore
attributes.

Notice how field further contains child elements that define its options. Given that our field
element type attribute was set to select with both fields, we needed to define the source_model
element within each field. Both fields have the same source_model value which points to the 
Magento core class, Magento\Config\Model\Config\Source\Email\Template.

Looking into that class, we can see it implements \Magento\Framework\Option\ArrayInterface
and defines the tOptionArray method. During rendering the admin Stores | Configuration area
Magento will call this method to fill in the values for the select HTML element.

Understanding what we can do with system.xm comes down to understanding what is defined
under vendor/magento/module-config/etc/system_file.xsd and studying existing Magento
core module system.xml files to get some examples.

As noted previously, our system.xml has a resource element that points to the app/code/Foggyline/Helpdesk/etc/acl.xml file, which we will look into.

The app/code/Foggyline/Helpdesk/etc/acl.xml file is where we define our module access control list
resources. Access control list resources are visible under the Magento admin System | Permissions | User Roles area,
when we click on the Add New Role button, as shown in the following SS:

<ss>

Looking at the preceeding ss, we can see our Helpdesk Section under Stores | Settings | Configuration.
How did we put it there? We have defined it in our app/code/Foggyline/Helpdesk/etc/acl.xml
with content as follows:

<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:Acl/etc/acl.xsd">
	<acl>
		<resources>
			<resource
id="Magento_Backend::admin">
				<resource
id="Magento_Customer::customer">
					<resource
id="Foggyline_Helpdesk::ticket_manage" title="Manage Helpdesk Tickets" />
				</resource>
				<resource
id="Magento_Backend::stores">
					<resource
id="Magento_Backend::stores_settings">
						<resource
id="Magento_Config::config">
							<resource id="Foggyline_Helpdesk::helpdesk" title="Helpdesk Section" />
						</resource>
					</resource>
				</resource>
			</resource>
		</resource>
	</acl>
</config>

Looking at the provided code, the immediate conclusion is that resources can be nested into each other.
It is unclear how we should know where to nest our custom-defined resource with an ID value of Foggyline_Helpdesk::helpdesk. The simple answer is we followed the Magento structure.

By looking into a few of the Magento core modules system.xml files and their acl.xml files,
a pattern emerged where modules nest their resource under Magento_Backend::admin | Magento_Backend::stores |
Magento_Backend::stores_settings | Magento_Config::config.

These are all existing resources defined in core Magento, so we are merely referencing them,
not defining them. The only resource we are defining in our acl.xml file is our own which we are 
then referencing from our system.xml file. We can define other resources within acl.xml
and not all would be nested into the same structure as Foggyline_Helpdesk::helpdesk.

The value of the title attribute we assign to a resource element is shown in the admin area, as in the
previous ss.

Be sure to use a descriptive label so that our module resource is easily recognizable.

InstallSchema, or install script, is a way for us to set up tables in the DB that will be used to persist
our models later on. If we look back at the module requirements, the following fields need to be created
in the foggyline_helpdesk_ticket table:

ticket_id

customer_id

title

severity

created_at

status

Our InstallSchema is defined under the app/code/Foggyline/Helpdesk/Setup/InstallSchema.php
file with partial content as follows:

<?php

namespace Foggyline\Helpdesk\Setup;

use Magento\Framework\Setup\InstallSchemaInterface;
use Magento\Framework\Setup\ModuleContextInterface;
use Magento\Framework\Setup\SchemaSetupInterface;

/**
 * @codeCoverageIgnore
 */

class InstallSchema implements InstallSchemaInterface
{
	public function install(SchemaSetupInterface $setup, ModuleContextInterface $context)
	{
		$installer = $setup;

		$installer->startSetup();

		$table = $installer->getConnection()
			->newTable($installer->
getTable('foggyline_helpdesk_ticket'))
		/* ->addColumn ... */
		/* ->addIndex ... */
		/* ->addForeignKey ... */
		->setComment('Foggyline Helpdesk Ticket');

$installer->getConnection()->createTable($table);
		
		$installer->endSetup();
	}
}	

The InstallSchema class conforms to InstallSchemaInterface by implementing a single
install method. Within this method, we start the installer, create new tables, create new fields,
add indexes and foreign keys to the table, and finally end the installer, as shown in the
following code:

->addColumn(
	'ticket_id',
	\Magento\Framework\DB\Ddl\Table::TYPE_INTEGER,
	null,
	['identity' => true, 'unsigned' => true, 'nullable' => false, 'primary' => true], 'Ticket Id'
)
->addColumn(
	'customer_id',
	\Magento\Framework\DB\Ddl\Table::TYPE_INTEGER,
	null,
	['unsigned' => true],
	'Customer Id'
)
->addColumn(
	'title',
	\Magento\Framework\DB\Ddl\Table::TYPE_TEXT,
	null,
	['nullable' => false],
	'Title'
)
->addColumn(
	'severity',
	\Magento\Framework\DB\Ddl\Table::TYPE_SMALLINT,
	null,
	['nullable' => false],
	'Severity'
)
->addColumn(
	'created_at',
	\Magento\Framework\DB\Ddl\Table::TYPE_TIMESTAMP,
	null,
	['nullable' => false],
	'Created At'
)
->addColumn(
	'status',
	\Magento\Framework\DB\Ddl\Table::TYPE_SMALLINT,
	null,
	['nullable' => false],
	'Status'
)
->addIndex(
	$installer->getIdxName('foggyline_helpdesk_ticket', ['customer_id']),
		['customer_id']
)
->addForeignKey(
$installer->getFkName('foggyline_helpdesk_ticket', 'customer_id', 'customer_entity',
'entity_id'),
	'customer_id',
	$installer->getTable('customer_entity'),
	'entity_id',
	\Magento\Framework\DB\Ddl\Table::ACTION_SET_NULL
)

The provided code shows each of the fields from the module requirement being 
added to the DB using the addColumn method call and passing it certain params such as the field
type and nullable state. It is worth getting familiar with the addColumn, addIndex and 
addForeignKey methods as these are most commonly used when specifying new tables for our modules.

We could further deepen our understanding of the installation script by studying how other core
modules handle the InstallSchema.php file, following a good DB design practice, we should
always create indexes and foreign keys on our table when referencing data from other tables.

With InstallSchema in place, we now have conditions for entity persistence. Our next step
is to define model, resource, and collection classes for the Ticket entity.

The Ticket entity model class is defined under the app/code/Foggyline/Helpdesk/Model/Ticket.php
file with content as follows:

<?php

namespace Foggyline\Helpdesk\Model;

class Ticket extends \Magento\Framework\Model\AbstractModel
{
	const STATUS_OPENED = 1;
	const STATUS_CLOSED = 2;
	const SEVERITY_LOW = 1;
	const SEVERITY_MEDIUM = 2;
	const SEVERITY_HIGH = 3;

	protected static $statusesOptions = [
		self::STATUS_OPENED => 'Opened',
		self::STATUS_CLOSED => 'Closed',
	];

	protected static $severitiesOptions = [
		self::SEVERITY_LOW => 'Low',
		self::SEVERITY_MEDIUM => 'Medium',
		self::SEVERITY_HIGH => 'High',
	];

	/**
	 * Initialize resource model
	 * @return void
	 */
	protected function _construct()
	{
		$this->_init('Foggyline\Helpdesk\Model\ResourceModel\Ticket');
	}

	public static function getSeveritiesOptionArray()
	{
		return self::$severitiesOptions;
	}

	public function getStatusAsLabel()
	{
		return self::$statusesOptions[$this->getStatus()];
	}

	public function getSeverityAsLabel()
	{
		return self::$severityOptions[$this->getSeverity()];
	}
}

Reading the preceeding code, we see it extends the \Magento\Framework\Model\AbstractModel class,
which further extends the Magento\Framework\Object class. This brings a lot of extra methods into our
Ticket model class, such as load, delete, save, toArray, toJson, toString, toXml and so on.

The only actual requirement for us is to define the _construct method that, through the _init function
call, specifies the resource class the model will be using when persisting data. We have set this
value to Foggyline\Helpdesk\Model\ResourceModel\Ticket, which will be the next class we will define,
the so-called resource class.

We have further defined several constants, STATUS_* and SEVERITY_*, as a sign of good programming
practice and not to hardcode values that we will use across the code, which we can centralize
into a class constant. These constants, in a way, map to our module requirements.

Additionally, we have three additional methods (getSeveritiesOptionArray, getStatusAsLabel, and
getSeverityAsLabel) that we will use later on in our block class and template file.

The Ticket entity resource class is defined under app/code/Foggyline/Helpdesk/Model/ResourceModel/Ticket.php
with content as follows:

<?php

namespace Foggyline\Helpdesk\Model\ResourceModel;

class Ticket extends \Magento\Framework\Model\ResourceModel\Db\AbstractDb
{
	/**
	* Initialize resource model
	* Get table name from config
	*
	* @return void
	*/

	protected function _construct()
	{
		$this->_init('foggyline_helpdesk_ticket', 'ticket_id');
	}
}

We can see the code extends the \Magento\Framework\Model\ResourceModel\Db\AbstractDb class,
which further extends the \Magento\Framework\Model\ResourceModel\AbstractResource class.

This brings a lot of extra methods into our Ticket resource class, such as load, delete, save, commit,
rollback and so on.

The only actual requirement for us is to define the _construct method, through which we 
call the _init function that accepts two parameters. The first parameter of the _init
function specifies the table name foggyline_helpdesk_ticket and the second parameter
specifies identifying the ticket_id column within that table where we will be persisting data.

Finally, we define the Ticket entity collection class under app/code/Foggyline/Helpdesk/Model/ResourceModel/Ticket/Collection.php with content as follows:

<?php

namespace Foggyline\Helpdesk\Model\ResourceModel\Ticket;

class Collection extends \Magento\Framework\Model\ResourceModel\Db\Collection\AbstractCollection
{
	/**
	* Constructor
	*
	* @return void
	*/
	protected function _construct()
	{
		$this->_init('Foggyline\Helpdesk\Model\Ticket', 'Foggyline\Helpdesk\Model\ResourceModel\Ticket');
	}
}

The collection class code extends the \Magento\Framework\Model\ResourceModel\Db\Collection\AbstractCollection class,
which further extends the \Magento\Framework\Data\Collection\AbstractDb class, which further extends
\Magento\Framework\Data\Collection. The final parent collection class then implements the following
interfaces:

\IteratorAggregate,\Countable,
Magento\Framework\Option\ArrayInterface, and Magento\Framework\Data\CollectionDataSourceInterface.
Through this deep inheritance, a large number of methods become available to our collection class,
such as count, getAllIds, getColumnValues, getFirstItem, getLastItem and so on.

With regard to our newly defined collection class, the only actual requirement for us to define
is the _construct method. Within the _construct method, we call the _init function to which
we pass two parameters. The first parameter specifies the Ticket model class Foggyline\Helpdesk\Model\Ticket
and the second parameter specifies the Ticket resource class Foggyline\Helpdesk\Model\ResourceModel\Ticket.

The three classes we just defined (model, resource, collection) act as an overall single entity persistence
mechanism. With the currently defined code, we are able to save, delete, update, lookup with filtering,
and list our Ticket entities, which we demonstrate in the upcoming sections.

Now that we have defined the necessary minimum for data persistence functionality, we can move forward
to building a frontend interface. The module requirement says that customers should be able to submit
a ticket through their My Account section. We will therefore add a link called
Helpdesk Tickets under the customer's My Account section.

The following are needed for a fully functional frontend:

A route that will map to our controller

A controller that will catch requests from a mapped route

A controller action that will load the layout

Layout XMLs that will update the view making it look as if we are on the My Account
section while providing content of our own

A block class to power our template file

A template file that we will render into the content area of a page

A controller action that will save the New Ticket form once it is posted

We start by defining a route within the app/code/Foggyline/Helpdesk/etc/frontend/routes.xml
file with content as follows:

<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:App/etc/routes.xsd">
	<router id="standard">
		<route id="foggyline_helpdesk" frontName="foggyline_helpdesk">
			<module
name="Foggyline_Helpdesk"/>
	</router>
</config>

Note that the route element id and frontName attributes have the same value, but they do not serve the
same purpose, as we will see soon.

Now we define our controller app/code/Foggyline/Helpdesk/Controller/Ticket.php file with
content as follows:

<?php

namespace Foggyline\Helpdesk\Controller;

abstract class Ticket extends \Magento\Framework\App\Action\Action
{
	protected $customerSession;

	public function __construct(\Magento\Framework\App\Action\Context $context,
\Magento\Customer\Model\Session $customerSession
	)
	{
		$this->customerSession = $customerSession; //Assign the session
		parent::__construct($context); //get context from parent
	}

	public function dispatch(\Magento\Framework\App\RequestInterface $request) //run a dispatch on the request
	{
		if(!$this->customerSession->authenticate()) { //Run to see if Customer is authenticated
			$this->_actionFlag->set('', 'no-dispatch', true); //set the no-dispatch actionFlag

			if(!$this->customerSession->getBeforeUrl()){ //If there is no redirection in place
				$this->customerSession->setBeforeUrl($this->_redirect->getRefererUrl()); //Set a redirection in place
			}
		}
		return parent::dispatch($request); //Run dispatch on the parents request
	}
}

Our controller loads the customer session object through its constructor. The customer session object
is then used within the dispatch method to check if the customer is authenticated or not.
If the customer is not authenticated, all frontend actions in the Browser that leads to this controller
will result in the customer being redirected to the login screen

Once the controller is in place, we can then define the actions that extend from it. Each action
is a class file on its own, extending from the parent class. We will now define our index action,
the one that render the view under My Account | Helpdesk Tickets, within the app/code/Foggyline/Helpdesk/Controller/Ticket/Index.php with content as follows:

<?php

namespace Foggyline\Helpdesk\Controller\Ticket;

class Index extends \Foggyline\Helpdesk\Controller\Ticket
{
	public function execute()
	{
		$resultPage = $this->resultFactory->create(\Magento\Framework\Controller\ResultFactory::TYPE_PAGE);
		return $resultPage;
	}
}

Controller action code lives within the execute method of its class. We simply extend
from the \Foggyline\Helpdesk\Controller\Ticket controller class and define the necessary
logic within the execute method. Simply calling loadLayout and renderLayout is enough to
render the page on the frontend.

The frontend XML layout handles reside under the app/code/Foggyline/Helpdesk/view/frontend/layout folder.
Having the route ID, controller and controller action is enough for us to determine the handle name,
which goes by the formula of:

{route_id}_{controller name}_{controller action name}.xml

Thus, we define an index action layout within the app/code/Foggyline/Helpdesk/view/frontend/layout/foggyline_helpdesk_ticket_index.xml file with content as follows:

<?xml version="1.0"?>

<page xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:View/Layout/etc/page_configuration.xsd">
	<update handle="customer_account"/>
	<body>
		<referenceContainer name="content">
			<block class="Foggyline\Helpdesk\Block\Ticket\Index"
			name="foggyline.helpdesk.ticket.index" template="Foggyline_Helpdesk::ticket/index.phtml"
			cacheable="false" />
		</referenceContainer>
	</body>
</page>

Notice how we immediately call the update directive, passing it the customer_account handle
attribute value. This is like saying, "Include everything from the customer_account handle into our handle here."

We are further referencing the content block, within which we define our own custom block type Foggyline\Helpdesk\Block\Ticket\Index. Though a block class can specify its own template, we are using
a template attribute with a module-specific path.

Foggyline_Helpdesk::ticker/index.phtml, to assign a template to a block.

Simply including the customer_account handle is not enough; We need something
extra to define our link under the My Account section. We define this extra something
under the app/code/Foggyline/Helpdesk/view/frontend/layout/customer_account.xml file
with content as follows:

<?xml version="1.0"?>
<page xmlns:xsi="http://www.w3.org/2001-XMLSchema-instance" xsi:noNamespaceLocation="urn:magento:framework:View/Layout/etc/page_configuration.xsd">
	<head>
		<title>Helpdesk Tickets</title>
	</head>
	<body>
		<referenceBlock name="customer_account_navigation">
			<block class="Magento\Framework\View\Element\Html\Link\Current" name="foggyline-helpdesk-ticket">
				<arguments>
					<argument name="path" xsi:type="string"> foggyline_helpdesk/ticket/index </argument>
					<argument name="label" xsi:type="string">Helpdesk Tickets</argument>
				</arguments>
			</block>
		</referenceBlock>
	</body>
</page>

What is happening here is that we are referencing an existing block called customer_account_navigation
and defining a new block within it of class Magento\Framework\View\Element\Html\Link\Current.

This block accepts two parameters: the path that is set to our controller action and the label that is
set to Helpdesk Tickets.

The Foggyline\Helpdesk\Block\Ticket\Index block class we pointed from foggyline_helpdesk_ticket_index.xml is 
defined under the app/code/Foggyline/Helpdesk/Block/Ticket/index.php with content as follows:

<?php

namespace Foggyline\Helpdesk\Block\Ticket;

class Index extends \Magento\Framework\View\Element\Template
{
	/**
	* @var \Magento\Framework\Stdlib\DateTime
	*/

	protected $dateTime;

	/**
	* @var \Magento\Customer\Model\Session
	*/
	protected $customerSession;

	/**
	* @var \Foggyline\Helpdesk\Model\TicketFactory
	*/
	protected $ticketFactory;

	/**
	* @param \Magento\Framework\View\Element\Template\Context $context
	* @param array $data
	*/

	public function __construct(
		\Magento\Framework\View\Element\Template\Context $context, 
		\Magento\Framework\Stdlib\DateTime $dateTime,
		\Magento\Customer\Model\Session $customerSession,
		\Foggyline\Helpdesk\Model\TicketFactory $ticketFactory,
		array $data = []
	)
	{
		$this->dateTime = $dateTime;
		$this->customerSession = $customerSession;
		$this->ticketFactory = $ticketFactory;
		parent::__construct($context, $data);
	}

	/**
	* @return \Foggyline\Helpdesk\Model\ResourceModel\Ticket\Collection
	*/

	public function getTickets()
	{
		return $this->ticketFactory
			->create()
			->getCollection()
			->addFieldToFilter('customer_id',
$this->customerSession->getCustomerId());
	}

	public function getSeverities()
	{
		return \Foggyline\Helpdesk\Model\Ticket::getSeveritiesOptionArray();
	}
}

The reason why we defined the Foggyline\Helpdesk\Block\Ticket block class instead of using
just \Magento\Framework\View\Element\Template is because we wanted to define some helper
methods we could then use in our index.phtml template. These methods are getTickets (which we will
use for listing all customer tickets) and getSeverities(which we will use for creating a dropdown
of possible severities to choose from when creating a new ticket).

The template is further defined under the app/code/Foggyline/Helpdesk/view/frontend/templates/ticket/index.phtml
file with content as follows:

<?php $tickets = $block->getTickets() ?>
<form
	id="form-validate"
	action="<?php echo $block->
getUrl('foggyline_helpdesk/ticket/save') ?>"
	method="post">
	<?php echo
$block->getBlockHtml('formkey') ?>
	
	<div class="field title required">
		<label class="label" for="title">
<span> <?php echo __('Title') ?></span>
</label>

		<div class="control">
			<input
				id="title"
				type="text"
				name="title"
				data-validate="{required:true}"
				value=""
				placeholder="<?php echo __('Something descriptive') ?>"/>
		</div>
	</div>
	<div class="field severity">
		<label lass="label for severity">
<span><?php echo __('Severity') ?></span>
</label>
		<div class="control">
			<select name="severity">
				<?php foreach
($block->getSeverities() as $value => $name);
?>
					<option value="<?php echo
$value ?>"><?php echo
$this->escapeHtml($name) ?></option>
				<?php endforeach; ?>
			</select>
		</div>
	</div>
	<button type="submit" class="action save primary">
		<span><?php echo __('Submit Ticket')?></span>
	</button>
</form>

<script>
	require([
		'jquery',
		'mage/mage'
	], function($) {
		var dataForm = $('#form-validate');
		dataForm.mage('validation', {});
	});
</script>

<?php if ($tickets->count()): ?>
	<table class="data-grid">
		<?php foreach ($tickets as $ticket):
?>
			<tr>
				<td><?php echo
$ticket->getId() ?></td>
				<td><?php echo
$block->escapeHtml($ticket->getTitle()) ?></td>
				<td><?php echo
$ticket->getCreatedAt() ?></td>
				<td><?php echo
$ticket->getSeverityAsLabel() ?></td>
				<td><?php echo
$ticket->getStatusAsLabel() ?></td>
			</tr>
		<?php endforeach; ?>
	</table>
<?php endif; ?>

Though this is a big chunk of code, it is easily readable as it is divided into a few very different
role-playing chunks.

The $block variable is actually the same as if we wrote $this, which is a rference to the instance of the
Foggyline\Helpdesk\Block\Ticket class where we defined the actual getTickets method. Thus, the
$tickets variable is first defined as a collection of tickets that belong to the currently
logged-in customer.

We then specified a form with a POST method type and an action URL that points to our Save controller action.
Within the form, we have a $block->getBlockHtml('formkey') call, which basically returns a 
hidden input field named form_key whose value is a random string.

Form keys in Magento are a means of preventing against Cross-Site Request Forgery (CRSF), so we need
to be sure to use them on any form we define. As part of the form, we have also defined
a title input field, severity select field, and submit button. Notice the CSS classes tossed around,
which guarantee that our forms look will match to those of other Magento forms.

Right after the closing form tag, we have a RequireJS type of JavaScript inclusion for validation.
Given that our form ID value is set to form-validate, the Javascript dataForm variable binds to it
and triggers a validation check when we press the Submit button.

We then have a count check and a foreach loop that renders all possibly existing customer tickets.

The final result of the template code can be seen in the following image:

<ss>

There is one more piece we are missing in order to complete our frontend functionality - a controller
action that will save the New Ticket form once it is posted. We define this action within the app/code/Foggyline/Helpdesk/Controller/Ticket/Save.php file with content as follows:

<?php

namespace Foggyline\Helpdesk\Controller\Ticket;

class Save extends \Foggyline\Helpdesk\Controller\Ticket
{
	protected $transportBuilder;
	protected $inlineTranslation;
	protected $scopeConfig;
	protected $storeManager;
	protected $formKeyValidator;
	protected $dateTime;
	protected $ticketFactory;

	public function __construct(\Magento\Framework\App\Action\Context $context,
	\Magento\Customer\Model\Session $customerSession,
	\Magento\Framework\Mail\Template\TransportBuilder $transportBuilder,
	\Magento\Framework\Translate\Inline\StateInterface $inlineTranslation,
	\Magento\Framework\App\Config\ScopeConfigInterface $scopeConfig,
	\Magento\Store\Model\StoreManagerInterface $storeManager,
	\Magento\Framework\Data\Form\FormKey\Validator $formKeyValidator,
	\Magento\Framework\Stdlib\DateTime $dateTime,
	\Foggyline\Helpdesk\Model\TicketFactory $ticketFactory
	)
	{
		$this->transportBuilder = $transportBuilder;
		$this->inlineTranslation = $inlineTranslation;
		$this->scopeConfig = $scopeConfig;
		$this->storeManager = $storeManager;
		$this->formKeyValidator = $formKeyValidator;
		$this->dateTime = $dateTime;
		$this->ticketFactory = $ticketFactory;
		$this->messageManager = $context->getMessageManager();
			parent::__construct($context, $customerSession);
	}

	public function execute()
	{
		$resultRedirect = $this->resultRedirectFactory->create();

		if(!$this->formKeyValidator->validate($this->getRequest())){
			return $resultRedirect->setRefererUrl();
		}

		$title = $this->getRequest()->getParam('title');
		$severity = $this->getRequest()->getParam('severity');

		try{
			/* Save Ticket */

			$ticket = $this->ticketFactory->create();

			$ticket->setCustomerId($this->customerSession->getCustomerId());
			$ticket->setTitle($title);
			$ticket->setSeverity($severity);

			$ticket->setCreatedAt($this->dateTime->formatDate(true));
			$ticket->setStatus(\Foggyline\Helpdesk\Model\Ticket::STATUS_OPENED);
			$ticket->save();

			$customer = $this->customerSession->getCustomerData();

			/* Send email to store owner */
			$storeScope = \Magento\Store\Model\ScopeInterface::SCOPE_STORE;

			$transport = $this->transportBuilder->setTemplateIdentifier($this->scopeConfig->
getValue('foggyline_helpdesk/email_template/store_owner', $storeScope))
->setTemplateOptions(
	[
		'area' => \Magento\Framework\App\Area::AREA_FRONTEND,
		'store' => $this->storeManager->getStore()->getId(),
	]
)
->setTemplateVars(['ticket' => $ticket])
->setFrom([
	'name' => $customer->getFirstName() . '' . $customer->getLastName(), 
	'email' => $customer->getEmail()
	])

addTo($this->scopeConfig->getValue(
'trans_email/ident_general/email',
$storeScope))
		->getTransport();

	$transport->sendMessage();

$this->inlineTranslation->resume();

$this->messageManager->addSuccess(__('Ticket successfully created'.));
		} catch(Exception $e) {
			$this->messageManager->addError(__('Error occurred during ticket creation.'));
		}
		return $resultRedirect->setRefererUrl();
	}
}

First, we look at __construct to see what params are passed to it. Given that the code we run in the
execute method needs to check if the form key is valid, create a ticket in the DB, pass on the ticket
and some customer info to the e-mail that is being sent to the store owner; Then we get 
an idea of what kind of objects are being passed around.

The execute method starts by checking the validity of the form key. If the form key is invalid,
we return with a redirection to the referring URL.

Passing the form key check, we grab the title and severity variables as passed by the form.
We then instansiate ticket entity by the ticket factory create method and simply set the ticket
entity values one by one. 

Note that the Ticket entity model Foggyline\Helpdesk\Model\Ticket does not really have methods like
setSeverity on its own. This is the inherited property of its \Magento\Framework\Object parent class.

Once the ticket entity is saved, we initiate the transport builder object, passing along all of the
required parameters for successful e-mail sending. Notice how setTemplateIdentifier uses our system.xml
config option foggyline_helpdesk/email_template/store_owner. 

This, if not specifically set under the admin Store | Config | Foggyline | Helpdesk area,
has a default value defined under config.xml that points to the e-mail template ID in the email_templates.xml file.

setTemplateVars expects the array or instance of \Magento\Framework\Object to be passed ot it.
We pass the entire $ticket object to it, just nesting it under the ticket key, thus making the props of 
a Ticket entity, like a title, become available in the e-mail HTML template as {{var ticket.title}}

When a customer now submits the New Ticket form from My Account | Helpdesk Tickets, the HTTP POST request
will hit the save controller action class. If the preceeding code is successfully executed, the ticket
is saved to the DB and redirection back to My Account | Helpdesk Tickets will occur showing a Ticket successfully
created message, in the browser.

Until now, we have been dealing with setting up general module configs, e-mail templates,
frontend route, frontend layout, block and template. What remains to complete the module
requirements is the admin interface, where the store owner can see submitted tickets and change
statuses from open to closed.

The following are needed for a fully functional admin interface as per the requirements:

ACL resource used to allow or disallow to the ticket listing

Menu item linking to tickets listing the controller action

Route that maps to our admin controller

Layout XMLs that map to the ticket listing the controller action

Controller action for listing tickets

Full XML layout grid definition within layout XMLs defining grid, custom column
renderers and custom dropdown filter values

Controller action for closing tickets and sending e-mails to customers

We start by adding a new ACL resource entry to the previously defined app/code/Foggyline/Helpdesk/etc/acl.xml
file, as a child of the Magento_Backend::admin resource as follows:

<resource id="Magento_Customer::customer">
	<resource
id="Foggyline_Helpdesk::ticket_manage" title="Manage Helpdesk Tickets"/>
</resource>

On its own, the defined resource entry does not do anything. This resource will later be used
within the menu and controller.

The menu item linking to the tickets listing the controller action is defined
under the app/code/Foggyline/Helpdesk/etc/adminhtml/menu.xml file as follows:

<?xml version="1.0"?>

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Backend:etc/menu.xsd">
	<menu>
		<add
id="Foggyline_Helpdesk::ticket_manage"
title="Helpdesk Tickets"
module="Foggyline_Helpdesk"

parent="Magento_Customer::customer"
action="foggyline_helpdesk/ticket/index"

resource="Foggyline_Helpdesk::ticket_manage"/>
	</menu>
</config>

We are using the menu | add element to add a new menu item under the Magento admin area.
The position of an item within the admin area is defined by the attribute parent,
which in our case means under the existing Customer menu.

If the parent is omitted, our item would appear as a new item on a menu. The title attribute
value is the label we will see in the menu. the id attribute has to uniquely differentiate our
menu item from others. The resource attribute references the ACL resource defined in the 
app/code/Foggyline/Helpdesk/etc/acl.xml file.

If a role of a logged-in user does not allow him to use the Foggyline_Helpdesk::ticket_manage resource,
the user would not be able to see the item menu.

Now, we add a route that maps to our admin controller, by defining the app/code/Foggyline/Helpdesk/etc/adminhtml/routes.xml file as follows:

<?xml version="1.0"?>

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:App/etc/routes.xsd">
	<router id="admin">
		<route id="foggyline_helpdesk"
frontName="foggyline_helpdesk">
			<module
name="Foggyline_Helpdesk"/>
		</route>
	</router>
</config>

The admin route definition is almost identical to the frontend router definition, where the difference primarily
lies in the router id value, which equals to the admin here

With the router definition in place, we can now define our three layout XMLs, under the app/code/Foggyline/Helpdesk/view/adminhtml/layout dir, which map to the ticket listing the controller action:

foggyline_helpdesk_ticket_grid.xml

foggyline_helpdesk_ticket_grid_block.xml

foggyline_helpdesk_ticket_index.xml

The reason we define three layout files for a single action controller and not one is because
of the way we use the listing in control in the Magento admin area.

The content of the foggyline_helpdesk_ticket_index.xml file is defined as follows:

<?xml version="1.0" encoding="UTF-8"?>

<page xmlns:xsi:="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:View/Layout/etc/page_configuration.xsd">
	<update handle="formkey"/>
	<update
handle="foggyline_helpdesk_ticket_grid_block"/>
	<body>
		<referenceContainer name="content">
			<block class="Foggyline\Helpdesk\Block\Adminhtml\Ticket" name="admin.block.helpdesk.ticket.grid.container">
		</block>
		</referenceContainer>
	</body>
</page>

Two update handles are specified, one pulling in formkey and the other pulling in foggyline_helpdesk_ticket_grid_block. We then reference the content container and define a new block of the Foggyline\Helpdesk\Block\Adminhtml\Ticket class with it.

We could have used Magento\Backend\Block\Widget\Grid\Container as a block class name. However, given
that we needed some extra logic, like removing the Add New button, we opted for a custom class that then
extends the \Magento\Backend\Block\Widget\Grid\Container and adds the requried logic.

The Foggyline\Helpdesk\Block\Adminhtml\Ticket class is defined under the app/code/Foggyline/Helpdesk/Block/Adminhtml/Ticket.php file as follows:

<?php

namespace Foggyline\Helpdesk\Block\Adminhtml;

class Ticket extends \Magento\Backend\Block\Widget\Grid\Container
{
	protected function _construct()
	{
		$this->_controller = 'adminhtml';
		$this->_blockGroup = "Foggyline_Helpdesk";
		$this->_headerText = __('Tickets');

		parent::_construct();

		$this->removeButton('add');
	}
}

Not much is happening in the Ticket block class here. Most importantly, we extend from
\Magento\Backend\Block\Widget\Grid\Container and define _controller and _blockGroup, as these
serve as a sort of glue for telling our grid where to find other possible block classes.

Since we won't have an Add New ticket feature in admin, we are calling the removeButton method to remove
the default Add New button from the grid container.

Back to our second XML layout file, the foggyline_helpdesk_ticket_grid.xml file, which we
defined as follows:

<?xml version="1.0"?>

<layout xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceLocation="urn:magento:framework:View/Layout/etc/layout_generic.xsd">
	<update handle="formkey"/>
	<update
handle="foggyline_helpdesk_ticket_grid_block"/>
	<container name="root">
		<block class="Magento\Backend\Block\Widget\Grid\Container"
name="admin.block.helpdesk.ticket.grid.container" template="Magento_Backend::widget/grid/container/empty.phtml"/>
	</container>
</layout>

Notice how the content of foggyline_helpdesk_ticket_grid.xml is nearly 
identical to that of foggyline_helpdesk_ticket_index.xml. The only difference between the two
is the value of the Block class and the template attribute. The Block class is defined as
Magento\Backend\Block\Widget\Grid\Container, where we previously defined it as Foggyline\Helpdesk\Block\Adminhtml\Ticket.

If we look at the content of the \Magento\Backend\Block\Widget\Grid\Container class, we can see the following
property defined:

protected $_template = 'Magento_Backend::widget/grid/container.phtml';

If we look at the content of the vendor/magento/module-backend/view/adminhtml/templates/widget/grid/container.phtml and vendor/magento/module-backend/view/adminhtml/templates/widget/grid/container/empty.phtml files,
the difference can be easily spotted. container/empty.phtml only returns grid HTML, whereas container.phtml
returns buttons and grid HTML.

Given that foggyline_helpdesk_ticket_grid.xml will be a handle for the AJAX loading grid listing during 
sorting and filtering, we need it to return only grid HTML upon reload.

We now move on to the third and largest of XML's layout files, the app/code/Foggyline/Helpdesk/view/adminhtml/layout/foggyline_helpdesk_ticket_grid_block.xml file. Given the size of it, we will split it into two code chunks
as we explain them one by one.

The first part, or initial content of the foggyline_helpdesk_ticket_grid_block.xml file, is
defined as follows:

<?xml version="1.0" encoding="UTF-8"?>

<page xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:View/Layout/etc/page_configuration.xsd">
	<body>
		<referenceBlock name="admin.block.helpdesk.ticket.grid.container">
			<block class="Magento\Backend\Block\Widget\Grid" name="admin.block.helpdesk.ticket.grid" as="grid">
				<arguments>
					<argument name="id" xsi:type="string"> ticketGrid</argument>
					<argument name="dataSource" xsi:type="object">
					Foggyline\Helpdesk\Model\ResourceModel\Ticket\Collection
					</argument>
					<argument name="default_sort" xsi:type="string">ticket_id</argument>
					<argument name="default_dir" xsi:type="string">desc</argument>
					<argument name="save_parameters_in_session" xsi:type="boolean">true</argument>
					<argument name="use_ajax" xsi:type="boolean">true</argument>
				</arguments>
				<block class="Magento\Backend\Block\Widget\Grid\ColumnSet" name="admin.block.helpdesk.ticket.grid.columnSet" as="grid.columnSet">
					<!-- Column definitions here -->
				</block>
			</block>
		</referenceBlock>
	</body>
</page>

Notice <!-- Column definitions here -->; we will come back to that soon. For now,
let's analyze what is happening here. Right after a body element, we have a reference to
admin.block.helpdesk.ticket.grid.container which is a content block child defined under
the foggyline_helpdesk_ticket_grid.xml and foggyline_helpdesk_ticket_index.xml files.

Within this reference, we are defining another block of class Magento\Backend\Block\Widget\Grid,
passing it a name of our choosing and an alias Further, this block has an arguments list and another
block of class Magento\Backend\Block\Widget\Grid\ColumnSet as child elements.

Through the arguments list we specify the:

id: Set to the value of ticketGrid, we can set any value we want here, ideally sticking to formula {entity name}

dataSource: Set to the value of Foggyline\Helpdesk\Model\ResourceModel\Ticket\Collection, which is the name
of our Ticket entity resource class.

default_sort: Set to the value of ticket_id, which is the property of the Ticket entity by which we want to sort.

default_dir: Set to the value of desc, to denote a descending order of sorting. This value functions
together with default_sort as a single unit.

save_parameters_in_session: Set to true, this is easiest to explain using the following example: if we do
some sorting and filtering on the Ticket grid and then move on to another part of the admin area, then come
back to the Ticket grid, if this value is set to yes, the grid we will see will have those
filters and sorting set.

use_ajax: Set to true, when grid filtering and sorting is triggered, an AJAX loader kicks in and reloads only
the grid area and not the whole page.

Right after the grid blocks argument list, we have the grid column set. This brings us to the second
part of foggyline_helpdesk_ticket_grid_block.xml content. We simply replace the <!-- Columns Here -->
comment with the following:

<block class="Magento\Backend\Block\Widget\Grid\Column" as="ticket_id">
	<arguments>
		<argument name="header" xsi:type="string" translate="true">ID</argument>
		<argument name="type" xsi:type="string">number</argument>
		<argument name="id" xsi:type="string">ticket_id</argument>
		<argument name="index" xsi:type="string">ticket_id</argument>
	</arguments>
</block>
<block class="Magento\Backend\Block\Widget\Grid\Column" as="title">
	<arguments>
		<argument name="header" xsi:type="string" translate="true">Title</argument>
		<argument name="type" xsi:type="string">string</argument>
		<argument name="id" xsi:type="string">title</argument>
		<argument name="index" xsi:type="string">title</argument>
	</arguments>
</block>
<block class="Magento\Backend\Block\Widget\Grid\Column" | as="severity">
	<arguments>
		<argument name="header" xsi:type="string" translate="true">Severity</argument>
		<argument name="index" xsi:type="string">severity</argument>
		<argument name="type" xsi:type="string">options</argument>
		<argument name="options" xsi:type="options" model="Foggyline\Helpdesk\Model\Ticket\Grid\Severity"/>
		<argument name="renderer" xsi:type="string">Foggyline\Helpdesk\Block\Adminhtml\Ticket\Grid\Renderer\Severity</argument>
		<argument name="header_css_class" xsi:type="string"> col-form_id</argument>
		<argument name="column_css_class" xsi:type="string"> col-form_id</argument>
	</arguments>
</block>
<block class="Magento\Backend\Block\Widget\Grid\Column" as="status">
	<arguments>
		<argument name="header" xsi:type="string" translate="true">Status</argument>
		<argument name="index" xsi:type="string">status</argument>
		<argument name="type" xsi:type="string">options</argument>
		<argument name="options" xsi:type="options" model="Foggyline\Helpdesk\Modal\Ticket\Grid\Status"/>
		<argument name="renderer" xsi:type="string"> Foggyline\Helpdesk\Block\Adminhtml\Ticket\Grid\Renderer\Status
		</argument>
		<argument name="header_css_class" xsi:type="string"> col-form_id</argument>
		<argument name="column_css_class" xsi:type="string"> col-form_id</argument>
	</arguments>
</block>
<block class="Magento\Backend\Block\Widget\Grid\Column" as="action">
	<arguments>
		<argument name="id" xsi:type="string">action</argument>
		<argument name="header" xsi:type="string" translate="true">Action</argument>
		<argument name="type" xsi:type="string">action</argument>
		<argument name="getter" xsi:type="string">getId</argument>
		<argument name="filter" xsi:type="boolean">false</argument>
		<argument name="sortable" xsi:type="boolean">false</argument>
		<argument name="actions" xsi:type="array">
			<item name="view_action" xsi:type="array">
				<item name="caption" xsi:type="string" translate="true">Close</item>
				<item name="url" xsi:type="array">
					<item name="base" xsi:type="string">*/*/close</item>
				</item>
				<item name="field" xsi:type="string">id</item>
			</item>
		</argument>
		<argument name="header_css_class" xsi:type="string"> col-actions</argument>
		<argument name="column_css_class" xsi:type="string"> col-actions</argument>
	</arguments>
</block>

Similar to grid, column definitions also have arguments that define its look and behavior:

header: Mandatory, the value we want to see as a label on top of the column

type: Mandatory, can be anything from: date, datetime, text, longtext, options, store,
number, currency, skip-list, wrapline and country

id: Mandatory, a unique value that identifies our column, preferably matching the name
of the entity property

index: Mandatory, the database column name

options: Optional, if we are using a type like options, then for the options argument
we need to specify the class like Foggyline\Helpdesk\Model\Ticket\Grid\Severity that implements
\Magento\Framework\Option\ArrayInterface, meaning it provides the toOptionArray method that
then fills the values of options during grid rendering.

renderer: Optional, as our Ticket entities store severity and status as integer vals in the db,
columns would render those ints into columns, which is not really useful. We want to turn those
ints into labels. In order to do so, we need to rewrite the rendering bit of a single table cell,
which we do with the help of the renderer argument.

The value we pass to it, Foggyline\Helpdesk\Block\Adminhtml\Ticket\Grid\Renderer\Severity,
needs to be a class that extends \Magento\Backend\Block\Widget\Grid\Column\Renderer\AbstractRenderer
and does its own implementation of the render method.

header_css_class: Optional, if we prefer to specify a custom header class.

column_css_class: Optional, if we prefer to specify a custom column class.

The Foggyline\Helpdesk\Block\Adminhtml\Ticket\Grid\Renderer\Severity class, defined 
in the app/code/Foggyline/Helpdesk/Block/Adminhtml/Ticket/Grid/Renderer/Severity.php file
as follows:

<?php

namespace Foggyline\Helpdesk\Block\Adminhtml\Ticket\Grid\Renderer;

class Severity extends \Magento\Backend\Block\Widget\Grid\Column\Renderer\AbstractRenderer
{
	protected $ticketFactory;

	public function __construct(\Magento\Backend\Block\Context $context,
	\Foggyline\Helpdesk\Model\TicketFactory $ticketFactory,
	array $data = []
	)
	{
		parent::__construct($context, $data);
		$this->ticketFactory = $ticketFactory;
	}

	public function render(\Magento\Framework\DataObject $row)
	{
		$ticket = $this->ticketFactory->create()->load($row->getId());

		if($ticket && $ticket->getId()){
			return $ticket->getSeverityAsLabel();
		}
		return '';
	}
}

Here, we are passing the instance of the ticket factory to the constructor and then using
that instance within the render method to load a ticket based on the ID value fetched from 
the current row.

Given that $row->getId() returns the ID of the ticket, this is a nice way to reload the entire ticket
entity and then fetch the full label from the ticket model by using $ticket->getSeverityAsLabel().

Whatever string we return from this method is what will be shown under the grid row.
Another renderer class that is referenced within the foggyline_helpdesk_ticket_grid_block.xml file
is Foggyline\Helpdesk\Block\Adminhtml\Ticket\Grid\Renderer\Status, and we define its content under
the app/code/Foggyline/Helpdesk/Block/Adminhtml/Ticket/Grid/Renderer/Status.php file as follows:

<?php

namespace Foggyline\Helpdesk\Block\Adminhtml\Ticket\Grid\Renderer;

class Status extends \Magento\Backend\Block\Widget\Grid\Column\Renderer\AbstractRenderer
{
	protected $ticketFactory;

	public function __construct(\Magento\Backend\Block\Context $context,
	\Foggyline\Helpdesk\Model\TicketFactory $ticketFactory, 
	array $data = []
	)
	{
		parent::__construct($context, $data);
		$this->ticketFactory = $ticketFactory;
	}

	public function render(\Magento\Framework\DataObject $row)
	{
		$ticket = $this->ticketFactory->create()->load($row->getId());

		if ($ticket && $ticket->getId()){
			return $ticket->getStatusAsLabel();
		}

		return '';
	}
}

Given that it too is used for a renderer, the content of the Status class is nearly
identical to the content of the Severity class. We pass on the ticket factory object
via the constructor, so we have it internally for usage within the render method.

Then we load the Ticket entity using the ticket factory and ID value fetched from a $row object.
As a result, the column will contain the label value of a status and not its integer value.

Besides referencing renderer classes, our foggyline_helpdesk_ticket_grid_block.xml file
also references the options class for the Severity field.

We define the Foggyline\Helpdesk\Model\Ticket\Grid\Severity options class under the 
app/code/Foggyline/Helpdesk/Model/Ticket/Grid/Severity.php file as follows:

<?php

namespace Foggyline\Helpdesk\Model\Ticket\Grid;

class Severity implements \Magento\Framework\Option\ArrayInterface
{
	public function toOptionArray()
	{
		return \Foggyline\Helpdesk\Model\Ticket::getSeveritiesOptionArray();
	}
}

The options value from XML layouts refers to a class that has to implement the toOptionArray method,
which returns an array of arrays, such as the following example:

return [
	['value'=>'theValue1', 'theLabel1'],
	['value'=>'theValue2', 'theLabel2'],
];

Our Severity class simply calls the static method we have defined on the Ticket class,
the getSeveritiesOptionArray, and passes along those values.

Up to this point, we have defined the menu item, ACL resource, XML layouts, block, options class
and renderer classes. What remains to connect it all are controllers. We will need three controller
actions (Index, Grid and Close), all extending from the same admin Ticket controller.

We define the admin Ticket controller under the app/code/Foggyline/Helpdesk/Controller/Adminhtml/Ticket.php file
as follows:

<?php

namespace Foggyline\Helpdesk\Controller\Adminhtml;

class Ticket extends Magento\Backend\App\Action
{
	protected $resultPageFactory;
	protected $resultForwardFactory;
	protected $resultRedirectFactory;

	public function __construct(\Magento\Backend\App\Action\Context $context,
	\Magento\Framework\View\Result\PageFactory $resultPageFactory,
	\Magento\Backend\Model\View\Result\ForwardFactory $resultForwardFactory
	)
	{
		$this->resultPageFactory = $resultPageFactory;
		$this->resultForwardFactory = $resultForwardFactory;
		$this->resultRedirectFactory = $context->getResultRedirectFactory();
		parent::__construct($context);
	}

	protected function _isAllowed()
	{
		return $this->_authorization->isAllowed('Foggyline_Helpdesk::ticket_manage');
	}

	protected function _initAction()
	{	
		$this->_view->loadLayout();
		$this->_setActiveMenu('Foggyline_Helpdesk::ticket_manage'
		)->_addBreadcrumb(
			__('Helpdesk'),
			__('Tickets')
		);
		return $this;
	}
}

There are a few things to note here:

$this->resultPageFactory

$this->resultForwardFactory

$this->resultRedirectFactory are objects to be used on the child (Index, Grid and Close),
so we do not have to initiate them in each child class separately.

The _isAllowed() method is extremely important every time we have custom-defined controller
or controller action that we want to check against our custom ACL resource.

Here, we are the isAllowed method call on the \Magento\Framework\AuthorizationInterface
type of object ($this->_authorization). The param passed to the isAllowed method call should
be the ID value of our custom ACL resource.

We then have the _initAction method, which is used for setting up logic shared across child classes,
usually things like loading the entire layout, setting up the active menu flag, and adding 
breadcrumbs.

Moving forward, we define the Index controller action within the app/code/Foggyline/Helpdesk/Controller/Adminhtml/Ticket/Index.php file as follows:

<?php

namespace Foggyline\Helpdesk\Controller\Adminhtml\Ticket;

class Index extends \Foggyline\Helpdesk\Controller\Adminhtml\Ticket
{
	public function execute()
	{
		if($this->getRequest()->getQuery('ajax')){
			$resultForward = $this->resultForwardFactory->create();
			$resultForward->forward('grid');
			return $resultForward;
		}
		$resultPage = $this->resultPageFactory->create();

		$resultPage->setActiveMenu('Foggyline_Helpdesk::ticket_manage');

		$resultPage->getConfig()->getTitle()->prepend(__('Tickets'));

		$resultPage->addBreadcrumb(__('Tickets'),
		__('Tickets'));
		$resultPage->addBreadcrumb(__('Manage Tickets'), __('Manage Tickets'));

		return $resultPage;
	}
}

Controller actions execute within their own class, within the execute method. Our execute method
first checks if the coming request is the AJAX param within it. If there is an AJAX param, the request
is forwaded to the Grid action of the same controller.

If there is no AJAX controller, we simply create the instance of the \Magento\Framework\View\Result\PageFactory object, and set title, active menu item, and breadcrumbs in it.

A logical question at this point would be how does all of this work and where can we see it. If we log
in to the Magento admin area, under the Customers menu we should be able to see the Helpdesk Tickets menu item.

This time, defined previously within app/code/Foggyline/Helpdesk/etc/adminhtml/menu.xml, says the menu
action attribute equals to foggyline_helpdesk/ticket/index, which basically translates to the Index action
of our Ticket controller.

Once we click on the Helpdesk Tickets link, Magento will hit the Index action within its Ticket
controller and try to find the XML file that has the matching route {id}+{controller name}+{controller action name}+{xml file extension}, which in our case translates to {foggyline_helpdesk}+{ticket}+{index}+{xml}

At this point, we should be able to see the screen, as shown in the following SS:

<ss>

However, if we now try to use sorting or filtering, we would get a broken layout. This is because
based on arguments defined under the foggyline_helpdesk_ticket_grid_block.xml file,
we are missing the controller Grid action. When we use sorting or filtering, the AJAX request
hits the Index controller and asks to be forwarded to the Grid action, which we haven't defined yet.

We now define the Grid action within the app/code/Foggyline/Helpdesk/Controller/Adminhtml/Ticket/Grid.php file
as follows:

<?php

namespace Foggyline\Helpdesk\Controller\Adminhtml\Ticket;

class Grid extends \Foggyline\Helpdesk\Controller\Adminhtml\Ticket
{
	public function execute()
	{
		$this->_view->loadLayout(false);
		$this->_view->renderLayout();
	}
}

There is only one execute method with the Grid controller action class, which is expected.
The code within the execute method simply calls the loadLayout(false) method to
prevent the entire layout loading, making it load only the bits defined under the
foggyline_helpdesk_ticket_grid.xml file. This effectively returns the grid HTML to the AJAX,
which refreshes the grid on the page.

Finally, we need to handle the Close action link we see on the grid. This link was 
defined as part of the column definition within the foggyline_helpdesk_ticket_grid_block.xml
file and points to */*/close, which translates to "router as relative from current URL/ controller as relative from current URL / close action", which further equals to our Ticket controller Close action.

We define the Close controller action under the app/code/Foggyline/Helpdesk/Controller/Adminhtml/Ticket/Close.php file as follows:

<?php

namespace Foggyline\Helpdesk\Controller\Adminhtml\Ticket;

class Close extends \Foggyline\Helpdesk\Controller\Adminhtml\Ticket
{
	protected $ticketFactory;
	protected $customerRepository;
	protected $transportBuilder;
	protected $inlineTranslation;
	protected $scopeConfig;
	protected $storeManager;

	public function __construct(\Magento\Backend\App\Action\Context $context,
	\Magento\Framework\View\Result\ForwardFactory $resultForwardFactory,
	\Foggyline\Helpdesk\Model\TicketFactory $ticketFactory,
	\Magento\Customer\Api\CustomerRepositoryInterface $customerRepository,
	\Magento\Framework\Mail\Template\TransportBuilder $transportBuilder,
	\Magento\Framework\Translate\Inline\StateInterface $inlineTranslation,
	\Magento\Framework\App\Config\ScopeConfigInterface $scopeConfig,
	\Magento\Store\Model\StoreManagerInterface $storeManager)
	{
		$this->ticketFactory = $ticketFactory;
		$this->customerRepository = $customerRepository;
		$this->transportBuilder = $transportBuilder;
		$this->inlineTranslation = $inlineTranslation;
		$this->scopeConfig = $scopeConfig;
		$this->storeManager = $storeManager;
		parent::__construct($context, $resultPageFactory, $resultForwardFactory);
	}

	public function execute()
	{
		$ticketId = $this->getRequest()->getParam('id');
		$ticket = $this->ticketFactory->create()->load($ticketId);

		if($ticket && $ticket->getId()){
			try{
				$ticket->setStatus(\Foggyline\Helpdesk\Model\Ticket::STATUS_CLOSED);
				$ticket->save();

				$this->messageManager->addSuccess(__('Ticket successfully closed.'));

				/* Send email to Customer */
				$customer = $this->customerRepository->getById($ticket->getCustomerId());
				$storeScope = \Magento\Store\Model\ScopeInterface::SCOPE_STORE;
				$transport = $this->transportBuilder->setTemplateIdentifier($this->scopeConfig->
getValue('foggyline_helpdesk/email_template/customer', $storeScope))
				->setTemplateOptions([
					'area' => \Magento\Framework\App\Area::AREA_ADMINHTML,
					'store' => $this->storeManager->getStore()->getId(),
					]
				)
				->setTemplateVars([
'ticket' => $ticket, 'customer_name' => $customer -> getFirstname()
				])
				->setForm([
					'name' => $this->scopeConfig->getValue('trans_email/ident_general/name', $storeScope),
				'email' => $this->scopeConfig->getValue('trans_email/ident_general/email', $storeScope)])
				->addTo($customer->getEmail())
					->getTransport();
					$transport->sendMessage();

				$this->inlineTranslation->resume();

				$this->messageManager->addSuccess(__('Customer notified via email.'));
			} catch (Exception $e) {
				$this->messageManager->addError(__('Error with closing ticket action.'));
			}
		}

		$resultRedirect = $this->resultRedirectFactory->create();
			$resultRedirect->setPath('*/*/index');

		return $resultRedirect;
	}
}

The Close action controller has two seperate roles to fulfill. One is to change
the ticket status; the other is to send an e-mail to the customer using the proper
e-mail template. The class constructor is being passed a lot of params that all
instansiate the object we will be juggling around.

Within the execute action, we first check for the existence of the id parameter and then
try to load a Ticket entity through the ticket factory and then try to load a Ticket entity
through the ticket factory, based on the provided ID value. If the ticket exists,
we set its status label to \Foggyline\Helpdesk\Model\Ticket::STATUS_CLOSED and save it.

Following the ticket save is the e-mail sending code, which is very similar to the one
that we already saw in the customer New Ticket save action. The difference is that the e-mail
goes out from the admin user to the customer this time.

We are setting the template ID to the config value at path foggyline_helpdesk/email_template/customer.
The setTemplateVars method is passed to the member array this time, both ticket and customer_name,
as they are both used in the e-mail template. The setForm method is passed the general store username
and e-mail, and the sendMessage method is called on the transport object.

Finally, using the resultRedirectFactory object, the user is redirected back to the tickets grid.
With this, we finalze our module functional requirement.

Though we are done with the functional requirement of a module, what remains for us as devs 
is to write tests. There are several types of tests, such as unit, functional integration and so on.
To keep things simple, within this chapter we will cover only unit tests across a single model class.

This chapter assumes that we have PHPUnit configed and available on the CMD line. If this is not the case,
PHPUnit can be installed using instructions from the https://phpunit.de/ website.

To build and run tests using the PHPUnit testing framework, we need to define test locations
and other config options via an XML file. Magento defines this XML config file under
dev/tests/unit/phpunit.xml.dist.

Let's make a copy of that file under dev/tests/unit/phpunit-foggyline-helpdesk.xml with
adjustments as follows:

<?xml version="1.0" encoding="UTF-8"?>

<phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://schema.phpunit.de/4.1/phpunit.xsd" colors="true" bootstrap="./framework/bootstrap.php">
	<testsuite name="Foggyline_Helpdesk - Unit Tests">
		<directory suffix="Test.php">
../../../app/code/Foggyline/Helpdesk/Test/Unit
		</directory>
	</testsuite>
	<php>
		<ini name="date.timezone" value="Europe/Zagreb"/>
		<ini name="xdebug.max_nesting_level" value="200"/>
	</php>
	<filter>
		<whitelist addUncoveredFilesFromWhiteList="true">
			<directory suffix=".php">
../../../app/code/Foggyline/Helpdesk/*
			</directory>
			<exclude>
				<directory>../../../app/code/Foggyline/Form/Helpdesk</directory>
			</exclude>
		</whitelist>
	</filter>
	<logging>
		<log type="coverage-html" target="coverage_dir/Foggyline_Helpdesk/test-reports/coverage" 
charset="UTF-8" yui="true" highlight="true"/>
	</logging>
</phpunit>

We are making a special XML config file for our module alone because we want to quickly run a few of the
tests contained within our module alone and not the entire Magento app/code folder.

Given that the actual art of writing unit tests is beyond the scope of this book and writing a full
unit test with 100% code coverage for this simple module would require at least a dozen more pages,
we will only write a single test, one that covers the Ticket entity model class.

We define our Ticket entity model class test under the app/code/Foggyline/Helpdesk/Test/Unit/Model/TicketTest.php file as follows:

<?php

namespace Foggyline\Helpdesk\Test\Unit\Model;

class TicketTest extends \PHPUnit_Framework_TestCase
{
	protected $objectManager;
	protected $ticket;

	public function setUp()
	{
		$this->objectManager = new \Magento\Framework\TestFramework\Unit\Helper\ObjectManager($this);
		$this->ticket = $this->objectManager->getObject('Foggyline\Helpdesk\Model\Ticket');
	}

	public function testGetSeveritiesOptionArray()
	{
		$this->assertNotEmpty(\Foggyline\Helpdesk\Model\Ticket::getSeveritiesOptionArray());
	}

	public function testGetStatusAsLabel()
	{
		$this->ticket->setStatus(\Foggyline\Helpdesk\Model\Ticket::STATUS_CLOSED);

		$this->assertEquals(\Foggyline\Helpdesk\Model\Ticket::$statusesOptions [\Foggyline\Helpdesk\Model\Ticket::STATUS_CLOSED], 
		$this->ticket->getStatusAsLabel());
	}

	public function testGetSeverityAsLabel()
	{
		$this->ticket->setSeverity(\Foggyline\Helpdesk\Model\Ticket::SEVERITY_MEDIUM);

		$this->assertEquals(\Foggyline\Helpdesk\Model\Ticket::$severitiesOptions [\Foggyline\Helpdesk\Model\Ticket::SEVERITY_MEDIUM],

		$this->ticket->getSeverityAsLabel()
		);
	}
}

The location of test files should map those of the files being tested. The naming of the
test file should also follow the naming of the file being tested with the suffix Test attached to it.
This means that if our Ticket model is located under the modules Model/Ticket.php file, then our test
should be located under Test/Unit/TicketTest.php

Our Foggyline\Helpdesk\Test\Unit\Model\TicketTest extends the \PHPUnit_Framework_TestCase class.
There is a setUp method we need to define, which acts like a constructor, where we set up
the variables and everything that requires initializing.

Using Magento ObjectManager, we instansiate the Ticket model, which is then used within the
test Methods. The actual test methods follow a simple naming pattern, where the name
of the method from the Ticket model matches the {test}+{method name} from the TicketTest class.

We defiend our four test methods:

testGetSeveritiesOptionArray,
testGetStatusesOptionArray,
testGetStatusAsLabel,
testGetSeverityAsLabel.

Within the test methods, we are using only assertEquals and assertNotEmpty
methods from the PHPUnit testing frameworklibrary to do basic checks.

We can now open a console, change the dir to our Magento install dir, and execute
the following command:

phpunit -c dev/tests/unit/phpunit-foggyline-helpdesk.xml

After the command executes, the console should show an output as shown:

PHPUnit 4.7.6 by Sebastian Bergmann and contributors ....

Time: 528 ms, Memory: 11.50Mb

OK (4 tests, 4 assertions)

Generating code coverage report in HTML format ... done

Looking back at our dev/tests/unit/phpunit-foggyline-helpdesk.xml file, under the
target attribute of the phpunit > logging > log element, we can see that the test report
is dumped into the coverage_dir/Foggyline_Helpdesk/test-reports/coverage folder relative
to the XML file.

If we open the dev/tests/unit/coverage_dir/Foggyline_Helpdesk/test-reports/coverage/ folder,
we should see a whole lot of files generated here, as shown in the following ss:

<ss>

Opening the index.html file in the brwoser should yield a result akin to a ss with
a legend of all relevant things we tested.

We can see the code coverage report showing 60% on lines and methods for our Model
folder and 0% for the rest. This is because we only wrote the test for the Ticket entity model
class, whereas the rest remain untested.

This chapter gave a full step-by-step guide to writing a simple yet functional
Magento module. Seemingly simple in terms of functionality, we can see that the module
code is significantly scattered across multiple PHP, XML and PHTML files.

With this simple module, we covered quite a lot of various Magento platform parts, from routes,
ACLs, controllers, blocks, XML layouts, grids, controller actions, models, resources, collections,
install scripts, interactions with session, e-mail templates, e-mail transport, and layout objects.

At the end we wrote a few simple unit tests for our models. Although the practice is to write
until tests for all of our PHP code, we opted for a shorter version or else we would need
more pages to cover everything.

The full module code is available here: https://github.com/ajzele/B05032-Foggyline_Helpdesk.

With this being the last chapter, let us look at a short overview of these things we learned
throughout the whole book. OUr journey started by grasping the Magento platform architechture,
where we gained significant insighti nto the tech stack behind it.

We then progressed to env management. Although it might seem like a wrong order of things,
we opted for this next step in order to quickly get us set for development. We then looked into
programming concepts and conventions, which served as a precursor to actual hands-on dev bits.

Details of entity persistence were shown through model, resource, collection classes, and indexers.
We further covered the importance and practical details of dependency injection and interception.
Backend and frontend-related dev was covered in their own two chapters, outlingin the most
common bits and pieces for making customization to our Magento platform.

We then dug into details of the web API, showing how to make authenticated API calls and even
define our own APIs. Along the way, we covered a few major function areas as well, such as customers,
reports, import export, cart and so on. The testing and QA took up a significant chunk as we briefly
covered all forms of available tests.

Finally, we used what we learned to build a fully functional moduel.

Although we have covered a significant path on our journey, this is merely a first step.
Given its massive code base, diverse tech stacks, and feature list, Magento is not an easy
platform to master. Hopefully, this book will give enough incentive to take steps into
profiling ourselves as true Magento experts.

