We begin by writing some simple Examples:

NOTE: These examples assume that you have apache installed, and that our files are in the Apache document root dir (such as /var/www/html)



<?php
// index.php
session_start();

//if the user is logged in,retrieve identity from session
$identity = null;
if (isset($_SESSION['identity'])){
	$identity = $_SESSION['identity'];
}
?>

//HTML
<html>
	<head>
		<title>Home page!</title>
	</head>
	<body>
		<h1>Home</h1>
		<?php if ($identity == null) : ?>
		<a href="login.php">Sign in</a>
		<?php else: ?>
		<strong>Welcome, <?= $identity ?></strong> <a href="logout.php">Sign Out</a>
		<?php endif; ?>

		<p>
			This is a simple website to demonstrate the advatanges of a PHP framework and disadvatanges
			of plain PHP.
		</p>
	</body>
</html>

Next, we make the login part:

<?php
//login.php
session_start();

//if user is logged in, redirect him to index.php
if (isset($_SESSION['identity'])){
	header('Location: index.php');
	exit;
}

$submitted = false;
if ($_SERVER['REQUEST_METHOD']=='POST'){
	
	$submitted = true;
	//Extract the form data
	$email = $_POST['email'];
	$password = $_POST['password'];

	//Authenticate the user
	$authenticated = false;
	if ($email=='admin@example.com' && $password=='Something'){
		$authenticated = true;

		//Save identity to session
		$_SESSION['identity'] = $email;

		//Redirect the user to index.php
		header('Location: index.php');
		exit;
	}
}
?>

<html>
	<head>
		<Title>Login Page</title>
	</head>
	<body>
		<h1>Sign in</h1>
		<?php if ($submitted && !$authenticated) : ?>
			<div class="alert">
				Invalid
			</div>
		<?php endif; ?>
		<form name="login-form" action"/login.php" method="POST">
			<label for="email">E-mail</label>
			<input type="text" name="email">
			<br>
			<label for="password">Password</label>
			<input type="password" name="password">
			<br>
			<input type="submit" name="submit" value="Sign In">
		</form>
	</body>
</html>

The general things are coding standards for Zend and PHP:

PHP File Formatting:

General:

For files that JUST have PHP code, we need not have a ?>. Omit it, cause it will circumvent accidental whitetrail injection

Inclusion of arbitrary binary data as permitted by __HALT_COMPILER() MUST NOT be used in PHP files in Zend projects. This is
only allowed for installation scripts.

Indentation:

MUST be 4 spaces. Tabs are not allowed.

Maximum Line Length:

Target line length is 80 chars. This is a general rule of thumb to aim for. MAX for PHP is 120.

Line termination MUST end with a single linefeed char. They are represented with hexadecimal 0x0A.

Do not use Carriage returns or carriage return. (0x0D and 0x0d, 0x0A)

The last line of a file MUST NOT end in a 0x0A.

Lines MUST NOT have space before linefeed chars.

Naming Conventions:

Namespaces have a 1:1 relationship to the filesystem.

Classes are stored within the dir determined by the namespace.

The root dir of a lib contains a dir named after the top-level namespace, in the
case of Zend, the root dir would be library/ as it contains the Zend/ dir, which is the
top-level dir of Zend.

Namespaces:

Namespaces MUST contain only alphanumeric chars, underscore and \\

Namespaces SHOULD be mixcase:

NO:

Zend\PDF

Zend_ZMLRPC

YES:

Zend\Pdf

Zend\XmlRpc

Code deployed alongside Zend framework libs, but whom are not part of Zend Framework standard distru,
SHOULD utilize separate namespaces.

Namespace Aliases:

Aliasing ZF Library could SHOULD follow these patterns:

use Zend\Filter; //Alias is then "Filter"

use Zend\Form\Element; //Alias is "Element"

use Zend\Controller\Action\HelperBroker; //Alias as "HelperBroker"

use Zend\Filter\Int as IntFilter; //using Suffix

Classes:

Class names MUST contain only aphanumeric chars and the underscore.
Underscore acts as path seperators. Do_Something would be the filename to Do/Something.php

If a classname is more than one word, it must be Mixed case, NOT Caps:

NO:

Zend_PDF

YES:

Zend_Pdf

Abstract Classes:

Abstract classes follow the same conventions as classes, with one additional rule,
abstract classes SHOULD begin with abstract.

As an example, both AbstractAdapter and AbstractWriter are both valid abstract class names.

Abstract Classes SHOULD be in the same namespace as concrete implementations.

NO:

//In library/Zend/Log/AbstractWriter.php
namespace Zend\Log;

abstract class AbstractWriter implements Writer
{
}

//In library/Zend/Log/Writer/StreamWriter.php
namespace Zend\Log\Writer;

use Zend\Log\AsbtractWriter;

class StreamWriter extends AbstractWriter
{
}

YES:

namespace Zend\Log\Writer;

use Zend\Log\Writer;

abstract class AbstractWriter implements Writer
{
}

class StreamWriter extends AbstractWriter
{
}

Assuming there is ONLY STATIC METHODS, in a Abstract method, then you can remove Abstract from the classname:

namespace Zend\Uri;

abstract class UriFactory
{
	public static function factory($uri)
	{
		//Work goes here
	}
}

Interfaces:

Interfaces follow the same rules as classes, except there are two more of em:

Interface MUST be nouns or adjectives and interface class names SHOULD end with the term Interface.
For example, ServiceLocationInterface, EventCollectionInterface and PluginLocatorInterface are considered legit.

They MUST be in the same namespace as concrete implementations:

namespace Zend\Log\Writer;

interface class WriterInterface
{
}

Filenames:

All other PHP files MUST Only use alphanumeric chars, underscores and -. Spaces are NOT allowed.

Any file that contains PHP code SHOULD end with .php, except for view scripts.

An example of acceptable ones:

Zend/Db.php

Zend/Controller/Front.php

Zend/View/Helper/FormRadio.php

File names MUST map to class names as described above.

Functions and Methods:

Function names MUST contain only alphanumeric chars. Underscores are not permitted.
Numbers are permitted in function names, but discouraged.

Function names MUST always start with a lowercase letter. When a function name consists of more
than one word, the first letter of each new word MUST be capitalzied. Camelcase.

Verbose names are encouraged.

Examples of acceptable function names:

filterInput()

getElementById()

widgetFactory()

For object oriented programming, acessors (getters n setters) should be prefixed with get or set.
In implementing design patterns, such as hte singleton or factory patterns, the name of the method should
contain the pattern name where practical info is available.

For methods or objs that are priv or prot, we can begin their names with _. Methods public, should
not contain a _.

Functions in global space are allowed, but discouraged. Use wrapper static classes or specific namespaces.

Variables:

Variable names MUST contain only alphanumeric chars. Underscores are not permitted. Numbers are permitted in
variable names but are discouraged.

For vars that are priv or prot, we can begin with _. 

As per function names, variable names MUST be camelCase.

Verbose names are promoted.

Constants:

Contant names MAY contain both alphanumeric chars and underscores.

All letters in a constant must be CAPS, and all words must be seperated by a _.

For example: EMBED_SUPPRESS_EMBED_EXCEPTION is allowed, but not EMBED_SUPPRESSEMBEDEXCEPTION.

Constants MUST be defined as class members with the const modifier. Constants MAY be defiend in the Global
scope or within namespaces.

Coding Style:

PHP Code Demarcation:

PHP code MUST always be delimitted by the full-form:

<?php

?>

The ?> MUST Be omitted ifn o markup or code follows it.

Short tags MUST NOT be used within Zend, but MAY be used within view scripts.

Strings:

String Literals:

If there is no variable substitution in a string, use single '.

$a = 'Example';

String literals Containing Apostrophes:

When we have ` in a String, we can assign it with ".

$sql = "SELECT `id`, `name` from `people` "
	. "WHERE `name`='Fred' OR `name`='Susan'";

Variable Substitution:

Var substitution should be done as follows:

$greeting = "Hello $name, welcome back!";

$greeting = "Hello {$name}, welcome back!";

How it should NOT be done:

$greeting = "Hello ${name}, welcome back!";

String Concatenation:

Strings MUST be concatenated using the . operator. A space MUST always be added before the . and after it:

$company = 'Zend' . ' ' . 'Technologies';

When concatenating with the ., break it into lines:

$sql = "SELECT Ã¬d`, `name` FROM `people` "
	. "WHERE `name` = 'Susan' "
	. "ORDER BY `name` ASC ";

Class Names in Strings:

When referencing a class name in a String, the fully qualified class name MUST be provided,
and MUST NOT include a preceeding namespace seperator. 

If in the Namespace Zend\Log, and we refer to the class StreamWriter in the Writer subnamespace,
we would do as follows:

Zend\Log\Writer\Streamwriter

Arrays:

Numerical Arrays:

When declaring numeric arrays, you MUST add a whitespace after each element:

$sampleArray = array(1, 2, 3, 'Zend', 'Studio');

It is allowed to have multiple lines in Array declaration, though it must be aligned then:

$sampleArray = array(1, 2, 3, 'Zend', 'Studio',
					 $a, $b, $c,
					 56.44, $d, 500,
					 );

we SHOULD use the trailing comma above, it allows for adding of new items etc.

Associative Arrays:

If associative, they must be algiend as well:

$sampleArray = array('firstKey' => 'firstValue',
					 'secondKey' => 'secondValue');

If broken up on the next line, the general pattern must be as follows:

$sampleArray = array(
	'firstKey' => 'firstValue',
	'secondKey' => 'secondValue',
);

Namespaces:

Namespace Declaration:

Files SHOULD contain a single namespace. Several are discouraged.

Namespace declaration MUST be the first statement in a file, unless multiple
namespaces are declared.

The only code that should precede the declaration should be a file-level
documentation block, with a single empty line between the docblock and the namespace declaration.

In case of that multiple namespaces MUST Be used in the same file, they MUST use {} blocks:

namespace Foo
{
	//Code
}

namespace Bar
{
	//Code
}

Import Statements:

All explicit dependencies used by a class MUST be imported. 

The only exceptions are:

Code within the current namespace or subnamespaces of the current namespace

Class names that are dynamically resolved (e.g, from a plugin broker)

There MUST be one use keyword per declaration.

There MUST be one blank line after the use block.

use Zend\Log\Logger,
use Zend\Event\EventManager as Events;
use Zend\View\PhpRender as View;

Imports SHOULD be in alphabetical order.

Classes:

Class Declaration:

Classes MUST be named according to Zend Framework's naming conventions.

The brace MUST be written on the line under the class name, at the same level of indentation 
as the class declaration.

Every class MUST have a documentation block that conforms to the PHPDOcumentor stnadard.

All code in a class MUST be indented with four spaces additional to the level of indentation
of the class declaration.

PHP Files declaring classes MUST contain only a single PHP class only.

Placing additional code in class files MAY be done, but is discouraged.
In such cases, two lank lines MUST seperate the class from any additional PHP code in the class file.

An example:

/**
  * Documentation block here
  * /
class SampleClass
{
	// All contents of class
	// must bei ndented four spaces
}

Some examples of declaration of dependencies in case of long running names:

class sampleClass extends AbstractFoo implements Bar
{
}

class SampleClass extends AbstractFoo implements 
	Bar
{
}

class SampleClass implements
	BarInterface,
	BazInerface
{
}

Class Member Variables:

As per normally with the Zend Framework's variable naming conventions.

The var construct MUST NOT be used. Member vars MUST declare their visibility by using
one of the private, protected or public.

Exceptions:

Each component MUST have a marker "ExceptionInterface" interface.

Concrete exceptions for a component MUST live in an Exception subnamespace.
Concrete exception classes MUST implement the component's ExceptionInterface,
and SHOULD extend one of the PHP's SPL exception types.

Conrete exception classes SHOULD be named after the SPL exception type they extend,
but MAY have a more descriptive name if warranted.

Subcomponents MAY define their own exception marker interface and concrete implemetantions,
following the same rules as the root component leve. The subcomponent exception interface
should extend the parent component's ExceptionInterface.

An example:

/**
  * Component exceptions
  */

// In Zend/Foo/Exception/ExceptionInterface.php:
namespace Zend\Foo\Exception;

interface ExeptionInterface
{
}

//In Zend/Foo/Exception/RuntimeException.php:
namespace Zend\Foo\Exception;

class RuntimeException extends \RuntimeException implements ExceptionInterface
{
}

//In Zend/Foo/Exception/TripwireException.php
namespace Zend\Foo\Exception;

use RuntimeException;

class TripwriteException extends extends RuntimeException implements ExceptionInterface
{
}

/**
  * Subcomponent exceptions
  */
// In Zend/Foo/Bar/Exception/ExceptionInterface.php
namespace Zend\Foo\Bar\Exception;

use Zend\Foo\Exception\ExceptionInterface as FooExceptionInterface;

interface ExceptionInterface extends FooExceptionInterface
{
}

//Subcomponent concrete exception
//In Zend/Foo/Bar/Exception/DomainException.php
namespace Zend\Foo\Bar\Exception;

class DomainException extends \DomainException implements ExceptionInterface
{
}

Using Exceptions:

Concrete exceptions should not be imported, instead, either use exception classes
within your namespace or import the Exception namespace you will use.

namespace Zend\Foo;

class Bar
{
	public function trigger()
	{
		//Resolves to Zend\Foo\Exception\RuntimeException
		throw new Exception\RuntimeException();
	}
}

//Explicit importing

namespace Zend\Foo\Bar;

use Zend\Foo\Exception;

class Baz
{
	public function trigger()
	{
		//resolves to Zend\Foo\Exception\RuntimeException
		throw new Exception\RuntimeException();
	}
}

When throwing exception, you should provide a useful exception message.
Such messages SHOULd indicate the root cause of an issue and provide meaningful diagnostics.

An example:

The method throwing the exception (__METHOD__)

Any params that were involved in calculations that led to the exception (often class names or var types will be sufficient)

Example:
throw new Exception\InvalidArgumentException(sprintf(
	'%s expects a string argument; received "%s"',
	__METHOD__,
	(is_object($param) ? get_class($param) : gettype($param))
));

Functions and Methods:

Function and Method Declaration:

Functions MUST be named according to Zend Framework's function naming conventions.

Methods inside classes MUST always declare their visibility by one of the private, public, or protected.

As with classes, the brace MUST always be written on the line underneath the function name.
Space MUST Not be inserted between the function name and the opening paranthesis for the arguments.

functions SHOULD NOT be declared in the global scope.

An example:

/**
  * Documentation Block here
  */
class Foo
{
	/**
	  * Documentation Block Here
	 */
	public function bar()
	{
		//All contents of function must be intended four spaces
	}
}

Case of having too long of a list of args, we have to linebreak them as follows:

class Foo
{
	/**
	  * Documentation Block Here
	  */
	public function bar(
		$arg1,
		$arg2,
		$arg3,
		$arg4,
		$arg5,
		$arg6
	) {
		//All contents of the function must be intended four spaces
	}
}

Pass by reference is the only allowed mechanism in method declarations, as Call-time pass-by-reference MUST NOT
be used:

/**
  * Documentation Block here
  */
class Foo
{
	/**
	  * Documentation Block here
	  */
	public function bar(&$baz)
	{
	}
}

The return value, MUST NOT be enclosed in ():

/**
  * Documentation block here
  */
class Foo
{
	/**
	  * WRONG
	  */
	public function bar()
	{
		return($this->bar);
	}

	/**
	  * RIGHT
	  */
	public function bar()
	{
		return $this->bar;
	}
}

Closure Definitions:

Closure definitions must generally follow the same rules as for functions and methods:

Space MUST NOT be inserted between the function keyword and the opening paranthesis for the arguments.

A space MUST be added between any use statement used in declaration and the opening paranthesis for its arguments.

etc.

The following example showcases the rules:

/**
  * Opening Brace
  */
$foo = function($x)
{
	//WRONG
};

$foo = function($x){
	//RIGHT
};

/**
  * Use Statement Declaration
  */
$foo = function($x) use($y) {
	//WRONG
};

$foo = function($x) use ($y) {
	//Right
}

/**
  * Indnetation
  */
$foo = array_map(function($x){
	//WRONG
return strtolower($x);
}, $array);

$foo = array_map(function($x) {
	//RIGHT
	return strtolower($x);
}, $array);

Function and Method usage:

Function arguments MUST be separated by a single trailing space after the comma delimeter.

An example:

threeArguments(1, 2, 3);

Call-time pass-by-reference MUST NOT be used. In passing arrays as arguments to a function, the function call MAY include the 
array declaration and MAY be split into multiple lines.

An example:

threeArguments(array(1, 2, 3), 2, 3);

threeArguments(array(
	1,
	2,
	3,
	'Zend',
	'Studio',
	$a,
	$b,
	$c,
	56.44,
	$d,
	500
), 2, 3);

Control Statements:

If/Else/Elseif

Control statements based on the if and else if construct must have a single space before the
opening paranthesis of the conditional and a single space after hte closing paranthesis.

Within the conditionals tatements between the parantheses,e operators must be seperated by
spaces of readability. Inner parantheses SHOULd be used ot improve logical grouping.

The opening brace MUST be written on the same line as the conditional statement,
if the conditional statement does not contain a line feed. Hte closing brace must be
written on its own line. Any content within the bracemust be indented:

if ($a != 2) {
	$a = 2;
}

If the maximum length is exceeded, break the line:

if (($a == $b)
	&& ($b == $c)
	|| (Foo::CONST == $d)
) {
	$a = $a;
}

The following example showcases how to use if and elses:

if ($a != 2) {
	$a = 2;
} else {
	$a = 7;
}

if ($a != 2) {
	$a = 2;
} elseif ($a == 3) {
	$a = 4;
} else {
	$a = 7;
}

if (($a == $b)
	&& ($b == $c)
	|| (Foo::CONST == $d)
) {
	$a = $d;
} elseif (($a != $b)
	|| ($b != $c)
){
	$a = $c;
} else {
	$a = $b;
}

Switches:

switch ($numPeople) {
	case 1:
		break;

	case 2:
		break;

	default:
		break;
}

If we intend to fallthrough conciiously in a Switch case, comment that so you know:

//makes no sense, insert comment after case a and b
switch ($foo) {
	case 'a':
	case 'b':
	case 'c':
		$bar = 'baz';
		break;
}

switch ($foo) {
	case 'a':
		$baz = 'baz';
		//Break intentionally omitted

	case 'b':
	case 'c':
		$bar = 'baz';
		break;
}

Inline Documentation:

Documentation Format:

It must adhere to the phpDocumentor format.

An example:

/**
  * @param string $argument1 This is the description of the first string argument being a parameter
  */

What follows is a listing of the type of tags available:

Tag 		Element 			Desc

api 		Methods 			Declares that elements are suitable for consumption by third parties

author 		Any 				documents the author of the associated element

category 	File,class 			Groups a series of packages together

copyright 	any 				Documents the copyright info for the associated element

deprecated 	any 				Indicates that the associated element is deprecated and can be removed in future versions

example 	any 				Shows the code of a specified example file or optionall just a port ion of it

filesource 	File 				includes the source of the current file for use in the output

global 		Variable 			informs phpDocumentor of a global variable or its usage

ignore 		Any 				tells phpDocument that hte associated element is not to be included in the documentation

internal 	Any 				denotes that the associated elements is internal to this application or libs and hides it by default

license 	File,Class 			indicates which license is applicable for the associated element

link 		Any 				indicates a relation between the associated element and a page of a website.

method 		Class 				allows a class to know which 'magic' methods are callable.

package 	File, Class 		categorizes the associated element into a logical grouping or subdiv.

param 		Method, Function 	documents a single argument of a function or method

proeprty 	Class 				allows a class to know which 'magic' properties are present

proeprty-read Class 			allows a class to know which magic props are present that are read only

property-write Class 			allows a class to know which magic props are present that are write only

return 		Method, Function 	documents the return value of functions or methods

see 		Any 				indicates a reference from the associated element to a website or other elements

since 		Any 				indicates at which version the associated element became available.

source 		Any, except File 	shows the source code of the associated element

subpackage 	File, Class 		categorizes the associated element into a logical grouping or subdivision

throws 		Method, Function 	indicates wether the associated element could throw a specific type of exception

todo 		Any 				indicates wether any development activity should still be executed on the associated element.

uses 		Any 				indicates a reference to and from a single associated element

var 		Properties 			

version 	Any 				indicates the current version of Structural Elements.

Annotations can come along as well, which, do influence the way the app behaves as well.

An example:

/**
  * @ORM\Entity(repositoryClass="MyProject\UserRepository")
  */

Back to the Coding Standards:

General Notes:

Classes and interfaces referenced by annotations MUST follow the same resolution order as PHP.
In other words:

If the class is in the same namespace, simply refer to the class name without the namespace:

namesapce Foo\Component;

class bar
{
	/**
	  * Assumes Foo\Component\Baz;
	  * @param Baz 4baz
	  */
	public function doSomething(Baz $baz)
	{
	}
}

If the class is in a subnamespae of the current namespace, refer to it relative to the current namespace:

namespace Foo\Component;

class Bar
{
	/**
	  * Assumes Foo\Component\Adapter\Baz:
	  * @param Adapter\Baz $baz
	  */
	public function doSomething(Adapter\Baz $baz)
	{
	}
}

If the class is imported, either via a namespace or a explicit class name, use the name as specified by the import:

namespace Foo\Component;

use Zend\EventManager\EventManager as Events;
use Zend\Log;

class Bar
{
	/**
	  * Assumes Zend\EventManager\EventManager and Zend\Log\Logger:
	  * @param Events $events
	  * @param Log\Logger $log
	  */
	public function doSomething(Events $events, Log\Logger $log)
	{
	}
}


If the class is from another namespace, but not explicitly imported, provide a globally resolvable name:

namespae Foo\Component;

class Bar
{
	/**
	  * Assumes \Zend\EventManager\EventManager:
	  * @param \Zend\EventManager\EventManager $events
	  */
	public function doSomething(\Zend\EventManager\EventManager $events)
	{
	}
}

The class example here should rarely occur, since we import dependencies, but it can happen. It may happen
in @return annotations as return types might be determined outside the class scope.

Files:

Every file that contains PHP code MUST have a doclobkc at the top of the file that contains
these phpDocumentor tags at a minimum:

/**
  * Zend Framework (http://framework.zend.com/)
  *
  * @link http://github.com/zendframework/zf2 for the canonical source repository
  * @copyright Copyright (c) 2005-2014 Zend Technologies USA Inc. (http://www.zend.com)
  * @license http://framework.zend.com/license/new-bsd New BSD License
  */

Classes:

Every class MUST have a Docblock that contains the following phpDocumentor structure at a minimum:

/**
  * Short description for class
  *
  * Long description for class (if any)...
  */

Functions:

Every function, including object methods, MUST have a docblock that contains at a minimum:

A description of the fuction

all of the arguments

all of the possible return values (even "void")

It is not nessecary to use the @access, cause that is already known from modifieds.

If a function or method may throw an exception, use one @throws for each discrete exception thrown:

@throws exceptionclass [description]

Server Requirements:

Zend Framework 3 requires PHP 5.6 >=.

The recommended way of installing ZF3 and other components your app depends on, is using Composer.
This forces the need of shell access (SSH) to be able to execute Composer cmd-line tool. Some web hostings provide
FTP access only, so you won't be able to install a ZF3-based app on such serves that usual way.

ZF3 utilizes URL rewriting extension for redirecting web-users to entry script of your site (You have to enable Apache's mod_rewrite module).
You may also need to install some PHP extensions, like memcached. This can be difficult when using a shared web hosting and requires
that you have admin rights on your server.

An alternative is also to install ZF3 based web app to a cloud-based hosting service, like Amazon.
Amazong provides Linux server instances as part of EC2 service.

Security:

ZF3 provides the following features allowing to make your website secure:

Entry Script (index.php) : is the only PHP file accessible to web visitors. ALl other PHP files are located outside of Apache
document root. 

Routing: Allows to define strict rules on how an acceptable page URL should look like. If a site user enters an invalid
url in a web browser nav bar, he is redirected.

Access Control Lists (ACL) and Role-Based Access Control (RBAC) : Allow to define fleible rules for granting and denying
access to certain resources of your website. For example, an anonymous user would have access to your index page only,
authenticated users would have access to their profile page, and the admin should have access to admin panel.

Form Validators and Filters: Forces input to conform.

Captcha and CSRF (Cross-Site REquest Forgery): used for human checks

Zend\Escaper: This component allows to strip unwanted HTML tags from data outputted to site pages.

Cryptography support allows you to store sensitive data with Crypto algos.

Performance:

Lazy class autoloading: Classes are loaded on demand. We don't have to write require_once for each class
we want to load. The framework discovers the classes we need with autoloading.

Efficient service nad PLugin loading: ZF3, classes are instansiated only when they really need to. 
This is achieved through service manager (The central container for services)

Support of Caching: PHP has several caching extensions (like Memcached) that can be used to speed-up ZF3-based
websites. Caching saves frequently used data to memory.

Dessign patterns:

ZF3 uses the following patterns:

Model-View-Controller (MVC) pattern. Is used in all modern PHP frameworks. This means we have three layers:
models (Business logic goes here), views (presentation goes here), controllers (code responsible for interaction)

Domain Driven design (DDD) pattern. In ZF3, you will have model layer further divided into entities
(classes mapped on DB tables), repositories (Classes used to retrieve entities from DBs), value objects (model classes
not having identity), services(classes responsible for business logic.)

Aspect Oriented Design pattern. In ZF3, everything is event-driven. When a site user requests a page, a event
is generated (triggered). A listener (or observer) can catch event and do something with it. For example,
Router component parses the URL and determines what controller class to call. When the evne finally reaches the page renderer,
an HTTP response is generated and the page shown.

Singleton Pattern. In ZF3, there is the service manager object, which is the centrealized conainer of all services
available in the app. Each service exists in a single instnace only.

Stratergy pattern. A stratergy is just a class encapsulating some algo. And you can ue different algos based on some
condition. For example, the page renderer has sevveral rendering stratergies, making it possible to render web pages
differently (the renderer can generate an HTML page, a JSON response, an RSS Feed etc.)

Adapter pattern: Adapters allow to adapt a generic class to concrete use case. For example, Zend\Db Component 
provides access to database in a genric way, interally, it uses adapters for each supported database (SQLite, MySQL, PostgreSQL etc.)

Factory pattern: You can generate an instnace of a class using the new operator. Or you can create it with a factory.
A factory is just a class encapsulating creation of other objects. Factories simplify dependency injection.
It also simplifies the testing of model and controller classes.

Gateway pattern: Encapsulate API communication to this class and call simple method calls to them.

Main ZF3 Components:

ZF3 consists of several decoupled components.

There are several "main" Components that are used (explicitly or implicitly) in almost any web app:

Zend\EventManager : This component allows to send events and register listens to react to them

Zend\ModuleManager : In ZF3, every app consists of modules and this component contains module loading functionality

Zend\ServiceManager : This is the centralized registry of all services available in the app, making it possible to
access services from any point of the website.

Zend\Http : An easy interface for doing HTTP requests

Zend\Mvc : Support of Model-View-Controller pattern and separation of business logic from presentation

Zend\View : Provides a system of helpers, output filters and variable escaping. used in presentation layer.

Zend\Form : Web form data collection, filterin, validation and rendering.

Zend\InputFilter : Provides an ability yo define form data validation rules

Zend\Filter : Provides as et of ocommonly used data filters, like string trimmers

Zend\Validator : Provides a set of ocommonly used validators.

Zend Skeleton Application:

Generally, you should read the Appendixg : Cofiguring Web Development Environment, but i will read this book in the
order of that it occurs. As such, i will begin with the parts of the Skeleton App first.

Getting Zend Skeleton Application:

To aquire the skeleton, we get it through the composer which we can do as follows:

cd ~

php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"

php composer-setup.php

php -r "unlink('composer-setup.php');"

The commands above change your working dir to the homr dir, downloads the composer-setup.php installer
script and runs it, then removes the installer.

Once we have run the above commands, we should have the composer.phar file in our working dir.

Now type the following command on your cmd line:

php composer.phar create-project -sdev zendframework/skeleton-application helloworld //This will get hte latest from Github, to get the latest version
//use:

composer create-project -s dev zendframework/skeleton-application src 3.0.1 //Might have to look up proper command for finding 3.0.1 through
//composer.

The above command will create a project and download it to a dir called helloworld.

We will get a prompt that will have us answer tons of questions in regards to our install, as follows:

NOTE: We can just install the dependencies that we skip, on a later notice.

Do you want a minimal install (no optional packages)? Y/n
n

Would you like to install the developer toolbar? y/N
n

Would you like to install caching support? y/N
n

Would you like to install database support (installs zend-db)? y/N
n

Would you like to install forms support? y/N
y

Will install zendframework/zend-mvc-form (^1.0)
When prompted to install as a module, select application.config.php or modues.config.php

Would you like to install logging support? y/N
n

Would you like to install MVC-based console support? (We recommend migrating to zf-console, symfony/console, or Aura.CLI) y/N
n

Would you like to install i18n support? y/N
n

Would you like to install the official MVC plugins, including PRG support, identity and flash messages? y/N
n
 Will install zendframework/zend-mvc-plugins (^1.0.1)
 When prompted to install as a module, select application.config.php or modules.config.php

Would you like to use the PSR-7 middleware dispatcher? y/N
n

Would you like to install sessions support? y/N
n

Will install zendframework/zend-session (^2.7.1)
When prompted to install as a module, select application.config.php or modules.config.php

Would you like to install MVC testing support? y/N
n

Will install zendframework/zend-test (^3.0.1)

Would you like to install the zend-di integration for zend-servicemanager? y/N
n

Once we have answered the questions, the installer will download and install all necessary packages and asks you to 
which config file you would like to inject information about install modules. When prompted, type 1 and press enter:

Please select which config file you wish to inject 'Zend\Form' into:
	[0] Do not inject
	[1] config/modules.config.php
	[2] config/development.config.php.dist
	Make your selection (default is 0):1

	Remember this option for other packages of the same type? (y/N) y

Next the installer will ask you if you would like to remove existing version control files from the project.
Since you will probably store your web app in your own version control system (like git), and do not need existing VCS files,
type y and press Enter.

Do you want to remove the existing VCS (.git, .svn..) history? [Y,n]? y

Now copy the composer.phar to the helloworld dir:

cp composer.phar helloworld

and finally, enabling the development mode by the following command:

cd helloworld
php composer.phar development-enable

The development mode is typically used when you develop your app. When you enable the dev mode
additional dev config files are created in the web app config dir. in this mode, your app may
optionally load additional dev modules. Configuration caching is also disabled in this mode 
allowing you to change your websites' config files and see the changes immedeatly.

Once you have finished the development, you can enable the production mode, by typing the following:

php composer.phar development-disable

Typical Directory Structure:

config
data
module
	Application
public
	css
	fonts
	img
	js
	index.php
vendor
composer.json
composer.lock
composer.phar
docker-compose.yml
Dockerfile
LICENSE.md
phpunit.xml.dist
README.md
TODO.md
Vagrantfile

In the top dir, which we will refer to as APP_DIR, there are the following files:

composer.json, a JSON configuration file for Composer.

composer.lock file, contains info about packages installed with Composer.

composer.phar is an executable PHP archive containing the code of Composer dependency management tool.

docker-compose.yml and Dockerfile files are auxiliary files used only if you use Docker container manager tool. In this book,
we do not cover the usage of Docker.

LICENSE.md is a text file containing ZF3 license (You had a chance to read it before), do not remove or modify it.
ZF3 license does not allow for it.

phpunit.xml.dist file is a config for PHPUnit (unit testing framework). You use this file when you want to create unit tests
for your website.

README.md is a text file containing a brief description of the skeleton app. You typically will replace this file contents
with the info about your website, its name, what it does, and how to install it.

TODO.md is an auxilliary file that can be safely removed.

Vagrantfile is an auxiliary file that contains configuration for Vagrant, which is a virtual development environment manager.
You can ignore this file if you don't know what Vagrant is. This book, does not use Vagrant.

We also have several subdirs:

The config dir, contains app-level config files.

The data dir, contains the data your app might create, it also contains cache used to speed up the ZF

The module dir contains all app modules. Currently there is a single module called Application. The Application
is the main module of your website. You can also put other modules here if you wish. We will talk about it a bit later.

The vendor directory is to contain third-party lib files, including ZF3 lib fiesl. This dir is typically populated by composer.

The public dir contains data publically accessible by the web-user. As you can se, web-users will mainly communicate with the index.php,
which is also called the entry point of your website.

The website has only one entry point, due to it being more secure.

Inside of the public dir, you can also find hidden .htaccess file. Its main purpose it to define URL rewriting rules.

The public dir contains several subdirs also publically accessible by web-users:

css subdir contains all public CSS files.

fonts subdir contains app-specific web-fonts.

img subdir contains publically accessible images (.JPG, .PNG, .GIF, .ICO, etc)

js subdir stores publicly accessible JavaScript files used by your web-pages. Typically, files of jQuery lib are placed
here, but you can put your own JS files here, too.

Because the Zend Skeleton App is stored on GitHub, inside of the Dir structure, you can find hidden .gitignore file.
This is a GIT version control system's files. You can ignore it (or even remove them if you do not plan to store your code in a GIT repo)

Application Dependencies:

A dependency is a third party code. For example, our website uses ZF3.

In composer, any lib is called a package. All packages installable by Composer are registered on Packagist.org
site. With Composer, you can identify the packages that your app requries and have Composer to download and install them automatically.

The dependencies of the skeleton applicatoon are declared in APP_DIR/composer.json file:

{
	"name": "zendframework/skeleton-application",
	"description": "Skeleton Application for Zend Framework zend-mvc applications",
	"type": "project",
	"license": "BSD-3-Clause",
	"keywords": [
		"framework",
		"mvc",
		"zf2"
	],
	"homepage": "http://framework.zend.com",
	"minimum-stability": "dev",
	"prefer-stable": true,
	"require": {
		"php": "^5.6 || ^7.0",
		"zendframework/zend-component-installer": "^1.0 || ^0.3 || ^1.0.0-dev@dev",
		"zendframework/zend-mvc": "^3.0.1",
		"zfcampus/zf-development-mode": "^3.0",
		"zendframework/zend-mvc-form": "^1.0",
		"zendframework/zend-mvc-plugins": "^1.0.1",
		"zendframework/zend-session": "^2.7.1"
	},
	"autoload": {
		"psr-4": {
			"ApplicationTest\\": "module/Application/test"
		}
	},
	"extra": [],
	"scripts": {
		"development-disable": "zf-development-mode disable",
		"development-enable": "zf-development-mode enable",
		"development-status": "zf-development-mode status",
		"serve": "php -S 0.0.0.0:8080 -t public/ public/index.php"
	}
}

In this file, we see some basic info about the skeleton app, name ,desc, license, keywords, homepage..

You will typically change this info for your future websites. This info is optional, so you can even safely remove it, if you do  
not plan to publish your web app on Packagist catalog.

What is interesting for us now is the require key. The require key contains the dependencies declarations for our application.
We see that we require PHP engine 5.6 or later, and several ZF components, like zend-mvc, zend-mvc-form etc.

The information contained in composer.json file is enough to locate the dependencies, download and install them into
the vendor subdir. If at any time you determine that you need to install another dependency, you can do that by
editing composer.json and adding your dependency in it, and then typing the following commands on your CMD shell:

php composer.phar self-update
php composer.phar install

The commands above will self-update the COmposer to the latest available version, and then install your dependencies.
By the way, Composer does not install PHP for you, it just ensures PHP has an appropiate version, and if itno, it will warn you.

If you look inside the vendor subdir, you can see that it contains a lot of files. ZF3 files can be found inside the 
APP_DIR/vendor/zendframework/ dir:

vendor
	bin
	composer
	container-interop
	zendframework
		zend-authentication
		zend-code
		zend-component-installer
		zend-config
		zend-escaper
		zend-eventmanager
		zend-filter
		zend-form
		zend-http
		zend-hydrator
		zend-i18n
		zend-inputfilter
		zend-loader
		zend-modulemanager
		zend-mvc
		zend-mvc-plugin-fileprg
		zend-mvc-plugin-flashmessenger
		zend-mvc-plugin-identity
		zend-mvc-plugin-prg
		zend-router
		zend-servicemanager
		zend-session
		zend-stdlib
		zend-uri
		zend-validator
		zend-view

In some other frameworks, another (conventional) way of dependency installation is used. You just download the dpeendecy lib as an archive, unpack it and put it somewhere inside o your dir structure (typically to vendor dir).

This approch was used for ZF1, but in ZF3, use Composer.

If we need to uninstall a specific depdendency that is causing us issues, we can do as follows:

php composer.phar remove zendframework/<whatever we want to remove> or manually edit the composer.json file, remove the line related
to that thing we want to remove, and then run php composer.phar update

Apache Virtual Host:

We are almost ready to host our skeleton. We just need to setup the virtual host.

A virtual host means that you can run several websites on the same machine. The virtual sites are differentiated by 
domain name (like site.mydomain.com and site2.mydomain.com) or by portnumber (like localhost and localhost:8080)

Virtual hosts work transparently for site users, that means users have no idea wether the sites are on the same machine
or different ones.

Currently, we have the skeleton app inside of our home dir. To let apache knwo about it, we need to 
edit the virtual host file.

Virtual host file may be located at a different path, depending on your OS. For example in Linux Ubuntu it
is located in /etc/apache2/sites-available/000-default.conf file. For OS- and Server-specific info about virtual
hosts, we will cover that later in the Appendix A.

Let's now edit the default virtual host file to make it look like below:

<VirtualHost *:80>
	ServerAdmin webmaster@localHost

	DocumentRoot /home/username/helloworld/public

	<Directory /home/username/helloworld/public/>
		DirectoryIndex index.php
		AllowOverride All
		Require all granted
	</Directory>
</VirtualHost>

Line 1 of the file, makes Apache listen to all the IP addresses on port 80.

Line 2 defines the web masters Email. If something bad happens, it will send an alert email to that
adress. We can enter our address here.

Line 4 defines the document root dir (APP-DIR/public). All files and dirs under the document root will be accessible
by web-users. You should set this to be the absolute path to skeleton application's public dir. So the dirs
and files inside public (like index.php, css,js, etc) will be accessible, while dirs and files above public dir
(like config, module, etc) won't be accessible by web users.

Lines 6-10 defines rules for the document root dir (APP_DIR/public). For example, the DirectoryIndex dir tells Apache
that index.php should be used as the default index file. The AllowOverride All directive allows to define any rules in .htaccess
files. The Require all granted directive allows everyone to visit the website.

Zend Framework 3 utilizes Apache's URL rewriting module for redirecting web-users to entry script of your website.
Please ensure that your web server has mod_rewrite module enables. This will be covered in Appendix A.

After editing the config file, do not forget to restart Apache to apply our changes.

Opening the Website in Your Browser:

To open the website, just type http://lcoalhost in your browsers Navigation bar.

On the page that appears, you can see the navigation menu at the top. The navigation bar currently contains
the single linke named Home. Under the nav bar, you can see the "Welcome to Zend Framework" caption. Below the caption,
you can find some advices for beginners.

Creating NetBeans project:

Now that we have the skeleton running, we can open it up in netbeans.

We go to netbeans, choose a new project, and choose PHP, PHP application with Existing Sources.

In the Name and Location dialog page, you should enter the path to the code (like /home/username/helloworld), the name
for the project (for example, helloworld) and specify the version of PHP your code uses (5.6 or later). The PHP version
is needed for the NetBeans PHP syntax checker which will scan your PHP code for errors and highlight them.

Press the Next button to go the next dialog page.

In the run configuration page, it is recommended that you specify the way you run the website (Local Web Site), and website
URL (http://localhost). Keep the Index File field empty, cause we are using mod_rewrite, the actual path to index.php file
is hidden by Apache). 

If we see a error message akin to Index File must be specified in order to run or debug project in cmd line, just ignore it.

Click the Finish button to create the project. When the helloworld project has been successfully created,
you should see the project window:

In the project window, you can see the menu bar, the tool bar and the Projects pane, where your proejct files are listed,
and, in the right part of the window, you can see the code of the index.php entry file.

please refer to appendix B for more Netbeans usage tips, including launching and interactively debugging ZF3-based websites.

Hypertext Access File (.htaccess):

We've mentioned the APP_DIR/public/.htaccess file when talking about typical dir structure. Now let's try to understand
the role of this file.

The .htaccess is actually a Apache web server's config file allowing to override some web server's global
config. The .htaccess file is a directory-level configuration, which means it affects only its owning directory and all-subdirs.

The content of .htaccess file is presented below:

RewriteEngine On
# The following rule tells Apache that if the request filename
# exists, simply serve it
RewriteCond %{REQUEST_FILENAME} -s [OR]
RewriteCond %{REQUEST_FILENAME} -l [OR]
RewriteCond %{REQUEST_FILENAME} -d
RewriteRule ^.*$ - [L]
# The following rewrites all other queries to index.php. The 
#condition ensures that if you are using Apache aliases to do
# mass virtual hosting or installed the project in a sub-dir
# the base path will be prepended to allow proper resoltuion
# of the index.php file; it will work in non-aliased environments as well, providing a safe, one-size
# fits all solution
RewriteCond %{REQUEST_URI}::$1 ^(/.+)/(.*)::\2$
RewriteRule ^(.*) - [E=BASE:%1]
RewriteRule ^(.*)$ %{ENV:BASE}/index.php [L]


Line 1 tells Apache web server to enable URL rewrite engine (mod_rewrite). The rewrite engine modifies the incoming URL requests,
based on the regex rules. This allows you to map arbitrary URLs to your internal URL structure in any way you like.

Lines 4 - 7 define rewrite rules that tell the web server that if the client (web browser) requests a file that exists in the document
root dir, than to return the contents of that file as a HTTP response.

Because we have our public dir inside of the virtual host's document root, we allow site users to see all files inside of the public dir,
including the index.php, css, JS, and image files.

Lines 14 - 16 defines rewrite rules that tell Apache what to do if the site user requests a file which does not exist in document
root. In such a case, the user should be redirected to index.php

Table 2.1 contains several URL rewrite examples. The first and second URLs point to existing files, so mod_rewrite returns
the requested file paths. The URL in the third example points to a non-existent file htpasswd (which may be a symptom of a hacker attack),
based on our rewrite rules, the engine returns index.php file:

Request URL 				Rewritten URL
http://localhost/index.php 	File exists, return the local file APP_DIR/public/index.php

http://localhost/css/bootstrap.css File exists, return the local file APP_DIR/public/css/bootstrap.css

http://lcaolhost/htpasswd 	File does not exist, return APP_DIR/public/index.php instead.

Blocking Access to the Website by IP Address:

Sometimes we may only wish to grant access to one IP, be that our own or otherwise.

To achieve this, we modify the virtual host and add the following line to it:

Require ip <target_ip> //The <> are required in this case.

HTTP Authentication:

To give permission through PW and Username, we can do as follows:

...
<Directory /home/username/helloworld/public/>
	DirectoryIndex index.php
	AllowOverride All
	AuthType Basic
	AuthName "Authentication Required"
	AuthUserFile /usr/local/apache/passwd/passwords
	Require valid-user
</Directory>
...

Line 5 defines the authType, basic being unencrypted. We can also put in AuthType digest, if we wish.
Thisis supported by most recent browsers, and encrypts the digest.

Line 6 defines the text that will be displayed to the user when we try to log in.

Line 7 defines the file where PWs will be stored. This file should be created with the htpasswd utility.

Line 8 will allow anyone to log in that is listed in the password file, and who correctly enters their pw.

To create passwords file, type the following command:

htpasswd -c /usr/local/apache/passwd/passwords <username>

In the command above, we replace username with the name of the user. We can choose an arbitrary name.

The command will request the User's PW and write the PW to the file:

# htpasswd -c /usr/local/apache/passwd/passwords <username>
New password:
Re-type new password:
Adding password for user <username>

The following part will be about Authentication and Authorization:

There are three types of modules involved in the authentication process. You will usually need
to choose at least one module from each group:

Authentication type (AuthType directive):

Require: This can have two values. Either, we put the Require valid-user, which just requires a valid user, or, we can specify
even more to who should access : by Require user Ex1, ex2 etc.

AuthType Digest: This serves to be a form of Digest encryption. However, it is not a security gain above using just 
Basic. Fact is, the files on the server are more exposed. As such, you can instead use basic auth and encrypt the whole
connection using mod ssl.

The Digest is built on MD5.

An example of using Digest Authentication:

<Location "/private/">
	AuthType Digest
	AuthName "private area"
	AuthDigestDomain "/private/" "http://mirror.my.dom/private2/"

	AuthDigestProvider file
	AuthUserFile "/web/auth/.digest_pw"
	Require valid-user
</Location>

AuthDigestDomain defines what domain to protect

The Password file refernece in the AuthUserFile dir may be created and managed using the htdigest tool.

NOTE: Digest authentication is not more safe than basic. A man-in-the-middle attacker can trivially force the browser
to downgrade to basic auth. And even a passive eavesdropper can brute-force the PW using graphics hardware, cause
the hashing algo used by digest is too fast.

Another problem is that the storage of the PW on the server is insecure. The contents of a stolent htdigest file can be used
directly for digest authentication. Therefor, using mod ssl to encrypt the whole connection is better.

mod auth digest only works properly on platforms where APR supports shared memory.

However, the AuthType Digest is deprecated, so i will write about the SSL mod instead.

SSL in Apache relies upon OpenSSL to provide the cryptography engine.

Environment Vars:

This module can be configed to provide several items of SSL info as additional environment vars to the SSL and CGI namespace. This info is not 
provided by default for performance reasons. The generated vars are listed in the table below. For backward compability,
the info can be made available under different names. 

SSL/TLS Strong Encryption: Compability:

What follows here is backwards compability between mod_ssl ando ther SSL solutions. mod_ssl is not the only SSL solution
for Apache; four additional products are (or were) also available: Ben laurie's Apache-SSL, Red hat's commercial Secure Web Server (based on
mod_ssl), Convalent's commercial Raven SSL module (based on mod_ssl) and C2Net's (Redhat's) commercial product Stronghold (based on
mod_ssl since 3.x)

mod_ssl provides a superset of the functionality of all the other solutions, so it's simple to migrate from one of the older modules to mod_ssl. 
The configuration directives and environment variables names used by the older SSL solutions vary from those used in
mod_ssl; mapping tables are included here to give equivalents used by mod_ssl.

Configuration Directives:

The mapping between config dirs used by Apache-SSL 1.x and mod_ssl 2.0.x is given in Table 1. The mapping from Sioux 1.x and Stronghold 2.x is only partial because of special functionality in these interfaces which mod_ssl does not provide:

//NOTE We will be using mod_ssl 3.0.

Table 1: Configuration Directive Mapping

Old Driective 				mod_ssl Directive
Apache-SSL 1.x & mod_ssl 2.0.x compability 			 Comment: 

SSLEnable 			SSLEngine on 					 compactified

SSLDisable 			SSLEngine off 					 compactified

SSLLogFile file 									 Use per-module LogLevel setting instead

SSLRequiredCiphers spec SSLCipherSuite Spec 		  renamed

SSLRequireCipher c1 .. SSLRequire %{SSL_CIPHER} in {"c1", ...} 	generalized

SSLBanCipher c1 .. 		SSLRequire not (%{SSL_CIPHER} in {"c1", ...}) 	generalized

SSLFakeBasicAuth 		SSLOptions +FakeBasicAuth 	merged

SSLCacheServerPath dir 	- 							removed

SSLCacheServerPort integer 	- 						removed

Apache-SSL 1.x compability:

SSLExportClientCertificates SSLOptions +ExportCertData 	merged

SSLCacheServerRunDir dir 							functionality not supported

Sioux 1.x compability:

SSL_CertFile file 		SSLCertificateFile file 			renamed

SSL_KeyFile file 			SSLCertificateKeyFile file 		renamed

SSL_CipherSuite arg 		SSLCipherSUite arg 				renamed

SSL_X509VerifyDir arg 		SSLCACertificatePath arg 		renamed

SSL_LOG file 				- 								Use per-module LogLevel setting instead

SSL_Connect flag 			SSLEngine flag 					renaed

SSL_CLientAuth arg 			SSLVerifyClient arg 			renamed

SSL_X509VerifyDepth arg 	SSLVerifyDepth arg 				renamed

SSL_FetchKeyPhraseFrom arg 	- 								not directly mappable, use SSLPassPhraseDialog

SSL_SessionDir dir 			- 								not directly mappable; use SSLSessionCache

SSL_Require expr 			- 								not directly mappable; use SSLRequire

SSL_CertFileType arg 		- 								Functionality not supported

SSL_KeyFileType arg 		- 								not supported

SSL_X509VerifyPolicy arg 	- 								not supported

SSL_LogX509Attributes arg 	- 								not supported

Stronghold 2.x compability: 

StrongholdAccelerator engine SSLCryptoDevice engine 		renamed

StrongholdKey dir 			- 								Not needed

StrongholdLicenseFile dir 	- 								Not needed

SSLFlag flag 				SSLEngine flag 					renamed

SSLSessionLockFile file 	SSLMutex file 					renamed

SSLCipherList spec 			SSLCipherSuite spec 			renamed

RequireSSL 					SSLRequireSSL 					renamed

SSLErrorFile file 			- 								not supported

SSLRoot dir 				- 								not supported

SSL_CertificateLogDir dir 	- 								not supported

AuthCertDir dir 			- 								not supported

SSL_Group name 				- 								not supported

SSLProxymachineCertPath dir SSLProxyMachineCertificatePath dir renamed

SSLProxymachineCertFile file SSLProxyMachineCertificateFile file 	renamed

SSLProxyCipherList spec 	SSLProxyCipherSpec spec 		renamed

Environment variables:

The mapping between environment variable names used by the older SSL solutions and hte names used by mod_ssl is given here:

Table 2: Environment Variable Derivation

Old Variable 					mod_ssl Variable 				Comment

SSL_PROTOCOL_VERSION 			SSL_PROTOCOL 					Renamed

SSLEAY_VERSION 					SSL_VERSION_LIBRARY 			Renamed

HTTPS_SECRETKEYSIZE 			SSL_CIPHER_USEKEYSIZE 			Renamed

HTTPS_KEYSIZE 					SSL_CIPHER_ALGKEYSIZE 			Renamed

HTTPS_CIPHER 					SSL_CIPHER 						Renamed

HTTPS_EXPORT 					SSL_CIPHER_EXPORT 				Renamed

SSL_SERVER_KEY_SIZE 			SSL_CIPHER_ALGKEYSIZE 			Renamed

SSL_SERVER_CERTIFICATE 			SSL_SERVER_CERT 				Renamed

SSL_SERVER_CERT_START 			SSL_SERVER_V_StART 				Renamed

SSL_SERVER_CERT_END 			SSL_SERVER_V_END 				Renamed

SSL_SERVER_CERT_SERIAL 			SSL_SERVER_M_SERIAL 			Renamed

SSL_SERVER_SIGNATURE_ALGORITHM 	SSL_SERVER_A_SIG 				Renamed

SSL_SERVER_DN 					SSL_SERVER_S_DN 				Renamed

SSL_SERVER_CN 					SSL_SERVER_S_DN_CN 				Renamed

SSL_SERVER_EMAIL 				SSL_SERVER_S_DN_Email 			Renamed

SSL_SERVER_O 					SSL_SERVER_S_DN_O 				Renamed

SSL_SERVER_OU 					SSL_SERVER_S_DN_OU 				Renamed

SSL_SERVER_C 					SSL_SERVER_S_DN_C 				Renamed

SSL_SERVER_SP 					SSL_SERVER_S_DN_SP 				Renamed

SSL_SERVER_L 					SSL_SERVER_S_DN_L 				Renamed

SSL_SERVER_IDN 					SSL_SERVER_I_DN 				Renamed

SSL_SERVER_ICN 					SSL_SSL_SERVER_I_DN_CN 			Renamed

SSL_SERVER_IEMAIL 				SSL_SERVER_I_DN_EMAIL 			Renamed

SSL_SERVER_IO 					SSL_SERVER_I_DN_O 				Renamed

SSL_SERVER_IOU 					SSL_SERVER_I_DN_OU 				Renamed

SSL_SERVER_IC 					SSL_SERVER_I_DN_C 				Renamed

SSL_SERVER_ISP 					SSL_SERVER_I_DN_SP 				Renamed

SSL_SERVER_IL 					SSL_SERVER_I_DN_L 				Renamed

SSL_CLIENT_CERTIFICATE 			SSL_CLIENT_CERT 				Renamed

SSL_CLIENT_CERT_START 			SSL_CLIENT_V_START 				Renamed

SSL_CLIENT_CERT_END 			SSL_CLIENT_V_END 				Renamed

SSL_CLIENT_CERT_SERIAL 			SSL_CLIENT_M_SERIAL 			Renamed

SSL_CLIENT_SIGNATURE_ALGORITHM 	SSL_CLIENT_A_SIG 				Renamed

SSL_CLIENT_DN 					SSL_CLIENT_S_DN 				Renamed

SSL_CLIENT_CN 					SSL_CLIENT_S_DN_CN 				Renamed

SSL_CLIENT_EMAIL 				SSL_CLIENT_S_DN_Email 			Renamed

SSL_CLIENT_O 					SSL_CLIENT_S_DN_O 				Renamed

SSL_CLIENT_OU 					SSL_CLIENT_S_DN_OU 				Renamed

SSL_CLIENT_C 					SSL_CLIENT_S_DN_C 				Renamed

SSL_CLIENT_SP 					SSL_CLIENT_S_DN_SP 				Renamed

SSL_CLIENT_L 					SSL_CLIENT_S_DN_L 				Renamed

SSL_CLIENT_IDN 					SSL_CLIENT_I_DN 				renamed

SSL_CLIENT_ICN 					SSL_CLIENT_I_DN_CN 				Renamed

SSL_CLIENT_IEMAIL 				SSL_CLIENT_I_DN_Email 			Renamed

SSL_CLIENT_IO 					SSL_CLIENT_I_DN_O 				Renamed

SSL_CLIENT_IOU 					SSL_CLIENT_I_DN_OU 				Renamed

SSL_CLIENT_IC 					SSL_CLIENT_I_DN_C 				Renamed

SSL_CLIENT_ISP 					SSL_CLIENT_I_DN_SP 				renamed

SSL_CLIENT_IL 					SSL_CLIENT_I_DN_L 				Renamed

SSL_EXPORT 						SSL_CIPHER_EXPORT 				Renamed

SSL_KEYSIZE 					SSL_CIPHER_ALGKEYSIZE 			Renamed

SSL_SECKEYSIZE 					SSL_CIPHER_USEKEYSIZE 			Renamed

SSL_SSLEAY_VERSION 				SSL_VERSION_LIBRARY 			Renamed

SSL_STRONG_CRYPOT 				- 								Not supported by mod_ssl

SSL_SERVER_KEY_EXP 				- 								-II-, all from here on out are not supported by mod_ssl

SSL_SERVER_KEY_ALGORITHM 		-

SSL_SERVER_KEY_SIZE 			-

SSL_SERVER_SESSIONDIR 			_

SSL_SERVER_CERTIFICATELOGDIR 	-

SSL_SERVER_CERTFILE 			-

SSL_SERVER_KEYFILE 				-

SSL_SERVER_KEYFILETYPE 			-

SSL_CLIENT_KEY_EXP 				-

SSL_CLIENT_KEY_ALGORITHM 		-

SSL_CLIENT_KEY_SIZE 			-

Custom Log Functions:

When mod_ssl is enabled, additional functions exist for the Custom Log Format of mod log config as documented in the Reference Chapter.
Beside the ``%{varname}x" eXtension format function which can be used to expand any var provided by any module, an additional Cryptography ``%{name}c"
cryptography format function exists for backward compability. The currently implemented function calls are as follows:

Table 3: Custom Log Cryptography Function

Function call 			Description

%...{version}c 			SSL Protocol version

%...{cipher}c 			SSL cipher

%...{subjectdn}c 		Client Certificate Subject Distinguished Name

%...{issuerdn}c 		Client Certificate Issuer Distinguished Name

%...{errcode}c 			Certificate verification Error (numerical)

%...{errstr}c 			Certificate Verification Error (String)

SSL/TLS Strong Encryption: How-To:

Basic Config Example:

LoadModule ss_module modules/mod_ssl.so

Listen 443
<Virtualhost *:443>
	ServerName www.example.com
	SSLEngine on
	SSLCertificateFile "/path/to/www.example.com.cert"
	SSLCertificateKeyFile "/path/to/www.example.com.key"
</VirtualHost>

Cipher SUites and Enforcing Strong Security:

How can i create an SSL Server which accepts Strong encryption only?

SSLCipherSUite HIGH:!aNULL:!MD5

With the following config you specify a preference to a specific speedoptimized ciphers (which will be slected by mod_ssl, provided that they are supported by the client):

SSLCipherSuite RC4-SHA:AES128-SHA:HIGH:!aNULL:!MD5
SSLHonorCipherOrder on

How can i create an SSL server which accepts all types of Ciphers in general, but requires a Strong Ciphers for acccessing a particular URL:

We can configure mod_ssl to target specific locations in terms of encryptions:

#Accept any really, at first
SSLCipherSuite ALL:!aNULL:RC4+RSA:+HIGH:+MEDIUM:+LOW:+EXP:+eNULL

<Location "/strong/area">
#But https://hostname/strong/area and below requires strong ciphers
SSLCipherSuite HIGH:!aNULL:!MD5
</Location>

OCSP Stapling:

The ONline certification Status Protocol (OCSP) is a mechanism for determining wether or not a server certificate has been revoked,
and OCSP Stapling is a special form of this in which the server, such as httpd and mod_ssl, maintains current OCSP responses for its certificates
and sends them to clients which communicate with the server.

Most certificates contain the address of an OCSP responder maintained by the issuing Certificate Authority and mod_ssl can communicate with
that responder to obtain a signed response that can be sent to clients communicating with the server.

Because the client can obtain the certificate revocation status from the server without requriing an extra connection from the client to the Certificate Authority, OCSP Stapling is the preferred way for revocation status to be obtained. Other benefits of eliminating the communication betwen clientsa nd the certificate authority are that the client browsing history is not exposed t othe Certificate Authority and obtaining status is more reliable by not dpeending on potentionally heavily loaded certificate authority servers.

Because the response obtained by the server can be reused for all clients using the same cert during the time that the response is valid, the overhaead for the server is minimal.

Once general SSL suppport has been configured properly, enabling OCSP Stapling generally requires only very minor mods to the httpd config:
SSLUseStapling On
SSLStaplingCache "shmcb:logs/ssl_stapling(32678)"

These dirs are placed at global scope (not within a VH def), wherever other global SSL config dirs are placed, such as in conf/extra/httpd-ssl.conf for normal open source builds of httpd, /etc/apache2/mods-enabled/ssl.conf for the Ubuntu or Debian-bundled httpd etc.

The path on the SSLStaplingCache dir (e.g logs/) should match the one on the SSLSessionCache dir. This path is relative to ServerRoot.

This particular SSLStaplingCache dir requires mod socache shmcb (from the shmcb prefix on the dir argument) this module is usually enabled already for SSLSessionCache or on behald of some module other than mod ssl.

If you enabled an SSL session cache using a mechanism other than mod socache shmbc, use that alternative mechanism for SSLStaplingCache as well.

Example:

SSLSessionCache "dbm:logs/ssl_scache"
SSLStaplingCache "dbm:logs/ssl_stapling"

You can use the openssl cmd line program to verify that an OCSP response is sent by your server:

$ openssl s_client -connect www.example.com:443 -status -servername www.example.com
...
OCSP response:
========================================
OCSP Response Data:
	OCSP Response Status: successful (0x0)
	Response Type: Basic OCSP Response
....
	Cert Status: Good
...

The following Sections highlight the most common situations which require further modification to the config. 

If more than a few SSL Certs are used for the server:

OCSP responses are stored in the SSL Stapling cache. While the responses are typically a few hundred to a few K bytes in size, mod_ssl supports OCSP responses up to around 10K bytes in size. With more than a few certs, the stapling cache size (32.7K) may need to be increased. Error message AH01929 will be logged in case of an error
storing a response.

If the cert does not point to an OCSP responder, or if a different address must be used:

Refer to the SSLStapling ForceURL Dir:

SSLStaplingForceURL Directive:

Override the OCSP responder URI specified in the certificate's AIA extension

SSLStaplingForceURL <uri> //Context: server config, vh, it is an extension, belongs to mod_ssl, works with OpenSSL 0.9.8h or later

You can confirm that a server certificate points to an OCSP responder using the openssl command-line program as follows:

$ openssl x509 -in ./www.example.com.crt -text | grep 'OCSP.*http'
OCSP - URI:htto://ocsp.example.com

if the OCSP URI is provided and the web server can communicate to it directly without using a proxy, config is required.
Note that the firewall rules that control outbound conns from the web server may need to be adjusted.

If no OCSP URI is provided, contact your Cert Authority to determine if one is available, if so, configure it with SSLStapingForceURL in the VH that uses the cert.

If Multiple SSL-enabled virtual hosts are configured and OCSP Stapling should be disabled for some:

Add SSLUseStapling Off to the virtual hosts for which OCSP staling should be disabled

If the OCSP responder is slow or unreliable:

Several dirs are available to handle timeouts and errors, such as SSLStapingFakeTryLater, SSLstaplingResponderTimeout, SSLStaplingReturnResponderErrors.

SSLStaplingFakeTryLater: Synthesize "trylater" responses for failed OCSP stapling queries. 

SSLStaplingFakerTryLater on|off //Defaults to on

context: server config, virtual host

SSLStaplingResponderTimeout: Timout for OCSP stapling queries

SSLStaplingResponderTimeout <seconds> //Defaults to 10

Context: server config, virtual host

SSLStaplingReturnResponderErrors: Pass stapling related OCSP errors on to client

Syntax: SSLStaplingReturnReponderErrors on|off //Defaults to on

Context: server config, virtual host

If mod_ssl logs error AH02217:

AH02217: ssl_stapling_init_cert: Can't retrieve issuer certificate!

In order to support OCSP Stapling when a particular server cert is used, the cert chain for that cert must be configed. If it was not configed as part of enabling SSL, the AH02217 error will be issued when stapling is enabled and an OCSP response will not be provided for clients
using the cert. Refer to SSLCertificateChainFile and SSLCertificateFile for instructions on configing the cert chain.

SSLCertificateChainFile Directive:

Deprecated.

SSLCertificateFile Directive:

Server PEM-encoded X.509 Certificate data file

Syntax: SSLCertificateFile file-path

This dir points to a file with cert data in PEM format. At a minimum, this file must include an end-entity (leaf) cert. The dir can be used multiple times (referencing different filenames) to support multiple algos for server aut, typically RSA, DSA and ECC.

The number of supported algos depends on the OpenSSL version being used for mod_ssl, with v 1.0 or later, openssl list-public-key-algorithms will output a list of supported algos, see also the note below about limitations of OpenSSL versions prior to 1.0.2 and how to work around it.

The files may also include intermediate CA certs, sorted from leaf to root. This is supported with version 2.4.8 and later, and obsoletes SSLCertificateChainFile.  When running with OpenSSL 1.0.2 or later, this allows to config the intermediate CA chain on a per-cert basis.

Custom DH params and an EC cure name for ephemeral keys, can also be added to end of the first file configured using SSLCertificateFile. This is supported in ver 2.4.7 or later.
Such params can be generated using the commands openssl dhparam and openssl ecparam.

The params can be added as-is to the end of the first cert file. Only the first file can be used for custom params as they are applied independantly of the auth algo type.

Finally the end-entity certs private key can also be added to the cert file instead of using a separate SSLCertificateKeyFile dir. This is discouraged, if it used the ,cert files using such a embedded key must be configured after the certs using a separate key file. If the private key is encrypted, the pass phrase dialog is forced at startup time.

DH param interoperability with primes > 1024 bit:

Beginning with ver 2.4.7, mod_ssl makes use of stnadardized DH params with prime lengths of 2048, 3072, 4096 bits and with additional prime len of 6144 and 8192 bits beginning with ver 2.4.10 (from RFC 3526) and hands them otu to clientsb ased on the length of the certs RSA/DSA key. With java clients (7 or earlier), this can lead to handshake failures.

Default DH Params when using multiple certs and OpenSSL versions prior to 1.0.2:

When using multiple certs to support different auth algos (like RSA, DSA, but mainly ECC) and OpenSSL prior to 1.0.2, it is recommended to either use custom DH params (preferably) by adding them to the first cert file or to order the SSLCertificateFile dirs such that RSA/DSA certs are placed after the ECC one.

This is due to a limitation in older versions of OpenSSL which don't let the Apache HTTP server determine the currently selected cert at handshake time (when the DH params must be sent to the peer) but instead always provide the last configed cert. Consequently, the server may select default DH params based on the length of the wrong certs key (ECC keys are much smaller than RSA/DSA ones and their len is not relevant for selecting DH primes).

Since custom DH params always take predecence over the default ones, this issue can be avoided by creating and configuring them thus using a ustom/suitable length.

Example:

SSLCertificateFile "/usr/local/apache2/confg/ssl.crt/server.crt"

Client Authentication and Access Control:

How can i force client to atuehtnicate using certs:

When you know all of your users you can require plain cert auth. All you need to do is create client certs signed by your own CA certificate (ca.crt) and then verify the clients against the cert:

#Require a client certificate which has to be directly signed by our CA certificate in ca.crt
SSLVerifyClient require
SSLVerifyDepth 1
SSLCACertificateFile "conf/ssl.crt/ca.crt"

How can i force clients to authenticate using certificates for a particular URL, but still allow arbitrary clients to acess the rest of the server?

To force clients to authenticate using certs for a particular URL, you an use the per dir reconfig features of mod_ssl:

SSLVerifyClient none
SSLCACertificateFile "confg/ssl.crt/ca.crt"

<Location "/secure/area">
SSLVerifyClient require
SSLVerifyDepth 1
</Location>

How cna i allow only clients who have certs to access a aparticular URL, but allow all clients ot access the rest of the server?

The key to doing this is checking the part of the client cert matches what you expect. Usually this means checking all or part of the Distinguished Name (DN),
to see if it contains some known string. THere are two ways to do this, using either mod auth basic or SSLRequire //SSLRequire is deprecated

The mod auth basic method is generally required when the certs are completely arbitrary or when their DNs have no common fields (sually the org) in this case, you should establish a PW db containing all clients allowed as follows:

SSLVerifyClient 		none
SSLCACertificateFile 	"conf/ssl.crt/ca.crt"
SSLCACertificatePath 	"confg/ssl.crt"

<Directory "/usr/local/apache2/htdocs/secure/area">
	SSLVerifyClient 	require
	SSLVerifyDepth 		5
	SSLOptions 			+FakeBasicAuth
	SSLRequireSSL
	AuthName 			"Snake Oil Authentication"
	AuthType 			Basic
	AuthBasicProvider 	file
	AuthUserFile 		"/usr/local/apache2/confg/httpd.passwd"
	Require 			valid-user"
</Directory>

The pw used in this example is the DES encrypted string "password".

SSLOptions Directive:

Configure various SSL engine run-time options

Syntax: SSLOptions [+|-] option ...

Context: server config, virtual host, diretory, .htacess
Overirde: Options

This directive can be used to control various run-time options on a per-directory basis. Normally, if multiple SSLOptions could apply to a dir,
then the most specific one is taken completely. The options are not merged. However, if all the options on the SSLOptions dir are preceded by a plus or a minus, the options are merged. Any options preceded by a plus are added to the options currently in force, and any options with the minus gets removed from the options currently in force.

The available ones are:

StdEnvVars: 

When this option is enabled, the stnadard set of SSL related CGI/SSI env vars are created. This per default is disabled for performance reasons, because the info extraction step is rather expensive operation. SO one usually enables this option for CGI and SSI request only.

ExportCertData:

When this option is enabled, additional CGI/SSI environment vars are created: SSL_SERVER_CERT, SSL_CLIENT_CERT and SSL_CLIENT_CERT_CHAIN_n (with n = 0,1,2..). These contain the PEM-encoded X.509 certs of Server and client for the current HTTPs connection and can be used by CGI scripts for deeper Cert checking. Additionally all other certs of the client certificate chain are provided too. This bloads up the env a little bit which is why you have to use this option to enable it on demand.

FakeBasicAuth:

When this option is enabled, the Subject Dinstugished Name (DN) of the Client X509 Cert is transalted into a HTTP Basi Auth username. This means that the stnadard Apache authentication methods can be used for access control. The user name is just the Subject of the Clients X509 Cert (can be determined by runnining OpenSSLs openssl x509 command: openssl x509 -noout -subject -in <certificate>.crt).
Note that no pw is obtained from the user.

Every entry in the user file needs this PW: ``xxj31ZMTZzkVA" which is the DES-encrypted version of the word `password". Those who live under the MD5-based encrypt (for instnace under FreeBSD or BSD/OS etc.), should use the following MD5 hash for the same word: ``$1$OXLyS...$Owx8s2/m9/gfkcRVXzgoE"

Note that the AuthBaiscFake dir within mod auth basic can be used as a more general emchanism for faking basic auth, giving control over
the structure of both the username and pw.

StrictRequire:

This forces forbidden access when SSQLRequireSSL or SSLRequire successfully decided that access should be forbidden. Usually the default is that in case where a ``Satisfy any`` dir is used, and other access restrictions are passed, denial of access due to SSLREquireSSL or SSLRequire is overriden (because that's how the Apache satisfy mechanism should work).

But for strict access restriction you can use SSLRequireSSL and/or SSLRequire in combination with an ``SSLOptions +StrictRequire".
Then an additional ``Satisfy Any" has no chance once mod_ssl has decided to deny access.

OptRenegotiate:

This enables optimized SSL Connection renegotiation handling when SSL dirs are used in per-dir context. By default a strict scheme is enabled where every per-dir reconfigure of SSL params causes a full SSL renegotiation handshake. When this option is used, mod_ssl tries to avoid unnecessary handskaes by doing more granular (but still safe) param checks. Nevertheless these granular checks sometimes may not be what the user expects,
so enable this on a per-directory basis only.

LegacyDNStringFormat:

This option influences how vlaues of the SSL_{CLIENT,SERVER}_{I,S}_DN variables are formatted. Since version 2.3.11, Apache HTTPD uses a RFC 2253 compatible format by default. This uses commas as delimiters between the attributes, allows the user of Non-Ascii chars (which are converted to UTF8), escapes various special chars with backslashes and and sorts the attributes with the "C" attribute last.

If LegacyDNStringFormat is set, the old format will be used which sorts the "C" attribute first, uses slashes as seperators, and does not handle non-ASCII and special chars in any consistent way.

Example:

SSLOptions +FakeBasicAuth -StrictRequire
<Files ~ "\.(cgi|shtml)$">
	SSLOptions +StdEnvVars -ExportCertData
</Files>

httpd.passwd:

/C=DE/L=Munich/O=Snake Oil, Ltd./OU=Staff/CN=Foo:xxj31ZMTZzkVA
/C=US/L=S.F./O=Snake Oil, Ltd./OU=CA/CN=Bar:xxj31ZMTZzkVA
/C=US/L=L.A./O=Snake Oil, Ltd./OU=Dev/CN=Quux:xxj31ZMTZzkVA

When your clients are all part of a common hierarchy, which is encoded into the DN, you can match them more easily using SSLRequire as follows:

SSLVerifyClient 		none
SSLCACertificateFile 	"conf/ssl.crt/ca.crt"
SSLCACertificatepath 	"conf/ssl.crt"

<Directory "/usr/local/apache2/htdocs/secure/area">
	SSLVerifyClient 	require
	SSLVerifyDepth 		5
	SSLOptions 			+FakeBasicAuth
	SSLRequireSSL 
	SSLRequire 			%{SSL_CLIENT_S_DN_O} 	eq "Snake Oil, Ltd." \
					and %{SSL_CLIENT_S_DN_OU} 	in {"Staff", "CA", "Dev"}
</Directory>

How can i requite HTTPS with strong ciphers, and either basic auth or client certs, for access to part of the INtranet website, for clients
coming from the Inet? I still want to allow plain HTTP access for clients on the Intranet.

These examples presume that clinets on the Intranet have IPs in the range of 192.168.10/24 and that the part of the Intranet website you want to allow internet acces to is /usr/local/apache2/htdocs/subarea.

This config should remain outside of our HTTPS virtual host, so that it applies both to HTTPS and HTTP.

SSLCACertificateFile "confg/ssl.crt/company-ca.crt"

<Directory "/usr/local/apache2/htdocs">
	# Outside the subarea only INtranet access is granted
	Require 			ip 192.168.0/24
</Directory>

<Directory "/usr/local/apache2/htdocs/subarea">
	# Inside the subarea any Intranet access is allowed
	# but from the intranet only HTTPS + STrong-Cipher + PW 
	# or the alternative HTTPS + STrong-Ciper + Client-cert

	#If the HTTP is used, make sure a strong cipher is used.
	# Additonally allow client certs as a alternative to basic auth.
	SSLVerifyClient 		optional
	SSLVerifyDetph 			1
	SSLOptions 				+FakeBasicAuth +StrictRequire
	SSLRequire 				%{SSL_CIPHER_USEKEYSIZE} >= 128

	# Force clients from the Internet to use HTTPS
	RewriteEngine 			on
	RewriteCond 			"%{REMOTE_ADDR}" "!^192\.168\.1\.[0-9]+$"
	RewriteCond 			"%{HTTPS}" "!=on"
	RewriteRule 			"." "-" [F]

	#Allow network access and/or basic auth
	Satisfy 				any

	# Network access control
	Require 				ip 192.168.1.0/24

	# 	HTTP Basic Auth
	AuthType 				basic
	AuthName 				"Protected Intranet Area"
	AuthBasicProvider 		file
	AuthUserFile 			"conf/protected.passwd"
	Require 				valid-user
</Directory>

Environment Variables:

Variable Name: 						Value Type: 		Desc:

HTTPS 								flag 				HTTPS is being used.

SSL_PROTOCOL 						String 				The SSL protocol version (SSLv3, TLSv1, TLSv1.1, TLSv1.2)

SSL_SESSION_ID 						String 				The hex-encoded SSL session id

SSL_SESSION_RESUMED 				String 				Initial or Resumed SSL Session. Note: Multiple requests may be served over the same (initial or resumed) SSL Session if HTTP KeepAlive is in use.

SSL_SECURE_RENEG 					String 				true if secure renegotiation is supported, else false

SSL_CIPHER 							String 				The cipher specification name

SSL_CIPHER_EXPORT 					String 				true if cipher is an export cipher

SSL_CIPHER_USEKEYSIZE 				number 				Number of Cipher bits (actually used)

SSL_CIPHER_ALGKEYSIZE 				number 				Numbero f Ciphers bits (possible)

SSL_COMPRESS_METHOD 				String 				SSL compression method negotiated

SSL_VERSION_INTERFACE 				String 				The mod_ssl program version

SSL_VERSION_LIBRARY 				String 				The OpenSSL Program version

SSL_CLIENT_M_VERSION 				String 				The version of the client certificate

SSL_CLIENT_M_SERIAL 				String 				The serial of the client certificate

SSL_CLIENT_S_DN 					String 				Subject DN in client's certificate

SSL_CLIENT_S_DN_x509 				String 				Component of client's subject DN

SSL_CLIENT_SAN_Email_n 				String 				Client certificate's subjectAltName extension entries of type rfc822name

SSL_CLIENT_SAN_DNS_n 				String 				Client certificate's subjectAltName extension entiries of type dNSName

SSL_CLIENT_SAN_OTHER_msUPN_n 		String 				Client certificate's subjectAltName extension entries of type otherName, Microsoft User principal Name from (OID 1.3.6.1.4.1.311.20.2.3)

SSL_CLIENT_I_DN 					String 				Issuer DN of client's certificate

SSL_CLIENT_I_DN_x509 				String 				Component of client's Issuer DN

SSL_CLIENT_V_START 					String 				Validity of client's certificate (start time)

SSL_CLIENT_V_END 					String 				Validity of client's certificate (end time)

SSL_CLIENT_V_REMAIN 				String 				Number of days until client's certificate expires

SSL_CLIENT_A_SIG 					String 				Algorithm used for the signature of client's certificate

SSL_CLIENT_A_KEY 					String 				Algorithm used for the public key of client's certificate

//Im just gonna presume the type is String until said otherwise from now on

SSL_CLIENT_CERT 	PEM-encoded client certificate

SSL_CLIENT_CERT_CHAIN_n 	PEM-encoded certificates in client certificate chain

SSL_CLIENT_CERT_RFC4523_CEA 	Serial number and issuer of the certificate. The format matches that of the CertificateExactAssertion in RFC4523

SSL_CLIENT_VERIFY 	NONE, SUCCESS, GENEROUS or FAILED:reason

SSL_SERVER_M_VERSION 	The version of the server certificate

SSL_SERVER_M_SERIAL 	The serial of the server certificate

SSL_SERVER_S_DN 		Subject DN in server's certificate

SSL_SERVER_SAN_Email_n 	Server Certificate's subjectAltName extension entries of type rfc822Name

SSL_SERVER_SAN_DNS_n 	Server certificate's subjectAltName extension entries of type dNSName

SSL_SERVER_SAN_OTHER_dnsSRV_n  Server certificate's subjectAltName extension entries of type otherName, SRVName from (OID 1.3.6.1.5.5.7.8.7, RFC 4985)

SSL_SERVER_S_DN_x509   Component of server's Subject DN

SSL_SERVER_I_DN 	Issuer DN of Server's certificate

SSL_SERVER_I_DN_x509 	Component of server's issuer DN

SSL_SERVER_V_START 		validity of server's certificate (start time)

SSL_SERVER_V_END 		validity of server's certificate (end time)

SSL_SERVER_A_SIG 		Algo used for the signature of server's certificate

SSL_SERVER_A_KEY 		Algo used for the public key of server's cert

SSL_SERVER_CERT 		PEM-encoded server certificate

SSL_SRP_USER 			SRP username

SSL_SRP_USERINFO 		SRP user info

SSL_TLS_SNI 			Contents of the SNI TLS extension (if supplied with ClientHello)

x509 specifies a component of an X.509 DN; one of C, ST, L, O, OU, CN, T, I, G, S, D, UID, Email. In Apache 2.1 and later, x509 may
also include a numeric _n suffix. If the DN in question contains multiple attributes of the same name, this suffix is used as a zero-based index to select a particular attribute. For example, where the server certificate subject DN included two OU attributes, SSL_SERVER_SN_DN_OU_O and SSL_SERVER_S_DN_OU_1 could be used to reference each.

A variable name without a _n suffix is equivalent to that name with a _0 suffix; the first ( or only) attribute. When the env table is populated using the StdEnvVars option of the SSLOptions directive, the first (or only) attribute of any DN is added only under a non-suffixed name: i.e, no_0 suffixed entries are added.

The format of the *_DN variables has changed in apache httpd 2.3.11.  //same old as before.

SSL_CLIENT_V_REMAIN is only avaialble in v 2.1 >.

A number of additinal env vars can also be used in SSLRequire expressions or in custom log formats:

HTTP_USER_AGENT 
HTTP_REFERER
HTTP_COOKIE
HTTP_FORWARDED
HTTP_HOST
HTTP_PROXY_CONNECTION
HTTP_ACCEPT
THE_REQUEST
REQUEST_FILENAME
REQUEST_METHOD
REQUEST_SCHEME
REQUEST_URI

PATH_INFO
QUERY_STRING
REMOTE_HOST
REMOTE_IDENT
IS_SUBREQ
DOCUMENT_ROOT
SERVER_ADMIN
SERVER_NAME
SERVER_PORT
SERVER_PROTOCOL
REMOTE_ADDR

REMOTE_USER
AUTH_TYPE
SERVER_SOFTWARE
API_VERSION
TIME_YEAR
TIME_MON
TIME_DAY
TIME_HOUR
TIME_MIN
TIME_SEC
TIME_WDAY
TIME

In these contexts, two special formats can also be used:

ENV:variablename //Will expand to the stnadard environment variable variablename

HTTP:headername //will expand to the value of the request header with name headername

Request Notes:

mod ssl sets "ntoes" for the request which can be used in ogging with the %{name}n format string in mod log config

The notes supported are as follows:

ssl-access-forbidden //This iset to value 1 if access was denied due to an SSLRequire or SSLRequireSSL directive.

ssl-secure-reneg //If mod ssl is built against a version of OpenSSL which supports the secure renegotiation extension, this note is set to the value 1 if SSL is in used for the current connection, and the client also supports the secure renegotiation extension. If the client oes not support the secure renegotiation extension, the note is set to the value 0. If mod ssl is not built against a version of OpenSSL which supports secure renegotiation or if SSL is not in use for the current connection, the note is not set.

Expression Parser Extension:

When mod ssl is built into Apache or least loaded (under DSO situation) any variables provided by mod ssl can be used in expressions for the ap_expr Expression Parser. The vars can be referenced using the syntax ``%{varname}". 

Starting with version 2.4.18 one can also use the mod rewrite style syntax ``%{SSL:varname}" or the function style syntax ``ssl (varname)".

Example using mod_headers:

Header set X-SSL-PROTOCOL "expr=%{SSL_PROTOCOL}"
Header set X-SSL-CIPHER "expr=%{SSL:SSL_CIPHER}"

Authorization providers for use with Require:

mod ssl provides a few authentication providers for use with mod authz cores Require directive:

Require ssl: 

mod_authz_core:

This module provides core authorization capabilities so that authenticated users can be allowed or denied access to portions of the web site. mod authz core provides the functionality to register various authorization providers. It is usually used in conjunction with an authentication provider module such as mod authn file and an authorization module such as mod authz user. It also allows for advanced logic to be applied to the authorization processing.

Creating AUthorization Provider Aliases:

Extended authorization providers can be created within the configuration file and assign an alias name. The alias providers
can then be referenced through the Require directive in the same way as a base authorization provider.

Besides the ability to create and alias an extended provider, it also allows the same extended authorization provider to be referenced
by multiple locations.

Example:

The example below creates two different ldap authorization provider aliases based on the ldap group authorization provider. This example allows a single authorization location to check group membership within ultiple ldap hosts:

<AuthzProviderAlias ldap-group ldap-group-alias1 cn=my-group,o=ctx>
	AuthLDAPBindDN cn=youruser,o=ctx
	AuthLDAPBindPassword yourpassword
	AuthLDAPURL ldap://ldap.host/o=ctx
</AuthzProviderAlias>

<AuthzProviderAlias ldap-group ldap-group-alias2 cn=my-other-group,o=dev>
	AuthLDAPBindDN cn=yourotheruser,o=dev
	AuthLDAPBindPassword yourotherpassword
	AuthLDAPUrl ldap://other.ldap.host/o=dev?cn
</AuthzProviderAlias>

Alias "/secure" "/webpages/secure"
<Directory "/webpages/secure">
	Require all granted

	AuthBasicProvider file

	AuthType basic
	AuthName LDAP_Protected_Place

	#implied OR operation
	Require ldap-group-alias1
	Require ldap-group-alias2
</Directory>

Authorization Containers:

The authorization container directives RequireAll, RequireAny and RequireNone may be combined with each other and with the REquire directive to express complex authorization logic.

The example below expresses the following logic. In order to access the resource, the user must either be the superadmin user, or belong to the admins group and the Administrators LDAP group and either belong to the sales group or have the LDAP dept attribute sales. Furthermore, in order to access the resource, the user must not belong to either the temps group or the LDAP group Temporary Employees.

<Directory "/www/mydocs">
	<RequireAll>
		<RequireAny>
			Require user superadmin
			<RequireAll>
				Require group admins
				Require ldap-group cn=Administraotrs,o=Airius
				<RequireAny>
					Require group sales
					Require ldap-attribute dept="sales"
				</RequireAny>
			</RequireAll>
		</RequireAny>
		<RequireNone>
			Require group temps
			Require ldap-group cn=Temporary Employees,o=Airius
		</RequireNone>
	</RequireAll>
</Directory>

The Require Directives:

Require env:

The env provider allows access to the server to be controller based on the existence of an environment variable.
When Require env env-variable is specified, then the request is allowed access if the environment variable env-variable exists.

THe server provides the ability to set the environment variables in a flexible way based on characteristics of the client request
using the directives provided by mod setenvif. Therefore, this direcntive can be used to allow access based on such factors as the clients User-Agent (Browser type), Referer or other HTTP request header fields.

SetEnvIf Useragent ^KnockKnock/2\.0 let_me_in
<Directory "/docroot">
	Require env let_me_in
</Directory>

In this case, browsers with a user-agent string beginning with KnockKnock/2.0 will be allowed access.

When the server looks up a path via an internal subrequest such as looking for a Dir index or generating a dir listing with mod autoindex, per-request environment vars are not inherited in the subrequest. Aditionally, SetEnvIf dirs are not separately evaluated in the subrequest due to the API phases mod setenvif takes action in.

Require All:

The all provider mimics the functionality that was previously provided by the Allow from all and deny from all dirs. This provider can take one of the two arguments which are 'granted' or 'denied'. The following examples will grant or deny access to all requests.

Require all granted

Require all denied

Require Method:

The method provider allows using the HTTP method in authorization decisions. The GET and HEAD methods are treated as equivilant. The TRACE Method is not available to this provider, use TraceEnable instead.

The following example will only allow GET, HEAD, POST and OPTIONS requests:

Require method GET POST OPTIONS

The following example will allow GET, HEAD, POST and OPTIONS requests without authentication, and require a valid user for all other methods:

<RequireAny>
	Require method GET POST OPTIONS
	Require valid-user
</RequireAny>

Require expr:

The expr provider allows basing authorization decisions in arbitrary expressions:

Require expr "%{TIME_HOUR} -ge 9 && %{TIME_HOUR} -le 17"

<RequireAll>
	Require expr "!(%{QUERY_STRING} =~ /secret/)"
	Require expr "%{REQUEST_URI} in { '/example.cgi', '/other.cgi' }"
</RequireAll>

Require expr "!(%{QUERY_STRING} =~ /secret/) && %{REQUEST_URI} in { '/example.cgi', '/other.cgi' }"

Normally, the expression is evaluated before authentication. However, if the expression returns false and references the variable %{REMOTE_USER}, authentication will be performed and the expression will be re-evaluated.

Syntax in Apache:

Historically, there are several syntax variants for expressions used to express a condition in the different modules of the Apache HTTP server.
There is some ongoing effort to only use a single variant, called ap_expr, for all configuration directives.

This document describes the ap_expr expression parser. THe ap_expr expression is intended to replace most other expression variants in HTTPD.
For example, the deprecated SSLRequire expressions can be replaced by Require expr.

Grammar in Backus-Naur Form notation:

Backus-Naur Form (BNF) is a notation technique for context-free grammars, often used to describe the syntax of languages used in computing.
In most cases, expressions are used to express boolean values, For these, the starting point in the BNF is expr. However, a few directives like LogMessage accept expressions that evaluate to a String value. For those, the starting point in the BNF is String.

expr 			::= "true" | "false"
				  | "!" expr
				  | expr "&&" expr
				  | expr "||" expr
				  | "(" expr ")"
				  | comp

comp 			::= stringcomp
				  | integercomp
				  | unaryop word
				  | word binaryop word
				  | word "in" "{" wordlist "}"
				  | word "in" listfunction
				  | word "=~" regex
				  | word "!~" regex

stringcomp 		::= word "==" word
				  | word "!=" word
				  | word "<"  word
				  | word "<=" word
				  | word ">"  word
				  | word ">=" word

integercomp 	::= word "-eq" word | word "eq" word
				  | word "-ne" word | word "ne" word
				  | word "-lt" word | word "lt" word
				  | word "-le" word | word "le" word
				  | word "-gt" word | word "gt" word
				  | word "-ge" word | word "ge" word

wordlist 		::= word
				  | wordlist "," word

word 			::= word "." word
				  | digit
				  | "'" string "'"
				  | """ string """
				  | variable
				  | rebackref
				  | function

String 			::= stringpart
				  | string stringpart

stringpart 		::= cstring
				  | variable
				  | rebackref

cstring 		::= ...
digit 			::= [0-9]+

variable 		::= "%{" varname "}"
				  | "%{" funcname ":" funcargs "}"

rebackref 		::= "$" [0-9]

function 		::= funcname "(" word ")"

listfunction 	::= listfuncname "(" word ")"

Variables:

The expression parser provides a number of variables of the form %{HTTP_HOST}. Note that the value may depend on the phase
of the request processing in which it is evaluated. For example, an expression used in an <If > directive is evaluated
before authentication is done. Therefore, %{REMOTE_USER} will not be set in this case.

The following vars provide the values of the named HTTP request headers. The values of other headers can be obtained with
the req function. Using these variables may cause the header name to be added to the Vary header of the HTTP response,

except where otherwise noted for the directive accepting the expression. The req_novary function may be used to circumvent this.

We will cover functions later.

Name:

HTTP_ACCEPT

HTTP_COOKIE

HTTP_FORWARDED

HTTP_HOST

HTTP_PROXY_CONNECTION

HTTP_REFERER

HTTP_USER_AGENT

Other request related variables:

Name 				Description

REQUEST_METHOD 		The HTTP method of the incoming request (e.g GET)

REQUEST_SCHEME 		The scheme part of the request's URI

REQUEST_URI 		The path part of the request's URI

DOCUMENT_URI 		Same as REQUEST_URI

REQUEST_FILENAME 	The full local filesystem path to the file or script matching the request, if this has already been determined by 
	the server at the time REQUEST_FILENAME is referenced. Otherwise, such as when used in virtual host context, the same value as
	REQUEST_URI.

SCRIPT_FILENAME 	Same as REQUEST_FILENAME

LAST_MODIFIED 		The date and time of last modification of the file in the format 20101231235959, if it has already been determined
by the server at the time LAST_MODIFIED is referenced.

SCRIPT_USER 		The user name of the owner of the Script

SCRIPT_GROUP 		The group name of the group of the script

PATH_INFO 			The trailing path name info, see AcceptPathInfo

AcceptPathInfo Directive:

Resources accept trailing pathname information

Syntax: AcceptPathInfo On|Off|Default

Default: AcceptPathInfo Default

This directive controls wether requests that contain trailing pathname info that follows an actual filename (or non-existent file in an
existing dir) will be accepted or rejected. The trailing pathname info can be made available to scripts in the PATH_INFO environment variable.

For example, assume the location /test/ points to a directory that contains only the single file here.html.

Then requests for /test/here.html/more/ and /test/nothere.html/more both collect /more as PATH_INFO

The three possible args for AcceptPathInfo dir are:

Off
	A request will only be accepted if it maps to a literal path that exists. Therefor a request with trailing pathname info after the
	true filename such as /test/here.html/more in the above example will return a 404 NOT FOUND error.

On
	A request will be accepted if a leading path component maps to a file that exists. The above example of /test/here.html/more will
	will be accepted if /test/here.html maps to a valid file.

Default
	The treatment of requests with trailing pathname information is determined by the handler responsible for the request.
	The core handler for normal files defaults to rejecting PATH_INFO requests.
	Handlers that serve scripts, such as cgi-script and isapi-handler, generally accept PATH_INFO by default.

The primary purpose of the AcceptPathInfo directive is to allow you to override the handler's choice of accepting or rejecting PATH_INFO.
This override is required, for example, when you use a filter, such as INCLUDES, to generate content based on PATH_INFO. The core handler
would usually reject the request, so you can use the following configuration to enable sucha script:

<Files "mypaths.shtml">
	Options +Includes
	SetOutputFilter INCLUDES
	AcceptPathInfo On
</Files>




QUERY_STRING 		The query string of the current request

IS_SUBREQ 			"true" if the current request is a subrequest "false" otherwise

THE_REQUEST 		The complete request line (e.g "GET /index.html HTTP/1.1")

REMOTE_ADDR 		The IP address of the remote host

REMOTE_PORT 		The port of the remote host (2.4.26 and later)

REMOTE_HOST 		The host name of the remote host

REMOTE_USER 		The name of the authenticated user, if any (not available during <If >)

REMOTE_IDENT 		The user name set by mod ident

Apache Module mod_ident

Description: RFC 1413 ident lookups

This module queries RFC 1413 compatible daemon on a remote host to look up the owner of a connection

IdentityCheck Directive:

Enables logging of the RFC 1413 identity of the remote user

Syntax: IdentityCheck On|Off
Default: IdentityCheck Off

This directive enables RFC 1413-compliant logging of the remote user name for each connection, where the client machine runs identd or something
similar. This information is logged in the access log using the %....l format string.

The information should not be trusted in any way except for rudimentary usage tracking.

Note that this can cause serious latency problems accessing your server since every request requires one of these lookups to be performed.
When firewalls or proxy servers are involved, each lookup might fail and add a latency duration as defined by the IdentityCheckTimeout
directive to each hit. So in general, this is not very useful on public servers accessible by the internet.

IdentityCheckTimeout Directive:

Determines the timeout duration for ident requests

Syntax: IdentityCheckTimeout <seconds>

Default: IdentityCheckTimeout 30

This directive specifies the timeout duration of an ident request. The default value of 30 seconds is recommended by 
RFC 1413, mainly because of possible network latency. However, if we wish, we can modify it.



SERVER_NAME 		The ServerName of the current vhost

SERVER_PORT 		The server port of the current vhost, see ServerName

ServerName Directive:

Desc: Hostname and port that the server uses to identify itself

Syntax: ServerName [scheme://]domain-name|ip-address[:port]

The ServerName directive sets the request scheme, hostname and port that the server uses to identify itself.

ServerName is used (possibly in conjunction with ServerAlias) to uniqely identify a virtual host, when using 
name-based VH's.

Additonally, this is used when creating self-referential redirection URLs when UseCanonicalName is set to a non-default value.

For example, if the name of the machine hosting the web server is simple.example.com, but the machine also has the DNS alias
www.example.com and you wish the web server to be so identified, the following directive should be used:

ServerName www.example.com

The ServerName directive may appear anywhere in the server setup, albeit, the latest occurance overrides any earlier implementation.

If no ServerName is specified, the server attempts to deduce the client visible hostname by first asking the operating system for the
system hostname, and if that fails, performing a reverse lookup on an IP address present on the system.

If no port is specified in the ServerName, then the server will use the port from the incoming request. For optimal reliability
and predictability, you should specify an explicit hostname and port using the ServerName directive.

If you are using a name-based virtual host, the ServerName inside a <VirtualHost> section specifies what hostname must appear
in the request's Host: header to match this VH.

Sometimes, the server runs behind a device that processes SSL, such as a reverse proxy, load balancer or SSL offload applicance.
When this is the case, specify the https:// scheme and the port number to which the clients connect in the ServerName directive
to make sure that the server generates the correct self-referential URLs.

See the description of the UseCanonicalName and UseCanonicalPhysicalPort directives for settings which determine wether
self-referential URLs (e.g, by the mod dir module) will refer to specified port, or to the port number given
in the client's request.

Failure to set ServerName to a name that your server can resolve to an IP address will result in a startup warning. httpd
will then use whatever hostname it can determine, using the system's hostname command. This will amost never be the hostname you want.

httpd: Could not reliably determine the server's fully qualified domain name, using rocinante.local for ServerName

SERVER_ADMIN 		The ServerAdmin of the current Vhost.

ServerAdmin directive:

Email address that the server includes in error messages sent to the client

Syntax: ServerAdmin email-address|URL

The ServerAdmin sets the contact address that the server includes in any error messages it returns to the client.
If the httpd doesn't recognize the supplied argument as an URL, it assumes, that it's an email-address and prepends
it with mailto: in hyperlink targets. However, it is recommended to use an actual email address, since there are a lot of 
CGI scripts that make that assumption.

if you want to use an URL, it should point to another server under your control. Otherwise users may not be able to contact you
in case of errors.

It may be worth setting up a dedicated address for this:

ServerAdmin www-admin@foo.example.com

as users do not always mention that htey are talking about the server.

SERVER_PROTOCOL:

The protocol used by the request

DOCUMENT_ROOT:

The DocumentRoot of the current vhost

DocumentRoot Directive:

Directory that forms the main document tree visible from the web

Syntax: DocumentRoot directory-path

Default: DocumentRoot "/usr/local/apache/htdocs"

This directive sets the directory from which httpd will serve files. Unless matched by a directive like Alias, the server appends
the path from the requested URL to the document root to make the path to the document.

Example:

DocumentRoot "/usr/web"

Then an access to http://my.example.com/index.html refers to /usr/web/index.html. If the directory-path is not absolute
then it is assumed to be relative to the ServerRoot

The DocumentRoot should be specified without a trailing slash.

httpd:

httpd is the Apache Hypertext Transfer Protocol (HTTP) server program. It is designed to be run as a standalone daemon process.
When used like this it will create a pool of child processes or threads to handle requests.

In general, httpd should not be invoked directly, but rather should be invoked via apachetl on Unix-based systems or as a Service/Console app on
Widows.

Synposis:

httpd [ -d serverroot ] [ -f config ] [-C directive ] [ -c directive ] [ -D parameter ] [ -e level ] [ -E file ] [ -k start|restart|graceful|stop|graceful-stop ] [ -h ] [ -l ] [ -L ] [ -S ] [ -t ] [ -v ] [ -V ] [ -X ] [ -M ] [ -T ]

On windows, the additional args follow:

httpd [ -k install|configure|uninstall ] [ -n name ] [ -w ]

Options:

-d serverroot 

Set the initial value of the ServerRoot directive to serverroot. This can be overriden by the ServerRoot directive in the configuration file.
The default is /usr/local/apache2

-f config
Uses the directives in the file config on startup. If config does not begin with a /, then it is taken to be a path relative to the ServerRoot.
The default is conf/httpd.conf.

-k start|restart|graceful|stop|graceful-stop
Signals httpd to start, restart, or stop. 

Stopping and Restarting Apache HTTP Server:

In order to stop or restart the Apache HTTP Server (on Linux), you must send a Signal to the running httpd processes. THere are two ways 
to send the signals. First, you can use the unix kill command to directly send signals to the processes.

You will notice many httpd executables running on your system, but you should not send signals to any of them except for the parent,
whos pid is in the PidFile. That is to say, you shouldn't ever need to send signals to any process except the parent. 

There are four signals that you can send to the parent: TERM, USR1, HUP and WINCH, which we will go through.

To send a signal to the parent you should issue a command such as:

kill -TERM `cat /usr/local/apache2/logs/httpd.pid`

The second method of signaling the httpd processes is to use the -k command line options: stop, restart, graceful and graceful-stop.
These are arguments to the httpd binary, but we recommend that you send them using the apachetl control script, which will pass
them through the httpd.

After you have signaled the httpd, you can read about its progress by issuing:

tail -f /usr/local/apache2/logs/error_log

Modify thoose examples to match your ServerRoot and PidFile settings.

PidFile Directive:

File where the server records the process ID of the daemon

Syntax: PidFile filename

Default: PidFile logs/httpd.pid

The PidFile directive sets the file to which the server records the process id of the daemon. If the filename is not absolute, then
it is assumed to be relative to the ServerRoot.

Example:

PidFile /var/run/apache.pid

It is often useful to be able to send the server a signal, so that it closes and then re-opens its ErrorLog and TransferLog, and re-reads
its configuration files.

This is done by sending a SIGHUP (kill -1) signal to the process id listed in the PidFile.

However, since Apache 2.0, we are recommended to use the apachetl:

Apachetl - Apache HTTP Server Control Interface

apachetl is a front end to the Apache HyperText Transfer Protocol (HTTP) server. It is designed to help the administrator control
the functioning of the Apache HTTPD daemon.

The apachetl script can operate in two modes. First, it can act as a simple front-end to the httpd command that simply sets any necessary 
environment variables and then invokes httpd, passing through any command line arguments.

Second, apachetl can act as a SysV init script, taking simple one-word arguments like start, restart, and stop, translating them 
into the appropiate signals for httpd.

If your Apache installation uses non-standard paths, you will need to edit the apachetl script to set the appropiate paths to the
httpd binary. You can also specify any necessary httpd command line arguments. See the comments in the script for details.

The apachetl script returns a 0 exit value on success and >0 if an error occurs. 

Synopsis:

When acting in pass-through mode, apachetl can take all the arguments available for the httpd binary.

apachetl [ httpd-argument ]

When acting in SysV init mode, apachetl takes simple, one-word commands, defined below:

apachetl <command>

Options:

Only the SysV init-style options are defined here. Other args are listed on the httpd manual page.

start:
Start the Apache httpd daemon. Gives an error if it is already running. This is equivilant to apachetl -k start

stop:
Stops the Apache httpd daemon. This is equivilant to apachetl -k stop

restart:
Restarts the Apache httpd daemon. If the daemon is not running, it is started. This command automatically checks the configuration
files as in configtest before initiating the restart to make sure the daemon does not die.

THis is equivilant to apachetl -k restart

fullstatus:
Displays a full status report from mod status. For this to work, you need to have mod status enabled on your server and a text-based
browser such as lynx available on the system. The URL used ot access the status report can be set by editing the STATUSURL variable
in the script.

status:
Displays a brief status report. Similar to fullstatus option, except that the list of requests currently being served is omitted.

graceful:
Gracefully restarts the Apache httpd daemon. If the daemon is not running, it is started. This differs from a normal restart in that
currently open connections are not aborted. A side effect is that old log files will not be closed isntantly.

THis means that if used in a log rotation script, a substansial delay may be nessecary to ensure that the old log files
are closed before processing them. This command automatically checks the configuration files as in configtest before initiating
the restart to make sure Apache does not die.

This is equivilant to apachetl -k graceful.

graceful-stop:
Gracefully stops the Apache httpd daemon. This differs from a normal stop in that currently open connections are not aborted.
A side effect is that old log files will not be closed immedeatly. This is equivilant to apachetl -k graceful-stop.

configtest:
Run a configuration file syntax test. It parses the configuration files and either reports Syntax Ok or detailed information about
the particular syntax error. This is equivilant to apachetl -t

ErrorLog Directive:

Location where the server will log errors

Syntax: ErrorLog file-path|syslog[:facility]

Default: ErrorLog logs/error_log (Unix) ErrorLog logs/error.log (Windows and OS/2)

The ErrorLog directive sets the name of the file to which the server will log any errors it encounters. if the file-path
is not absolute then it is assumed to be relative to the ServerRoot.

ErrorLog "/var/log/httpd/error_log"

If the file-path begins with a pipe char "|" then it is assumed to be a command to spawn to handle the error log.

ErrorLog "|/usr/local/bin/httpd_errors"

Using syslog instead of a filename enables logging via syslogd(8) if the system supports it. The default is to use syslog
facility local7, but you can override this by using the syslog:facility syntax where facility cna be one of the names
usually documented in syslog(1). The facility is effectively global, and if it is changed in individual virtual hosts,
the final facility specified affects the entire server.

ErrorLog syslog:user

Additional modules can provide their own ErrorLog providers. The syntax is similar to the syslog example above.

Only allow writing permissions of the server daemon owner.

Note: When entering a file path on non-unix platforms, care should be taken to make sure that only forward slashes are used
even though the platform may allow the use of backslashes. In general, it is a good idea to always use forward slashes throughout
the config files.

TransferLog directive:

Specify location of a log file

Syntax: TransferLog file|pipe

This directive has exactly the same arguments and effect as the CustomLog directive, with the exception that it does not allow
the log format to be specified explicitly or for conditional logging of requests.

Instead, the log format is determined by the most recently specified LogFormat directive which does not define a nickname.
Common Log Format is used if no other format has been specified.

Example:

LogFormat "%h %l %u %t \t"%r\" %>s %b \"%{Referer}i\" \"%{User-agent}i\""
TransferLog logs/access_log

Alias Directive:

Maps URLs to filesystem locations

Syntax: Alias [URL-path] file-path|directory-path

The Alias directive allows documents to be stored in the local filesystem other than under the DocumentRoot.

URLs with a (%-decoded) path beginning iwth URL-path will be mapped to local files beginning with directory-path.
The URL-path is case-sensitive, even on case-insensitive file systems.

Alias "/image" "/ftp/pub/image"

A request for http://example.com/image/foo.gif would cause the server to return the file /ftp/pub/image/foo.gif

Only complete path segments are matched, so the above alias would not match a request for http://example.com/imagefoo.gif 
For more complex matching using regex, see the AliasMatch directive.

Note that if you include trailing / on the URL-path then the server will require a trailing / in order to expand the alias.
That is, if you use:

Alias "/icons" "/usr/local/apache/icons/"

then the URL /icons will not be aliased, as it lacks the trailing /. Likewise, if you omit the slash on the URL-path
then you must also omit it from the file-path.

Note that you may need to specify additional <Directory> sections which cover the destination of aliases. Aliasing occurs before
<Directory> sections are checked, so only the destination of aliases are affected.

(note however <Location> sections are run through once before alises are performed, so they will apply.)

In particular, if you are creating an Alias to a dir outside of your DocumentRoot, you may need to explicitly
permit access to the target dir.

Alias "/image" "/ftp/pub/image"
<Directory "/ftp/pub/image">
	Require all granted
</Directory>

Any number of slashes in the URL-Path param matches any number of slashes in the request URL-Path.

If the Alias directive is used within a <Location> or <LocationMatch> section the URL-path is omitted, and the
file-path is interpeted using expression syntax.

<Location "/image">
	Alias "/ftp/pub/image"
</Location>
<Locationmatch "/error/(?<NUMBER>[0-9]+)">
	Alias "/usr/local/apache/errors/%{env:MATCH_NUMBER}.html"
</LocationMatch>

Directive: AliasMatch 

Syntax: AliasMatch regex file-path|directory-path

This directive is equivilant to Alias, but makes use of regex instead of simple prefix matching. The supplied regex is matched
against the URL-path, and if it matches, the server will substitute any parenthesized matches into the given string and use it
as a filename.

For example, to activate the /icons dir, one might use:

AliasMatch "^/icons{/|$)(.*)" "/usr/local/apache/icons$1$2"

the full range of regex is available. We can do a case-insensitive alias matching if we wish, for matching the URL-path:

AliasMatch "(?i)^/image(.*)" "/ftp/pub/image$1"

One subtle difference between Alias and AliasMatch is that Alias will automatically copy any additonal part of the URI,
past the part that matched, onto the end of the file path on the right side, while AliasMatch will not.

this means that in almsot all cases, you will want regex to match the entire request URI from beginning to end, and to use subtitution
on the right side.

In other words, just changing Alias to AliasMatch will not have the same effect. At a minimum, you need to add ^ to the beginning
of the regex and add (.*)$ to the end, and add $1 to the end of replacement.

For example, suppose you want to replace this with AliasMatch:

Alias "/image/" "/ftp/pub/image/"

IS NOT EQUIVILANT TO

AliasMatch "/image/" "/ftp/pub/image/"

To get the same effect:

AliasMatch "^/image/(.*)$" "/ftp/pub/image/$1"

Of course, there is no point of AliasMatch where Alias would work. AliasMatch lets you do more complicated things. For example, you could
serve different kinds of files from different directories:

AliasMatch "^/image/(.*)\.jpg$" "/files/jpg.images/$1.jpg"
AliasMatch "^/image/(.*)\.gif$" "/files/gif.images/$1.gif"

Multiple leading slashes in the requested URL are discarded by the Server before directives from this module compares against 
the requested URL-path.

Note: Apache builds on the Perl Regex. Gonna have to freshen up that part.

ServerRoot Directive:

Base dir for the Server installation

Syntax: ServerRoot dir-path

Default: ServerRoot /usr/local/apache

The ServerRoot directive sets the directory in which the server lies. Typically it will contain the subdirectories conf/ and logs/. Relative
paths in other configuration directives (such as Include or LoadModule) are taken as relative to this dir.

ServerRoot "/home/httpd"

The default location of ServerRoot may be modified by using the --prefix argument to configure, and most third-party distrus of the server
have a different default location from the one listed above.

AUTH_TYPE: 

The configured AuthType (e.g "basic")

CONTENT_TYPE:

The content type of the response (not available during <If >)

HANDLER:

The name of the handler creating the response.

Apache's Handler Use:

What is a Handler:

Related modules 	Related Directives

mod actions  		Action
mod asis 			AddHandler
mod cgi 			RemoveHandler
mod imagemap 		SetHandler
mod info
mod mime
mod negotiation
mod status

A "handler" is an internal Apache representation of the action to be performed when a file is called. Generally, files have implicit
handlers, based on the file type. Normally, all files are simply served by the server, but certain file types are "handeled" separately.

Handlers may also be configured explicitly, based on either filename extensions or on location, without relation to file type.
This is advantageous both because it is a more elegant solution, and because it also allows for both a type and a handler to be 
associated with a file.

Handlers can either be built into the server or included in a module, or they can be added with the Action directive. The built-in
handlers in the standard distribution are as follows:

default-handler: Send the file using the default_handler(), which is the handler used by default to handle static content (core).

send-as-is: Send file with HTTP headers as is. (mod asis)

cgi-script: Treat the file as a CGI script (mod cgi)

imap-file: Parse an imagemap rule file (mod imagemap)

server-info: Get the server's configuration information (mod info)

server-status: Get the server's status report (mod status)

type-map: Parse as a type map file for content negotiation (mod negotiation)

Examples:

Modifying static content using a CGI script:

The following directives will cause requests for files with the html extension to trigger the launch of footer.pl
CGI script.

Action add-footer /cgi-bin/footer.pl
AddHandler add-footer .html

Then the CGI script is responsible for sending the originally requested document (pointed to by the PATH_TRANSLATED environment variable) and
making whatever modifications or additions are desired.

Files with HTTP headers:

The following directives will enable the send-as-is handler, which is used for files which contain their own HTTP headers. All files in the
/web/htdocs/asis/ directory will be processed by the send-as-is handler, regardless of their filename extensions:

<Directory "/web/htdocs/asis">
	SetHandler send-as-is
</Directory>

Programmer's Note:

In order to implement the handler features, an additon has been made to the Apache API that you may wish to make use of.
Specifically, a new record has been added to the request_rec structure:

char *handler

If you wish to have your module engage a handler, you need only set r->handler to the name of the handler at any point prior to
the invoke_handler stage of the request. Handlers are implemented as they were before, albeit using the handler name instead
of a content type. 

While it is not nessecary, the naming convention for handlers is to use a dash-seperated word, with no slashes, so as not to invade
the media type name-space.

HTTP2:

"on" if the request uses http/2, "off" otherwise.

HTTPS:

"on" if the request uses https, "off" otherwise.

IPV6:

"on" if the connection uses IPV6, "off" otherwise.

REQUEST_STATUS:

The HTTP error status of the request (not available during <If >)

REQUEST_LOG_ID:

The error log id of the request (see ErrorLogFormat)

CONN_LOG_ID:

The error log id of the connection (see ErrorLogFormat)

CONN_REMOTE_ADDR:

The peer ID address of the connection (see the mod remoteip module)

CONTEXT_PREFIX

CONTEXT_DOCUMENT_ROOT

Misc Variables:

Name 						Desc
TIME_YEAR 					The current year

TIME_MON 					Current month

TIME_DAY 					current day of month

TIME_HOUR 					hour part of current time, digitally (00-23)

TIME_MIN 					Minute part of current time

TIME_SEC 					The second part of current time

TIME_WDAY 					The day of the week (starting with 0 for Sunday)

TIME 						The date in a String cascading format (YYYYMMDDHHMMSS)

SERVER_SOFTWARE 			The Server version String

API_VERSION 				The date of the API version (module magic number)

Some modules register additional variables, like mod_ssl

Binary Operators:

Comparison Operators:

Name 			Alternaive 				Desc

== 				= 						String equality

!=  									String inequality

< 										String less than

<= 										String less than or equal to

> 										String greater than

>= 										String greater than or equal

-eq 			eq 						Integer equality

-ne 			ne 						Integer inequality

-lt 			lt 						Integer less than

-le 			le 						Integer less than or equal

-gt 			gt 						Integer greater than

-ge 			ge 						Integer greater than or equal

Other Binary operators:

Name 				Desc

-ipmatch 			IP Address matches address/netmask

-strmatch 			left string matches pattern of right string (containign wildcards *, ?, [])

-strcmatch 			same as -strmatch but case insensitive

-fnmatch 			same as -strmatch but slashes are not matched by wildcard

Unary operators:

Unary operators take one argument and have the form "-[a-zA-Z]", i.e a minus and one char. The name is case sensitive. Modules may register
additional unary operators:

name 		desc 																				restricted

-d 			The argument is treated as a filename. True if file and is a Directory 				yes

-e 			The argument is treated as a filename. True if the file (or dir or special) exists  yes

-f 			The argument is treated as a filename. True if file exists and is just a regular file yes

-s 			The argument is treated as a filename. True if the file is not empty and exists 	yes

-L 			The argument is treated as a filename. True if the file exists and is symlink 		yes

-h 			The argument is treated as a filename. True if the file exists and is symlink (Same as -L) yes

-F 			True if string is a valid file, accessible via servers current configured access controls for that path.
			This uses an internal subrequest to do the check, so use it with care - it can impact server performance.

-U 			True if string is a valid URL, accessible via all the servers currently-configured access controls for that path.
			This uses an internal subrequest to do the check, so use with care. 

-A 			Alias for -U

-n 			True if string is not empty

-z 			True if string is empty

-T 			False if string is empty, "0", "off", "false", or "no" (Case insensitive). True otherwise.

-R 			Same as "%{REMOTE_ADDR} -ipmatch ...", but more efficient

The operators marked as restricted, are not available in modules like mod include.

Functions:

Normal string-valued functions take one string as a argument and return a string. Functions names are not case
sensitive. Modules may register additional functions.

Name 		Desc 																							Special notes

req. http 	Get HTTP request header; header names may be added to the Vary Header

req_novary 	Same as req, but header names will not be added to the Vary header

resp 		Get HTTP response header

reqenv 		Lookup request environment variable (as a shortcut, v can also be used to access variables) 	ordering

osenv 		Lookup operating system environment variable 

note 		Lookup request note 																			ordering

env 		Return first match of note, regenv, osenv 														ordering

tolower 	Convert string to lower case

toupper 	Conver string to upper case

escape 		Escape special characters in %hex encoding

unescape 	Unescape %hex encoded string, leaving encoded slashes alone; return empty string if %00 is found

base64 		Encode the string using a base64 encoding

unbase64 	Decode base64 encoded string, return truncated string if 0x00 is found

md5 		Hash the string using MD5, the encode the hash with hexadecimal encoding

sha1 		hash the string using SHA1, then encode the hash with hexadecimal encoding

file 		Read contents from a file (including line endings, when present) 								restricted

filemod 	Return last modification time of a file (or 0 if file does not exist or is not regular file) 	restricted

filesize 	Return size of a file (or 0 if file does not exist or is not a regular file) 					restricted

The functions marked as restricted, are not available in some modules like mod include

The functions marked as "ordering", requires consideration for ordering of operations, especially if it's used in the <If> directive
which is evaluated relativily early.

Environment variable ordering:

When environment variables are looked up within an <If> condition, it's important to consider how extremely early in request
processing that this resolution occurs. As a guideline, any directive defined outside of virtual host context (directory, location,
htaccess) is not likely to have yet had a chance to execute. SetEnvIf in virtual host scope is one directive that runs prior to this
resolution.

When reqenv is used outside of <If>, the resolution will generally occur later, but the exact timing depends on directive the expression
has been used within.

When the functions req or http are used, the header name will automatically be added to the Vary header of the HTTP response, except
where otherwise noted for the directive accepting the expression.

The req_novary function can be used to prevent names from being added to the Vary header.

In addition to string-valued functions, there are also list-valued functions which take one string as argument and
return a wordlist, i.e a list of strings. The wordlist can be used with the special -in operator.

Function names are not case sensitive. Modules may register additional functions.

There are no built-in list-valued functions. mod ssl provides PeerExtList. See the description of SSLRequire for details.
(but PeerExtList is also usable outside of SSLRequire)

Example expressions:

The following examples show how expressions might be used to evaluate requests:

#Compare the host name to example.com and redirect to www.example.com if it matches
<If "%{HTTP_HOST} == 'example.com'">
	Redirect permanent "/" "http://www.example.com/"
</If>

#Force text/plain if requesting a file with the query string contains 'forcetext'
<If "%{QUERY_STRING} =~ /forcetext/">
	ForceType text/plain
</If>

# Only allow access to this content during business hours
<Directory "/foo/bar/business">
	Require expr %{TIME_HOUR} -gt 9 && %{TIME_HOUR} -lt 17
</Directory>

# Check a HTTP header for a list of values
<If "%{HTTP:X-example-header} in { 'foo', 'bar', 'baz' }">
	Header set matched true
</If>

# Check an environment variable for a regex, negated.
<If "! reqenv('REDIRECT_FOO') =~ /bar/">
	Header set matched true
</If>

# Check result of URI mapping by running in Directory context with -f
<Directory "/var/www">
	AddEncoding x-gzip gz
<If "-f '%{REQUEST_FILENAME}.unzipme' && ! %{HTTP:Accept-Encoding} =~ /gzip/">
	SetOutputFilter INFLATE
</If>
</Directory>

# Check against the client IP
<If "-R '192.168.1.0/24'">
	Header set matched true
</If>

# Function example in boolean context
<If "md5 ('foo') == '<bla>'">
	Header set checksum-matched true
</If>

# Function example in string context
Header set foo-checksum "expr=%{md5:foo}"

# This delays the evaluation of the condition clause compared to <If>
Header always set CustomHeader my-value "expr=%{REQUEST_URI} =~ m#^/special_path\.php$#"

Other:

Name 			Alternative 			Desc
-in 			in 						String contained in wordlist

/regexp/ 		m#regexp# 				Regex (the second form allows different delimiters than /)

/regexp/i 		m#regexp#i 				Case insensitive regular expression

$0 ... $9 								Regex backreferences

Regex backreferences:

The Strings $0 ... $9 allow for refernece to the capture groups from a previously executed, successfully matching regex.
They can normally only be used in the same regex as the matching regex, but some modules allow special uses.

Comparison with SSLRequire:

The ap_expr syntax is mostly a superset of the syntax of the deprecated SSLRequire directive. 

//PERSONAL NOTE: Due to the time constraint, i cannot further explore Apache at this given moment. If the need arises,
//i shall go and see what is needed, but not more, as i am under time constraint.

Back to the Zend Framework, 2.10

Having Multiple Virtual Hosts:

When developing several websites on the same machine, you will want to create several virtual hosts. For each
virtual host you need to specify a domain name (like site1.mydomain.com). But if you currently do not have a domain name,
you can specify a different port instead.

An example:

#Listen directive tells Apache to listen requests on port 8080
Listen 8080

<VirtualHost *:8080>
	...
</VirtualHost>

After editing the Virtual host config file, we restart apache to apply the changes.

2.11. Hosts File:

When you have multiple local websites mapped to different ports, it becomes difficult to remember on which port each site presents.
To simplify this, you can use name-based virtual host and define an alias for your website in your system hosts file.

First, modify your Apache virtual host file to be name-based virtual host:

<VirtualHost *:80>
	#Add the ServerName directive
	ServerName site1.localhost
	...
</VirtualHost>

Next, you should edit the hosts file. The hosts file is a system file which contains mappings between IP addresses and host names.
The hosts file contains lines of text consisting of IP addresses in the first text field, followed by one or more host names.

To add an alias for your local website, add lines for each of your websites as shown:

127.0.0.1 			site1.localhost

With this, we will be able to simply enter site1.localhost in our browser instead of the portnumber.

The 127.0.0.1 is the loopback localhost IP, so, generally, you would like to assign this ip to be your broadcasting IP instead.

In Linux, the hosts file is located in /etc/hosts. In windows, the file is typically located in C:\Windows\System32\drivers\etc\hosts.

to edit the file, you need to be an admin. Some anti-virus may block editing of this file, thus, if it does, we need to disable it
whilst doing it.

If you have purchased a real domain name for your website (like example.com) you do not need to modify your hosts file,
because Apache will be able to resolve the IP address of your website using the DNS system. You modify your hosts file
only when DNS system knows nothing about the domain name and can't resolve the IP address of your website.

Advanced Composer Usage:

Earlier in this chapter, we used Composer to install ZF 3 lib code. Now let's briefly describe some advanced
Composer usage examples.

As we already know, the only required key in the composer.json file is require. This key tells what packages are
required by your applciation:

{
	"require": {
		"php": "^5.6 || ^7.0",
		"zendframework/zend-component-installer": "^1.0 || ^0.3 || ^1.0.0-dev@dev",
		"zendframework/zend-mvc": "^3.0.1",
		"zfcampus/zf-development-mode": "^3.0",
		"zendframework/zend-mvc-form": "^1.0",
		"zendframework/zend-mvc-plugins": "^1.0.1",
		"zendframework/zend-session": "^2.7.1"
	}
}

Package names and Version:

A package name consists of two parts, venodr name and project name. For example, "zendframework/zend-mvc" package name consists
of "zendframework" vendor name and "zend-mvc" project name. You can search for other packages from "zendframework"
vendor through Packagist.org

Packagist is the main repo for all Composer compatible libs.

A package also has a associated version number. A version number consists of major number, minor number, optional build number
and optional stability suffix (e.g b1, rc1). Within the require key we specify which versions of the package are acceptable.

For example, "^5.6" means that we can install versiosn greater than 5.6, but lower than 6 (As to not break backwards comp.)

Package version definitions:

3.0.1 			Exact version. Only this version will be isntalled.

>=3.0.1 		Greater or equal version can be installed (3.0.1, 3.2.1 etc.)

>3.0.1 			Greater version can be installed (3.0.2 etc)

<=3.0.1 		Lower or equal version can be installed (1.0, 1.5, 2.0.0 etc)

<3.0.1 			Lower version can be installed (1.0, 1.1, 1.9, etc)

!=3.0.1 		All versions except this version can be installed

>=3.0,<3.1.0 	Any version belonging to this range can be installed.

3.* 			Any major version belonging to 3

~3.0 			Any version starting at 3, but lower than 4 (is equivilant to >=3.0,<4.0)

^3.0 			Any version starting from 3.0, but lower than the next major version (equivilant to >=3.0, <4.0). Similar to ~3.0, but it
				sticks closer to semantic versioning, and will always allow non-breaking updates.

Installing and Updating Packages:

We've seen how to use the php composer.phar install command to install our dependencies. As soon as you call this command,
Composer will find, download and install the dependencies of your vendor subdir.

Is it safe to install dependencies with Composer?

Well, some people are afraid of Composer-style dependency management, because they think someone can update the dependencies
system-wide by mistake or inetntionally, causing the web app to break. Composer NEVER installs system-wide, instead it installs
them to the APP_DIR/vendor/ dir.

After installation, Composer also creates the APP_DIR/composer.lock file. This file now contains actual versions of the packages
that were installed. If you run the install command again, Composer will encounter the composer.lock file, check with dependencies
already installed and as all packages already installed, it just exits without doing anything.

Now assume that in some period of time new security updates for your dependency packages are released. You will want to update
your packages to keep your website secure. You can do that by typing the following:

php composer.phar update

If you want to update only a single dependency, type its name as the following:

php composer.phar update zendframework/zend-mvc

After the update command, your composer.lock file will be updated too.

What to do if i want to roll back to a previous version of the package?

If the update procedure resulted in unwanted problems with your system, you can roll back by reverting the changes
to your composer.lock file and issuing the install command again.  Reverting changes to composer.lock is easy with
a GIT or SVN tool.

Otherwise, just make a copy of composer.lock first.

Adding a New Dependency:

If you want to add a new dependency to the application, you can either edit composer.json manually, or issue require
command. For example, to install Doctrine ORM to your web site (to add the "doctrine/doctrine-module" package to the app deps):

php composer.phar require doctrine/doctrine-module 2.*

The command above edits composer.json file and downloads and installs the package. We will use this command later in 
the chapter, Managing Database with Doctrine, when we dive into DB management.

Virtual Packages:

Composer can be used to require some functionality to present on your system. You've already seen how we require "php:^5.6" 
PHP package is a virtual package representing PHP itself. You can also require other stuff like PHP extensions:

Definition Example 							Desc
 
"php":"^5.6" 						Require PHP version greater or equal than 5.6 , but lower than 6.0

ext-dom, ext-pdo-mysql 				Require PHP DOM and PDO MySQL extensions

lib-openssl 						Require OpenSSL library

You can use php composer.phar show --platform command to display a list of available virtual packages for your machine.

Composer and Version Control Systems:

If you are using a version control system (like Git), you will be curious about what should be stored in Git: 
your app code only, or your app code + all the Composer-installed dependencies in APP_DIR/vendor dir?

In general, it is not recommended to store your Composer-dependencies under version control because this can 
make your repo really big and slow to check out and branch. Instead, you should store your composer.lock file
under version control.

The composer.lock file guarantees that everyone will install the same versions of dependencies as you have. This
is useful in development teams having more than one dev, because all devs should have the same code to avoid 
unwanted issues with env misconfigs.

What if some dependency is declared obsolete and removed from Packagist.org?

Well, the possibility of package removal is minimum. All packages are free and open-source, and the community
of users can always restore the dependency even if it is removed from packagist.

By the way, the same concept of dependency installation is used in Linux (as per APT or RPM manager).

But there are some situations where you should store some dependency libs under version control:

If you have to make custom changes to third-party code. For example, assume you have to fix a bug in a lib, and you
cannot wait for the lib's vendor to fix it for  you (or if the lib vendor can't fix the bug). Then place the lib code
under version control (GIT).

If you have written a reusable module or lib and want to store it in the vendor dir without publishing it on Packagist.org
Because you do not have the possibility to isntall it via Packagist, store it under version control.

If you want a 100% guarantee that a third-party package won't be lost. Although the risk is minimum, for some app it is 
critical to be autonomous and not depend on package availability on Packagist.org

Website Operation:

In this chapter, we will provide some theory on how a typical ZF3 based app works.

We will learn some basic PHP, PHP namespaces for avoiding name collisions, what a class autoloading is,
how to define application configuration parameters and the stages present in an application life-cycle.

You will also become familiar with such important ZF3 components as Zend\EventManager, Zend\ModuleManager and Zend\ServiceManager.

ZF3 components covered in this chapter:

Component 							Desc
Zend\Mvc 					Support of Model-View-Controller pattern. Separation of business logic from presentation.

Zend\ModuleManager 			This component is responsible for loading and initializing modules of the web app.

Zend\EventManager 			This component implements functionality for triggering events and event handling.

Zend\ServiceManager 		Implements the registry of all services available in the web app.

PHP Classes:

PHP supports OOP:

<?php

class Person
{
	private $fullName;

	public function __construct()
	{
		//Some init code
		$this->fullName = 'Unknown Person';
	}

	public function getFullName()
	{
		return $this->fullName;
	}

	public function setFullName($fullName)
	{
		$this->fullName = $fullName;
	}
}

When we only have php code, we need no php closing tag.

Example of basic interaction:

<?php

//instansiate person
$person = new Person();

$person->setFullName('john doe');

echo "Person's full name is: " . $person->getFullName() . "\n";

PHP Namespaces:

When you use classes from different libs (or even classes from different components of a single lib) in your program,
the class name may conflict. This means you can encounter two classes having the same name, resulting in PHP interpeter error.

If you've ever programmed websites with ZF 1, you will remember verbose names.

To achieve the same principle, i.e avoiding name collision. ZF 3 uses a PHP language feature called namespaces.
The namespaces allow to solve name collisions between code components, and provide you with the ability to make
long names shorter.

A namespace is a container for a group of names. You can nest namespaces into each other. If a class does not define a namespace,
it lives inside of the global namespace (for example, PHP classes Exception and DateTime belong to global namespace).

Akin to Python.

A example, from Zend\Mvc:

<?php
namespace Zend\Mvc;

/**
  * Main application class for invoking applications.
  */
class Application
{
	//omitted for brevity
}

In ZF3, all classes belong to top-level Zend namespace. Here, we define a namespace of Mvc, which is nested in Zend.

All classes of this component (including the Application class) belong to this namespace.

We seperate namespaces with \.

An example of referencing the fully-qualified name of Application:

<?php
$application = new \Zend\Mvc\Application();

Please note the leading backslash here. If we define a class name that begins with \, it is a fully-qualified class name.
It is also possible to specify class names relativily to the current namespace - to which we need not begin with a \.

It is also possible to use the alias (short name for the class) with the help of PHP's use statement.

<?php
//Define the alias
use Zend\Mvc\Application;

//use the short class name, possible through the alias assignment
$application = new Application();

The usage of alias is optional. 

Every PHP file of your application typically defines the namespace (except index.php entry script and config files, which typically
do not). For example, the main module of your site, the Application Module, defines it's own namespace whose name equals to the module name.

<?php
namespace Application;

class Module
{
	//Omitted for simplicity
}

PHP Interfaces:

In PHP, we also have interfaces. Interfaces are also are called contracts, for they mustfill the conditions.

An example of usage of the ApplicationInterface:

<?php
namespace Zend\Mvc;

interface ApplicationInterface
{
	//Retrieves the service manager
	public function getServiceManager();

	//Retrieves the HTTP request object.
	public function getRequest();

	//Retrieves the HTTP response object.
	public function getResponse();

	//Runs the application.
	public function run();
}

As we can see in the example above, we define the interface and define the methods which we must.

The ones that we see here that we must implement, are:

getServiceManager() //gets the service manager

getRequest() and getResponse() //retrieves HTTP request and response

run() //For running the app

In ZF3 by convention, interface classes should be named with Interface suffix, like ApplicationInterface.

A class implementing an interface is called a concrete class. 

An example of a class implementing the ApplicationInterface:

<?php
namespace Zend\Mvc;

class Application implements ApplicationInterface
{
	//implement the interface methods here

	public function getServiceManager()
	{
		//implementation
	}

	public function getRequest()
	{
		//implementation
	}

	public function getResponse()
	{
		//implementation
	}

	public function run()
	{
		//implementation
	}
}

PHP Class Autoloading:

A web application consists of many PHP classes, and each class typically resides in a separate file. Thus, we need to include them.

For example, let's assume we have a file named Application.php which contains the definition for the \Zend\Mvc\Application class
from the previous section. Before you create an instance of the Application class somewhere in your code, you have to include
the contents of Application.php file, to which we can do via require_once with the full path name.

<?php
require_once "/path/to/zendframework/zend-mvc/src/Application.php";

use Zend\Mvc\Application;

$application = new Application();

As our app grows in size, so does the need for inclusion of classes and to circumvent the inclusion lest needed for resolution. To resolve this, we have Class autoloaders.

The PHP function spl_autoload_register() allows you to register an autoloader function. In more complex sitautions, we can have 
even several of them chain to become a stack.

During script execution, if PHP interpeter encounters a class name which has not been defined yet, it calls all the registered
autoloader functions in turn, until either the autoloader function includes the class or "not found" is raised.

This makes for "lazy" loading, meaning it only loads when it really needs it.

Class Map Autoloader:

An example of a autoloader:

<?php
//Autoloader function
function autoloadFunc($className)
{
	//Class map static array
	static $classMap = [
		'\\Zend\\Mvc\\Application' => '/path/to/zendframework/zend-mvc/src/Zend/Mvc/Application.php',
		'\\Application\\Module' => '/path/to/app/dir/module/Application/Module.php',
		//...
	];

	//Check for presence in the class map for class names
	if(isset(static::$classMap[$className])){
		$fileName = static::$classMap[$className];

		// Check if file exists and is readable.
		if (is_readable($fileName)){
			//include the file
			require $fileName;
		}
	}
}

//Register our autoloader function.
spl_autoload_register("autoloadFunc");

In the above example, we define the autoloadFunc() autoloader function, which we will further refer to as the class map autoloader.

The class map autoloader uses the class map for mapping between class name and absolute path to PHP file containing that class.
The class map is just a usual PHP array containing keys and values.

To determine the file path by class name, the class map autoloader just needs to fetch the value from the class map array.
It is obvious, that the class map autoloader works very fast. (Could have been faster with hashtables i guess)

The disadvantage is that we must update the map when we add a class.

Because each library's vendor uses it's own code naming and file organization conventions, you will have to register
a different custom autoloader function per dependency library, which is annoying.

But, there is a solution.

PSR-4 standard.

PSR is for PHP Standard Recommendations.

The standard itself, is what the code structure or lib must adhere to, to assert that autoloaders work interoperabile.

The standard says:

The class namespaces should be organized in the following way:

\<Vendor Name>\(<Namespace>)*\<Class Name>

Namespaces can have as many nested levels as it wishes, but the Vendor should be the top-level namespace.

Namespaces should map to directory structure. Each namespace seperator ('\') is converted to a OS-specific DIRECTORY_SEPARATOR
constant when loading from the file system.

The class name is suffixed with .php extension when loading from the file system.

For example, Zend\Mvc\Application class, gives the following directory structure:

/path/to/zendframework/zend-mvc/src
	/Zend
		/Mvc
			Application.php

The disadvantage is that then we need to put our code in nested directories (zend and mvc)

To fix this, PSR-4, allows you to define that a contiguous series of one or more leading namespaces
and sub-namespace names corresponds to a "base directory". 

For example, if you have the \Zend\Mvc\Application fully qualified class name, and if you define that
the series \Zend\Mvc corresponds to the "/path/to/zendframework/zend-mvc/src" directory, you can organise your
files as:

/path/to/zendframework/zend-mvc/src
	Application.php

For the code conforming to PSR-4 standard, we can write and register an autoloader, which we will refer to as the "standard"
autoloader:

<?php

//Standard autoloader function
function standardAutoloadFunc($className)
{
	//Replace the namespace prefix with base directory.
	$prefix = '\\Zend\\Mvc';
	$baseDir = '/path/to/zendframework/zend-mvc/src/';
	if(substr($className, 0, strlen($prefix)) == $prefix){
		$className = substr($className, strlen($prefix)+1);
		$className = $baseDir . $className;
	}

	//Replace namespace separators in class name with directory separators.
	$className = str_replace('\\', DIRECTORY_SEPARATOR, $className);

	//Add the .php extension
	$fileName = $className . ".php";

	//Check if file exists and is readable
	if (is_readable($fileName)){
		//include the file
		require $fileName;
	}
}

//Register the autoloader function
spl_autoload_register("standardAutoloadFunc");

The standard autoloader works as follows: Assuming that the class namespace can be mapped to the dir structure one-by-one,
the function calculates the path to the PHP file by transforming back-slashes (NS separators) to forward slashes (path separators),
and concatenating the result path with the absolute path to the directory where the library is located.

Then the function checks if such a PHP file really exists, and if so, includes it with the require statement.

It is obvious, that the standard autoloader works slower than the class map autoloader. However, the advantage is that we need
not maintain any list of Classes to trace.

ZF3 conforms to PSR-4 standard, making it possible to use standard autoloading mechanism across all its components.
It is also compatible with other PSR-4 conforming libraries like Doctrine or Symfony.

Composer-provided Autoloader:

Composer can generate autoloader functions (both class map autoloaders and PSR-4 standard autoloaders) for the code you install
with it. ZF 3 uses the autoloader implementation provided by Composer.

When you isntall a package with Composer, it automatically creates the file APP_DIR/vendor/autoload.php, which uses the spl_autoload_register()
PHP function to register an autoloader. This way, all PHP classes located in APP_DIR/vendor directory are correctly autoloaded.

To autoload PHP classes located in your own modules (like Application module), you'll have to specify the autoload key in your 
composer.json file:

"autoload": {
	"psr-4:" {
		"Application\\": "module/Application/src"
	}
}

Then we need but include the autoloader in the index.php:

//Composer autoloading
include __DIR__ . '/../vendor/autoload.php';

The autoload.php is generated each time you install a package with Composer. Besides that, to make Composer
generate the autoload.php file, you may need to execute the dump-autoload command:

php composer.phar dump-autoload

PSR-4 and Module's Source Directory Structure:

In the Zend Skeleton Application, you can see how the PSR-4 standard is applied in practice.
For the default module of your website, the Application module, PHP classes which are registered with the standard
autoloader are stored under the APP_DIR/module/Application/src directory

For example, let's look at the IndexController.php file of Application module:

Vmodule
	VApplication
		>config
		Vsrc
			VController
				IndexController.php
			Module.php
		>test
		>view

As you can see, it contains the IndexController class belonging to Application\Controller namespace. To be able to
follow the PSR-4 standard and use the standard autoloader with this PHP class, we have to put it under the Controller dir
under the modules source dir.

The IndexController is the default controller of the skeleton website.

HTTP Request and Response:

When a site user opens a web page in a web browser's window, the browser generates a request message and sends
it using HTTP protocol to the web server. The web server directs this HTTP request to your web application.

HTTP (stands for Hyper Text Transfer Protocol) - is a protocol for transfering data in teh form of hyper text documents
(web pages). HTTP is based on the client-server technology: the client initiates a connection and sends a request to the
web server, and the server waits for a connection, performs the actions and returns a response message back.

Thus, the main underlying goal of any web application is handling the HTTP request and producing HTTP responses
typically containing the HTML code of the requested web page.

The response is sent by the web server to the client web browser and the browser displays a web page on the screen.

A typical HTTP request is presented below:

GET http://www.w3schools.com/HTTP/1.1
Host: www.w3schools.com
Connection: keep-alive
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64)
Accept-Encoding: gzip,deflate,sdch
Accept-Language: en-US;q=0.8,en;q=0.6
Cookie: __gads=ID=<bla>:<bla>:<bla>;
(empty line)
(message body goes here)

The HTTP request message above conists of three parts:

The starting line specifies the method of the request (e.g GET or POST), the URL string and HTTP protocl version.
Optional headers characterize the message, the transmission parameters and provide other meta information.

In the example above, each row represents a single header in the form of name:value.

Optional message body contains message data. It is seperated from the headers with a blank line.

The headers and the message body may be absent, but the starting line is always present in the request, because it indicates
its type and URL.

The server response for the above request is presented below:

HTTP/1.1 200 OK
Cache-Control: private
Content-Type: text/html
Content-Encoding: gzip
Vary: Accept-Encoding
Server: Microsoft-IIS/7.5
Set-Cookie: <stuff>; path=/
X-Powered-By: ASP.NET
Date: Sun, 04 Aug 2013 13:33:59 GMT
Content-Length: 8434
(empty line)
(page content follows)

As we can see above, the HTTP response has also the same format as the request:

it starts with HTTP version, response code and associated type with that code.

Optional headers provide various meta data about the response.

Optional message body follows the headers, and must be seperated from the other headers by a line. The message
body typically contains the HTML code of the requested web page.

Site Entry Script:

When the Apache web server receives an HTTP request from a client browser, it executes the APP_DIR/public/index.php file,
also called the entry script.

The entry script is the only PHP file accessible to the outside world. Apache web server directs all HTTP requests
to this script (remember the .htaccess file?). Having this single entry script makes the website more secure (comparing with 
the situation when you allow everyone to access all PHP files of your app).

Althought the index.php is very important, it is very small, as follows:

<?php

use Zend\Mvc\Application;
use Zend\Stdlib\ArrayUtils;

/**
  * This makes our life easier when dealing with paths. Everything is relative
  * to the application root now.
  */
chdir(dirname(__DIR__));

//Decline static file requests back to the PHP built-in webserver
if (php_sapi_name() === 'cli-server'){
	$path = realpath(__DIR__ . parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH));
	if (__FILE__ !== $path && is_file($path)){
		return false;
	}

	unset($path);
}

//Composer autoloading
include __DIR__ . '/../vendor/autoload.php';

if (! class_exists(Application::class)){
	throw new RuntimeException(
		"Unable to load application.\n"
		. "- Type `composer install` if you are developing locally.\n"
		. "- Type `vagrant ssh -c 'composer install'` if you are using Vagrant.\n"
		. "- Type `docker-compose run zf composer install` if you are using Docker.\n"
	);
}

//Retrieve configuration
$appConfig = require __DIR__ . '/../config/application.config.php';
if (file_exists(__DIR__ . '/../config/development.config.php')){
	$appConfig = ArrayUtils::merge($appConfig, require __DIR__ . '/../config/development.config.php');
}

//Run the App
Application:init($appConfig)->run();

There is mainly three things happening here:

Cwd is changed to APP_DIR, with chdir(dirname(__DIR__)); //chdir is just change dir

We include the autoloader so that we can include stuff with lazy loading, without having to do require_once statements.

And lastly, we create an instance of the Zend\Mvc\Application class, by initializing with the settings read from application.config.php
config file, and the app is run.

Events & Application's Life Cycle:

As you've learned from the previous section, on every HTTP request, the Zend\Mvc\Application object is created.

Typically, an application "lives" for a second or less (This is enough time to generate the HTTP response). The application's
"life" consists of several stages:

ZF3 uses the concept of event. One class can trigger an event, and other classes may listen to events.
Technically, triggering an event means just another class' callback method. The event management is implemented
inside of the Zend\EventManager component.

Each application life stag is initiated by the application by triggering an event (this event is represented by the 
MvcEvent class living in Zend\Mvc namespace). Other classes (either belonging to Zend Framework or specific to your application)
may listen to events and react accordingly.

Below, the five main events (life stages) are presented:

Bootstrap: When this event is triggered by the application, a module has a chance to register itself as a listener
of further application events in its onBootstrap() callback method.

Route: When this event is triggered, the request's URL is analyzed using a router class 
(typically, with Zend\Router\Http\TreeRouteStack class) If an exact match between the URL 
and a route is found, the request is passed to the site-specific controller class assigned to the route.

Dispatch: The controller class "dispatches" the request using the corresponding action method and produces
the data that can be displayed on the web page.

Render: On this event, the data produced by the controller's action method are passed for rendering to Zend\View\Renderer\PhpRenderer
class. The renderer class uses a view template file for producing an HTML page.

Finish: On this event, the HTTP response is sent back.

We could paint out the process as follows:

	Events 						Listeners //Listeners goes here
 	  V
	Bootstrap  >>>>>>>>>>>>>>>>>
	  V
	Route >>>>>>>>>>>>>>>>>>>>>>
	  V
	Dispatch >>>>>>>>>>>>>>>>>>>
	  V
	Render >>>>>>>>>>>>>>>>>>>>>
	  V
	Finish >>>>>>>>>>>>>>>>>>>>>

Although needed relativily rarely, some practical examples of how to listen and react to an event can be
found in the Creating a New Module chapter.

Application Configuration:

Most of Zend Framework components which are used in your website, require configuration (fine-tuning).
For example, in the configuration file you define database connection credentials, specify which modules
are present in your application, and, optionally, provide some custom parameters specific to your application.

You can define the configuration parameters at two levels: either at the application level, or at the module level.

At the application level, you typically define parameters which control the whole app and are common to all modules
of your application.

At the module leve, you define parameters specifically for that specific module.

Some PHP frameworks prefer conventions over configuration concept, where most of your parameters are hard-coded
and do not require configuration. This makes it faster to develop the application, but makes it less customizable.

In ZF3, we go the path of configuration over convention. Meaning, we spend more time on configuring, than going by
conventions.

Application-Level Config Files:

The APP_DIR/config sub-dir contains application-wide configuration files. Let's look at this subdirectory
in more details.

v config
	v autoload
		development.local.php.dist
		global.php
		local.php.dist
		README.md
		zend-developer-tools.local-development.php
	application.config.php
	development.config.php.dist
	modules.config.php

The APP_DIR/config/application.config.php file is the main configuration file. It is used by the application
on start up for determining which application modules should be loaded and which services to create by default.

Below, the content of application.config.file is presented. You can see that the configuration file is just a usual PHP
nested associative array, and each component have a specific key in that array.

You can provide comments for the array keys to make it easier to understand what each key means.

By convention, key names should be in lower case, and if they key name consists of several words, the words should
be separated by the _ symbol.

return [
	//Retrieve list of modules used in this application
	'modules' => require __DIR__ . '/modules.config.php',

	//These are various options for the listeners attached to the ModuleManager
	'module_listener_options' => [
		//This should be an array of paths in which modules reside
		// If a string key is provided, the listener will consider that a module
		// namespace, the value of that key the specific path to that module's
		// Module class.
		'module_paths' => [
			'./module',
			'./vendor',
		],

		//An array of paths from which to glob configuration files after
		// modules are loaded. These effectively override configuration
		// provided by modules themselves. Paths may use GLOB_BRACE notation.
		'config_glob_paths' => [
			realpath(__DIR__) . '/autoload/{{,*.}global,{,*.}local}.php',
		],

		//Wether or not to enable a configuration cache
		//If enabled, the merged configuration will be cached and used in 
		// the subsequent requests
		'config_cache_enabled' => true,

		// The key used to create the configuration cache file name
		'config_cache_key' => 'application.config.cache',

		//Wether or not to enable a module class map cache
		//If enabled, creates a module class map cache which will be used
		// by in future requests, to reduce the autoloading process
		'module_map_cache_enabled' => true,

		//THe key used to create the class map cache file name.
		'module_map_cache_key' => 'application.module.cache',

		//The path in which to cache merged configuration
		'cache_dir' => 'data/cache/',

		// Wether or not to enable modules depedency checking
		// Enable by default, prevents usage of modules that depend on other modules
		// that were not loaded
		// 'check_dependencies' => true,
	],

	//USed to create an own service manager. May contain one or more child arrays.
	//'service_listener_options' => [
	//	[
	// 		'service_manager' => $stringServiceManagerName,
	// 		'config_key' 	  => $stringConfigKey,
	// 		'interface' 	  => $stringOptionalInterface,
	// 	    'method' 		  => $stringRequiredMethodName,
	//	],
	//],
	

	//Initial configuration with which to seed the ServiceManager.
	// Should be compatible with Zend\ServiceManager\Config.
	// 'service_manager' => [],
];

We begin the script with defining the modules key, to which modules will be loaded on start up. We can see that
the module names are stored inside of another config file modules.config.php, which lists all modules presented in your website.

The module_paths key tells ZF3 about directories where to look for source files belonging to modules.
Application modules that you develop are located under APP_DIR/module directory, and third-party modules may be
located inside the APP_DIR/vendor directory.

The config_glob_paths key, tells ZF3 where to look for extra config files. You see that files from
APP_DIR/config/autoload which have global.php or local.php suffix, are automatically loaded.

Summing up, you typically use the main application.config.php file for storing the information about which modules should
be loaded into your app and where they are located and how they are loaded (for example, you can control caching options here).

In this file, you can also tune the service manager. It is not recommended to add more keys in this file. For that purpose it is
better to use autoload/global.php 

And let's look inside the modules.config.php file. Currently, you have the following modules installed in your website:

return [
	'Zend\Session',
	'Zend\Mvc\Plugin\Prg',
	'Zend\Mvc\Plugin\Identity',
	'Zend\Mvc\Plugin\FlashMessenger',
	'Zend\Mvc\Plugin\FilePrg',
	'Zend\Form',
	'Zend\Router',
	'Zend\Validator',
	'Application',
];

The application module is a module containing your app's files. All other modules listed are ZF components.

in ZF3, a special composer plugin called component installer was introduced. If you remember since before,
from installing the Skeleton, we answered yes and no to several options. The ones we answered yes to, it injected
thoose components' module names, here, in modules.config.php

Application-Level Extra Config Files:

"Extra" config files, APP_DIR/config/autoload/global.php and APP_DIR/config/autoload/local.php files,
define application-wide environment-agnostic and environment-dependant parameters, respectively.

What we mean by this, is basically that global applies to the entire application, local applies to the 
environment-dependant environment.

These config files are automatically loaded and recursively merged with the module-provided config files,
that's why their directory is named autoload.

Having different config files in APP_DIR/config/autoload directory, you might have been confused about 
which parameters should be put into each one. Here are some hints:

You use the autoload/global.php file for storing parameters which do not depend on the concrete machine environment.
For example, here you can store parameters which override the default parameters of some module.

Do not store sensitive information (like DB credentials) here, for that purpose it's better to use autoload/local.php

You use the autoload/local.php file for storing parameters specific to the concrete environment. For example, here you can
store your database credentials. Each developer usually has a local DB when developing and testing the site. The
developer thus will edit the local.php file and enter his own Db credentials here.

When you install your site to the production server, you will edit the local.php file and enter the credentials
for the "live" database here.

Because the autoload/local.php file contains environment-specific parameters, in version control system you
store it's "distribution template" local.php.dist. Each developer in your team then renames the local.php.dist
file into local.php and enters their own params.

This local.php file should not be stored under version control, because it may contain sensitive information
like database credentials (username and pw), and for security reasons we do not need to show that.

Application-Level Development Config File:

The application-level development configuration file (APP_DIR/config/development.config.php) presents only
when you enable the development mode. If you remember, we enabled it as follows:

php composer.phar development-enable

The development.config.php file is merged with the main application.config.php file. This allows you to
override some parameters. For example, you can:

diable config caching. When you develop your website, you frequently modify your config files, so config
caching may have undesired consequences, like inability to see the result of your changes immediately.

load additional modules. For example, you can load ZendDeveloperTools module only in development mode.

If we disable the development mode, the development.config.php file is removed. So you should not store
this file under version control. Instead, store it's distribution version, development.config.php.dist under
version control.

Application-Level Extra Development Config Files:

The application-level extra development configuration file (APP_DIR/config/autoload/development.local.php) presents 
only when you enable the development mode.

The development.local.php file is merged with other module-level config files. This allows you to override some
module-specific parameters used in development environment only.

If we disable development mode, the development.local.php file will be removed. So, you should not store this file
under the version control. Instead, store it's distribution version, development.local.php.dist under version control.

Module-Level Config Files:

Earlier, we could see that the Application module shipped with your application has the module.config.php file, in which
we put our module-specific parameters. Let's look at module.config.php file of the Application module:

<?php
namespace Application;

use Zend\Router\Http\Literal;
use Zend\Router\Http\Segment;
use Zend\ServiceManager\Factory\InvokableFactory;

return [
	'router' => [
		'routes' => [
			'home' => [
				'type' => Literal::class,
				'options' => [
					'route' 	=> '/',
					'defaults' => [
						'controller' => Controller\IndexController::class,
						'action' 	 => 'index',
					],
				],
			],
			'application' => [
				'type' 	  => Segment::class,
				'options' => [
					'route' 	=> '/application[/:action]',
					'defaults' 	=> [
						'controller' 	=> Controller\IndexController::class,
						'action' 		=> 'index',
					],
				],
			],
		],
	],
	'controllers' => [
		'factories' => [
			Controller\IndexController::class => InvokableFactory::class,
		],
	],
	'view_manager' => [
		'display_not_found_reason' 	=> true,
		'display_exceptions' 		=> true,
		'doctype' 					=> 'HTML5',
		'not_found_template' 		=> 'error/404',
		'exception_template' 		=> 'error/index',
		'template_map' 	=> [
			'layout/layout' 			=> __DIR__ . '/../view/layout/layout.phtml',
			'application/index/index'	=> __DIR__ . '/../view/application/index/index.phtml',
			'error/404' 				=> __DIR__ . '/../view/error/404.phtml',
			'error/index' 				=> __DIR__ . '/../view/error/index.phtml',
		],
		'template_path_stack' => [
			__DIR__ . '/../view',
		],
	],
];

In this file, you register the module's controllers, put information about routing rules for mapping URLs to your controllers,
register controller plugins and register view templates and view helpers (we will learn more about these things in this chapter
and the next ones)

Combining the Configuration Files:

When an application is being created, module-provided configuration files and extra configuration files from APP_DIR/config/autoload
directory are being merged into one big nested array, so every configuration parameter becomes available to any piece of the website.

So, potentionally, you are able to override some parameters defined by the modules.

You might also have seen the "combined" config file when installing PHP, where there is the main php.ini file
and several extra config files, which are included into the main one.

Such a seperation makes your application configuration fine-grained and flexible, because you don't have to put all your params
to a single file and edit it each time you need to change something.

The configuration files are loaded in the following order:

1. The main application.config.php file is loaded first. It is used to initialize the service manager and load application modules.
The data loaded from this config is stored alone and not merged with other config files.

2. Configuration files for each application module are loaded and merged. Modules are loaded in the same order as 
they are listed in the application.config.php file. If two modules store (either intentionally, or by mistake) parameters
in the similar-named keys, these parameters may be overwritten.

3. Extra config files from the APP_DIR/config/autoload folder, are loaded and merged into a single array. Then this
array is merged with the module config array produced on the previous stage, when loading the module configuration.

Application-wide configuration has higher priority than the module configuration, so you can override module keys here,
if you wish.

Module Entry Point:

In ZF3, your web application consists of modules. By default, you have the single Application module, but can
create more if needed.

Typically, your own modules are stoped in APP_DIR/module directory, while third-party modules live in APP_DIR/vendor 
directory.

On start up, when the Zend\Mvc\Application object is created, it uses the Zend\ModuleManager component to find
and load all modules registered in application config.

Each module of the web application has the Module.php file which is some kind of entry point for the module.
This file provides the Module class. Below, the contents of skeleton application's Module class is presented.

<?php
namespace Application;

class Module
{
	public function getConfig()
	{
		return include __DIR__ . '/../config/module.config.php';
	}
}

The class module belongs to the module's namespace (for the main module it belongs to the Application namespace).

The getConfig() is typically used to provide module's configuration to ZF (module.config.php file)

We can also register some event listeners here, we'll see how to do this later in Creating a New Module chap.

The Module::getConfig() returns an array created in module.config.php

And it is here, we can combine production config (module.config.php) with local/environment dependent
config and achieve the same situation as in the previous chapter, for example:

//Global config
$module = include __DIR__ . '/../config/module.config.php';

//Local config
$local = include __DIR__ . '/../config/local.config.php';

//return result
return = array_merge($module, $local);

Service Manager:

You can imagine the web application as a set of services. For example, you can have an authentication service responsible
for logging in the site users, entity manager service responsible for accessing the DB, event manager service responsible
for triggering events and delivering them to the event listeners, etc.

In ZF, the ServiceManager class is a centralized container for all application services. The service manager is implemented
in Zend\ServiceManager component, as the ServiceManager class. Class inheritance diagram is shown as:

Interop\Container\ContainerInterface
				^
				^
				^
Zend\ServiceManager\ServiceLocatorInterface
				^
				^
				^
	Zend\ServiceManager\ServiceManager

The service manager is created on application start up (inside of init() static method of Zend\Mvc\Application class).
The standard services available through service manager are presented in table 3.1. This table is is partial:

Service Name 											Desc

Application 			Allows to retrieve the singleton of Zend\Mvc\Application class

ApplicationConfig 		Configuration Array extracted from application.config.php file

Config 					Merged configuration array extracted from module.config.php files merged 
						autoload/global.php and autoload/local.php

EventManager 			Allows to retrieve a new instance of Zend\EventManger\EventManager class. The event manager
						allows to send (trigger) events and attach event listeners.

SharedEventManager 		Allows to retrieve the singleton instance of Zend\EventManager\SharedEventManager class.
						The shared event manager allows to listen to events defined by other classes and components.

ModuleManager 			Allows to retrieve the singleton of Zend\ModuleManager\ModuleManager class. The module manager is
						responsible for loading application modules.

Request 				The singleton of Zend\Http\Request class. Represents HTTP request received from client.

Response 				The singleton of Zend\Http\Response class. Represents HTTP response that will be sent to client.

Router 					The singleton of Zend\Router\Http\TreeRouteStack. Performs URL routing.

ServiceManager 			Service manager itself.

ViewManager 			The singleton of Zend\Mvc\View\Http\ViewManager class. Responsible for preparing the view layer
						for page rendering.

A service is typically an arbitrary PHP class, but not always. For example, when ZF3 loads the configuration files
and merges the data into nested arrays,it saves the arrays in the service manager as a couple of services:

ApplicationConfig 

and

Config

The first one is the array loaded from application-level configuration file application.config.php and later one
is the merged array from module-level config files and auto-loaded application-level config files.

Thus, in the service manager you can store anything you want: a PHP class, a simple variable or an array.

From table 3.1, you can see that in ZF3 almost everything can be considered as a service. The service manager
is itself registered as a service. Moreover, the Application class is also registered as a service.

An important thing you should note about the services is that they are typically stored in a single instance only
(this is also called the singleton pattern). Obviously, you don't need the second instance of the Application
class.

But there is an important exception from the rule above. It may be confusing at first, but the EventManger 
is not a singleton. Each time you retrieve the event manager service from service manager, you receive
a new object.

This is done for performance reasons and to avoid possible event conflicts between different components. We will
discuss this further in the About Event Manager section later, here.

The service manager defines several methods needed for locating and retrieving a service from the service
manager:

Method name 					Desc

has($name) 				Checks if such a service is registered

get($name) 				Retrieves a registered service's instance.

build($name, $options) 	Always returns a new instance of the requested service.

We can test if a service is registered by passing its name to the service manager's has()
method. It returns a boolean true if the service is registered, or false if the service
with such a name is not registered.

You can retrieve a service by its name later with the help of the service manager's get()
method. This method takes a single parameter representing the service name.

An example:

<?php

//Retrieve the application config array.
$appConfig = $serviceManager->get('ApplicationConfig');

//Use it (for example, retrieve the module list)
$modules = $appConfig['modules'];

And the build() always creates a new one, unlike the get(), which typically makes
one only once, and typically returns it later.

You will typically retrieve services from service manager not in any place of your code,
but inside of a factory. A factory is a code responsible for creation of an object.

When creating the object, you can retrieve services it depends on from the service manager
and pass those services (dependencies) to the object's constructor. This is what we call,
dependency injection.

In ZF3, we have to pass dependencies explicitly. 

Registering a Service:

When we make services, we often need to register them ourselves with the service manager.
One of the ways to do this, is by virtue of setService() of the service manager.

For example, let's create and register the currency converter service class, which will
be used, for example, on a shopping cart page to convert from EUR to USD:

<?php
//Define a namespace where our custom service lives.
namespace Application\Service;

//Define a currency converter service class
class CurrencyConverter
{
	public function convertEURtoUSD($amount)
	{
		return $amount*1.25;
	}
}

Then to set the service we:

//Create an instance of the class:
$service = new CurrencyConverter();
//Save the instance to service manager.
$serviceManager->setService(CurrencyConverter::class, $service);

NOTE: We assume the serviceManager is of the type Zend\ServiceManager\ServiceManager and was declared somewher else

The setService has two params, the class name and the service instance. The name should be unique within all
other possible services.

Once the service is stored in service manager, you can retrieve it by name at any place of your application
with the help of the service manager's get() method. An example:

<?php
//retrieve the currency converter service
$service = $serviceManager->get(CurrencyConverter::class);

//use it 
$convertedAmount = $service->convertEURtoUSD(50);

Service Names:

Different services use different names. By virtue of saving by fully qualified class name, as follows:

$serviceManager->setService(CurrencyConverter::class);

In this example, we used the keyword class, which when used with a class, expands to the fully qualified name of the class.
Which, in this case, would be: \Application\Service\CurrencyConverter 

Overriding an Existing Service:

If you are trying to register the service name which is already present, the setService() method will throw an exception.
But sometimes, we want to override services.

For this purpose, we can use setAllowOverride(), as follows:

<?php
//Allow to replace services
$serviceManager->setAllowOverride(true);

//Save the instance to service manager. There will be no exception
// even if there is another service with such a name
$serviceManager->setService(CurrencyConverter::class, $service);

The setAllowOverride just takes a boolean and sets the allowed override status there after.

Registering Invokable Classes:

What is bad with the setService() method, is that you have to create the service instance before you really need it.
If we never need to use it, the service instansiation goes to waste on resources.

To resolve it, the service manager provides us with the setInvokableClass() method:

<?php
// Register an invokable class
$serviceManager->setInvokableClass(CurrencyConverter::class);

In the example above, we pass to the service manager the fully qualified class name of the service
instead of passing it's instnace. 

This does so the service manager only loads it when someone calls it with get(CurrenConverter::class).
This is what we refer to as when we talk about lazy loading.

Services often depend on each other. For example, the currency converter service may use entity manager
service to read money exchange rates from the DB.

The disadvantage of setInvokableClass() is that it does not allow to pass params (dependencies) to
the service on object instansiation. To resolve this, we can use factories.

Registering a Factory:

A factory, is a class that can do one thing: Spawn other objects.

We register a factory for a service with the setFactory() method of the service manager.

The simplest factory is InvokableFactory - it is analogous to the setInvokableClass() method:

<?php
use Zend\ServiceManager\Factory\InvokableFactory;

//This is equivilant to the setInvokableClass() method from the previous section
$serviceManager->setFactory(CurrencyConverter::class, InvokableFactory::class);

After you registered the factory you can retrieve the service from service manager 
as usual with the get() method. The service will be instansiated only when you retrieve
it from service manager (lazy loading).

Sometimes, service instansiation is more complex than just creating the service instance 
with new operator (like InvokableFactory does). You may need to pass some parameters
to the service's constructor or invoke some service methods just after construction.

We can resolve this by creating our own factory. Factories implement the FactoryInterface.

<?php
namespace Zend\ServiceManager\Factory;

use Interop\Container\ContainerInterface;

interface FactoryInterface
{
	public function __invoke(ContainerInterface $container,
						$requestedName, array $options = null);
}

As we see from the definition of the FactoryInterface, the factory class must provide the __invoke
magic method returning the instance of a single service. 

The service manager is passed to the __invoke method as the $container parameter; it can be used 
during the construction of the service for accessing other services (to inject dependencies).

The second argument, $requestedName, is the service name. The third argument, $options, can be
used to pass some parameters to the service, and is used only when you request the service with
the build() method of the service manager.

As an example, let's write a factory for our currency converter service (see the code below).
We don't use complex construction logic for our CurrencyConverter service, but for more complex services,
we might need to do so.

<?php
use Zend\ServiceManager\Factory\FactoryInterface;
use Application\Service\CurrencyConverter;

//Factory class
class CurrencyConverterFactory implements FactoryInterface
{
	public function __invoke(ContainerInterface $container, $requestedName,
					array $options = null)
	{
		//Create an instance of the class.
		$service = new CurrencyConverter();

		return $service;
	}
}

Technically, in ZF3, we can instansiate several services with the same factory. However,
MOSTLY, we create a different factory per each service.

Registering an Abstract Factory:

Even more complex case of a factory is when you need to determine at run time which service names should be 
registered. For such a situation, you can use an abstract factory. An abstract factory class should implement
the AbstractFactoryInterface interface:

<?php
namespace Zend\ServiceManager\Factory;

use Interop\Container\ContainerInterface;

interface AbstractFactoryInterface extends FactoryInterface
{
	public function canCreate(ContainerInterface $container, $requestedName);
}

An abstract factory has two methods: canCreate() and __invoke(). The first one is needed
to test if the factory can create the service with the certain name, and the latter one allows
to actually create the service.

The methods take two parameters: service manager ($container) and service name ($requestedName)

Comparing to usual factory class, the difference is that the usual factory class typically creates
only a single type of service, but an abstract factory can dynamically create as many types of 
services as it wants.

You register an abstract factory with the setAbstractFactory() method of the service manager.

Abstract factories are a powerful feature, but you should use them only when really nessecary,
because they negatively impact performance. It is better to use the usual (non-abstract) factories.

Registering Service Aliases:

Sometimes, we may want to have aliases for a service. The alias is like a symbolic link, it references
the already registered service. To create one, you use the service manager's setAlias() method:

<?php
//Register an alias for the CurrencyConverter service
$serviceManager->setAlias('CurConv', CurrencyConverter::class);

Once registered, we can retrieve the service by both name and alias, using the service manager's get()
method.

Shared and Non-Shared Services:

By default, services are stored in service manager in single instance only. This is as we call it, the Singleton design pattern.
For example, when you try to retrieve the CurrencyConverter service twice, you will receive the same object.

We also call this, shared service.

But in some cases, albeit rare, we will need to create a new instance of a service each time someone requests it
from the service manager. An example is the EventManager - You get a new instance of it every time you request it.

To mark a service as a non-shared, you can use service manager's setShared() method:

$serviceManager->setShared('EventManager', false);

Service Manager Configuration:

In your website, you typically use service manager configuration to register your services (instead of calling service
manager's methods as described above).

To automatically register a service within the service manager, typically the service_manager key of a configuration file
is used. You can put this key either inside of an application-level configuration file or in a module-level configuration
file.

If you are putting this key in a module-level configuration file, be careful about the danger of name overwriting 
during the configs merge. Do not register the same service name in different modules.

This service_manager key should look like below:

<?php
return [
	//...

	//Register the services under this key
	'service_manager' => [
		'services' => [
			//register service classes instances here
		],
		'invokables' => [
			//Register invokable classes here
		],
		'factories' => [
			//Register factories here
		],
		'abstract_factories' => [
			//register abstract factories here
		],
		'aliases' => [
			//register service aliases here
		],
		'shared' => [
			//Specify here which services must be non-shared
		]
	],

	//...
];

The services subkey, allows to register class instances,

the invokables subkey allows to register full class name of a service; the service will be instansiated using lazy loading.

the factories subkey allows for registering a factory, which is able to create instances of a single service.

the abstract_factories can be used for registering abstract factories, which are able to register several services by name.

the aliases subkey provides an ability to register an alias for a service.

the shared subkey allows to specify which services must be non-shared.

As an example, let's register our CurrencyConverter service and create an 
alias for it:

<?php
use Zend\ServiceManager\Factory\InvokableFactory;
use Application\Service\CurrencyConverter;

return [
	//...

	// Register the services under this key
	'service_manager' => [
		'factories' => [
			//Register CurrencyConverer service
			CurrencyConverter::class => InvokableFactory::class
		],
		'aliases' => [
			//register an alias for the CurrencyConverter service.
			'CurConv' => CurrencyConverter::class
		],
	],

	//...
];

Plugin Managers:

Now that you understand what service manager is, it should not be very difficult for you to learn
the concept of plugin managers. A plugin manager is almost the same as the service manager, but it can
instansiate services of the single type only.

Which plugin type a plugin manager may instansiate is hard-coded inside the plugin manager class.

Why would you need such a thing? Actually, in ZF3, plugin managers are widely used, because they allow
to instansiate a plugin only when it is needed (this reduces CPU and memory usage). There is a separate 
plugin manager for:

controllers (the Zend\Mvc\Controller\ControllerManager class)

controller plugins (the Zend\Mvc\Controller\PluginManager class)

view helpers (the Zend\View\HelperPluginManager class)

form elements (the Zend\Form\FormElementManager\FormElementManagerV3PolyFill class)

filters (the Zend\Filter\FilterPluginManager class)

validators (the Zend\Validator\ValidatorPluginManager class)

and probably more.

The fact that each plugin manager inherits from the Zend\ServiceManager\ServiceManager base class allows
all plugin managers to have similar configuration.

For example, controllers are registered under the controllers key in the module.config.php file, and this key
may have the same subkeys: services, invokables, factories, abstract_factories and aliases.

The same structure has the view_helpers key that is used for registering view helpers, the controller_plugins key
that is used for registering controller plugins, and so on.

About Event Manager:

In this section, we will give some advanced information about event manager. You can skip this section,
however refer to it if you plan to implement some advanced event listeners in your website.

Previously in this chapter, we have mentioned that the application life cycle consists of events. One class
can trigger an event, and other classes may listen to events. Technically, triggering an event means just
calling another class' "callback" method.

The event management is implemented inside of the Zend\EventManager component.

ZF3 (and particularly it's Zend\Mvc component) hardly depends on events to operate, and because of that
its source code is a combination of event listenrs which is rather difficult to understand.

Fortunately, in most cases, you do not need to understand how ZF3 triggers and handles events internally,
you just need to understand what event is, what events present in application life cycle and what is the
difference between usual event manager and shared event manager.

Event & MvcEvent:

An event, is technically an instnace of the Zend\EventManager\Event class. An event can basically have
at least the following parts:

name - uniquely identifies the event,

target - this is typically a pointer to the object which triggered the event,

params - event-specific arguments passed to the event listeners.

It is possible to create custom types of events by extending the Event class. For example, the Zend\Mvc component
defines the custom event type named Zend\Mvc\MvcEvent, which extends the Event class and adds several properties
and methods needed for the Zend\Mvc component to work.

EventManager & SharedEventManager:

It is important to understand the difference between these two.

The usual event manager is not stored as a singleton in the service manager. Every time you request
the EventManager service from the service manager, you receive a new isntance of it. This is done for
privacy and performance reasons:

1. It is assumed by default that the class triggering events will request and save somewhere it's own private event
manager, beause it does not want other classes to automatically listen to those events. Events triggered by the class
are assumed to belong to that class privately.

2. If anyone would be able to listen to any event tirggered by any class, there would be performance issues.
Too many event listenrs would be invoked, thus increasing page load time. It is better to keep it to singletons.

but, in case if someone intentionally NEEDS to listen to other's events, there is a special shared event manager.
The SharedEventManager service is stored in the service manager as a singleton, so you can be sure everyone will have
the same instnace of it.

With the SharedEventManager, you can attach a listener to private events triggered by certain class (or several classes).
You specify the unique class identifiers to which to listen to.

Some practical examples of how to listen to and react to events can be found in Creating a New Module chapter and
User Management, Authentication & Access Filtering chapter.

ZF3 uses PHP namespaces and class autoloading features, simplifying the development of applications which uses
many third-party components. The namespaces allow to solve the name collisions between code components, and provide
you with the ability to make the long names shorter.

The class autoloading makes it possible to use any PHP class in any library installed with Composer without the use
of require_once statements. Composer also provides a PSR-4 autoloader for the classes located in the modules of
your web app.

Most of ZF 3 components require configuration. You can define the configuration parameters either at the application
level, or at the module level.

The main goal of any web application is handling the HTTP request and producing an HTTP response typically containing
the HTML code of the requested web page. When Apache web server receives an HTTP request from a client browser,
it executes the index.php file, which is also called the site's entry script.

On every HTTP request, the Zend\Mvc\Application object is created, whose "Life cycle" consists of several
stages (or events).

The web application's business logic can also be considered as a set of services. In ZF3, the service manager 
is a centralized container for all the application services. A service is typically a PHP class, but in general it
can be a variable or an array, if needed.

Model-View-Controller:

In this chapter, we will learn about the models, views and controllers (the MVC design pattern).
A web application uses the MVC pattern to separate business logic from presentation.

The goal of this is to allow for code reusability and separation of concerns.

ZF3 Components covered here:

Component 				Desc

Zend\Mvc 			Support of MVC pattern. Implements base controller classes, controller plugins, etc.

Zend\View 			Implements the functionality for variable containers, rendering a web page and common view helpers.

Zend\Http 			Implements a wrapper around HTTP request and response

Get the Hello World Example from Github:

https://github.com/olegkrivstov/using-zf3-book-samples

Here, we will find the concrete example that most of the following chapters will build upon.

The Hello World is a complete website which can be installed on our machine. To install the example, 
either edit the default Apache Virtual host file or create a new one.

After editing, restart the Apache HTTP Server and open the website in your web browser.

Separating Business Logic from Presentation:

A typical website has three kinds of functionality: code implementing business logic, code implementing user interaction
and code rendering HTML pages (presentation). Before PHP frameworks, programmers usually merged these three types of 
code in a single big PHP script file. 

Which made it a pain to test and maintain such code, especially when you write a large website.

Since that time, PHP became object-oriented, and now you can organize stuff into classes. The Model-View-Controller
(MVC) is just a recommendation of how to sort code ,to make it easier to maintain.

In MVC, classes implementing your business logic are called models, code snippets rendering HTML pages are called views,
and the classes responsible for interacting with user are called controllers.

Views are implemented as code snippets, not as classes. This is because views are very simple and contain
only a mix of HTML and inline PHP code.

The main objective of the MVC concept is to separate the business logic (models) from it's visualization (views).
This is also called the separation of concerns, when each layer does it's specific task only.

By separating your models from views, you reduce the number of dependencies between them.

Therefore, changes made to one of the layers have the lowest impact on the others. This separation also
improves code reusability. For example, you can create multiple visual representations for the same models (Changable themes)

To better understand how this works, let's remember that any website is just a PHP program receiving an HTTP request
from the web server, and producing a HTTP response. 

A figure explains, how a HTTP request is processed by the MVC app and how the response is generated:

														Browser
1. HTTP request is Received, URL http://localhost			V ^
															V ^ 12. HTTP response is sent to client browser over the Internet
															V ^ 
															V ^
													Apache HTTP Server
													V 				^ 
													V 				^ 	11. HTTP response is returned to web server
				2.	index.php script is executed <Entry Script> 	^
													v 				^
													v 				^
			3. Application instnace is created 	   <	Application 	>
													V  		 ^
													V 		 ^
			4. Router parses the URL and looks for 	V 		 ^
			controller that is assigned to this URL V 		 ^
													V 		 ^
												< Router > 	 ^ 10. Controller returns the data to application
													V 		 ^
													V   	 ^
	5. Controller's action method extracts request  V  		 ^
	parameters, instansiates needed models and mani-V        ^
	pulates them								< Controller >
									<<<<<<<<<<<<<<< 		V	<<<<<<<<<<<<<
									V 7. Controller passes 	V				v 9. View produces HTML output
									V models to rendering	V				v 
	6. Model performs task specific <Model> 				>>>>>>>>>>>>>>>< View >
	to app business-logics domain 		<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
												8. View may use models to retrieve needed data

First a website visitor enters a URL in his/her web browser, for example http://localhost, and the web browser
sends the request to the web server over the Internet.

Web server's PHP engine runs the index.php entry script. The only thing the entry script does is creating the 
Zend\Mvc\Application class instance.

The application uses its router component for parsing the URL and determining to which controller to pass the 
request. If the route match is found, the controller is instansiated and its appropiate action method is called.

In the controller's action method, parameters are retrieved from GET and POST variables. To process the incoming
data, the controller instansiates appropiate model classes and calls their methods.

Model classes use business logic algorithms to process the input data and return the output data. The business logic
algorithms are application-specific, and typically include retrieving data from database, managing files, interacting
with external systems and so on.

The result of calling the models are passed to the corresponding view script for the rendering of the HTML page.

View script uses the model-provided data for rendering the HTML page.

Controller passes the resulting HTTP response to application.

Web server returns the resulting HTML web page to the user's web browser.

The user sees the page in browser window.

Now, you might have some idea of how models, views and controllers cooperate to generate HTML output.
In the next sections, we describe them in more details.

Controllers:

A controller provides communication between the application, models and views: gets input from HTTP request and uses
the model(s) and the corresponding view to produce the necessary HTTP response.

Controllers belonging to module typically reside in the Controller subdir of module's source dir.

Zend Skeleton Application provides you with the default implementation of IndexController class. The IndexController
is typically the main controller class of the website. Its code is presented below (Some parts are omitted for simplicity):

<?php
namespace Application\Controller;

use Zend\Mvc\Controller\AbstractActionController;
use Zend\View\Model\ViewModel;

class IndexController extends AbstractActionController
{
	public function indexAction()
	{
		return new ViewModel();
	}
}

From the example above, we can see that we defien our own namespace the first thign we do.

The Index Controleler, as all other controllers from the Application module, lives in Application\Controller namespace.

A controller is a usual PHP class derived from the AbstractActionController.

By default, the controller class contains the single action method called indexAction(). Typically, you will create other
action methods in your controller classes.

ZF3 automatically recognizes the action methods by the Action suffix. If a controller method's name does not have that
suffix, it is considered a normal method, not an action.

As it's name assumes, an action method performs some site action, which typically results in producing a single web page.
Index controller usually contains action methods for site-wide web pages.

For example, you would have "index" action for the Home page, "about" action for About page, "contactUs" action for
the Contact Us page and possible other actions.

Action method 					Desc

IndexController::indexAction() 	The "index" action displays the Home page of your site

IndexController::aboutAction() 	The "about" action displays the About page of the site. The About page contains contact and
								copyright info.

IndexController::contactUsAction() The "contactUs" action displays the Contact Us page of the site. The Contact Us page displays
								the form for contacting site authors.

Base Controller Class:

Every controller in your website is inherited from the AbstractActionController base class. 

The AbstractActionController provides you with several useful methods you can use in your controller classes.
The following provides you with a brief summary of methods:

Method name 					Desc

getRequest() 				Retrieves the Zend\Http\Request object, which is the representation of HTTP request data.

getResponse() 				Retrieves the Zend\Http\PhpEnvironment\Response object allowing to set data of HTTP response

getEventManager() 			Returns the Zend\EventManager\EventManager object, allowing to trigger events and listen to events.

getEvent() 					Returns the Zend\Mvc\MvcEvent object, which represents the event the controller responds to

getPluginManager() 			Returns the Zend\Mvc\Controller\PluginManager object, which can be used for registering controller plugins

plugin($name, $options) 	This method allows to access certain controller plugin with the given name

__call($method, $params) 	Allows to call a plugin indirectly using the PHP __call magic method.

As we can see, the base controller gives us access to HTTP requests and response data, and provides us with the access
to the event manager. It also gives you an ability to register and call controller plugins (we will learn about controller
plugins later in this chapter)

Retrieving Data from HTTP Request:

In a controller's action method, we may need to retrieve the data from the HTTP request (the data like GET and POST variables,
cookies, HTTP headers and so on). For this purpose, ZF3 provides you with Zend\Http\Request class, which is part of Zend\Http
component.

To get the HTTP request object, inside of your action method, you can use the following code:

// Get the HTTP request object
$request = $this->getRequest();

The code above returns the instance of Zend\Http\Request class, containing all the HTTP request data. 
In the following table, we can find some of the most widely used ones:

Methods of Zend\Http\Request class:

Name 					desc

isGet() 				Checks if this is a GET request

isPost() 				Checks if this is a POST request

isXmlHttpRequest() 		Checks if this request is an AJAX request

isFlashRequest() 		Checks if this request is a Flash request

getMethod() 			Returns the method for this request

getUriString() 			Returns the URI for this request object as a string.

getQuery($name, $default) Returns the query parameter by name, or all query parameters. if a param is not found,
						returns the $default value

getPost($name, $default ) Returns the parameter container responsible for post parameters or a single post parameter

getCookie() 			Returns the Cookie header

getFiles($name, $default) Returns the parameter container responsible for file parameters or a single file.

getHeaders($name, 		Returns the header container responsible for headers or all headers of a certain name/type.
$default) 

getHeader($name, 		Returns a header by $name. If a header is not found, returns the $default value.
$default)

renderRequestLine() 	Returns the formatted request line (first line) for this HTTP request

fromString($string) 	A static method that produces a Request object from a well-formed Http Request String

toString() 				Returns the raw HTTP request as a string

Retrieving GET and POST Variables:

To simply get a GET or POST variable from an HTTP request, you use the following code:

//Get a variable from GET
$getVar = $this->params()->fromQuery('var_name', 'default_val');

//Get a variable from POST
$postVar = $this->params()->fromPost('var_name', 'default_val');

Here, we use the Params controller plugin, which provides us with the convinient methods of accessing 
GET and POST variables, uploaded files etc.

We also use fromQuery() for retrieving a variable having name "var_name" from GET. If such a variable
does not present, the default value 'default_val' is returned.

The default_val is handy, because that way we need not use isset() to check for existence of a variable.

We use fromPost() to retrieve the variable from POST. The meaning of this method's parameters is 
the same as for fromQuery.

In ZF3, we must not access request params through the superglobals $_GET and $_POST arrays. Instead,
use the ZF3 provided API methods.

Putting Data to HTTP Response:

Although you rarely interact with HTTP response data directly, you can do that with the help of getResponse() method
provided by the AbstractActionController base class. The getResponse() method returns the instance of Zend\Http\PhpEnvironment\Response
class.

The following table contains the most important methods of this class.

Methods of Zend\Http\PhpEnvironment\Response class:

Method name 							Desc

fromString($string)  			Populate response object from String

toString() 						Renders entire response as HTTP response string

setStatusCode($code) 			Sets HTTP status code and (optionally) message

getStatusCode() 				Retrieves HTTP status code

setReasonPhrase($reasonPhrase) 	Sets the HTTP status message

getReasonPhrase() 				Gets the HTTP status message

isForbidden() 					Checks if the response code is 403 forbidden

isNotFound() 					check if the status code indicates resource not found (404 code)

isOk() 							Checks wether the response is successful

isServerError() 				Checks against 5xx code.

isRedirect() 					Checks wether the response is 303 Redirect.

isSuccess() 					Checks wether the response is 200 Successful.

setHeaders(Headers $headers) 	Allows to set response headers.

getHeaders() 					Returns the list of response headers.

getCookie() 					Retrieves Cookie header.

setContent($value) 				Sets raw response content

getContent() 					Returns raw response content

getBody() 						Gets and decodes the content of the response

For example, use the following code to set 404 status code for the response:

$this->getResponse()->setStatusCode(404);

Use the following code to add a header to response:

$headers = $this->getResponse()->getHeaders();
$headers->addHeaderLine("Content-type: application/octet-stream");

Use the following code to set response content:

$this->getResponse()->setContent('Some content');

Variable Containers:

After you retrieved the data from the HTTP request, you would do something with that data (typically you will process
the data with your model layer) and return the data from the action method.

You can see that the indexAction() method of the index controller returns an instance of the ViewModel class.
The ViewModel class is a kind of a variable container. All variables sent to it's constructor will be accessible by the view script.

Let's have a real-life example. We will create another action method in our IndexController class, which we will call the
aboutAction(). The "about" action will display the About page of our site. In the action method, we will create two variables
containing information about the website, and return the variables for rendering in a view with the help of ViewModel object:

//The "about" action
public function aboutAction()
{
	$appName = 'HelloWorld';
	$appDescription = 'A sample application for the Using Zend Framework 3 book';

	//Return variables to view script with the help of ViewModel variable container
	return new ViewModel([
		'appName' => $appName,
		'appDescription' => $appDescription
	]);
}

In the above example, we create two variables as pass them in as associative arrays into the cosntructor of the ViewModel.

The ViewModel class provides several methods that you can additionaly use to set variables to ViewModel and retrieve variables 
from it. The following table provides the methods summary:

Methods of ViewModel class:

Method name 							Desc

getVariable($name, $default) 		Returns a variable by name (or default if the variable does not exist)

setVariable($name, $value) 			Sets a variable

setVariables($variables, $overwrite) Sets a group of variables, optionally overwriting the existing ones.

getVariables() 						Returns all variables as an array

clearVariables() 					Removes all variables

Expressing Error Conditions:

Sometimes things go wrong and some error occurs. For example, you expect to receive a GET variable from HTTP request,
but it is missing or has an invalid value. 

To express this error condition, you typically set 4xx status code in HTTP response and return from controller's action.

For example, in a blog app, assume a User enters the following URL in his browser's navigation bar: http://localhost/posts/view?id=10000
The intention of such a request is to find the blog post with id = 10000. It does not exist.

Thus, we do as follows:

//The "view" action displays a blog post with a given ID
public function viewAction()
{
	//Get ID argument from GET, if it exists, get it, otherwise default to -1
	$id = (int)$this->params()->fromQuery('id', -1);

	//Validate the argument
	if ($id<1){
		//Error condition - there is no such post
		$this->getResponse()->setStatusCode(404);
		return;
	}

	//Try to find the post (we omit the SQL query for simplicity)
	$post = ...
	if (!$post){ //We did not find the thing in the SQL
		//Error condition post not found
		$this->getResponse()->setStatusCode(404);
		return;
	}

	//Normal execution
	// ...
}

When ZF3 encounters an error page, it redirects to a special error page. We will talk about error pages
later in this chapter.

Another way to express a critical error condition is to throw an exception:

throw new \Exception("Post with ID=$id could not be found!");

When ZF3 encounters uncaught exceptions, it displays another error page with the information about the exception.

Controller Registration:

All controller classes belonging to a module should be registered in the module.config.php configuration file.
If your controller class does not need to use some services (does not have dependencies), you can register it as follows:

<?php
use Zend\ServiceManager\Factory\InvokableFactory;

return [
	//...

	'controllers' => [
		'factories' => [
			Controller\IndexController::class => InvokableFactory::class
			//Put other controllers registration here
		],
	],

	// ...
];

Here, we have the controllers key which has the factories subkey. We then add the Controller class fully qualifying name 
(by virtue of ::class) and then accompany that with the factory to which we wish to use for it.

The standard factory to use is the InvokableFactory, but we could make our own if we want.

By using the InvokableFactory, you tell ZF that it can invoke the controller by instansiating it with the new
operator. This is the most simple way of instansiating the controller. As an alternative, you can register
your own factory to create the controller instnace, and inject dependencies into the controller.

Registering a Controller Factory:

If your controller class needs to call some service (this happens very often), you need to request that service from
the service manager, and pass that service to controller's constructor and the controller saves the service
you passed in a private property for internal usage (dependency injection)

This procedure is usually done within a factory class. For example, assume our controller class needs to use some
CurrencyConverter service which will convert money from USD to EUR. 

The factory class would look as follows:

<?php
namespace Application\Controller\Factory;

use Zend\ServiceManager\Factory\FactoryInterface;
use Application\Service\CurrencyConverter;
use Application\Controller\IndexController;
use Interop\Container\ContainerInterface;

//Factory class
class IndexControllerFactory implements FactoryInterface
{
	public function __invoke(ContainerInterface $container,
					 $requestedName, array $options = null)
	{
		//get the instance of CurrencyConverter service from the service manager
		$currencyConverter = $container->get(CurrencyConverter::class);

		//Create an instance of the controller and pass the dependency 
		// to controller's constructor
		return new IndexController($currencyConverter);
	}
}

Then we register the controller with our newly written factory:

<?php
return [
	//...

	'controllers' => [
		'factories' => [
			Controller\IndexController::class => Controller\Factory\IndexControllerFactory::class
		],
	],

	//...
];

LazyControllerAbstractFactory:

Writing a factory for every controller class can be a PITA. We can use the LazyControllerAbstractFactory instead.

The LazyControllerAbstractFactory uses reflection to determine which services your controller wants to use.
You just need to typehint the arguments of controller's constructor and the factory will itself retrieve 
the needed services and pass it to the constructor.

For example, to inject the CurrencyConverter service in your controller, make sure it's constructor looks like below:

namespace Application\Controller;

use Application\Service\CurrencyConverter;

class IndexController extends AbstractActionController
{
	//here we will save the service for internal use
	private $currencyConverter;

	//Typehint the arguments of constructor to get the dependencies
	public function __construct(CurrencyConverter $currencyConverter)
	{
		$this->currencyConverter = $currencyConverter;
	}
}

Then we register the controller the same way, but specify the LazyControllerAbstractionFactory factory:

<?php
use Zend\Mvc\Controller\LazyControllerAbstractFactory;

return [
	//...

	'controllers' => [
		'factories' => [
			Controller\IndexController::class => LazyControllerAbstractFactory::class
		],
	],

	//...
];

When to create a new controller?:

When your site grows in size, you should create new controller classes instead of putting all actions to IndexController.
The Index controller is used for defining the actions which work for your entire site.

It is not recommended to create huge controllers with hundreds of actions, because they are unwieldy.

It is recommended to create new controller classes for each model (or for most important ones) of your business logic
domain.

For example, you can create UserController to manage users of your site. This controller would have the default "index"
action for displaying the page with all users, "add" action for adding a new user, "edit" action for editing user's profile
and "delete" for deleting the user.

By analogy, you would create PurchaseController and it's actions to manage the purchase of your products and implementing
the shopping cart, DownloadController and its actions to manage file downloads for the site, etc.

Controller Plugins:

A controller plugin is a class which extends the functionality of all controllers in some way.

Without plugins, to extend the functionality of all controllers, you would have to create a custom base class,
say BaseController and derive all other controllers from that base class.

This way can also be used, but from ZF3 creators point of view, plugins are a better solution, because they use
class composition, which provides better flexibility comparing to class inheritance.

You register your plugin controller and it automatically becomes accessible from all controllers of your app
(AbstractActionController base class uses PHP's __call() magic method to proxy calls to registered controller plugins).

Composition, is a "has-a" relationship between two classes. The owner class keeps a reference to another class (plugin).
The owner is responsible for the lifetime of the object it holds.

There are several standard controller plugins available out of the box, and we've already used one of them (the Params plugin)
in one of our previous examples:

Standard Controller Plugins:

Standard Plugin Class 							Description

Params 							Allows to retrieve variables from HTTP request, including GET and POST variables.

Url 							Allows to generate absolute or relative URLs from inside controllers.

Layout 							Given access to layout view model for passing data to layout template

Identity 						Returns the identity of the user who has logged into the website.

FlashMessenger 					Allows to define "flash" messages which are stored in session and can be displayed on a different web page

Redirect 						Allows to redirect the request to another controller's action method

PostRedirectGet 				Redirects the POST request, converting all POST variables to GET ones.

FilePostRedirectGet 			Redirects the POST request, preserving uploaded files.

Inside of the controller's action method, you access a plugin in the following way:

//Access url plugin
$urlPlugin = $this->url();

//Access layout plugin
$layoutPlugin = $this->layout();

//Access redirect plugin
$redirectPlugin = $this->redirect();

As an alternative, we can invoke a plugin by it's fully qualified name with the plugin() method provided by the base controller
class, as follows:

use Zend\Mvc\Controller\Plugin\Url;

//inside your controller's action use the plugin() method
$urlPlugin = $this->plugin(Url::class);

Writing our own Controller Plugin:

In your websites, you most likely need to create custom controller plugins. For example, assume you need that all
your controller classes to be able to check wether a site user is allowed to access certain controller actions.

This can be implemented with the AccessPlugin class.

The controller plugin should be derived from the AbstractPlugin class. Plugins typically live in their own namespace
Plugin, which is nested in Controller namespace:

<?php
namespace Application\Controller\Plugin;

use Zend\Mvc\Controller\Plugin\AbstractPlugin;

//plugin class
class AccessPlugin extends AbstractPlugin
{
	//Thsi method checks wether user is allowed
	// to visit the page
	public function checkAccess($actionName)
	{
		//...
	}
}

To let ZF3 know about the plugin, we register it in the module.config.php under the controller_plugins key:

<?php
return [
	//...

	'controller_plugins' => [
		'factories' => [
			Controller\Plugin\AccessPlugin::class => InvokableFactory::class,
		],
		'aliases' => [
			'access' => Controller\Plugin\AccessPlugin::class,
		]
	],

	//...
];

We also register a alias for the plugin by its short name.

After htat, we will be able to access our custom plguin from all of our controller's actions in this way:

//Check if site used is allowed to visit the "index" page
$isAllowed = $this->access()->checkAccess('index');

Views:

Views belong to the presentation layer of the web application, because their goal is to produce HTML output returned by
the web server to site visitors.

In ZF3, you implement a view as a template file, which is a file having .phtml extension ("phtml" stands for PHP+HTML).
View templates have such a name because they usually contain HTML code mixed with PHP code snippets used for rendering
the web pages.

Views typically live inside of the view subdir of the module:

>data
vmodule
	vApplication
		>config
		>src
		>test
		vview
			vapplication
				vindex
					index.phtml
		>error
		>layout
>public
>vendor

Why are view template files not stored under module's source directory?

View templates (.phtml files) are not stored under module's src/ dir, because they are not usual PHP classes
and do not need to be resolved by a PHP class autoloading feature. View templates are resolved by the special
ZF3 class called view resolver, and for this reason, view templates are stored under the module's view directory.

View templates can have different behaviors, based on variables you pass to them from the controller's action method.
Data is passed to view templates with the help of a ViewModel variable container.

For example, let's implement the view template for the aboutAction() of our Index controller. 
The About page will display the title and some information about our Hello World application.

To create the view template file, in your Netbeans window, navigate to view/application/index directory and right
click on the "index" directory name. From the context menu, select new PHP file.

In the name creation, call it about.phtml.

In it, we enter the following:

<h1>About</h1>

<p>
	The Hello World application.
</p>

<p>
	Application name: <?= $this->escapeHtml($appName); ?>
</p>

<p>
	Application description: <?= $this->escapeHtml($appDescription); ?>
</p>

As you can see, the view template is a usual HTML page with several PHP code fragments.
A view script just renders the data you pass to it with a ViewModel variable container.

for example, we get the $appName and print it out into the standard output stream.

Inside the view template, you can easily access the variables that were passed from the controller's action.

For example, to aquire the value of the application name variable, use either $appName or $this->appName syntax.
They are equivilant, but the first takes less writing, so we will use that.

Please note that we are using EscapeHtml view helper to escape the String printed to the web page to make the
website resistant to hacker attacks.

You should always escape variables that you print to your web page. Escaping allows to be sure that no malicious
code is injected on your page.

In your view script, you can also use simple flow control operations (like if, foreach, switch) to make the appearance
of the page differentiate depending on variable values.

Now if you were to go to the page, we would find what we come to expect.

In general, the PHP code you used inside of views must be as simple as possible. Views typically do not
modify the data you pass from controller. For example, a view can use the model you pass to it to walk through
database table rows and render the items to an HTML page, but it should never create DB tables or modify them itself.

View Helpers:

A view helper is typically a (relativily) simple PHP class whose goal is to render some part of a view.
You can invoke view helpers from any view template. With view helpers, you can create reusable widgets (like menus,
navigation bars, etc.) for your web pages.

View helpers are analogous to controller plugins: the controller plugins allow to "extend" the functionallity
of controllers, and view helpers allow to "extend" the functionality of view templates.

ZF3 provides many standard view helpers out of the box. Some of them follows:

Standard View Helpers:

Standard Plugin Class 							Desc

BasePath 						Allows to retrieve the base path to the web app, which is the absolute path to APP_DIR

Url 							Allows to generate absolute or relative URL addresses from inside view templates.

ServeUrl 						Retrieves the current request's URL

Doctype 						Helper for setting and retrieving the doctype HTML element of the web page.

PageTitle 						Helper for setting the title HTML element of the web page

HtmlList 						Helper for generating ordered and unordered HTML lists

ViewModel 						Helper for storing and retrieving the view model

Layout 							Retrieves the layout template view

Partial 						Allows to render a "partial" view template

InlineScript 					Helper for setting and retrieving script elements for inclusion in HTML body section.

Identity 						View helper to retrieve the authenticated user's identity

FlashMessenger 					Allows to retrieve the "flash" messages stored in session

EscapeHtml 						Allows to escape a variable outputted to a web page.

To demonstrate the usage of a view helper, below we will show how to set a title for a web page. Typically,
it is required to give a different title per each web page.

You can do this with the HeadTitle view helper. For example, you can set the title for the About page by adding 
the following PHP code in the beginning of the about.phtml view template:


<?php
$this->headTitle('About');
?>

In the above example, we call the headTitle helper with the argument of about, setting the headTitle to be about.

We will discuss the view helpers in more details and provide more usage examples in the chapter Page Appearance and Layout.

View Template Names:

When you return data with the ViewModel variable container from your controller's action method, Zend Framework
somehow knows the name of the corresponding view template file. For example for your IndexController's aboutAction() method,
ZF3 automatically uses the about.phtml view template.

ZF3 determines the correct view template name by module name, controller name and action name. For example,
IndexController::aboutAction() action belonging to Application module will have the application/index/about.phtml
view template by default.

If your controller or action name consists of several words in camel-case (like UserRegistrationController and registrationStep1Action),
the corresponding view template will be application/user-registration/registration-step-1.phtml (camel-cased names are converted
to lower-case and words are seperated by dashes).

Overriding Default View Template Name:

The ViewModel can also be used to override the default view template resolving. Actually the ViewModel class is more 
than just a variable container. Additionally, it allows to specify which view template should be used for page rendering.

The summary of methods provided for this purpose is shown as follows:

Methods of the ViewModel class for setting and getting view template name:

Name 					Desc

setTemplate() 			Sets the view template name

getTemplate() 			Returns the view template name

To set the view template name, you use the setTemplate() method. The getTemplate() method returns the view template
name currently set for the view model.

The following code example shows how you can call the setTemplate() method from your IndexController class indexAction()
method to force ZF3 to use the about.phtml view template file for rendering the Home page, instead of the index.phtml file:

//index action renders the home page of your site
public function indexAction()
{
	//use a different view template for rendering the page
	$viewModel = new ViewModel();
	$viewModel->setTemplate('application/index/about');
	return $viewModel;
}

In the code above, we created a new instance of the ViewModel class as per usual.

Then we called the setTemplate on the view model object and passed the name of the template name as its
argument.

The name is actually a relative path minus file extension.

Finally, we return the viewModel from the action method.

However, calling the setTemplate() method in every action method is optional. If you don't do that,
ZF3 will determine the view template name automatically by concatenating the current module name, controller name 
and action method name.

View Resolver:

When Zend Framework has the template name, it only remains to determine the absolute path to the corresponding .phtml file.
This is also called the view template resolving. View templates are resolved with the special Zend Framework's class
called the view resolver.

In ZF3, there are two view resolvers out of the box: TemplatePathStack and TemplateMapResolver. Both resolvers take a view
template name as input, and return path to view template file as output.

The template name is usually composed of module named followed by controller name followed by template name, like 
"application/index/about", "application/index/index". An exception is "layout/layout", which does not include module name.

The template map resolver uses a PHP nested array to determine path to view template file by its name. 
This way is fast, but you have to maintain some template map array and update it each time you add a new script.

The template path stack resolver assumes that the view template name can be mapped to directory structure.
For example, "application/index/about" template name maps to APP_DIR/module/Application/view/application/index/about.phtml

This way is simpler, because you need not maintain maps.

View resolvering settings are stored inside of our module.php.config file under the view_manager key:

<?php
return [
	//...

	'view_manager' => [
		//...

		'template_map' => [
			'layout/layout' 			=> __DIR__ . '/../view/layout/layout.phtml',
			'application/index/index' 	=> __DIR__ . '/../view/application/index/index.phtml',
			'error/404' 				=> __DIR__ . '/../view/error/404.phtml',
			'error/index' 				=> __DIR__ . '/../view/error/index.phtml',
		],
		'template_path_stack' => [
			__DIR__ . '/../view',
		],
	],
];

You can see that template map resolver's settings are stored under the template_map key. By default, there are several
"standard" view templates, which are resolved this way: the index page template, the layout template.

(We will talk about that in Page Appearance and Layout and error templates (later on)). These standard pages are served
with this type of resolver, because it is fast.

The template path stack resolver's settings are stored under the template_path_stack key. You can see that this resolver
looks for your view scripts under the "view" directory of your module. That's why we could just put about.phtml file under
that directory, and ZF will automatically find the template.

The template map and template path stack resolver work in pair. First, the fast template map resolver tries to find
the template view in it's array map, and if the page is not found, the template patch stack resolver is executed.

Disabling the View Rendering:

Sometimes, you would need to disable the default view rendering. To do that, just return the Response object from the 
controller's action.

For example, let's create a DownloadController class, and add the "file" action, which would allow site users to 
download files from your website. This action does not need a corresponding file.phtml view template, because it just
dumps file contents to PHP stdout stream.

Add the DownloadController.php file to Controller directory of Application module, then put the following code into the file:

<?php
namespace Application\Controller;

use Zend\Mvc\Controller\AbstractActionController;
use Zend\View\Model\ViewModel;

/**
  * This is the controller class for managing file downloads
  */
class DownloadController extends AbstractActionController
{
	/**
	  * This is the file action that is invoked
	  * when a user wants to download the given file.
	  */
	public function fileAction()
	{
		//get the file name from GET variable
		$fileName = $this->params()->fromQuery('name', '');

		//take some precaution to make file name secure
		$fileName = str_replace("/", "", $fileName); //Remove slashes
		$fileName = str_replace("\\", "", $fileName); //remove backslashes

		//Try to open the file
		$path = '.data/download/' . $fileName;
		if (!is_readable($path)){
			//Set 404 not found status code
			$this->getResponse()->setStatusCode(404);
			return;
		}

		//Get the file size in bytes
		$fileSize = filesize($path);

		//Write HTTP headers
		$response = $this->getResponse();
		$headers = $response->getHeaders();
		$headers->addHeaderLine(
				"Content-type: application/octet-stream");
		$headers->addHeaderLine(
				"Content-Disposition: attachment, filename=\"" . $fileName . "\"");
		$headers->addHeaderLine("Content-length: $fileSize");
		$headers->addHeaderLine("Cache-control: private");

		//Write file content
		$fileContent = file_get_contents($path);
		if($fileContent!=false){
			$response->setContent($fileContent);
		} else {
			//Set 500 server error status code
			$this->getResponse()->setStatusCode(500);
			return;
		}

		//Return response to avoid default view rendering
		return $this->getResponse();

	}
}

The action method takes the name param from URL's query part, removes slashes from file name, adds HTTP 
headers to Response object and file contents. Finally, it returns the Response object to disable the default
view rendering.

Register the DownloadController class by adding the following line to your module.config.php file:

<?php
return [
	//...
	'controllers' => [
		'factories' => [
			//...
			Controller\DownloadController::class => InvokableFactory::class
		],
	],
	//...
];

You will also need to add a route to your module.config.php (a route tells ZF3 to what URL to map the controller action).
Modify the routes key of the config file as follows:

<?php
return [
	//...
	'router' => [
		'routes' => [
			//Add this route for the DownloadController
			'download' => [
				'type' 	=> Segment::class,
				'options' => [
					'route' 	=> '/download[/:action]',
					'defaults' 	=> [
						'controller' 	=> Controller\DownloadController::class,
						'action' 		=> 'index',
					],
				],
			],
		],
	],

	//...
];

To see how the file download works, create APP_DIR/data/download directory and put some text file named sample.txt in it
Then open your web browser and type the URL "http://localhost/download/file?name=sample.txt" in your browser's 
navigation bar and press the Enter key. The browser will download the sample.txt and offer you to save it to some location.

View Rendering Strategies:

A rendering strategy determines how the page will be rendered. By default, to produce the HTML page, the .phtml
view template is rendered with the help of PhpRenderer class living in Zend\View\Renderer namespace.

This strategy works well in 99% of the cases. But sometimes, we may need to return something else, like, a JSON
response or a RSS feed response.

A response in JSON format is typically returned when you implement some kind of API (Application Programming Interface).
API is used to retrieve some the data in machine-readable format. A response in RSS feed format is typically
used to publish frequently changing info, like blog posts or news.

So, ZF3 provides three view rendering strategies out of the box:

the default one (also known as PhpRenderingStrategy)

the JsonStrategy producing an JSON response

the FeedStrategy producing an RSS feed response

For example, let's show how to use JsonStrategy to return JSON response from a controller action.

First, you'll need to register the strategy in module.config.php configuration file:

<?php
return [
	//...

	'view_manager' => [
		//...

		'strategies' => [
			'ViewJsonStrategy',
		],
	],
];

Then, return JsonModel (instead of the usual ViewModel) from your controller's action method:

namespace Application\Controller;

use Zend\Mvc\Controller\ActionController;
use Zend\View\Model\JsonModel;

class IndexController extends ActionController
{
	public function getJsonAction()
	{
		return new JsonModel([
			'status' => 'SUCCESS',
			'message'=>'Here is your data',
			'data' => [
				'full_name' => 'John Doe',
				'address' => '51 Middle st.'
			]
		]);
	}
}

NOTE: This requries the zend-json package to be installed. To install it, do:

composer require zendframework/zend-json

Error Pages:

When a page could not be found or some other error happens inside of your web application, a standard error page is displayed.
The appearance of the error page is controlled by the error templates. There are two error templates: error/404, which is used
for "404 Page Not Found" error and error/index which is displayed when a generic error occurs (such as unhandled exception is
thrown somewhere in the app)

The module.config.php file contains several parameters under the view_manager key, which you can use to configure the 
appearance of your error templates:

<?php
return [
	//...

	'view_manager' => [
		'display_not_found_reason' => true,
		'display_exceptions' 	   => true,
		//...
		'not_found_template' 	   => 'error/404',
		'exception_template' 	   => 'error/index',
		'template_map' => [
			'error/404' => __DIR__ . '/../view/error/404.phtml',
			'error/index' => __DIR__ . '/../view/error/index.phtml',
		],
		//...
	],
];

The display_not_found_reason param controls wether to display the detailed info about the Page not Found error.

The display_exceptions parameter defines wether to display information about an unhandled exception and it's stack trace.

The not_found_template defines the template name for the 404 error.

The exception_template specifies the template name for the unhandeled exception error.

You typically set the display_not_found_reason and display_exceptions parameters to false in production systems,
because you do not want site visitors to see the details about errors in your site. However, you will still be
able to retrieve the detailed information from Apache's error.log file.

Models:

A model is a PHP class which contains the business logic of your app. The business logic is the "core" of your website.
It implements the goal of site operation. For example, if you implement an E-commerce website, you will have models implementing
the product catalog and the shopping cart.

In general, the term model means a simplified representation of a real-life object or phenomenon. Simplified because
the real-life obj has infinite properties. <flavor stuff>.

Models can have some behavior. For example, a mailer model may send E-mail messages, the currency converter model may
be able to convert money and so on.

With ZF3, you represent models as usual PHP classes. Properties are implemented as class fields, and the behaviors 
are implemented as class methods.

Model Types:

In ZF3, there is no single Model directory for storing the model classes, as you could assume. Instead, by convention,
models are further subdivided into the following principal types, and each type is stored in it's own subdirectory:

Model Types and Their Locations:

Model Type 						Dir

Entities 					APP_DIR/module/Application/src/Entity

Repositories 				APP_DIR/module/Application/src/Repository

Value Objects 				APP_DIR/module/Application/src/ValueObject

Services 					APP_DIR/module/Application/src/Service

Factories 					In factory subdirs under each model type dir. For example, controller factories would be stored in
							APP_DIR/module/Application/src/Controller/Factory

Separation of models into different types makes it easier to design your business logic domain. This is also
called the "Domain Driven Design" (or shortly, DDD). 

Entities:

Entities are intended for storing some data and always have some identifier property, so you can uniquely identify the data.
For example, a User entity always has a unique login property, and you can identify the user by that attribute.

You can change some other attributes of the entity, like firstName or Address etc., but it's identifier never changes.
Entities are usually stored in a DB, in a file system or in any other storage.

Below, you can find an example of a User entity, which represents a site visitor:

//The user entity represents a Site visitor
class User
{
	//Properties
	private $login; 	//e.g. "admin"
	private $title; 	//e.g. "Mr."
	private $firstName; //e.g. "John"
	private $lastName; 	//e.g  "Doe"
	private $country;
	private $city;
	private $postCode;
	private $address;

	//behaviors
	public getLogin()
	{
		return $this->login;
	}

	public setLogin($login)
	{
		$this->login = $login;
	}

	//...
}

We can of course put in whatever other methods we want, as well.

Repositories:

Repositories are specific models responsible for storing and retrieving entities. For example, a UserRepository
may represent a database table and provide methods for retrieving User entities. You typically use repositories
when storing entities in a DB.

With repositories, you can encapsulate SQL query logic in a single place and maintain/test it.

We learn more about repositories later on.

Value Objects:

Value objects are a kind of model for which the identity is not as important as for entities. A value object is usually
a small class identified by all of it's attributes. It does not have an identifier attribute. 

value objects typically have getter methods, but do not have setters (value objects are immutable)

For example, a model wrapping a money amount can be treated as a value object:

class MoneyAmount
{
	//Properties
	private $currency;
	private $amount;

	//Constructor
	public function __construct($amount, $currency='USD')
	{
		$this->amount = $amount;
		$this->currency = $currency;
	}

	//Gets the currency code
	public function getCurrency()
	{
		return $this->currency;
	}

	//Gets the money amount 
	public function getAmount()
	{
		return $this->amount;
	}
}

Value Objects are immutable, they have no setters.

Services:

Service models usually encapsulate some business logic functionality. Services usually have easily recognizable names ending
with "er" suffix, like FileUploader or UserManager.

Below, an example of Mailer service is represented. It has the sendMail() method which takes an EmailMessage value object
and sends an E-mail using the standard PHP mail() function:

<?php

//The email message value object
class EmailMessage
{
	private $recipient;
	private $subject;
	private $text;

	//constructor 
	public function __construct($recipient, $subject, $text)
	{
		$this->recipient = $recipient;
		$this->subject = $subject;
		$this->text = $text;
	}

	//Getters
	public function getRecipient()
	{
		return $this->recipient;
	}

	public function getSubject()
	{
		return $this->subject;
	}

	public function getText()
	{
		return $this->text;
	}
}

//The mailer service, which can send messages by E-mail
class Mailer
{
	public function sendMail($message)
	{
		//Use PHP mail() function to send an e-mail
		if(!mail($message->getRecipient(), $message->getSubject(), 
			$message()->getText()))
		{
			//error sending message
			return false;
		}

		return true;
	}
}

In ZF, you typically register your service models in Service Manager.

Factories:

Factories are usually being designed to instansiate other models (particularly service models). In the simplest cases
you can create an instance of a service without any factory, just by using the new operator.

But sometimes the creation logic might be rather complex. For example, services often depend on each other, so you might
need to inject dependencies to a service. Also, sometimes it may be required to initialize the service right 
after instansiation by calling one (or several) of it's methods.

Factory classes typically have names ending with Factory suffix, like CurrencyConverterFactory, MailerFactory, etc.

For a real-life example, let's imagine that we have a PurchaseManager service, which can process purchases of some goods,
and that the PurchaseManager service uses another service named CurrencyConverter, which can connect to an external
system providing money exchange rates. 

Let's write a factory class for the PurchaseManager, which would instansiate the service and pass it the dependency:

<?php
namespace Application\Service\Factory;

use Interop\Container\ContainerInterface;
use Zend\ServiceManager\Factory\FactoryInterface;
use Application\Service\CurrencyConverter;
use Application\Service\PurchaseManager;

/**
  * This is the factory for PurchaseManager service. Its purpose is to instansiate the 
  * service and inject its dependencies
  */
class PurchaseManagerFactory implements FactoryInterface
{
	public function __invoke(ContainerInterface $container,
			$requestedName, array $options = null)
	{
		//Get CurrencyConverter service from the service manager
		$currencyConverter = $container->get(CurrencyConverter::class);

		//Instansiate the service and inject dependencies
		return new PurchaseManager($currencyConverter);
	}
}

In the code above, we have the PurchaseManagerFactory class which implements the Zend\ServiceManager\Factory\FactoryInterface
interface.

The factory class has the __invoke() method whose goal is to instansiate the object. This method has the $container argument
which is the service manager. You can use $container to retrieve services from service manager and pass them to the constructor
method of the service being instansiated.

Determining the Correct Model Type:

Is it not confusing to have so many model types?

Well, yes and no. As time goes on, we sill distingusi them.

When writing your own app, you may be confused when trying to decide to which model type your class belongs
(wether it is an entity, value object, repository, service or factory). Below, we have some guidelines:

Service:

Encapsulates some business logic

call it from controller class

best name for it ends with "er", like, FileUploader or VersionChecker

Entity:

Stored in DB

has an ID

has getters/setters

ValueObject:

getters but no setters (immutable)

changing any attribute would make the model completely different

Repoistory:

if it works with a DB to retrieve entities

Factory:

Can create objects and do nothing else.

What if we just want to store models in a single models dir?

The Doctrine ORM lib uses the DDD principles. Use it.

Other Model Types:

In your website, you will typically divide your principal model types into subtypes. For example, you will have:

Forms: Forms are models whose purpose is to collect data entered by web users. Forms are a subtype of entities.
You will typically store forms in APP_DIR/module/Application/src/Form directory

Filters: Filters are designed for transforming input data. Filters are a subtype of services. You will typically
store filters in APP_DIR/module/Application/src/Filter directory

Validators: Validators are used for checking input data for correctness. Validators are also a subtype of services.
You will typically store validators in APP_DIR/module/Application/src/Validator directory

View Helpers: They encapsulate some page rendering functionality. View helpers are similar to services. You will typically
store view helpers in APP_DIR/module/Application/src/View/Helper directory.

Routes: Routes are a specific service model used for implementing custom mapping rules between URLs and your controllers.
You will typically store custom routes in APP_DIR/module/Application/src/Route directory.

Generally, we might end up with the following directory structure:

/Application/src
	/Controller
			/Factory
			/Plugin
				/Factory
	/Entity
	/Filter
	/Form
	/Repository
	/Route
	/Service
		/Factory
	/Validator
	/ValueObject
	/View
		/Helper
			/Factory

We can of course, have more subtypes and a arbitrarily more complex structure.

Skinny Controllers, Fat Models, Simple Views:

When developing a website using Model-View-Controller pattern, there is a risk of misunderstanding the role of
controllers, views and models. This results in making controllers huge and models small.

Which in turn makes it difficult to test and support your application.

This section's goal is to give you a general understanding of what code may be placed in a controller class,
what code may be placed in a view template, and what code may be placed in a model class.

Skinny Controllers:

The idea behind the term "skinny controller" is that typically, in your controller classes, you put only the code
that:

accesses user request data ($_GET, $_POST, $_FILES and other PHP variables).

Checks the validity of input data.

(optionally) makes some basic preparations to the data

passes data to model(s) and retrieves the result returned by the model(s)

and finally returns the output data as a part of a ViewModel variable container.

A controller class should avoid:

Containing complex business logic, which is better kept in model classes.

Containing any HTML or any other presentational markup code. This is better put in view templates.

For an example of a "skinny" controller, look at the CurrencyConverterController class below. This controller 
provides the "convert" action method whose goal is to convert an amount of money from EUR to USD currency.

The user passes the amount of money through the "amount" GET variable:

class CurrencyConverterController extends AbstractActionController
{
	//Currency converter model
	private $currencyConverter;

	//Constructor. It's purpose is to "inject" dependencies
	public function __construct($currencyConverter)
	{
		$this->currencyConverter = $currencyConverter;
	}

	//The "convert" action displays the converted money amount
	public function convertAction()
	{
		//Get the money amount from GET
		$amount = (float)$this->params()->fromQuery('amount', -1);

		//Validate input data
		if($amount<0){
			//money amount is missing
			$this->getResponse()->setStatusCode(404);
			return;
		}

		//pass the data to the CurrencyConverter model
		$convertedAmount = $this->currencyConverter->convertEURtoUSD($amount);

		return new ViewModel([
			'amount'=>$amount,
			'convertedAmount'=>$convertedAmount
		]);
	}
}

The controllers action method above, does the following:

Takes the data passed by site user. This data is usually part of Request object and
can be retrieved using the controller's getRequest() method or Params controller plugin.

Performs the basic check on the data passed by user (line 19), and if the data is missing (or invalid),
sets an HTTP error code 

Passes the money amount to the CurrencyConverter model by calling it's convertEURtoUSD method.
The method then returns the converted amount.

Constructs the ViewModel variable container and passes the resulting data to it. This variable container
can be further accessed in the corresponding view template responsible for data presentation.

Fat Models:

Because you need to keep your controllers as thin as possible, most of the business logic of your application
should be put into model classes.

In a properly designed Model-View-Controller application, models look "huge". A model class may contain the code
which:

Performs complex data filtering and validation. Because the data that you retrieved in controller is passed to your
application from an outside world, in your model, we have to take a lot of care to verify the data and process it
properly.

Performs data manipulation. your models should load from db, save to db and transform the data. Models is the right place
for storing DB queries, file reading and writing functionality, etc.

In a model class, you do not:

Access the data from HTTP requests, $_GET, $_POST etc. It is the controllers work to extract said data and pass
it to the model's input

Produce HTML or other code specific to presentation. The presentational code may vary depending on the user request,
and it is better to put in a view template.

If we follow this, we find that models are easy to test, cause the input and output is predictable.
It also makes it easy to write unit tests.

If we are confused about where to put certain code in a controller or a model, we have to ask ourselves: Is this
an important business logic that needs to be carefully tested? If yes, put it in a model.

Simple View Templates:

Because most of the logic is stored in models, our view templates should be as simple as possible to produce the 
presentation of the data passed through the variable container. In a view template, you may:

Keep static HTML markup code

Retrieve the data from a variable container and echo them to PHP output stream

If a controller passed a certain model through a variable container, poll the model for data 
(e.g you can retrieve table rows from a database table and render them)

Contain simple PHP flow control operations, like if, foreach, switch and so on. This allows
to vary the presentation depending on vars passed by the controller.

The view template should NOT:

Access data from HTTP requests and superglobals.

Create models, manipulate them and modify the state of the app.

If you follow these principles, you will encounter that your views can easily be substituted without modifying
the business logic of your app. For example, we could easily change the design or introduce changable themes.

Summary:

a ZF3 based website is just a PHP program receiving an HTTP request from the web server, and producing an
HTTP response. The web app uses Model-View-Controller pattern to separate business logic from presentation.
The goal of this is to allow for code reusability and separation of concerns.

A controller is a mediator between the app, models and views: it gets input from HTTP request and uses
the model(s) and the corresponding view to produce the necessary HTTP response. A controller is a usual
PHP class containing action methods.

Views are simple HTML+PHP code snippets producing HTML output returned by the web server to site visitors.
You pass the data to view scripts through the ViewModel variable container.

A model is a PHP class which contains the business logic of our app. The business logic is the "core"
of your website, which implements the goal of site operation.

Models can access DB's, manipulate disk files, connect to external systems, manipulate other models etc.

Routing:

When a site user enters a URL in a web browser, the HTTP request is finally dispatched to controller's action
in our ZF3 based website.

In this chapter, we will learn about how ZF3-based apps maps page URLs to controllers and their actions.
This mapping is accomplished with the help of routing. Routing is implemented as a part of Zend\Router component.

ZF3 components covered in this chapter:

Component 					Desc

Zend\Router 				Implement support of routing

Zend\Barcode 				Auxilliary component implementing barcodes.

URL Structure:

To better understand routing, we first need to look at the URL structure. A typical URL from an HTTP request
consists of several parts. There are scheme, host name, path, fragment and query parts.

For example, let's look at the following URL: "http://site1.yourserver.com/path/to/page#section?a=1&b=2"

Scheme: http

hostname: site1.yourserver.com

path: path/to/page 

fragment: #section? 

query: a=1&b=2

This URL begins with the scheme (the scheme typically looks akin to http or https), followed by hostname (The domain name
of your server).

Then comes a optional path segments seperated by /, follow the hostname. If we have the page:

"path/to/page", would then have "path", "to", "page" as path segments. After the # comes the fragment name.

Finally, after the question mark, the optional query part follows. It consists of one or several "name=value"
params separated from each other by an ampersand char ('&').

Each part in a URL uses special character encoding, which is named the URL encoding. This ensures that the
URL contains chars adhering to ASCII. If it contains unsafe chars, they are casted to hexadecimal with '%20' for instance,
(this would be space)

Route Types:

Routing is a mechanism which allows to map HTTP request to a controller's action. With routing, ZF3 knows 
which of the controller's action method to execute as the result of the request.

For example, you can map "http://localhost/" URL to IndexController::indexAction and "http://localhost/about" to IndexController::aboutAction().

We define the mapping between URLs and controllers iwth hte help of routes.

There are several standard route types provided by ZF3. These route types are implemented as classes living in the Zend\Router\Http namespace.

Route Types:

Route type 				description

Literal 			Exact matching against the path part of a URL

Segment 			Matching against a path segment (or several segments) of a URL

Regex 				matching the path part of a URL against a regex template

Hostname 			Matching the host name against some criteria

Scheme 				Matching URL Scheme against some criteria

Method 				Matchign an HTTP method (e.g. GET, POST, etc.) against some criteria

Each route type in the table above (Except the method type) may be matched against a specific part (or several parts)
of a URL. The method route type is matched against the HTTP method (GET or POST) retrieved from the HTTP request.

Combining Route Types:

Routes may be combined with the help of "aggregate" route types. The compound route types allow to
define arbitrarily complex URL mapping rules.

Aggregate Route Types:

Route Type 							Description

SimpleRouteStack 		Aggregates different route types in a list with priorities

TreeRouteStack 			Aggregates different route types in a tree-like structure

Part 					Aggregates different route types in a subtree

Chain 					Aggregates different route types in a chain (degenerate subtree)

The TreeRouteStack and SimpleRouteStack are used as the "top-level" route types. The SimpleRouteStack
allows to organize different routes in a priority list. The TreeRouteStack allows to nest different routes, forming a "tree".

The following, shows the route class inheritance diagram.

	>>>>>>>>>>>>>>>>>>>>Zend\Router\RouteInterface<<<<<<<
	^ 													 ^
	^ 													 ^
RouteStackInterface 									 ^
	^ 												Http\RouteInterface
	^ 												^  ^ ^  ^ ^  ^
SimpleRouteStack 									^  ^ ^ 	^ ^  ^
	^ 											Scheme ^ ^ 	^ ^  ^
	^ 												>>>^ ^	^ ^  Literal
Http\TreeRouteStack 								^ 	 ^	^ ^
 ^ 			^ 										^    ^	^ ^<<< Segment
 ^ 			^ 									Method   ^	^ 
Part 	   Chain 								 		 ^	^
											   Hostname >> 	<< Regex

As we can see from this image, all route classes are inherited from RouteInterface interface (We will learn
this interface in details in the Writing Own Route Type section later in this chapter). 

The SimpleRouteStack is a parent class for TreeRouteStack class, which inherits the behavior of the
 simple route stack (allows to organize routes in a prio list) and extends it (allows to organize routes in subtrees).

The Part and Chain classes are derived from TreeRouteStack class and are used internally by the TreeRouteStack for building
subtrees and chains of child routes.

Simple Route Stack:

The SimpleRouteStack allows to combine different routes in a priority list. For example of such a list:

SimpleRouteStack
	V
	V
	V>> Literal
	V
	V>> Literal
	V
	V
	V>> Segment
	V
	V>> Segment

It has several literal and segment routes. When matching against the HTTP request, the SimpleRouteStack walks 
through the list of routes and tries to match each route in turn.

Each route in the list has a priority, the routes with the higher priority are visited first. The lookup is finished
once some route matches the HTTP request. If none of the routes match, "not found" error is raised.

Tree Route Stack:

The TreeRouteStack class extends the SimpleRouteStack class, which means it can organize routes in
a priority list, plus it provides an ability to nest routes in subtrees and chains.

An example tree route stack is presented as follows:

TreeRouteStack
V
V>> Literal
V
V>> Chain
V	V
V	V>> Literal
V	V
V	V>>> Segment
V
V> Part >> Scheme
	V
	V>> Part >> Hostname
	V	 V
	V	 V>>> Segment
	V
	V> Segment

The list contains one literal route, a chain of Literan and Segment routes, and a Subtree  consisting of two branches:
A branch containing a single segment route, and a branch consisting of Scheme, Hostname, and Segment routes.

The tree route stack performs request matching in the following way. It walks through its priority list items (denoted
by dashed lines), starting from high-priority routes. If a certain item is a Chain route or a Part route, it processes
such a nested route from it's parent route to children.

If the parent route matches, the children are analyzed then. The nested route is considered matching if at least one route
matches in each tree (or chain) level.

Each route in a tree (or chain) consumes a part of the URL. The parent route is matched against the first part of the URL,
its child is matched again the next part, and so on, until end of the URL is reached.

http://site1.yourserver.com/path/to/page
^ 			^ 					^
^ 			^ 					^
Scheme 		^ 					^
			^ 					^
		Hostname 			Segment

TreeRouteStack
V
V>> Part >> Schema
     V
     V>> Part >> Hostname
     	  V
     	  V>>>>>>> Segment

Routing Configuration:

You typically do not create the route stack (or tree) yourself, instead you provide the instructions for ZF3
on how to do that.

The routing configuration for a module is stored in module.config.php configuration file:

<?php
use Zend\Router\Http\TreeRouteStack;

return [
	//...
	'router' => [
		'router_class' => TreeRouteStack::class,
		'routes' => [
			//Register your routing rules here!
		],
		'default_params' => [
			//Specify default parameters here for all routes
		]
	],
];

Above, we can see the router key with the routes subkey.

With the router_class value, we can define which top-level route class to use (either TreeRouteStack or SimpleRouteStack)
with the router_class parameter.

If this param is not present, the TreeRouteStack is used by default.

You can use the optional default_params key to define the default values for parameters for all routes at once.
however, you typically do not use this key and define the defaults on a per-route basis.

We will go through extracting parameters from routes later in this chapter.

Configuration for Simple Routes:

A typical route has the name, type and options:

The name is used to uniquely identify the route

The type defines the fully qualified name of the route type (PHP class which implements the matching algorithm)

The options is an array that includes the route string which should be compared against the URL part, and several
parameters called the defaults.

Configuration for each route under the routes subkey may have the following format:

'<route_name>' => [
	'type' => '<route_type_class>',
	'priority' => <priority>,
	'options' => [
		'route' => '<route>',
		'defaults' => [
			//...
		],
	],
]

Above, the route_name should be the name of the route. A route name MUST be in lowercase. The type
key specifies the fully qualified route class name.

The optional priority key allows to define the priority (which should be an integer number) of the route
in the priority list (routes with higher priority will be visited first). If you omit the priority key,
the routes will be visited in the LIFO order. (last item added is taken out first)

Routes having equal prio will be visited in LIFO order. Thus, for best performance, you should register
routes that will match most often in the last turn, and least common routes should be registered first.

The options key defines the array of route's options. We will discuss the options in the following 
sections of this chapter.

Configuration for Nested Routes:

To organize routes in a subtree, you add the child_routes key to the route definition, and add your child routes under that
key, like below:

'<route_name>' => [
	'type' => '<route_type_class>',
	'priority' => <priority>,
	'options' => [
		//...
	],
	'child_routes' => [
		//Add child routes here
	]
],

If we need to organize the routes in a chain (degenerate subtree), you add the chain_routes key to your route configuration:

'<route_name>' => [
	'type' => '<route_type_class>',
	'priority' => <priority>,
	'options' => [
		//...
	],
	'chain_routes' => [
		//add chained routes here
	]
],

Looking at the two examples above, we won't see explicit usage of the Part and Chain route types, because
ZF3 uses them automatically when it encounters child_routes and chain_routes keys in your routing configuration.

Default Routing Configuration in Zend Skeleton App:

Now that we know how to configure routes and organize them in compound structures, let's look at a real life example, showcasing
a fresh Zend Skeleton Application, the routing config looks as follows:

<?php
use Zend\Router\Http\Literal;
use Zend\Router\Http\Segment;

return [
	'router' => [
		'routes' => [
			'home' => [
				'type' => Literal::class,
				'options' => [
					'route' 	=> '/',
					'defaults' => [
						'controller' => Controller\IndexController::class,
						'action' 	 => 'index',
					],
				],
			],
			'application' => [
				'type' 	=> Segment::class,
				'options' => [
					'route' 	=> '/application[/:action]',
					'defaults' => [
						'controller' 	=> Controller\IndexController::class,
						'action' 		=> 'index',
					],
				],
			],
		],
	],

	//....
];

In the configuration above, we have two routing rules listed in turn: first we have the "home" route, and then we have the
application route.

The home route,maps the empty URL path to the "index" action of the IndexController controller. For example, if we enter
"http://localhost/" in the browser, we get hte home page. This route is of type "Literal".

The "application" route (of type "Segment") maps URLs looking like "http://localhost/application", "http://localhost/application/about",
"http://localhost/application/news" etc. onto the coresponding action of the IndexController controller.

The actual action name is defined by the action param. The default value is index, meaning if we do not specify an action,
we get the index action.

This configuration corresponds to: 

TreeRouteStack
V
V>> home(Literal)
V
V>> application (Segment)

Literal Route Type:

With Literal route type, the route match is achieved only when you have the exact match of the route
string against the URL path part. You typically use the Literal type for URLs which should be short and 
memorable, like '/about' or '/news'.

Below, the definition of the route named "home" is presented. The "home" route is usually mapped to the
"index" action of the IndexController and points to the Home page of your site:

'home' => [
	'type' => Literal::class,
	'options' => [
		'route' 	=> '/',
		'defaults' 	=> [
			'controller' 	=> Controller\IndexController::class,
			'action' 		=> 'index',
		],
	],
],

Here, we say that the type of route is Literal. The actual route matching algo is implemented in the 
Zend\Router\Http\Literal class.

We define the route to match against the URL path ('/' means empty URL part). Because we have the 
literal route type, the route match is achieved only when you have the exact literal path match.

For example, if you have the URL "http://localhost/" or "http://localhost", it will match the "/" route string.

We also define the defaults, which are the parameters returned by the router if the route matches. The controller
and action parameters define the controller and controller's action method which should be executed. You can also
define other parameters here, if needed.

As another example of the Literal route type, let's add the '/about' route for the About page we've created
earlier in the Views sections of the chapter Model-View-Controller. To create the route, add the following
lines right after the "home" route definition inside of your module.config.php file:

'about' => [
	'type' => Literal::class,
	'options' => [
		'route' => '/about',
		defaults' => [
			'controller' => Controller\IndexController::class,
			'action' 	 => 'about',
		],
	],
],

If you now open the "http://localhost/about" URL in your web browser, you should see the About page.

Segment Route Type:

The Segment route type allows for matching the route string against one or several URL path segments.

If you look at the module.config.php file, you can see the Segment route type is inside of the "application"
route to make actions of your IndexController automatically mapped to site URLs. You just add an action
method to your IndexController class, and it becomes available by a URL like "http://localhost/application/<action>". 

For example, you can see the About page of your site within the following URL: "http://localhost/application/about"

To demonstrate the creation of the Segment route type, let's implement a controller action which will generate a
simple barcode image.

Bardcodes are widely used in supermarkets for optically recognizing goods in your shopping cart. The bardcodes
may be of different types and have different labels. We will use the Segment route type to map the action to a 
URL like "http://localhost/bardcode/<type>/<label>"

To able to use bardcodes, you need to install the Zend\Barcode component with Composer, by typing the following
command:

php composer.phar require zendframework/zend-barcode

Please note, that for bardcode images to work, you need to have the GD extension of the PHP engine installed
and enabled. In Linux Ubuntu, you can install this extension with the following command:

sudo apt-get install php-gd

After installing the extension, restart Apache to apply the changes.

The PHP GD extension allows us to create image files in different formats (like JPEG, PNG, GIF, etc.)

First, we define the "barcode" route in the module.config.php file:

'barcode' => [
	'type' 	=> Segment::class,
	'options' => [
		'route' => '/barcode[/:type/:label]',
		'constraints' => [
			'type' 	=> '[a-zA-Z][a-zA-Z0-9_-]*',
			'label' => '[a-zA-Z0-9_-]*'
		],
		'defaults' => [
			'controller' => Controller\IndexController::class,
			'action' => 'barcode',
		],
	],
],

Segments of the route string may be constant or variable. We can define the variable segments by using "wildcards".
We have three segments: barcode, :type and :label. The barcode segment is constant, while the latter two are 
wildcards. (Wildcard's name should start with a colon).

You specify how a wildcard should look like inside of the constraints subkey. We define the regex 
which constraints our :type wildcard to begin with a letter and (optionally) contain several letters,
digits, underscores or minus chars.

The constraint for the :label wildcard is almost the same, but this segment can start with any allowed
character (either letter, digit, underscore or minus sign char)

Optional segments can be enclosed in []. In our example, we have both the :type and :label segments as optional.

We define the defaults, the parameters that will be returned by the router. The controller and action defaults
specify which controller and action method to execute on route match.

Next, we add the barcodeAction() method into the IndexController class:

//Add name alias in the beginning of the file
use Zend\Barcode\Barcode;

//...

// The "barcode" action
public function barcodeAction()
{
	//Get parameters from route
	$type = $this->params()->fromRoute('type', 'code39');
	$label = $this->params()->fromRoute('label', 'HELLO-WORLD');

	//Set barcode options
	$barcodeOptions = ['text' => $label];
	$rendererOptions = [];

	//Create barcode object
	$barcode = Barcode::factory($type, 'image',
				$barcodeOptions, $rendererOptions);

	//The line below will output barcode image to standard 
	// output stream
	$barcode->render();

	//Return Response object to disable default view rendering
	return $this->getResponse();
}

We aquire the type and label wildcards from route. We do that with the help of Params
controller plugin's fromRoute() method. Analogous to fromQuery() method, it takes two arguments:
The variable name and it's default value.

For generating the barcode image, we use the Zend\Barcode component. We then define the label text
for the barcode. And we then go to make a barcode object from the factory method of the Barcode namespace

And we then output the image to standard output stream by just calling render() on the barcode.

Zend\Barcode is an auxiliary component used for generation of various barcode images. For additional
info about this component, please refer to the corresponding section of Zend Framework reference manual.

We then finish off by returning the response to disable the default view rendering.

We can then represent different barcodes with wildcarding type and label parameters
of the barcode image in the URL.

Examples:

http://localhost/barcode/code39/HELLO-WORLD
http://localhost/barcode/leitcode/12345

etc.

Regex Route Type:

The regex rotue type is useful if you have URLs which can be matched against a regex.

For example, assume you want to create a simple documentation system for your website. The documentation
would consist of "static" pages mapped to URLs like /doc/<page_name>.html

By the term "static" we refer to a page which mostly contains static HTML code plus several PHP inline
fragments. For such simple pages you do not need to create separate controller actions.

All "static" pages can be served by the single controller action.

Let's implement the route which will serve the "static" pages of the site. Because "static" pages
are simple,  you typically won't need to add per-page action methods to the controller. All pages
will be handeled by the single action IndexController::doAction().

First, we add the Regex route named "doc" to the module.config.php file:

'doc' => [
	'type' 	=> Regex::class,
	'options' 	=> [
		'regex' 	=> '/doc(?<page>\/[a-zA-Z0-9_\-]+)\.html',
		'defaults' => [
			'controller' => Controller\IndexController::class,
			'action' 	 => 'doc',
		],
		'spec'=>'/doc/%page%.html'
	],
],

First, we define the Regex type, assign the regex in options, which will match against stuff like
"/doc/contents.html", "/docs/introduction.html" and so on.

The regex contains the <page> variable, which will be returned by the router on match together with
the default parameters.

We define the spec option, which is used for generating URLs by route (Which we will discuss later).

in PHP PCRE regex, it is possible to name a sub-pattern using the syntax (?P<name>pattern), this sub-pattern is
then indexed in the matches array by its name.

Do not forget to add the following line to the beginning of module.config.php file:

use Zend\Router\Http\Regex;

Next, we add the following action to IndexController class:

public function doAction()
{
	$pageTemplate = 'application/index/doc'.
		$this->params()->fromRoute('page', 'documentation.phtml');

	$filePath = __DIR__.'/../../view/'.$pageTemplate.'.phtml';
	if(!file_exists($filePath) || !is_readable($filePath)) {
		$this->getResponse()->setStatusCode(404);
		return;
	}

	$viewModel = new ViewModel([
			'page'=>$pageTemplate
		]);

	$viewModel->setTemplate($pageTemplate);

	return $viewModel;
}

First, we retrieve the page parameter from route, the one we had earlier with the regex,
and save it as the $pageTemplate variable. We will use the $pageTemplate variable for determining
the view template name to pass to the view resolver.

Then, we get the filePath to see if the file exists and is readable, otherwise we just set a statusCode of 404 and reutrn it.

If it goes through, we just spawn a viewModel, assign the page to be the page template and assign the template of the page template to 
be the viewModel and return the viewModel.

To see the documentation system in action, create a couple of "static" view template files: the Table of Contents page (contents.phtml)
and the Introduction page (introduction.phtml). Create the doc subdirectory under the view/application/index directory of
the Application module and put the contents.phtml view template there:

<h1>Table of Contents</h1>

<ul>
	<li>
		<a href="<?= $this->url('doc', ['page'=>'introduction']); ?>">
			Introduction
		</a>
	</li>
</ul>

In the lines above, we provide the HTML code for the "Table of Contents" page header, and the list which
contains the single item named "Introduction" pointing to the Introduction "static" page. The link URL is generated
with the Url view helper (for more details on the Url helper, see further sections in this chapter).

Then add the introduction.phtml page into the same doc directory:

<h1>Introduction</h1>

<p>Some stuff goes here</p>

This is just the HTML for the content page.

Now, if you open the "http://localhost/doc/contents.html" URL in your browser, you should 
see a nice simple documentation system which you can extend and use in your site.

Clicking the link will redirect you to the page we defined. We can also add other pages to the doc
dir to make them automatically available for site users through our Regex route.

One disadvantage of such a documentation system is that it does not work well if you place 
nested pages in subdirs under the doc directory. The reason of this limitation lies in the way
the Regex route assembles URLs.

You can't generate URLs containing slash characters, as these "unsafe" chars will be automatically
URL-encoded. We will work around this problem with our custom route type that we will create at the
end of this chapter.

Other Route Types:

The Hostname, Scheme, and Method route types are used less commonly compared to the route
types mentioned previously.

Hostname:

The Hostname route type can be used, for example, if you develop a CMS engine, which should
save several websites at once, each site using a different sub-domain. In that case, you will
define the Hostname route as the parent and nest child routes of other types inside of it.

'routename'  => [
	'type' 	=> Hostname::class,
	'options' => [
		'route' => ':subdomain.yourserver.com',
		'constraints' => [
			'subdomain' => '[a-zA-Z][a-zA-Z0-9_-]*'
		],
		'defaults' => [
		],
	],
	'child_routes'=>[
		//...
	],
],

In the example above, we define the route for which has the type Hostname. The route option defines
the domain name to match against. The :subdomain is a wildcard, which can take different sub-domain values.

The constraints key defines the regex, this sub-domain parameter must match. THe Hostname route will differentiate
your domains, so each site will behave differently, depending on the value of the subdomain parameter returned:

//An example of an action that uses parameters returned by Hostname route.
public function someAction()
{
	//Get the 'subdomain' parameter from the route.
	$subdomain = $this->params()->fromRoute('subdomain', null);

	//Use different logic based on sub-domain.
	//...

	//Render the view template.
	return new ViewModel();
}

Scheme:

The Scheme route type is useful if you need to handle HTTP and HTTPS protocols in different ways.

The HTTPS protocol is typically used for secure connections, like account page or shopping cartp age.
When you use HTTPS, the request data is tunnelled through Secure Socket Layer (SSL) channel and not
available to third parties.

The typical Scheme route configuration is presented below:

'routename' => [
	'type' 	=> Scheme::class,
	'options' => [
		'scheme' => 'https',
		'defaults' => [
			'https' => true,
		],
	],
	'child_routes'=>[
		//...
	],
],

Above, we define the route of type Scheme. It takes the scheme option, which should be the scheme
to match against (like http or https). If the scheme in HTTP request's URL is exactly the same as the scheme option,
the route is considered matching.

You can use the defaults key to return some params on route match. in this example, we return the https boolean..

Method:

The Method route type can be used if you need to direct GET and POST requests into different controller's 
actions. It's typical configuration is presented below:

'routename' => [
	'type' => Method::class,
	'options' => [
		'verb' => 'post',
		'defaults' => [
		],
	],
	'child_routes' => [
		//...
	],
],

Above, we define the route which has the Method type. It takes the verb option, which may be the comma-seperated
list of acceptable HTTPS verbs (like GET, POST, PUT etc.)

Extracting Parameters from Route:

On route match, the router (top-level route class) returns some parameters: the "defaults" (parameters listed in the defaults
section of routing configuration) plus any wildcard params extracted from URL string.

In your controller, you will often need to retrieve these parameters. We already did this in the examples
above. In this section, we will give some summary.

To retrieve a param from the route in your conroller's action method, you typically use the Params controller plugin
and its fromRoute() method, which takes two arguments: the name of the param and the value to return in case of it
not being present.

The fromRoute() method can also be used to retrieve all parameters at once as an array. To do that, call the
fromRoute() without arguments, as follows:

//An example action
public function someAction()
{
	//Get the single 'id' parameter from route.
	$id = $this->params()->fromRoute('id', -1);

	// get all route parameters at once as an array
	$params = $this->params()->fromRoute();

	//...
}

Retrieving the RouteMatch and the Router Object:

On route match, the router class internally creates an instnace of Zend\Router\Routematch class, providing the
methods for extracting the matched route name and parameters extracted from route.

The useful methods of the RouteMatch class is as follows:

Zend\Router\RouteMatch class methods:

Name 					Desc

getMatchedRouteName() 	Gets the name of matched route

getParams() 			Get all parameters

getParam($name, $default) Get a specific param

In most cases, it will be sufficient to use he Params controller plugin, but alternatively you can use the
RouteMatch object for accomplishing the same task.

To get the RouteMatch object from your 	controller's action method, you can use the following code:

//An example action
public function someAction()
{
	//Get the RouteMatch object
	$routeMatch = $this->getEvent()->getRouteMatch();

	//Get matched route's name
	$routeName = $routeMatch->getMatchedRouteName();

	//Get all route parameters at once as an array
	$params = $routeMatch->getParams();
}

In the above example, we use the getEvent method of the AbstractActionController base class to retrieve 
the MyEvent object, which represents the event (in ZF3, the app life cycle consits of events).

We then use the getRouteMatch() method of the MvcEvent class to retrieve the RouteMatch object.

In line 8, we use the getMatchedRouteName() method to retrieve the name of the route that matched the
HTTP request, and in line 11, we retrieve all the parameters from the route.

The MvcEvent class can also be used for retrieving the router (the top-level route clas). You can do this 
with the getRoute() method of the MvcEvent class as follows:

//Call this inside of your action method
//to retrieve the RouteStackInterface for the router class
$router = $this->getEvent()->getRouter();

In the code above, we use the getRouter() method, which returns the RouteStackInterface interface. This
interface is the base interface for both SimpleRouteStack and TreeRouteStack, and it provides the methods
for working with the routes contained inside the route stack.

Generating URLs from Route:

The main task of any route class is to determine wether this given route matches the HTTP request, and on match,
return the set of parameters by which a controller and action can be determined.

An oppposite task a route class allows to do is generating a URL by page. It can also be used inside view
templates for generating hyperlinks.

Generating URLs in View Templates:

Your web pages usually contain hyperlinks to other pages. These links may point either to a page internal 
to your site or to a page on another site. A hyperlink is represented by the <a> tag in HTML having the href
attribute specifying the URL of the desitnation page.

Below, an example:

<a href="http://example.com/path/to/page">A link lol</a>

When we generate links that are internal to our site, we need not absolute paths:

<a href="/path/to/internal/page">Internal link lol</a> //Just skip the hostname

To generate URLs in your view templates (phtml files), we can use the URL view helper class, which takes the
route name as an input arg:

<!-- A hyperlink to Home Page -->
<a href="<?= $this->url('home'); ?>">Home page</a>

<!-- A hyperlink to About page -->
<a href="<?= $this->url('about'); ?>">About page</a>

In the lines above, we generate two relative URLs. In line 2, we call the Url view helper and pass the
"home" route name as its param. In line 5, we pass the "about" route name as an arg for the Url view helper.

In the example above, the Url view helper internally uses the RouteMatch object and calls the Literal route
to assemble the URL string by route name.

After the PhpRenderer class executes the view template's code, the output HTML markup wil be the following:

<!-- A hyperlink to Home page -->
<a href="/">Home Page</a>

<!-- A hyperlink to About Page-->
<a href="/about">About page</a>

Passing Parameters:

If a route uses some variable parameters, you should pass them to the Url view helper as the second argument:

<!-- A hyperlink to About page -->
<a href="<?= $this->url('application', ['action' => 'about']); ?>" >
	About Page
</a>

<!-- A hyperlink to a Barcode image -->
<a href="<?= $this->url('application', ['action' => 'barcode',
	'type' => 'code39', 'text' => 'HELLO-WORLD']); ?>" >
	Barcode image </a>

In the example above, we use the Url view helper to generate the two URLs by route name and parameters.
We pass the "application" route name as teh first argument, and an array of parameters as the second argument.

In line 2, we pass the "action" parameter to tell the Segment route class that it should substitute the
corresponding wildcard in the route string with the "about" string.


As another example, let's make a link to our Regex route (the one that serves our "static" pages).

<!-- A hyperlink to Introduction Page -->
<a href="<?= $this->url('doc', ['page'=>'introduction']); ?>">
	Introduction </a>

This will generate the following HTML markup:

<!-- a Hyperlink to introduction page -->
<a href="/doc/introduction.html"> Introduction </a>

Generating Absolute URLs:

If you need to generate an absolute URL (having the scheme and host name), you can specify the third
param for the Url view helper. The third param should be an array containing one or several options.

For assembling the absolute URL, pass the force_canonical option, as follows:

<!-- A hyperlink to Home Page -->
<a href="<?= $this->url('home', [], ['force_canonical' => true]); ?>" >
	Home Page</a>

<!-- A hyperlink to About Page -->
<a href="<?php echo $this->url('application', ['action' => 'about'],
	['force_canonical' => true]); ?>" > About Page </a>

In line 2 of example above, we pass the "home" route name as the first argument, empty array as the second
argument, and an array containing force_canonical option as the third argument.

AS the third option, we pass the force_canonical option for generating the URL of the About page.

The resulting HTML markup of the code above will be as follows:

<!-- A hyperlink to Home Page -->
<a href="http://localhost/" > Home Page </a>

<!-- A hyperlink to About Page -->
<a href="http://localhost/application/index/about" > About page </a>

Specifying Query part:

If you want your URL to have a Query part, you can specify the query option in the third argument
of the Url view helper. For example, assume you have the "search" action in some controller (and a route 
mapped ot this action), and you want to pass it search query string and count output results per page.

The url for htis action would be like this: "http://localhost/search?q=topci&count=10". To generate 
such a URL, you can use the following code:

<a href="<?= $this->url('search', [], ['force-canonical' => true, 'query'=>['q'=>'topci', 'count'=>10]]); ?>" >
	Search </a>

In the code above, we specify the query option, which is the array containing name=>value pairs 
of the query params.

Generating URLs in Controllers:

You can generate URLs inside your controller's action methods using the Url controller plugin. To generate
a URL, you call the url controller plugin's fromRoute() method, as follows:

//An example action method
public function someAction()
{
	//generate a URL pointing to the Home page ('/')
	$url1 = $this->url()->fromRoute('home');

	//generate an absolute URL pointing to the About page
	// ('http://localhost/appllication/about')
	$url2 = $this->url()->fromRoute('application',
				['action'=>'about'], ['force_canonical'=>true]);
}

The arguments the Url plugin takes and their meaning are identical to the Url view helper's ones.
So, you can generate absolute or relative URLs the same way you did in your view templates.

URL Encoding:

When generating URLs either with the Url view helper or with the Url controller plugin, you should
remember that URLs may only contain "safe" chars from The ASCII set. Thus, if you pass the param containing
unsafe chars, these will be encoded with % and hexadecimal.

For example, let's try to generate a URL for our Regex route and pass it the "page" param, with the value "/chapter1/introduction":

<!-- A hyperlink to Introduction page -->
<a href="<?= $this->url('doc', ['page'=>'chapter1/introduction']); ?>">
	Introduction </a>

Because of that the / is unsafe, we would get the following URL encoded:

<!-- a Hyperlink to INtroduction page -->
<a href="/doc/chapter1%2Fintroduction.html"> Introduction </a>

It won't be usable because it does not match the regex route.

Writing Own Route Type:

Althought ZF3 has many route types, we might need to make our own.

One example of the need for such a custom route type is when you have to define the URL mapping
rules dynamically. Usually you store the routing configuration in module's config file, but in some CMS systems
you will have documents stored in the DB.

For such a system, you would need to develop a custom route type which would connect to the DB and perform route
matching against the data stored in the DB. You cannot store this information in config file, because new documents
are created by system admins. //The hell i can't

RouteInterface:

We know that every route class must implement the Zend\Router\Http\RouteInterface interface.
The methods of this interface is as follows:

RouteInterface methods:

name 						Desc

factory($options) 			Static method for creation of the route class.

match($request) 			Method which performs match against the HTTP request data.

assemble($params, $options) Method for generating URL by route parameters.

getAssembledParams() 		Method for retrieving parameters that were 	utilized for URL generation.

The static factory() method is used by the ZF3 router (TreeRouteStack or SimpleRouteStack) for instansiating the route class.
The router passes the options array an argument for the factory() method.

The match() method is used to perform the matching of the HTTP request (or particullarly its URL) against the options 
data passed to the route class through the factory().

The match() method should return either an instance of the RouteMatch class on successful match, or null on failure.

The assemble() method is used for generating URL string by route parameters and options. The getAssembledParams() helper
method's purpose is to return the array of parameters which were used on URL generation.

Custom Route Class:

To demonstrate the creation of a custom route type, let's improve our previous approach to building the simple 
documentation system with Regex route type. The disadvantage of the Regex route type is that you cannot organize
the static pages in a hierarchy by creating subdirectories under the doc directory (when generating an URL for such
a page, the / dir symbol gets encoded as its seen as unsafe).

We will create our own StaticRoute class that allows to fix this issue:

Moreover, the class we will create is more powerful, because it willy not only recognize URLs starting
with "/doc" and ending with ".html". Instead, it will recognize generic URLs like "/help" and "/support/chapter1/introduction"

What we want to achieve:

The StaticRoute class should be insertable to the route stack (to SimpleRouteStack or to TreeRouteStack) and usable
together with other route types.

The route class should recognize generic URLs like "/help" or "/introduction"

The route class should match the URL against the dir structure. For example, if the URL is "/chapter1/introduction"
then the route should check if the corresponding view template file <base_dir>/chapter1/introduction.phtml 
exists and is readable, and if so, report match. If the file does not exist (or not readable), return the failure status.

The route class should check the URL for acceptable file names using a regex. For example, the file name "Introduction"
is acceptable, but the name of "intro$duction" is not, so then the failure should be returned.

The route should be able to assemble the URL string by route name and parameters.

To start, create the Route subdir under the module's source directory and put the StaticRoute.php file inside of it:

helloworld //php project from skeleton
	VSource Files
		>config
		>data
		vmodule
			vapplication
				>config
				vsrc
					>Controller
					VRoute
						StaticRoute.php
					Module.php
				>test
				>view
		>public
		>vendor

Inside that file, paste the stub code presented below:

<?php
namespace Application\Route;

use Traversable;
use \Zend\Router\Exception;
use \Zend\Stdlib\ArrayUtils;
use \Zend\Stdlib\RequestInterface as Request;
use \Zend\Router\Http\RouteInterface;
use \Zend\Router\Http\RouteMatch;

//Custom route that serves "static" web pages
class StaticRoute implements RouteInterface
{
	//Create a new route with given options
	public static function factory($options = [])
	{
	}

	//Match a given request
	public function match(Request $request, $pathOffset = null)
	{
	}

	//Assemble a URL by route params.
	public function assemble(array $params = [], array $options = [])
	{
	}

	//Get a list of parameters used while assembling
	public function getAssembledParams()
	{
	}
}

Here, we place the StaticRoute class inside of it of the Application\Route namespace.

We define some name aliasing for making class names shorter

We also define the stub for the StaticRoute class. The StaticRoute class implements the RouteInterface 
interface and defines all the methods specified by the interface: factory(), match(), assemble(), getAssembeledParams()

Next, let's add several protected properties and the constructor method to the StaticRoute class, as below:

<?php
//...

class StaticRoute implements RouteInterface
{
	//base view dir
	protected $dirName;

	//Path prefix for the view templates
	protected $templatePrefix;

	//File name pattern
	protected $fileNamePattern = '/[a-zA-Z0-9_\-]+/';

	//Defaults
	protected $defaults;

	//List of assembeled parameters
	protected $assembledParams = [];

	//Constructor
	public function __construct($dirName, $templatePrefix, $fileNamePattern, array $defaults [])
	{
		$this->dirName = $dirName;
		$this->templatePrefix = $templatePrefix;
		$this->fileNamePattern = $fileNamePattern;
		$this->defaults = $defaults;
	}

	//..
}

First, we define the base view dir name, which will serve to be the dir name of where we store the "static" view templates.
Then, we define the $templatePrefix class variable for storing the prefix for prepending to all view template names.

The $fileNamePattern variable that will be used for checking the file name.

We define the constructor method that is called on instance creation for initializing the protected props.

Next, we define the factory() method for our StaticRoute custom route class. The factory() method will be called
by the router for instansiating the route class:

<?php
//...

class StaticRoute implements RouteInterface
{
	//...

	//Create a new route with given options
	public static function factory($options = [])
	{
		if($options instanceof Traversable) {
			$options = ArrayUtils::iteratorToArray($options);
		} elseif (!is_array($options)) {
			throw new Exception\InvalidArgumentException(__METHOD__ . ' expects an array or Traversable set of options.');
		}

		if (!isset($options['dir_name'])){
			throw new Exception\InvalidArgumentException('Missing "dir_name" in options array.');
		}

		if (!isset($options['template_prefix'])){
			throw new Exception\InvalidArgumentException('Missing "template_prefix" in options array.');
		}

		if (!isset($options['filename_pattern'])) {
			throw new Exception\InvalidArgumentException('Missing "filename_pattern" in options array');
		}

		if (!isset($options['defaults'])) {
			$options['defaults'] = [];
		}

		return new static(
			$options['dir_name'],
			$options['template_prefix'],
			$options['filename_pattern'],
			$options['defaults']);
	}
}

In the example above, we see that the factory() method takes the options array as the argument. The oprions array
may contain options for configuring the route class. The StaticRoute class will accept the following options:

dir_name 	- the base dir where to store all "static" view templates

template_prefix 	- the prefix to prepend to all template names

filename_pattern 	- the regex for checking file names

defaults 			- parameters returned by router by default

Once we have parsed the oprions, we call the class' constructor method to instansiate and return the StaticRoute 
object.

The next method we add to the StaticRoute route class is the match() method:

<?php
//...

class StaticRoute implements RouteInterface
{
	//...

	//match a given request
	public function match(Request $request, $pathOffset=null)
	{
		//Ensure this route type is used in a HTTP request
		if (!method_exists($request, 'getUri')) {
			return null;
		}

		//Get the URL and its Path part
		$uri = $request->getUri();
		$path = $uri->getPath();

		if($pathOffset!=null)
			$path = substr($path, $pathOffset);

		//Get the array of path segments
		$segments = explode('/', $path);

		//Check each segment against allowed file name template
		foreach ($segments as $segment){
			if (strlen($segment)==0)
				continue;
			if(!preg_match($this->fileNamePattern, $segment))
			return null;
		}

		//Check if such a .phtml file exists on disk
		$fileName = $this->dirName . '/' .
				$this->templatePrefix.$path.'.phtml';

		if(!is_file($fileName) || !is_readable($fileName)) {
			return null;
		}

		$matchedLength = strlen($path);

		//Prepare the RouteMatch object
		return new RouteMatch(array_merge(
			$this->defaults,
			['page'=>$this->templatePrefix.$path]
			),
			$matchedLength);
	}
}

In the code above, we can see that the match() method takes two arguments: the HTTP request object (an instance of
Zend\Stdlib\Request class) and the URL path offset. The request object is used for accessing the request URL.

THe path offset parameter is a non-negative int, which points to the portion of the URL the route is matched against.

We then extract the segments from URL. Then we check if every segment is an acceptable file (directory) name.
If it is not, we return null as a failure status.

We then calculate the path to the view template, and go to check if such a file really exists and is accessible 
for reading. This way we match the URL against the directory structure.

We then prepare the RouteMatch object with the default options, plus the page parameter containing the view
template name for rendering.

To complete the implementation of our StaticRoute class, we add the assemble() and getAssembleParams() methods,
that will be used for generation of URLs by route parameters.

They are as follows:

<?php
//...

class StaticRoute implements RouteInterface
{
	//...

	//Assemble a URL by route params
	public function assemble(array $params = [], array $options = [])
	{
		$mergedParams = array_merge($this->defaults, $params);
		$this->assembledParams = [];

		if(!isset($params['page'])) {
			throw new Exception\InvalidArgumentException(__METHOD__ . ' expects the "page" parameter');
		}

		$segments = explode('/', $params['page']);
		$url = '';
		foreach($segments as $segment){
			if(strlen($segment)==0)
				continue;
			$url .= '/' . rawurlencode($segment);
		}

		$this->assembledParams[] = 'page';

		return $url;
	}

	//Get a list of parameters used while assembling.
	public function getAssembledParams()
	{
		return $this->assembledParams;
	}
}

In the code above, we define the assemble() method, which takes two arguments: the parameters array and the options array.
The method constructs the URL by encoding the segments with URL encoding and concatenating them.

The method getAssembledParams just returns the names of he parameters we used for URL generation.

Now we've finished the StaticRoute route class. To use our custom route type, we add the following configuration
to the module.config.php configuration file:

'static' => [ //Define the routing rule to be named static
	'type' 	=> StaticRoute::class,
	'options' => [
		'dir_name' 			=> __DIR__ . '/../view', //The base dir where static pages are placed
		'template_prefix' 	=> 'application/index/static', //template pre-fix
		'filename_pattern' 	=> '/[a-z0-9_\-]+/', //filename pattern
		'defaults' => [ //name of Controller and action
			'controller' => Controller\IndexController::class,
			'action' 	 => 'static',
		],
	],
],

Do not forget to insert the following line to the beginning of the module.config.php class:

use Application\Route\StaticRoute;

The final step is creating the action method in the IndexController class:

public function staticAction()
{
	//Get path to view template from route params
	$pageTemplate = $this->params()->fromRoute('page', null);

	if($pageTemplate==null){
		$this->getResponse()->setStatusCode(404);
		return;
	}

	//Render the page
	$viewModel = new ViewModel([
			'page'=>$pageTemplate
		]);
	$viewModel->setTemplate($pageTemplate);
	return $viewModel;
}

The action above is almost identical to the action we used for the Regex route. 

We retrieve the page parameter from route, save it as the $pageTemplate variable.
We create the ViewModel variable container, and we explicitly set the view template name for rendering.

To see the system in action, let's add a couple of "static" view pages: the Help page (help.phtml), and the introduction
page (intro.phtml)

Create the static subdirectory under the view/application/index directory of the Application module and put the help.phtml
view template there:

<h1>Help</h1>

<p>
	See the help <a href="<?= $this->url('static',
		['page'=>'/chapter1/intro']); ?>">introduction</a> here.
</p>

Then create the chapter1 subdirectory in the static directory and put the following chapter1/intro.phtml file
in there:

<h1>Introduction</h1>

<p>
	Write the help introduction here
</p>

The final product should look as follows:

	Vview
		Vapplication
			Vindex
				>doc
				vstatic
					vchapter1
						intro.phtml
					help.phtml
				about.phtml
				index.phtml
		>error
		>layout
>public
>vendor

Eventually, open the following URL in your browser: http://localhost/help. The Help page should appear.
if we type the http://localhost/chapter1/intro URL in our browser, we'd see the intro site.

We can create more static pages, just by adding the phtml files under the static directory and they will automatically
become available to site users.

All of this, in a working format, exists in the Hello World application example.

In this chapter, we've learned about routing. Routing is used for mapping HTTP request to controller's action method.
There are several route types (Literal, Segment, Regex, Hostname, Scheme, Method etc.).

Each route type uses different URL parts (and possible, other data from HTTP request) to compare the URL with the specified
route template. We also learned how to write custom route class if the capacity of the standard route types are not
sufficient.

The main task of a route class is to return a route match containg the set of parameters, by which a controller
and action can be determined. An opposite task a route class allows to do is generating a URL by parameters.

This feature is widely used in view layer of the application for generating links.

Route types can be combined in a nested tree with the help of TreeRouteStack router, or organized in a chain
with SimpleRouteStack router. These two routers allow to define arbitrary complex rules.

Routing configuration is stored in module's configuration files under the router key. Each module exposes
its own routing rules, which are merged with other module's configuration upon application start up.

Page Appearance and Layout:

In this chapter, we will learn how to make our websites look better, with the help of Twitter Bootstrap CSS
Framework and how to position elements on a page using ZF3 layout mechanisms. We'll also become familiar
with common view helpers allowing for composing web pages of reusable parts.

If you are new to Twitter Bootstrap, it is also recommended that you refer to the Appendix C, later on
for advanced description of Bootstraps Capabilities.

ZF3 Components covered here:

Component 						Description

Zend\Mvc 				Support of MVC pattern. Implements base controller classes, controller plugins, etc.

Zend\View 				Implements the functionality for variable containers, rendering a web page and common view helpers.

About CSS Stylesheets and Twitter Bootstrap:

In a ZF3-based website, for defining the visual appearance and style of the web pages, CSS is utilized.
These CSS files are typically stored in APP_DIR/public/css directory.

Since CSS is shit in terms of complexity, there are frameworks for it. Like bootstrap.

Twitter Bootstrap is shipped with the Zend Skeleton Application, so we can use it out of the box.
Alternatively, we get hte latest version.

Generally, the BS does the following things:

It provides the CSS reset that is a style sheet defining styles for all possible HTML elements.
This ensures your web site will look the same way in all web browsers.

It provides the base CSS rules that define style of typography (headings and text), tables, forms, buttons,
images and so on.

It defines the grid system. The grid system allows you to arrange elements on your web page in a grid-like structure.
For example, the Skeletons main page has 3 columns.

It defines useful web interface components like dropdown menus, nav bars, breadcrumbs, pagination and so on.
For example, on the skeleton's app's main page, there is the nav bar component at the top, and the header
(Also called the Hero unit or Jumbotron) component below the navbar.

These components are very handy on any website.

In includes the Javascript extensions that allow to make Bootstrap-provided interface components more interactive.
For example, JavaScript is used to animate dropdown menus and display modals.

The general layout of the main page of the skeleton app:

< 					NavBar 						>



< 					Hero Unit (Jumbotron) 		>

<column 1> 			<column 2> 			<column 3>

Page Layout in ZF3:

Pages of your website typically have some common structure that can be shared among them. For example,
a typical page has the <!DOCTYPE> declaration to identify the HTML document, and the <head> and <body> elements:

<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Welcome</title>
		<!-- Include metas, stylesheets, and scripts here -->
	</head>
	<body>
		<!-- Include page content here -->
	</body>
</html>

The <head> element contains the page title text, meta info and referencces to include stuff.
The <body> element contains the content of the page, like the logo image, the nav bar, page text,
and the footer with copyright info.

In ZF3, you define this common structure with the "master" view template called the layout. The layout
"decorates" other view templates.

The layout template typically has a placeholder in which ZF3 puts the content specific to a particular 
page.

For example:

<Project name>
<Navbar>

<page content PH>

<Footer>

In the Skeleton Application, the default layout template file is called layout.phtml and is located
inside of the view/layout directory in Application module's directory:

Vhelloworld //php project from skeleton app
	VSource Files
		>config
		>data
		Vmodule
			VApplication
				>Config
				>src
				Vview
					>application
					>error
					Vlayout
						layout.phtml
					Module.php
		>public
		>vendor

The layout.phtml is as follows:

<?= $this->doctype() ?>

<html lang="en">
	<head>
		<meta charset="utf-8">
		<?= $this->headTitle('ZF Skeleton Application')
				 ->setSeparator(' - ')->setAutoEscape(false) ?>

		<?= $this->headMeta()
			   ->appendName('viewport', 'width=device-width, initial-scale=1.0')
			   ->appendHttpEquiv('X-UA-Compatible', 'IE=edge')
		?>

		<!-- Le Styles -->
		<?= $this->headLink(['rel' => 'shortcut icon', 'type' => 'image/vnd.microsoft.icon',
							 'href' => $this->basePath() . '/img/favicon.ico'])
			->prependStylesheet($this->basePath('css/style.css'))
			->prependStylesheet($this->basePath('css/bootstrap-theme.min.css'))
			->prependStylesheet($this->basePath('css/bootstrap.min.css'))
		?>

		<!-- Scripts -->
		<?= $this->headScript()
			->prependFile($this->basePath('js/bootstrap.min.js'))
			->prependFile($this->basePath('js/jquery-2.2.4.min.js'))
		?>
	</head>
	<body>
		<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
			<div class="container">
				<div class="navbar-header">
					<button type="button" class="navbar-toggle" data-toggle="collapse"
							data-target=".navbar-collapse">
					  <span class="icon-bar"></span>
					  <span class="icon bar"></span>
					  <span class="icon-bar"></span>
					</button>
					<a class="navbar-brand" href="<?php echo $this->url('home') ?>">
						<img src="<?= $this->basePath('img/zf-logo.png') ?>"
							alt="Zend Framework <?= \Application\Module::VERSION ?>"/>
							&nbsp;Skeleton Application
					</a>
				</div>
				<div class="collapse navbar-collapse">
					<ul class="nav navbar-nav">
						<li class="active">
							<a href="<?= $this->url('home') ?>">Home</a>
						</li>
					</ul>
				</div>
			</div>
		</nav>
		<div class="container">
			<?= $this->content; ?>
			<hr>
			<footer>
				<p>&copy; 2005 - <?= date('Y') ?> By Zend Technologies Ltd.
					All rights reserved.
				</p>
			</footer>
		</div>
		<?= $this->inlineScript() ?>
	</body>
</html>

You can see that the layout.phtml file (as a usual view template) consists of HTML tags mixed with PHP code fragments.
When the template is being rendered, ZF3 evaluates the inline PHP fragments and generates resulting HTML page visible
to site users.

Line 1 generates the <!DOCTYPE> of the HTML page with the Doctype view helper, declaring what version of HTML we are using
and what format we are going to convert to.

Line 3 defines the <html> element representing the root of the HTML document. The <html> tag is followed by the <head>
tag, which typically contains a title for the document, and can include other information, like scripts, CSS styles
and meta info.

In line 5, the <meta> tag provides the browser with a hint that the document is encoded using UTF-8 char encoding.
The UTF-8 allows any char from any alphabet, so we will use that.

In line 6, we have the HeadTitle view helper that allows to define the title for the page ("ZF Skeleton Application").
The title will be displayed in the web browser's caption. The setSeparator() method is used to define the separator
character for the compound page titles; the setAutoEscape() method enhances the security by escaping unsafe characters
from the page title.

A "compound" page title consits of two parts, the first is defined by the layout, the second by a particular page,
added to hte previous. For example, the about page, would have "About - ZF Skeleton Application" and for the
Documentation page you will have something like "Documentation - ZF Skeleton Application"

In line 9, the HeadMeta view helper allows to define the <meta name="viewport"> tag containing meta information
for the web browser to control layout on different display devices, including mobile browsers.

The width property controls the size of the viewport, while the initial-scale property controls the zoom level
when the page is loaded. This makes the web page layout "responsive" to device viewport size.

In line 15, the HeadLink view helper allows to define the <link> tags. With the <link> tags, you typically define
the "favicon" for the page (located in APP_DATA\public\img\favicon.ico file) and the CSS stylesheet.

In lines 17-19, the stylesheets common to all site pages are included by the prependStylesheet() method
of the HeadLink view helper. Any page in our website will load three CSS stylesheet files: bootstrap.min.css
(the minified version of Twitter Bootstrap CSS Framework), bootstrap-theme.min.css (the minified Bootstrap theme stylesheet)
and style.css(CSS file allow us to define our own CSS rules overriding Bootstrap CSS rules).

Lines 23-25 include the JavaScript files that all your web pages will load. The scripts are executed by
the client's web browser, allowing to introduce some interactive features for your pages. We use the 
bootstrap.min.js (minified version of Twitter Bootstrap), and jquery-2.2.4.min.js (minified version of jQuery)
scripts.

All scripts are located in APP_DIR/public/js directory

Line 28 defines the <body> tag, the document's body which contains all the contents of the document, such
as nav bar, text, hyperlinks, images, tables, lists, etc.

In lines 29-52, we can recognize the Bootstrap navigation bar definition. The skeleton application uses
the collapsible navbar with dark inverse theme. The navbar contains the single link Home.

If we look at 53-61, we notice the <div> element with container class which denotes the container element
for the grid system. So you can use the Bootstrap grid system to arrange the contents of your pages.

Line 54, is very important, because this line defines the inline PHP code that represents the page 
content placeholder we talked about in the beginning of this section.

When the ZF3 page renderer evaluates the layout template, it echoes the actual page content here.

Lines 56-60 define the page footer area. The footer contains the copyright information like "2016 by Zend
Technologies Ltd. All rights reserved." You can replace this information with our own companyn ame.

Lines 62 is the PH for JS scripts loaded by the concrete page. The InlineScript view helper will substitute here
all the scripts you register (about registering JavaScript scripts, we will see this in action later).

And finally, line 63-64 contain the closing tags for the body and the HTML document.

Modifying the Default Page Layout:

To demonstrate how you can define your own page layout, we will modify the original layout
of the Zend Skeleton Application website. We want to make it display the "Hello World" page title, the "Hello World" header
text at the top, the nav bar and breadcrumbs below the header, page content placeholder in the middle of the page and
the footer with the copyright info at the bottom.

Let us start with the Hello World page title. We replace the lines 6-7 in layout.phtml as follows:

<?= $this->headTitle('Hello World')->setSeparator(' - ')->setAutoEscape(false) ?>

Next, we will use the Bootstrap-provided grid system for arranging the main blocks on the page.
Replace the HTML code of the <body> elements (28-63) with the following one:

<body>
	<div class="container">
		<div class="row">
			<!-- Page header -->
			<div class="col-md-4">
				<div class="app-caption">Hello world!</div>
			</div>
		</div>
		<div class="row">
			<div class="col-mid-12">
				<!-- Navbar -->
			</div>
		</div>
		<div class="row">
			<div class="col-md-12">
				<!-- breadcrumbs -->
			</div>
		</div>
		<div class="row">
			<div class="col-md-12">
				<!-- Page content placeholder -->
				<?= $this->content; ?>
			</div>
		</div>
		<div class="row">
			<div class="col-md-12">
			<hr>
			<p>&copy; 2005 - <?= date('Y') ?> By your company. All rights reserved.</p>
		</div>
	</div> <!-- /container -->
	<?php echo $this->inlineScript() ?>
</body>

In the code above, we defined the <div> element with the container class and put the <div> elements 
of the grid inside of it. The grid consists of 5 rows:

THe page header containing the "Hello World" text (line 3-8). The header text spans four grid columns. For styling
the text, we use our custom CSS class app-caption (we define this later in the style.css)

We left the space for nav bar interface component on line 11

In line 16, we have the space for breadcrumbs component.

In line 22, we have the page content placeholder. When the renderer evaluates the page, it will echo the
value of the $content variable, so the actual page content will be substituted here.

And in line 25-29, we provided the page footer with the text "(c) 2013 by your company, all rights reserved". We can change
it and replace our own stuff there, the name that is.

Where it says navbar, we now put in the navigation bar:

<!-- Navigation Bar -->
<nav class="navbar navbar-default" role="navigation">
	<div class="collapse navbar-collapse navbar-ex1-collapse">
		<ul class="nav navbar-nav">
			<li class="active">
				<a href="<?= $this->url('home') ?>">Home</a>
			</li>
			<li>
				<a href="<?= $this->url('application', ['action'=>'downloads']) ?>">
					Downloads
				</a>
			</li>
			<li class="dropdown">
				<a href="#" class="dropdown-toggle" data-toggle="dropdown">
					Support <b class="caret"></b>
					<ul class="dropdown-menu">
						<li>
							<a href="<?= $this->url('doc', ['page'=>'contents']) ?>">
								Documentation
							</a>
						</li>
						<li>
							<a href="<?= $this->url('static', ['page'=>'help']) ?>">
								Help
							</a>
						</li>
					</ul>
				</a>
			</li>
			<li>
				<a href="<?= $this->url('about') ?>">About</a>
			</li>
		</ul>
	</div>
</nav>

In the code above, we used the navbar interface component provided by the Bootstrap. We also used the Url view 
helper to insert the links to the navigation items.

We discussed the usage of the Url view helper in the Generating URLs from Route section in Model-View-Controller.

next, we put the breadcrumbs in their respective slot:

<!-- Breadcrumbs -->
<ol class="breadcrumb">
	<li class="active">Home</li>
</ol>

Finally, we need to provide a couple of custom CSS rules to fine-tune the look and feel. We define our 
own CSS rules in the style.css stylesheet.

We want to make the "Hello World!" header text to use larger bold font and use a nice looking color.
To do this, open the style.css file and append the following lines to the end:

div.app-caption {
	padding: 25px 0px;
	font-size: 3.0em;
	font-weight: bold;
	color: #6aacaf
}

In the css above, we created the app caption class which can be applied to <div> element and defining the
25 pixels vertical padding, large font size, bold text style and the hexadecimal representation of RGB text color.

By default, in skeleton application, the navbar is pinned to page top, and the CSS rule for the page body defines
the 20 pixels top padding to leave space for it. Since in our Hello World example we've unpinned the navigation
bar from top of the page and place it in page flow, we need to remove the padding from page body top.

To do that, edit the body CSS rule in the style.css file and make it look like the one below:

body {
	padding-bottom: 40px;
}

Great, we've completed the page layout template. To see the results of the change, open the site in your brwoser,
you should see the page as in above. You can click the links in navigation bar to visit the pages like About or Documentation, etc.

The content of a particular page is put into the content placeholder of our layout.

The result can be seen in action in the Hello World sample application that is part of this book's example code available
on GitHub.

Switching Between Layouts:

By default, ZF3 provides you with a single layout template layout.phtml. In real-life apps, you will probably need 
to have several layouts and switch the layout for certain controller/action.

For example, you may have a front-end and a back-end part of your site. The front-end part would consist of web pages
publiclly visible to all users and would utilize the default layout for all of these pages.

The back-end part would consist of pages visible to the admin user and utilize another layout template containing 
the admin menu.

First, prepare another layout template file. For example, call it layout2.phtml. To simplify the file preparation,
copy the content of the default layout.phtml and make the necessary changes.

When the second layout template is ready, we can switch between layouts for a particular controller's action
by using the following code:

//A controller's action method that uses an alternative layout template
public function indexAction()
{
	//...

	//Use the layout plugin to access the ViewModel
	// object associated with layout template
	$this->layout()->setTemplate('layout/layout2');

	//..
}

In the example above, we use the layout controller plugin that allows to access the instance of the viewModel class
associated with the layout template. To change the layout template for this particular action method, we called the
setTemplate() provided by the ViewModel class.

In additon to the Layout controller plugin, there is the Layout view helper which provides the same capabilities.
With the Layout view helper, we can for example, switch template from the "static" page which has no specific controller action.

Setting Layout for All Actions of a Controller:

If all action methods of a controller class need to use he same alternative layout, we can override the 
onDispatch() method of the AbstractActionController class and call the setTemplate() method there, as shown in the following:

//Add this alias in the beginning of the controller file
use Zend\Mvc\MvcEvent;

//...

class IndexController extends AbstractActionController
{
	/**
	  * We override the parent's class onDispatch() method to
	  * set an alternative layout for all actions in this controller.
	  */
	public function onDispatch(MvcEvent $e)
	{
		//Class the base class' onDispatch() first and grab the response
		$response = parent::onDispatch($e);

		//Set the alternative layout
		$this->layout()->setTemplate('layout/layout2');

		//return the response
		return $response;
	}
}

Partial Views:

A partial view is a .phtml view template file which can be rendered by another view template. Partial views allows
to compose your page of pieces and reuse pieces of view rendering logic across different view templates.

For a simple example of partial view usage, let's imagine that we need to render a table of some products.
Each product has the ID, the name and the price. We can use partial view template to render a single row
of the table several times.

First, let's add the partialDemoAction() method to the index controller:

//An action that demonstrates the usage of partial views.
public function partialDemoAction()
{
	$products = [
		[
			'id' => 1,
			'name' => 'Digital Camera',
			'price' => 99.95,
		],
		[
			'id' => 2,
			'name' => 'Tripod',
			'price' => 29.95,
		],
		[
			'id' =# 3,
			'name' => 'Camera Case',
			'price' => 2.99,
		],
		[
			'id' => 4,
			'name' => 'Batteries',
			'price' => 39.99,
		],
		[
			'id' => 5,
			'name' => 'Charger',
			'price' => 29.99,
		],
	];

	return new ViewModel(['products' => $products]);
}

The action method above just prepares an array of products for rendering and passes it to the view template with the help
of the ViewModel variable container.

Next, add the partial-demo.phtml template file:

<?php
$this->headTitle('partial view demo');
?>

<h1>Partial View Demo</h1>
<p>
	Below , the table of products is presented. It is rendered with the help of 
	partial views.
</p>
<table class="table table-striped table-hover">
	<tr>
		<th>ID</th>
		<th>Product</th>
		<th>Price</th>
	</tr>

	<?php
		foreach ($this->products as $product) {
			echo $this->partial('application/index/table-row', ['product'=>$product]);
		}
	?>
</table>

In the view template above, we define the markup for the table of products (lines 10-22). In line 18, we walk through
the items of the products array and render each row with the Partial view helper.

The first argument of the Partial view helper is the name of the partial view template file ("application/index/table-row")

The second argument of the Partial view, should be an array of arguments passed to the view template. They will
be accessible the same was as if you would pass them with the ViewModel variable container.

Finally, create the table-row.phtml view template, which will be used as the partial view template:

<tr>
	<td> <?= $this->product['id'] ?> </td>
	<td> <?= $this->product['name'] ?> </td>
	<td> <?= $this->product['price'] ?> </td>
</tr>

In the view template above, we just render a single row of teh table.

To see the resulting web page, type "http://localhost/application/partialdemo" URL in your webbrowsers navbar. 

Placeholder View Helper:

The Placeholder is another useful view helper allowing for capturing HTML content and storing it for later use.
Thus, analogous to the Patrial view helper, it allows us to compose our page of several pieces.

The Placeholder view helper stores the data in PHP session storage. In theory, this means that we can capture
content on one page and then render/use it on another one.

For example, you can use the Placeholder view helper in pair with the Partial view helper to "decorate" the
content of a view template with another view template. A useful practical application for this is layout "inheritance".

Imagine the situation, when you need to create an alternative layout which has exactly the same head section, header
and the footer, but has differences in the middle page section. 

The "brute force" way of solving this, would be to copy and paste the content of the original layout template, and make
necessary changes. Another (better) way, is "inheriting" the original one, when the resulting layout will reuse the 
common parts.

To demonstrate how to inherit a layout, we will create the layout2.phtml view template, which will inherit the default
layout.phtml template, and add the Ads bar at the right of the page. Keeping ads in layout would be useful, if we
plan to profit from commercial ads.

Put the following code in the layout2.phtml template file:

<?php $this->placeholder('content')->captureStart(); ?>

<div class="row">
	<div class="col-md-8">
	<?= $this->content; ?>
	</div>
	<div class="col-md-4">
		<div class="panel panel-default">
			<div class="panel-heading">
				<h3 class="panel-title">Ads</h3>
			</div>
			<div class="panel-body">
				<strong>Zend Framework 3 book</strong>
				<p>Learn how to create modern web applications with PHP and ZF3</p>
				<a target="_blank"
					href="https://github.com/olegkrivstov/using-zend-framework-3-book">
					Learn More
				</a>
			</div>
		</div>
	</div>
</div>

<?php
	$this->placeholder('content')->captureEnd();
	echo $this->partial('layout/layout',
			['content'=>$this->placeholder('content')]);
?>

In the code above, we begin capturing the HTML to store internally instead of sneding out, from line 1, with the
captureStart() call, and then we end with the captureEnd() call.

In lines 3-23, we put the markup of the "Inherited" layout. The derived layout uses the two-cell grid. 
The first cell of the grid (spanning 8 columns) will contain teh actual content of a certain page, and the second
cell (spanning 4 columns) will contain advertisements. 

For styling the ads, we use the Panel interface component provided by bootstrap.

In line 27, we use the Partial view helper which is used to render the "parent" layout (layout.phtml).
We pass the content captured by the Placeholder view helper to the Partial view helper as the second argument.

This way, we produced the nice-looking layout which inherits the default layout and improves the code reusability.

now, if we set it to the layout2.phtml for all actions, of, say Index controller, you should be able to see the 
result.

Adding Scripts to a Web Page:

JavaScript code can be inserted into HTML pages and makes them interactive. Scripts should be inserted to an
HTML file between <script> and </script> tags. Below, an example:

<script type="text/javascript">
	//A simple alert
	$(document).ready(function(){
		alert('Hello World');
	});
</script>

In the example above, we created the <script> element and put the jQuery callback function in it. 
The jQuery binds a function to be executed when the DOM has finished loading. When the function is executed,
a simple alert window with the "Hello World!" text and OK button will appear.

Since you put this JS code inside the HTML file, we will refer to it as inline script. An alternative
way of storing JS is putting it in external .js files. External files typically contain code that is desinged
to be used by several web pages. Typically, external JS files are stored in APP_DIR/public/js/ dir. To link an
external JS file to your html page, just add them in the script tags:

<script type="text/javascript" src="/js/yourscript.js"></script>

When the browser encounters such a <script> element, it reads the external JS file and executes the code.

Generally, there are two places inside an HTML file where you can put the script:

JS code can be put in the <head> section of an HTML page. This method is recommended to use when you need JS
to be loaded before the content of the page. We used this method for loading the Twitter BS JS extensions and
jQuery lib.

Script can be placed at the bottom of the <body> section of an HTML page, just before the closing </body>
tag. This way is acceptable when you need the netire DOM to be loaded before the script can start executing.

If a certain JS file needs to be used on all (or on most) of the web pages, it is better to place it in Layout
view template. But when a script needs to be used on a single page only, putting it in the layout template
is not the best idea.

If we put such a script to layout template, the script will be loaded to all pages, which can produce an unneeded
traffic and increase page load time for the whole site. To avoid this, you can add such a script for the desired
page only.

To add a page-specific script which will be put in the <head> section of the web page, you use the HeadScript
view helper. It's methods are summarized as follows:

Method Name 						Desc

appendFile() 				Puts a link to external JS file after all others.

offsetSetFile() 			Inserts a link to external JS file in a given list position

prependFile() 				Puts a link to external JS file before all others

setFile() 					Clears the list of scripts and puts the single external JS file in it.

appendScript() 				Puts an inline script after all others

offsetSetScript() 			Inserts an inline script to a given list position

prependScript() 			Puts an inline script before all others

setScript() 				Clears the list of inline scripts and puts the single inline script in it

To add a link to external JS files to the <head> section of a page, we add the following PHP code in the beginning
of our view template (.phtml) file:

<?php
$this->headScript()->appendFile('/js/yourscript.js', 'text/javascript');
?>

In the code above, we called the appendFile() method of the HeadScript view helper. This method takes two arguments.
The first one is the path to external JS file (if the file is stored inside APP_DIR/public/js dir, or an URL of a JS file
if the file is located on another web server).

The second argument is just the type of argument (usually text/javascript)

Other methods provided by the HeadScript view helper (such as prependFile(), offsetSetFile() and setFile() differentiate only
in the position in the list of scripts into which the new script will be inserted.)

The methods prependScript(), appendScript(), offsetSetScript() and setScript() are designed to insert an inline JS code.
They are rarely used, because you typically insert external JS scripts in the head section of the document.

To insert a script to the end of the <body> section of the document, you can use the InlineScript view helper. It provides
exactly the same methods as the HeadScript view helper. Below, an example is presented which can be used to append 
an inline JS code to the end of document body.

NOTE: THe name InlineScript does not fully reflect the capabilities of this view helper. Actually, it can insert both inline and external
scripts. The better name for this view helper would be BodyScript, because it is intended for inserting Scripts in document body.

<?php
$script = <<<EOT
	$(document).ready(function() {
		alert('Hello World!');
	});
EOT;
$this->inlineScript()->appendScript($script);

In the example above, we use the PHP's Heredoc syntax to fill in the $script variable with the inline JS code.
Then we call the appendScript() function of the InlineScript view helper and pass the code as its arg.

Heredoc is an alternative string definition method provided by PHP. It works well with multi-line strings.

But using the InlineScript view helper may be not very convinient in sense of readability. Moreover, Netbeans IDE
syntax checker will be stuck on the Heredoc notations and will not recognize the JS code.

To fix this, we can simply put the <script> tag at the bottom of your view tempalte, as follows:

<!-- Page content goes first -->

<!-- Inline script goes last -->
<script type="text/javascript">
	$(document).ready(function() {
		//Show a simple alert
		alert("Hello world!");
	});
</script>

This ensures the same effect as InlineScript view helper, but allows for better script readability and
automatic syntax checking in the netbeans IDe.

For HeadScript and Inline script view helpers to work, you should ensure their content is echoed in layout
view template (look at line 23 and 62 of layout.phtml file). If you remove those lines from the layout template
the scripts won't be inserted in the web page.

Example:

For a real-life example inserting a JS code in our web page, let's add a page with auto-complete feature.
With this feature, the web browser will predict a word or phrase that the user wants to type in by several
first letters, without the user actually entering the text compeltely.

We can use an auxilliary JS lib called Twitter Typeahead. Analogous to Twitter BS, the Typeahead lib
was developed by Twitter for internal reasons.

Download typeahead.min.js file (a minified version of the Typeahead lib) from the official project page. 
When the download is done, place the ifle in your APP_DIR/public/js dir

Then add the typeahead.phtml file in your application/index/static subdir under the module's view dir.
This directory is served by the StaticRoute route type that we've created and configuread earlier 
in the chapter of ROuting, and all "static" pages placed there will be made available to site users. (The old dir since previous)

In the typeahead.phtml viewttemplate file, put the following:

<?php
$this->headTitle('Typeahead');
//add a JS file
$this->headScript()->appendFile('/js/typeahead.min.js', 'text/javascript');
?>

<h1>Typeahead</h1>
<p>Type a continentn ame (lol) in the text field below</p>
<input type="text" class="typeahead" title="Type here"/>

<script type="text/javascript">
	$(document).ready(function(){
		$('input.typeahead').typeahead({
			name: 'continents',
			local: [
				'Africa',
				'Antarctica',
				'bla',
				'etc'
			]
		});
	});
</script>

IN the code above, we set the title, append the tpyahead.minjs file to the head by using the headScript's appendFile() method.

We then create a input textfield wher ehte user can enter stuff

We set the JS script on the bottom, use the typeahead on the input to check against what the persno is writing
and suggest stuff there after.

The selector we use the input elements with the typeahead class  annotation

The typeahead method takes two args, the name arg identifies the dataset, and the second is a JSON array with variables which are the
auto-complete variants.

To give the auto-completion field and its dropdown menu a nice-looking visual appearance, add the following CSS rules 
to your style.css file:

.typeahead,
.tt-query,
.tt-hint {
	width: 396px;
	height: 30px;
	padding: 0px 12px;
	font-size: 1.1em;
	border: 2px solid #ccc;
	border-radius: 4px;
	outline: none;
}

.tt-dropdown-menu{
	width: 422px;
	margin-top: 12px;
	padding: 8px 0;
	background-color: #fff;
	border: 1px solid #ccc;
	border: 1px solid rgba(0, 0, 0, 0.2);
	border-radius. 4px;
}

.tt-suggestion {
	padding: 3px 20px;
	font-size: 1.1em;
	line-height: 24px;
}

.tt-suggestion.tt-is-under-cursor {
	color: #fff;
	background-color: #0097cf;
}

.tt-suggestion p {
	margin: 0;
}

To see the auto-completion feature at work, we just type the "http://localhost/typeahead" url in our browser and press enter.
The Typeahead page will appear and it will work as we expect it to.

We can see the complete working example in the Hello World sample bundeled with this book by typing the URL "http://localhost/typeahead".

Adding CSS Stylessheets to a Web page:

CSS stylesheets are typically placed to the <head> section of an HTML document, either as a link to an external file 
(external CSS stylesheet files are usually stored in APP_DIR/public/css dir)

<link rel="stylesheet" type="text/css" href="/css/style.css">

Or as an inline <style> element:

<style>
	body {
		padding-top: 60px;
		padding-bottom: 40px;
	}
</style>

To store the CSS rules, external CSS stylesheets are recommended. For example, the base CSS rules provided by
Twitter Bootstrap CSS framework are loaded from bootstrap.min.css and bootstrap-theme.min.css file.

Custom site-specifc CSS rules can be stored in style.css file. Since you need this CSS stylesheets for most
of your pages, it is better to link them in the head section of the layout template.

But, if a certain CSS stylesheet needs to be loaded for a single page only, you place it on that page's
view template.

To add an external CSS stylesheet to a view template, you use the HeadLink view helper:

<?php
$this->headLink()->appendStyleSheet('/css/style.css');
$this->headLink()->appendStyleSheet('//code.jquery.com/ui/1.10.3/themes/smoothness/jquery-ui.css');

In the example above, we used the appendStylesheet method of the HeadLink view helper to add an external
CSS stylesheet to the head section of the document. The method accepts a path to local CSS file, or a URL to CSS
file located under another sever, as per the second one.

The summary of the headLink view helper's methods are as follows:

Methods provided by HeadLink view helper:

Method name 					Desc

appendStylesheet() 			Puts a link to CSS stylesheet file after all others.

offsetSetStylesheet() 		Inserts a link to CSS stylesheet file in a given list position

prependStyleSheet() 		Puts a link to external CSS stylesheet file before all others.

setStylesheet() 			Clears the list and puts the single CSS file instead.

If we wish to add an inline <style> element in the head section of the document, you can use the HeadStyle view helper.
its methods are as follows:

Methods of the HeadStyle view helper:

Method Name 				Desc

appendStyles() 			Adds an inline CSS code after all others.

offsetSetStyle() 		Inserts an inline CSS stylesheet file in a given list position.

prependStyle() 			puts a link to external CSS stylesheet file before all otehrs

setStyle() 				Clears the list and puts the single CSS file instead.

Example:

To demonstrate how to add a CSS stylesheet, we will take a real-life example. Assume we need to add
a date-picker with a jQuery datepicker widget.

We download the two jquery files needed for this:

jquery-ui.min.js 		- Minified version of jQuery UI JS code.

jquery-ui.min.css 		- The minified version of jQuery UI theming styles.

jQuery UI provides a set of "user interface interactions, effects, widgets, and themes". It is based on the jQuery library,
jQuery UI is analogoous to Twitter BS in the sense of reusable UI components.

Put the jquery-ui.min.js file to APP_DIR/public/js and jquery-ui.min.css file to APP_DIR/public/css. Finally, add the
datepicker.phtml view template to the application/index/static dir under the module's view directory:

<?php
$this->headTitle('Datepicker');

$this->headScript()->appendFile('/js/jquery-ui.min.js', 'text/javascript');
$this->headLink()->appendStylesheet('/css/jquery-ui.min.css');
?>

<h1>Datepicker</h1>

<p>
	Click the edit box below to show the datepicker
</p>

<input type="text" class="datepicker" title="Type here"/>

<script>
	$(document).ready(function() {
		$("input.datepicker").datepicker({ dateFormat: 'yy-mm-dd' });
	});
</script>

In the example above, we use the HeadScript view helper's appendfile() method to add the link to jquery-ui.min.js file
to the head section of the document.

In line 5, we used the HeadLink view helper's appendStyleSheet() method to add the link to jquery-ui.min.css CSS stylesheet
to the head section of the document.

in line 14, we added the text input field which will be used to enter the date.

In line 16-20, we added an inline JS code for binding jQuery event handler to the text input field. When the user clicks
the text input field, the datepicker widget 	will appear allowing to select date.

Writing Own View Helpers:

Earlier in this chapter, we've created the layout common to all pages of the web site. But we still have a couple of things
to do to make the layout fully functional. If you remember, the layout template contains the navigation bar and breadcrumbs.

But both navigation bar and breadcrumbs interface components provided by Twitter Bootstrap are currently "static", while 
they need to be more interactive.

For example, the active item of the nav bar should depend on the controller's action that is being executed at the
moment. And the breadcrumbs should display the path to the currently viewed page. In this seciton, we will make these
widgets completely ready for the website with the help of our own view helpers.

A typical view helper is a PHP class deriving from Zend\View\Helper\AbstractHelper base class, which in turn implements
the Zend\View\Helper\HelperInterface interface: (Inheritance is as follows)

HelperInterface
	^
	^
	^
AbstractHelper
	^
	^
   Menu

Menu:

First, let's implement the Menu view helper class that will render the HTML code of teh nav bar. The Menu class
will provide several methods allowing set the menu items in a form of array, set the active menu item and render
the menu:

Methods of the Menu view helper:

method name 						Desc

__construct($items) 			Class constructor

setItems($items) 				Method for setting the menu items

setActiveItemId($activeItemId) 	method for setting the currently active menu item

render() 						Renders the menu

renderItem($item) 				Renders a single menu item

The information describing a single menu item will be represented by an array like below: (For example, the Home item will
have an id, text, label and URL for a hyperlink):

[
	'id' => 'home',
	'label' => 'Home',
	'link' => $this->url('home')
]

We also want to add the support for dropdown menus as nav items. For example, in case of the Support dropdown menu
having the Documentation and Help sub-items, the item desc will take the following form:

[
	'id' => 'support',
	'label' => 'Support',
	'dropdown' => [
		[
			'id' => 'documentation',
			'label' => 'Documentation',
			'link' => $this->url('doc', ['page'=>'contents'])
		],
		[
			'id' => 'help',
			'label' => 'Help',
			'link' => $this->url('static', ['page'=>'help'])
		]
	]
]

We want to put hte menu class in the Application\View\Helper namespace. Thus,start by creating the Menu.php
file in the ViewHelper dir under Application module's Source dir:

vhelloworld //App from skeleton structure
	vsource files
		>config
		>data
		vmodule
			vApplication
				>config
				vsrc
					>Controller
					>Route
					VView
						vHelper
							Menu.php
						Module.php
				>test
				>view
		>public
		>vendor

Why do we place the view helper class under module's source directory?

View helpers (unlike .phtml view templates) are stored under module's src/ directory, because they are 
usual PHP classes and require to be resolved by a PHP class auto-loading feature. On the other hand,
view templates are resolved by the special ZF3 class called view resolver, and for this reason,
views are under the module's view/ directory

Next, we create the stub code for the Menu Class:

<?php
namespace Application\View\Helper;

use Zend\View\Helper\AbstractHelper;

//This view helper class displays a menu bar
class Menu extends AbstractHelper
{
	protected $items = [];

	//Active item's ID
	protected $activeItemId = '';

	//Constructor
	public function __construct($items=[])
	{
		$this->items = $items;
	}

	//Sets menu items
	public function setItems($items)
	{
		$this->items = $items;
	}

	//Sets ID of the active items
	public function setActiveItemId($activeItemId)
	{
		$this->activeItemId = $activeItemId;
	}
}

In the code above, we define several private fields under the menu class. The $items field is an array which
will store the info on the menu items, and the $activeItemField is the ID of an atcive menu item. The active menu item 
will be visually highlighted.

In lines 16-19 we define the class constructor method, which (optionally) takes the array of items for initializing the
menu. An alternative method of menu initialization is through the setItems() method (line 22-25). And the setActiveItemId()
method (line 28-31) sets the Id of the currently active menu item.

Next, let's add the render() method, which will generate HTML code for the whole navigation bar and return it as a text string:

//Render hte menu
public function render()
{
	if (count($this->items)==0)
	 	return ''; //Do nothing if there are no items



	 $result = '<nav class="navbar navbar-default" role="navigation">';
	 $result .= '<div class="navbar-header">';
	 $result .= '<button type="button" class="navbar-toggle" ';
	 $result .= 'data-toggle="collapse" data-target=".navbar-ex1-collapse">';
	 $result .= '<span class="sr-only">Toggle navigation</span>';
	 $result .= '<span class="icon-bar"></span>';
	 $result .= '<span class="icon-bar"></span>';
	 $result .= '<span class="icon-bar"></span>';
	 $result .= '</button>';
	 $result .= '</div>';

	 $result .= '<div class="collapse navbar-collapse navbar-ex1-collapse">';
	 $result .= '<ul class="nav navbar-nav">';

	 //Render items
	 foreach ($this->items as $item) {
	 	$result .= $this->renderItem($item);
	 }

	 $result .= '</ul>';
	 $result .= '</div>';
	 $result .= '</nav>';

	 return $result;
}

In the code above, we make the HTML markup for the Bootstrap navbar component . The navbar will use the default
theme and will be collapsible (adaptive to differen screen widths). The navbar will not have the brand text 
in teh header.

In lines 22-24, we loop through the menu items and render each one with the renderItem() method. Finally, the render()
method returns the resulting HTML code as a text string.

To finish with creating the Menu class, Let's implement the renderItem() method. This method will produce the HTML
code for a single menu item:

//Render an item
protected function renderItem($item)
{
	$id = isset($item['id']) ? $item['id'] : '';
	$isActive = ($id==$this->activeItemId);

	$label = isset($item['label']) ? $item['label'] : '';

	$result = '';

	if (isset($item['dropdown'])) {
		$dropDownItems = $item['dropdown'];

		$result .= '<li class="dropdown ' . ($isActive?'active':'') . '">';
		$result .= '<a href="#" class="dropdown-toggle" data-toggle="dropdown">';
		$result .= $label . ' <b class="caret"></b>';
		$result .= '</a>';

		$result .= '<ul class="dropdown-menu">';

		foreach ($dropdownItems as $item) {
			$link = isset($item['link']) ? $item['link'] : '#';
			$label = isset($item['label']) ? $item['label'] : '';

			$result .= '<li>';
			$result .= '<a href="' .$link.'">'.$label.'</a>';
			$result .= '</li>';
		}
	} else {
		$link = isset($item['link']) ? $item['link'] : '#';

		$result .= $isActive?'<li class="active">':'<li>';
		$result .= '<a href="'.$link.'">'.$label.'</a>';
		$result .= '</li>';
	}

	return $result;
}

In the renderItem() method's code above we did the following. First, we checked wether the item is a dropdown menu or a simple
item (line 10). If the item is a dropdown menu, we walk through the dropdown menu items, and render each one in return (line 21-28).
Lines 35-39 contain teh rendering cod efor he case of a simple item.

to be able to use the Menu view helper in a view template, it is required to register it in configuration
To do that, add the following view_helpers key in the module.config.php file:

<?php
return [
	//...

	// The following registers our custom view
	// Helper classes in view plugin manager.
	'view_helpers' => [
		'factories' => [
			View\Helper\Menu::class => InvokableFactory::class,
		],
		'aliases' => [
			'mainMenu' => View\Helper\Menu::class
		]
	],
];

IN the example above, we registered our menu class as a mainMenu view helper and will bea ble to access it 
from any view template.

Since we plan to use the Menu view helper in the layout view template, replace the navigation menu markup in
layout.phtml with the following code:

<!-- navigation bar -->
<?php
	$this->mainMenu()->setItems([
		[
			'id' => 'home',
			'label' => 'Home',
			'link' => $this->url('home')
		],
		[
			'id' => 'downloads',
			'label' => 'Downloads',
			'link' => $this->url("application", ['action'=>'downloads'])
		],
		[
			'id' => 'support',
			'label' => 'Support',
			'dropdown' => [
				[
					'id' => 'documentation',
					'label' => 'Documentation',
					'link' => $this->url('doc', ['page'=>'contents'])
				],
				[
					'id' => 'help',
					'label' => 'Help',
					'link' => $this->url('static', ['page'=>'help'])
				]
			]
		],
		[
			'id' => 'about',
			'label' => 'About',
			'link' => $this->url('about')
		],
	]);

	echo $this->mainMenu()->render();
?>

IN the code above, we access the registered mainMenu view helper and set the navigation bar items with the help of setitems()
method (line 3). As a param for the method, we pass the array of items. Then we render the navigation bar with render() method.

To set the active item for the navigation bar, we can call the setActiveItemId() method from any view template. 
For example, add the following code to the beginning of the view template for the ABout page (applicaton/index/about.phtml) as follows:

<?php
$this->mainMenu()->setActiveItemId('about');
?>

Now, if you open the About page in your browser, you should see that the About item of the navigation menu is highlighted
with a different color. To display the activei tem properly, you need to call the setActiveItemId() method for each apge
presenting in the navbar (home, downloads, documentaiton etc.), we can see how this is done in the Hello World sample.

Breadcrumbs:

now that you know how to implement a view helper, let's create the second view helper for rendering the breadcrumbs.
It is completely analogous to the Menu view helper, so below we just provide the complete code for the Breadcrumbs class:

<?php
namespace Application\View\Helper;

use Zend\View\Helper\AbstractHelper;

//This view helper class displays breadcrumbs
class Breadcrumbs extends AbstractHelper
{
	//array of items
	private $items = [];

	//Constructor
	public function __construct($items=[])
	{
		$this->items = $items;
	}

	//Sets the items
	public function setItems($items)
	{
		$this->items = $items;
	}

	//Renders the breadcrumbs
	public function render()
	{
		if(count($this->items)==0)
			return ''; //Do nothing if there are no items

		//Resulting HTML code will be stored in this var

		$result = '<ol class="breadcrumb">';

		//Get hte item count
		$itemCount = count($this->items);

		$itemNum = 1; //item counter

		//walk through items
		foreach ($this->items as $label=>$link) {
			
			//make the last item inactive
			$isActive = ($itemNum==$itemCount?true:false);

			//Render current item
			$result .= $this->renderItem($label, $link, $isActive);

			//increment item counter
			$itemNum++;
		}

		$result .= '</ol>';

		return $result;
	}

	//Renders an item
	protected function renderItem($label, $link $isActive)
	{
		$result = $isActive?'<li class="active">':'<li>';

		if(!$isActive)
			$result .= '<a href="'.$link.'">'.$label.'</a>';
		else
			$result .= $label;

		$result .= '</li>';

		return $result;
	}
}

To be able to use the Breadcrumbs view helper, register it with the module.config.php file as follows:

<?php
return [
	//...

	//The following registers our custom view helper classes
	'view_helpers' => [
		'factories' => [
			View\Helper\Breadcrumbs::class => InvokableFactory::class,
		],
		'alises' => [
			'pageBreadcrumbs' => View\Helper\Breadcrumbs::class,
		]
	],
];

Since we plan to use teh breadcrumbs view in the layout view tempalte, replace the breadcrumbs markup in layout.phtml
file with the following code:

<!-- breadcrumbs -->
<?= $this->pageBreadcrumbs()->render(); ?>

In the code above, we access the pageBreadcrumbs() view helper and call it with the render() method.
The echo operator then outputs the HTML code of the breadcrumbs.

Finally, you need to pass the breadcrumbs items for each view template. For example, add the following lines in the view
template for the About page:

<?php
$this->pageBreadcrumbs()->setItems([
			'Home'=>$this->url('home'),
			'About'=>$this->url('about'),
			]);
?>

Now, if we open the about page, we should see breadcrumbs as in Links clickable or inactive if that is the current page.

View Models and Page Composition:

Earlier, when we wrote action methods, for the controller classes, we used the ViewModel class as a variable container
for passing the variables from controller to view template, and we also used the ViewModel for overriding the default view
templates name.

But actually, the ViewModel class is more than just a variable container plus the view template name. IN fact, it is 
closely related to the layout and page composition.

The third big capability of the view model class is that it allows for combining several view models in a tree-like
structure. Each view model in the tree has the associated view template name and data variables that can be passed to
the view template to control the process of rendering.

This feature is inernally used by ZF3 when "combining" the layout view template file and the view template
associated with the controller's action method. ZF3 internally creates the view model for the layout template
and assigns it with layout/layout view template name.

When your controller's action method returns the ViewModel object, this objecti s attached as a child to the layout
view model:

Layout view model >>>>>>>> layout/layout.phtml //$content

		^
		^
		^ 	View models have parent-child relation
		^
		^
View model returned from >>>>>>>>>> application/index/index.phtml
indexAction() method

The resulting process of page rendering is the following:

The child view model is visited first and its associated view template is rendered, and the resulting HTML markup
is saved in a temporary storage.

The output HTML markup of the child view model is passive to the layout view model as the $content variable.
This way the layout view template can render hte content specific to the certain page.

THe following table gives a summary of the methods provided by the ViewModel class for the purpose of page compositon:

Methods of the ViewModel class for page comp.:

Method name 				Desc

addChild() 			Adds a child view model

getChildren() 		Gets the list of child view models.

hasChildren() 		Tells if the view model has children or not

clearChildren() 	Removes all children view models

count() 			Returns count of child view models

getIterator() 		Returns the iterator for child view models

setTerminal() 		Sets the terminal flag

terminate() 		Tests wether the view model is terminal

setCaptureTo() 		Sets the name of the variable for capturing the output

setAppend() 		Sets the append flag

isAppend() 			Tests wether to append this view model to another one

Below, we provide the brief desc of the methods presented above:

the addChild(), getChild()	, hasChildren() and clearChildren() are used for (respectively), adding a child view model
to the parent one, retrieving the array of view models attached, testing if the view model is leaf (does not have chidlren)
and detaching all children.

The setCaptureTo() method allows to set the variable in the parnet view template into which to inejct the HTML markup code
produced by a child view template. If two child view models use the same var, the second one overwrites the first one.

The setAppend() method can be used when you need to inject the results of two or more view templates into a single PH variable.
The next rendered view template will be appended to the variable's existing content. The view model returned by the controller
is assigned the $content capture variable.

A view model can be marked as terminal with the setTerminal() method. The setTerminal() method takes a single flag param.
If true, the view model is considered as terminal (top-level parent) and teh renderer returns the output of the view template 
to the application, otherwise its parenrs are rendered as well. The method terminate() tests whether the view model is terminal or not.

The setTerminal() method is very useful in some situations, because with its help you can disable the rendering of the 
layout view template. If you return from the controller the view model marked as terminal, the layout will not be applied.

This can be used, for example, when you want to load part of a page asynch with Ajax request and need to isnert its
HTML code into the DOM tree of an existing page.

Summary:

ZF3 is shipped with BS and provides the base CSS rules, simple layout grid, useful interface components (like navbars, breadcrumbs,
pagination etc.)

In a typical web site, pages have common structure (for example, a typical page may have a nav bar at the top, the body 
with page content, and the footer with the copyright information at the bottom). in Zf3, you define this common structure
with a view template file called the layout. The layout template may have PHs in which ZF3 puts the content specific
to a particular page.

view helpers are (relativily) simple PHp classes that encapsulate a part of page rendering work. For example, they
allow for composing the page  of several parts, setting page title, meta tags, and creating the reusable 
widgets like navbars or breadcrumbs.

Collecting User Input with Forms:

In this chapter, you will become familar with using web forms for gathering data entered by website users.
In ZF3, functionality for working with forms is mainy spread across four components: 

Zend\Form: Allows us to build forms and contains the view helpers for rendering form elements.

Zend\Filter, Zend\Validator, Zend\InputFilter components which allow you to filter and validate 
user input.

Also, there is a special "integration" component Zend\Mvc\Form that is designed for integrating forms
into an MVC web application.

Component 						Desc

Zend\Form 			Contains base form model classes

Zend\Filter 		Contains various filters classes

Zend\Validator 		Implements various 	validator classes

Zend\InputFilter 	Implements a Container for filters/Validators

Zend\Mvc\Form 		Integrating forms with an MVC application

Zend\Mail 			Contains e-mail sending functionality

Get the Form Demo Sample from GitHub:

We will demonstrate form usage on the Form Demo sample web appl bundled with the book. 
This sample is a complete web site we can install and see teh working forms in action.

To download the Form Demo app, visit the Link in 7.1 and click Clone or Download to download
the code as a zip archive. When the download is complete, unpack the archive to a dir of your choosing.

Then navigate to the formdemo directory which contains the complete source code of the Form Demo web app:

/using-zf3-book-samples
	/formdemo
	...

To install this example, we can either edit the default VH file or create a new one. After editing the file,
restart the Apache HTTP Server and open the web site in your web browser. For additonal info on Apache VHs,
we can refer to appendix A.

About HTML Forms:

Form functionality provided by ZF3 internally uses HTML forms. Because of that, we start with a brief introduction
to HTML forms topic.

In HTML, forms are enclosed with <form> and </form> tags. A form typically consits of fields: text input fields, 
check boxes, radio buttons, submit buttons, hidden fields and so on.

HTM provides several tags intended for defining form fields:

<input> - specifies an input field where the user can enter some data (field appearance and behavior depends on the field type.)

<textarea> - multi-line text area which can contain an unlimited number of chars

<button> - a clickable button

<select> - a dropdown list

<option> - used inside the <select> element for defining the available options in a dropdown list.

The <button> field is analogous to <input type="button">, however, it allows for greater capacity, such as a graphical
icon etc.

As follows, we can find examples of HTML form field defs. 

Standard HTML form fields:

Field 						Definition

Text input field 			<input type="text">

Text area 					<textarea rows=4></textarea>

Password 					<input type="password">

Button 						<input type="button" value="Apply"> or <button type="button">Apply</button>

Submit Button 				<input type="submit" value="Submit">

Image (graphical sbm btn) 	<input type="image" src="button.jpg">

Reset button 				<input type="reset" value="Reset">

Checkbox 					<input type="checkbox">Remember me</input>

Radio 						<input type="radio" value="Radio">Allow</input>

Select 						<select><option>Enable</option><option>Disable</option></select>

File 						<input type="file">

Hidden field 				<input type="hidden">

HTML5 introduced several new form field types.

HTML5 fields provides more convenient ways for entering the most frequently used data types: numbers, dates, e-mails,
URLs etc. Additionally, on form submit, the web browser validates that the user entered data is in a correct format, and
if not the browser will prevent form submission and ask the user to correct the input error.

HTML5 Form fields:

Field 						Definition

Color picker 				<input type="color">

Date 						<input type="date">

Date-time (with time zone) 	<input type="datetime">

Date-time (Without time zone) <input type="datetime-local">

Email address 				<input type="email">

Number 						<input type="number">

Time 						<input type="time">

Month 						<input type="month">

Week 						<input type="week">

URL 						<input type="url">

Range (Slider) 				<input type="range">

Search field 				<input type="search" name="googlesearch">

Telephone number 			<input type="tel">

Fieldsets:

We can group related form fields with the help of the <fieldset> tag, as shown in the example below. 
The optional <legend> tag allows you to define the caption for the group.

<fieldset>
	<legend>Choose a payment method:</legend>
	<input type="radio" name="payment" value="paypal">PayPal</input>
	<input type="radio" name="payment" value="card">Credit Card</input>
</fieldset>

Example "Contact Us" form:

An example of a typical HTML form is presented below:

<form name="contact-form" action="/contactus" method="post">
	<label for="email">E-mail</label>
	<input name="email" type="text">
	<br>
	<label for="subject">Subject</label>
	<input name="subject" type="text">
	<br>
	<label for="body">Message</label>
	<textarea name="body" class="form-control" rows="6"></textarea>
	<br>
	<input name="submit" type="submit" value="submit">
</form>

In the example above, we have the feedback form which allows the user to enter his E-mail address, message subject,
and text, and then submit them to the server. The form definition begins with the <form> tag. (line 1)

The <form> tag contains several important attributes:

the name attribute specifies the name of the form

the action attributes defines the URL of the server-side script which is responsible for processing the submitted form

the method attribute defines the method (either GET or POST) to use for delivering form data. In this example, we use
the POST method (Recommended).

In line 3, we define a text input field with the help of the <input> element. The name attribute specifies the name
of the field ("email"). The type attribute specifies the purpose of the element (the type "text" means the input field 
is intended for entering text)

In line 2, we have the <label> element which represents the label for the E-mail text input field (the corresponding input 
field's name is determined by the for attribute of the <label> element)

In lines 5-6, by analogy, we have the "Subject" input field and its label.

In line 9, we have the text are field which is suited well for entering multi-line text. The height of the text area (6 rows)
is defiend by the rows attribute.

In line 11, we have the submit button (input element with "submit" type). The value attribute allows you to
set the title text for the button ("Submit"). By clicking this button, the user will send the form data to the server.

Line break <br> elements are used in lines 4,7,10 to position form controls one below another (Otherwise they would be
positioned in one line).

If we entered some data in the feedback and clicked the Submit button, the browser will send an HTTP request to the 
URL we specified in the Action attribute of the form. The HTTP request will contain the data we entered.

GET and POST Methods:

HTML forms support GET and POST methods for submitting the data to the server. These methods have important technical
differencens.

When using POST method for submitting the form, the data is sent in HTTP request body. For exmaple, when we press the Submit
button on the feedback form, an HTTP request will look like the example below:

POST http://localhost/contactus HTTP/1.1
Host: localhost
Connection: keep-alive
Content-Length: 76
Accept: text/html,application/xhtml+xml,application/xml
Origin: null
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64)
Content-Type: application/x-www-form-urlencoded

email=name%40example.com&subject=Example+Subject&body=Hello%21&submit=Submit

Above, you can see that the form data is transmitted in request body (line 10, last line). Form fields are concatenataed
in a single string and then URL-encoded to replace unsafe chars with allowed chars from the ASCII table.

In comparison, when you set the GET method for the form, an HTTP request will look like below:

GET http://localhost/contactus?email=name%40example.com&subject=Example+Subject&body=Hello%21&submit=Submit HTTP/1.1
Host: localhost
Connection: keep-alive
Accept: text/html, application/xhtml+xml, application/xml
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64)
Accept-Encoding: gzip,deflate,sdch

In the example above, we can see  that the form data is concatenated, URL-encoded and sent as part of the HTTP request's URL (line 1),
which makes the URL long and harder to read. Since the form data is sent inside the URL, this makes it easily visible to site visitors.

In most cases, you will use the POST method for delivering form data in the request body, because the user doesn't need to 
see  the data in the browser's navigation bar (especially when submitting passwords or other sensitive data)

Please note that submitting data with POST is still not safe. To protect it, use an SSL tunnel. This is the https
protocol, which we can enable in Apache by obtaining an SSL certificate from a trusted provider and install it 
on our server.

Styling HTML Forms with BS:

In ZF3 based websites, we use BS for styling forms and form fields. To apply the CSS rules to a form field (like <input>, <textarea>)
you should assign it the .form-control CSS class. Additionally, when using labels together with input fields, put the label-input
pairs inside of <div> elements with the .form-group CSS class.

For submit buttons, you can use the .btn CSS class plus a theme class like .btn-default, .btn-primary, etc.

A modified example of the Feedback form with BS styling

<h1>Contact Us</h1>

<p>
	please fill out bla bla
	bla.
</p>

<form name="contact-form" action="/contactus" method="post">
	
	<div class="form-group">
		<label for="email">Your email</label>
		<input name="email" type="text" class="form-control"
			   placeholder="name@example.com">
	</div>

	<div class="form-group">
		<label for="subject">Subject</label>
		<input name="subject" type="text" class="form-control"
			   placeholder="Type subject here">
	</div>

	<div class="form-group">
		<label for="body">Message Body</label>
		<textarea name="body" class="form-control" rows="6"
				  placeholder="Type message text here"></textarea>
	</div>

	<input name="submit" type="submit"
		   class="btn btn-primary" value="Submit">
</form>

By default, BS maxes width. To customze it, we can use centering by offsets and grid columns:

<div class="row">
	<div class="col-md-offset-3 col-md-6">
		<form>
			...
		</form>
	</div>
</div>

Making the form be encapsulated by a size md-6 makes it the half of the screen (12 is default entier screen)

Installing ZF3 Form components:

To use forms in an MVC web app, you need to install at least the Zend\Mvc\Form component:

php composer.phar require zendframework/zend-mvc-form

When you install the Zend\Mvc\Form component, there will be installed other components implementing 
forms in ZF3: Zend\Form, Zend\InputFilter, Zend\Filter, Zend\Validator and some few others.

Retrieving Form Data in a Controller's Action:

The website user typically works with the form in the following order:

First, a controller's action is executed rendering the web page containing the form prompting the site
user for input. Once the user fills the form fields, they click the Submit button and this generates an 
HTTP request and sends the data to the server.

Second, in our controller's action method, you can extract the submitted data from POST (and/or GET) variables,
and display the page with the results of the form processing.

Typically these two web pages are handeled by the same controller action.

In the following example, we will showcase how to create a controller action for displaying the feedback form and retrieving
the data submitted by the user. To start, add the contact-us.phtml view template in the application/index/ directory under
the module's view/ directory:

Vformdemo //PHp project Code from github
	V Source Files
		> Config
		> Data
		V Module
			V Application
				> Config
				> Src
				> test
				V view
					V application
						> image
						V index
						  about.phtml
						  contact-us.phtml //In this one
						  index.phtml
						  send-error.phtml
						  thank-you.phtml
					> error
					> layout
		> public

Put the HTML markup code of the feedback form from the previous section into the view template file.

Then, add the contactUsAction() method to the IndexController class. In the action method, we want to 
extract raw data from the feedback form submitted by the site user:

<?php
namespace Application\Controller;

//...

class IndexController extends AbstractActionController
{
	//This action displays the feedback form
	public function contactUsAction()
	{
		//Check if user has submitted the form
		if($this->getRequest()->isPost()) {

			//Retrieve form data from POST variables
			$data = $this->params()->fromPost();

			//Do something with the data
			var_dump($data);
		}

		//pass form variable to view
		return new ViewModel([
				'form' => $form
			]);
	}
}

In the code above, we define the contactUsAction() action method in the IndexContoller class (line 9).

Then, in line 12, we check whether the request is a POST request (checking the starting line of the HTTP request).
Typically, the form uses the POST method for submitting the data. For this reason, we can detect if the form is
submitted or not by checking the starting line of the HTTP request.

In line 15, we retrieve the raw data submitted by the user. We extract all the POST variables with the help
of the Params controller plugin. The data is returned in the form of an array and saved into the $data variable.

Finally, we add a literal route to make a short and memorable URL for the Contact Us page. Add the following
contactus key to the routing config in the module.config.php file:

<?php
return [
	// ...
	'router' => [
		'routes' => [
			//Add the following routing rule for the "Contact Us" page
			'contactus' => [
				'type' => Literal::class,
				  'options' => [
				  	'route' 	=> '/contactus',
				  	'defaults' => [
				  		'controller' => Controller\IndexController::class,
				  		'action' 	 => 'contactUs',
				  	],
				],
			],
		],
	],

	// ...
];

Now if we type http://localhost/contactus in the web browser's nav bar, we should see the expected stuff.

Enter an E-mail, subject, and body text and click the Submit button on the form. The data will be sent to the server,
and finally extracted in the IndexController::contactUsAction() method.

Below, an example of the $data array (produced with the var_dump() PHP function) is shown. As you can see, the array
contains a key for each form field, including the "submit" field.

array (size=4)
	'email' => string 'name@example.com' (length=16)
	'subject' => string 'Happy new year!' (length=15)
	'body' => string 'fok u' (length=4)
	'submit' => string 'Submit' (length=6)

Forms and Model-View-Controller:

In the previous section, we've considered a very simple form usage case: We prepared the view template with form HTML
markup and a controller action responsible for displaying the form and dumping raw user input to the screen.

However, using raw user input in RL apps is silly, cause no validation against malicious/faulty values.

In a ZF3 site that uses the MVC pattern, form functionality is usually separated into form models responsible
for field definition, filtering and validation, and form presentation (view) which is typically implemented
with the help of special view helpers.

The functionality allowing to create form models, add filtering and validation rules and use view helpers,
is schematically shown as follows:

<View Helpers> <InputFilter>
<Base Form     <Validators>
Model Class>   <Filters>
<        HTML Forms 	   >

The MVC approach to working with forms has the following advantages:

You are able to reuse your form model in a different controller's actions.

By using the view helpers, you can (partly) avoid the boring work of preparing HTML markup 
for rendering the form and its possible validation errors.

You are able to create one or several visual representations for the same form model.

By encapsulating the form validation logic in a single form model class you have fewer
places in your code where you need to user input.

A Typical Form Usage Workflow:

Generally speaking, you instansiate a form model inside of your controller's action method, then you
retrieve the user-submitted data from PHP variables, and pass it to the form model for validation.

Form view helpers are used in a view template for generating HTML markup of the form. This typical
workflow is as follows:


					Inside of the Controller's action method, you instansiate the form model and fill it with the data by the user

									<Controller>
								<<<<<<< 	>>>>>>>>
							1	V 				   V  2
								V 				   V
								V  				   V
							<model> <<<<<<<<<<<<< <View>
									     3  			Inside of the .phtml view template, you produce the form HTML markup with form view helpers
						Inside of the form
						model class, we validate
						the submitted form fields,
						and if the data is incorrect
						produce errors.

Our arrows denote the direction of the actions:

1. First, inside of the controller's action method, you retrieve the data submitted by the site user from GET, POST (and possibly other)
PHP vars. Then you create an instnace of the form model and pass it the user-submitted data. The form model's work is to
check (validate) the data format, and if something is wrong, throw an error.

2. Secondly, you pass the form model to the .phtml view template for rendering (with the help of the ViewModel variable container).
The view template then will be able to access the form model and call it's methods.

3. And finally, the view template uses the form model and the view helpers provided by ZF3 to render the form fields
(and to display possible validation error messages produced at the vlaidation stage). As a result the HTML markup of the
form is produced.

We will discuss this in more detail to come.

A Form Model:

A form model is usually a PHP class which creates a number of fields. The base class for all form models is the
Form class defined in the Zend\Form component.

Fields in a form model can optionally be grouped into fieldsets. Moreover, the form model itself can be considered
as a fieldset. This fact is reflected from the class inheritance:

					<Form>
					V 	 V
					V 	 V
				<<<<<    >>>>>>>>
	<FormInterface>    			<FieldSet>
								V 		 V
								V 		 V 
								V 		 V
					<FieldsetInterface>  V
										 V
									<Element>
										V
										V
										V
								<ElementInterface>

The inheritance goes backwards in this picture, the lower we get, the higher we are in the hierarchy.

As you can see from the figure, the Form class extends the Fieldset class. The Fieldset class, in turn, is derived
from the Element class, which represents a single form field and it's attributes.

This class inheritance may look a bit strange at first, but everything becomes logical if you remember that
the Form class inherits methods for adding form fields from the Fieldset class, and that it inherits 
methods for setting form attributes from the Element class.

Below, we provide a stub model class for the feedback form from our previous examples:

<?php
namespace Application\Form;

use Zend\Form\Form;

//A Feedback form model
class ContactForm extends Form
{
	//Constructor
	public function __construct()
	{
		//Define form name
		parent::__construct('contact-form');

		//Set the POST method for this form
		$this->setAttribute('method', 'post');

		//(Optionally) set action for this form
		$this->setAttribute('action', '/contactus');

		//Create the form fields here ...
	}
}

We can see, form models of the web site's Application module (by convention) belong to Application\Form namespace.

In line 7, we define the ContactForm form model class which extends the Form base class.

In line 10, we define the constructor method for the class. Because we derive our form model from the base Form class,
we have to call the parent class' constructor to initialize it (line 13). THe parent class' constructor accepts an
optional argument allowing it to set the form's name ('contact-form')

We can also set form data delivery method (POST) by using the setAttribute() method provided by the base class (line 16).
The setAttribute() takes two parameters: the first one is the name of the attribute to set, and the second one is the
value of the attribute.

You can also set the form's "action" attribute (line 19) with the setAttribute() method, analogoous to the way 
you did with the "name" attribute. Actually, we will see later, that setting the action attribute is optional for a form.

Setting the "action" attribute for the form is optional, because if we omit it, it defaults to submit form data to
the URL of the current page. This is sufficient in most scenarios, because usually you use the single controller
action for both displaying the form and processing its data.

Form fields are typically created inside of the form model's constructor (look at line 21). in the next section,
we will learn which form fields are available and how to add them to the form model.

Form Elements:

In a form model, an input field is typically paired with the text label (<label> and <input> tags are used together).
Such a pair is also called a form model's element.

Analogous to an HTML form field, a form model's element may contain the name and other (optional attributes) 
(e.g "id", "class", etc.). Additionally, you may set options to an element, the options mostly allow you to specify the
text and attributes for the element's label.

All form model's elements are inherited from the base class Element which also belongs to the Zend\Form component.
The Element base class implements the ElementInterface interface. The class inheritance is as follows:

	ElementInterface
			^
			^
		Element

Basically, Element implements the ElementInterface.

Concrete form element classes extend the Element base class. They are listed as follows, and live in the
Zend\Form\Element namespace:

HTML4 Form elements:

Class name 						Desc

Button 			Button

Checkbox 		Check Box

File 			File field

Hidden 			hidden field

Image 			image field

Password 		pw field

Radio 			radio button

Select 			dropdown list

Submit 			submit button

Text 			General-purpose text input field

Textarea 		Multi-line text area

HTML5 Form elements:

Class name 		Desc

Color 			Color picker

Date 			Date picker

DateTime 		Date & time (with time zone)

DateTimeTotal 	Date & time (w/o time zone)

Email 			E-mail field

Month 			Month input field

Number 			A text input field accepting numbers

Time 			Text input field for time

Url 			Text input field for entering an URL

Week 			Text input field for entering days of week

Range 			Range field (Slider)

Compound Fields:

MultiCheckbox 	A group of related check boxes

DateTimeSelect 	Date & time select

DateSelect 		Date select

MonthSelect 	Month select

Security Form elements:

Captcha 		Human check image

Csrf 			Cross-site request forgery prevention

Other form elements:

Collection 		Element Collection

IN the table above, we can see that hte ZF3 provided form elemetns have direct mapping on HTML4 and HTML5 input fields.

For your convenience, ZF3 also provides several "compound" fields. The MultiCheckbox field is a field which is composed
of a group of typical checkboxes related to each other. The DateTimeSelect and MonthSelect elemetns are analogous 
to corresponding HTMl5 elements, but simulate them with the usual select fields.

The sei nput fields have an advantange in that htey are supportedb y all web browsers, unlike the corresponding
HTML5 fields. 

In addition, ZF3 provides the Captcha and CSRF for security purposes. the Captcha is what we have come to expect of Captcha.
The Csrf is just against cross sire reference forgery attacks, and has no visual representation.

Cross-site-reference-forgery is the name of the attack where a malicious user exploits a website by unauthorized commands
from a user that hte website trusts.

THere i another special form of element htati s also called collection. This element is analogous to fieldset, because it
allows you to group related form elements. But, it is designed for adding form elements dynamically bindng an array
of obejcts to the form.

Adding Elements to a Form Model:

The methods inherited by the Form base class from the Fieldset class are used to add elements (and fieldsets) to the
form model. These methods are summarized as follows:

Methods provided by the Fieldset class:

Method name 						Desc

add($elementOrFieldset, $flags) 	Attachs an element or a fieldset.

has($elementOrFieldset) 			Checks wether certain element is attached

get($elementOrFieldset) 			Retrieves the given element or fieldset by name

getFieldSets() 						Retrieves all attached fieldsets

getElements() 						Retrieves all attached elements

count() 							Return the count of attached elements/fieldsets

remove($elementOrFieldset) 			Removes the element (or fieldset)

particularly, we are interested in the add() method which is used to attach an element to a form.

The add() method takes two args, teh first one (named $elementOrFieldset) is an element to insert,
and the second one (named $flags) is optional flags.

The $elemtnorFieldset param may either be an instance of Element-derived class (or the Fieldset class), or an array
describing the element that should be created.

The optional $flags argument is an array which may contain a combination of the following keys: name (allows you to 
set hte element's name) and priority (allows to specify the zero-based index in the list of elements to insert the element to.
If the prio flag is not specified, the element will be inserted at the end of the list of the form model's elements.)

Below, we provide two code exmaples illustrating the possible ways of attaching elements to a form

Method 1: Passing an instance of an element:

The following code fragment creates an instance of the Zend\Form\Element\Text clas and adds the element to the form model.

<?php
namespace Application\Form;

//Define an alias for the class nam,e
use Zend\Form\Form;
use Zend\Form\Element\Text;

//A feedback form model
class ContactForm extends Form
{
	//Constructor
	public function __construct()
	{
		//Create form fields here..

		$element = new Text(
					'subject', //name of element
					[
						'label' => 'Subject' //Array of options, this is our only option, label for the text
					]);
		$element->setAttribute('id', 'subject');

		//Add the "subject field" to the form
		$this->add($element);
	}
}

IN the code above, we created an isntance of the Zend\Form\Element\Text class (line 15). The class constructor
takes two params, the elements name "subject", and an array of options (we specify the text label "Subject")

Additioanly, you may configure the element using the methods provided by the Element base class. For exmaple, in line 20,
we set the "id" attribute with the setAttirbute. For our reference, teh most improtant methods of the element class
is the list as follows, whom are used for configuring a form element:

Methods provided by the Element Class:

Method name 						Desc

setName($name) 						Sets elements name

getName() 							Gets element name

setOptions($options) 				Sets otions

getOption($option) 					Gets the specified option

setAttribute($key, $value) 			Defines a attribute with the key and the value of the key

getAttribute($key) 					Retrieves a single elemtn attribute

removeAttribute($key) 				Removes an attribute

hasAttirbute($key) 					Checks for existence of attribute

setAttributes($arrayOrTraversable) 	Sets a group of attributes

getAttributes() 					Retrieves all attributes at once

clearAttributes() 					Removes all atributes at once

setValue() 							Sets the elemtn value

getValue() 							Retrievs the element value

setLabel() 							Sets the label used for this element

getLabel() 							Retrieves the label string used for this element

setLabelAtributes() 				Sets the attributes to use with the label

getLabelAttributes() 				Gets the attributes to use with the label

setLabelOptions() 					Sets label specific options

getLabelOptions() 					Retreives label specific options

Method 2: uSing array specifications

The second example below (equivilant to the first one), show how to use an array specification to add an element to form.
This method is preferable, since it requires less code to write.

When usign array specification for adding an element to a form, the elemnet will be instansiated and then configured
automatically. Internally, this is accomplished with the help of the Zend\Form\Factory facotry class.

Element, FieldSet, or array specification
				V
				V
				V 				Yes 
		Is it an array? >>>>>>>>>>>>>>> Use Zend\Form\Factory class for instansiating and configuring the element
				V 											V
				V No 									    V
				V 											V
		Add the element to the form <<<<<<<<<<<<<<<<<<<<<<<<

The actual class implementation of this is as follows:

<?php
namespace Application\Form;

//Define an alias for the class name
use Zend\Form\Form;

//A feedback form model
class ContactForm extends Form
{
	//Constructor
	public function __construct()
	{
		//Add "Subject" field
		$this->add([
			'type' => 'text', //Element tyÃ¥e
			'name' => 'subject', //field name
			'attributes' => [ //arary of attributes
				'id' => 'subject',
			],
			'options' => [ //array of options
				'label' => 'Subject', //Set the label
			],
		]);
	}
}

In line 14 above, we call the form model's add() to add the elemnt to the form. We pass the element specification
to the add() method in the form of an array. The array has the following typical keys:

The type key (line 15) defines the class name to use for instansiation of the element. Here you can use either the fully qualified
class name (e.g Text::class) or its short alias (e.g text)

The name key (line 16) defines the name for the field ("subejct")

The attributes key (line 17) defines the list of HTMl attributes to set (here we set hte id attribute)

The options array (line 18) allows us to specify the teext label for the element.

We get the alias name of elements from Zend\Form\FormElementManager class

Example: Creating the Contact Form Model:

Now that we know how to set the form name, action and method attributes and how to add fields (elements) to the form,
let's create the complete model class for the feedback form that we used in our previous examples.

As we know, form model classes for the Application module live inside the Application\Form namespace. So, we have to
create the ContactForm.php inside of the Form direcotry under the Application module's source dir:

Vformdemo //PHP project file from repo
	V Source Files
		> config
		> data
		V module
			V Application
				> config
				V src
					> Controller
					> Filter
					V Form
						ContactForm.php
						ImageForm.php
					> Service
					> Validator
					> View
					Module.php
				> test
				> view
		> public
		> vendor

We will have two methods in our form class:

___construct() constructor will define the form name and method (POST) and initialize the form by adding its elements.

addElements() private method will contain the actual code for adding form elements and will be called by the constructor

We put the field creation logic into the addElements() private method to better structure the form model's code.

The code of the ContactForm class is as below:

<?php
namespace Application\Form;

use Zend\Form\Form;

/**
  * This form is used to collect user feedback data like user e-mail
  * Message subject and text
  */
class ContactForm extends Form
{
	//Constructor
	public function __construct()
	{
		//Define form name
		parent::__construct('contact-form');

		//Set POST method for this form
		$this->setAttribute('method', 'post');

		//Add form elements
		$this->addElements();
	}

	//This method adds elements to form (input fields and submit button)
	private function addElements()
	{
		//Add "email" field
		$this->add([
				'type' 	=> 'text',
				'name' 	=> 'email',
				'attributes' => [
					'id' => 'email'
				],
				'options' => [
					'label' => 'Your E-mail',
				],
			]);

		//Add subject field
		$this->add([
				'type' => 'text',
				'name' => 'subject',
				'attributes' => [
					'id' => 'subject'
				],
				'options' => [
					'label' => 'Subject',
				],
			]);

		//Add "Body" field
		$this->add([
				'type' => 'text',
				'name' => 'body',
				'attributes' => [
					'id' => 'body'
				],
				'options' => [
					'label' => 'Message Body',
				],
			]);

		//Add the submit button
		$this->add([
				'type' => 'submit',
				'name' => 'submit',
				'attributes' => [
					'value' => 'Submit',
				],
			]);

	}
}

Above, we define the ContactForm which extends from the Form base class.

In lines 13-23, we have the constructor method. It calls the base class constructor (line 16) and passes teh form
name as its argument ("contact-form"). In line 19, the base class setAttribute() method is called allowing you 
to set the method name for the form (we set the POST method)

In line 22, the addElements() private method is called, which does the actual work of adding elements to the form.
The code of the addElements() is located in lines 27-73. To add elements to the form, we call teh add() method 
provided by the base class. 

This method accepts the single arg, an array containing config for an element. We add four fields:

the email, the subject, the body and the submit field.

A schematical notation of this:

Attributes  >>> name: "contact-us"
	V 		^
	V>>>>>>>>
			V
			>> method: "post"
Elements
	V
	V>> email: Text
	V
	V> subject: Text
	V
	V>> body: TextArea
	V
	V> submit: Submit

Adding Form Filtering and Validation Rules:

Form validation is the procedure of filtering and checking the data passed to the server during the form submission.
For example, for our feedback form, we want to perform the following checks:

We want to test that the E-mail address, message subject, and body fields are always present (Because they are required)

We want to ensure that hte user enter a valid e-mail address like name@example.com

Users may add white space chars to the beginning and/or the end of the Email address, so we would like to filter such
chars out (perform the String trimming operation)

It would be useful to check for minimum and maximum allowed length of the message subject and body text

For the message subject, we would like to filter out (strip) the \n char and html tags

We also want to strip HTML tags from the message body.

There may be malicious user inserting HTML code in the message. If you open such code in your browser, you may see undesired
content. So we replace the HTML tags in the subject and the text.

The requirement above are what we call validation and filtering rules. Those rueles can be divide into two categories.
Filters and validators.

THe filters transform the user-entered data to fix possible errors or to ensure that the data conforms to a certain format.
Filters are typically applied first, validators are applied in the last turn.

Validators check wether the data is acceptable or not. If all data is correct, the form is considered valid and the data
can be safeuly used by the business logic layer. If a certain value is invalid, a validator raises an error flag.

In that case, the form is typically shown to the user again and the user is asked to correct any input errors and
resend the form to the se3rver.

What happens if we don't add a validation rule for a specific form field?

If you do not add validation rules then the user-submitted fields will not be checked, leaving a hole in security.

Input Filter:

In ZF3, you store the filtering and validation rules with the help of the InputFilter class. The InputFilter class
is defined in the Zend\InputFilter component. The input filter is a container for so called inputs. Typically, 
you add an Input per each form model's field you have.

An input may consist of filters and/or validators and some addtional information. For example, an input may contain
the flag telling if the field is requreid or ifits value may be missing from the HTTP request.

Analogoous to adding a form model's fields, there are two possible ways of adding inputs to the input filter
container. Either via passing an instance of an input class as the argument of its add() method or via passing it
via the array specfication.

In the next seciton, we will go over this, albeit we cover the array method (less to write)

In the array case, the input will automatically be created with the help of the Zend\InputFilter\Factory class.

Adding Inputs to Input Filter:

To add an input to the input filter, you use its add() method which takes a single argument, an array specificaton
of the input in the following form:

[
	'name' => '<name>',
	'type' => '<type>',
	'required' => <required>,
	'filters' => [
		//Add filters config here
	],
	'validators' => [
		//add validators config here
	]
]

In the above array, we have the following keys:

The name key (line 2) defines the name of the input. The name should be the same as the name of the form 
model's field. If the name of the input does not match the name of the corresponding model's field, the validation rule
won't be applied to the field

The type key (line 3) defines the class name of the input. This key is optional. By default (when this key is omitted),
the Zend\InputFilter\Input class is used. Available input classes are shown in the following figure soon. The input class
in said figure, is designed to be used with regular scalar values, ArrayInput is used for filtering\validating array,
and FileInput is used for checking uploaded files.

The rquired key (line 4) tells wether the forme field is required or optional. If the field is required, the site user
will ahve to fill it in; otehrwise he will receive an validation error.

The filters (line 5) and validators (line 8) keys may contain the configuration for zero, one or several filters and/or 
validators applied to the form model's field.

The following is the inheritance chart:

InputInterface
	  ^
	  ^
	  ^
	Input 
<<<<<  >>>>>>
FileInput 	ArrayInput

Filter Configuration:

A typical filter config:

[
	'name' => '<filter_name>',
	'priority' => <priority>,
	'options' => [
		//Filter options go here
	]
],

The name key (line 2) is the name for the filter. This may either be a fully qualified filter class name (e.g StringTrim::class or
an Alias, e.g StringTrim)

The optional priority key (line 3) defines filter priority in the list of filters. The priority must be an integer number.
The filters with the highest prio will be applied first. By default, the FilterChain::DEFAULT_PRIORITY constants (value 1k) is assigned.

The options array is specific to certain filter and may contain params for configuring that filter.

Validator Configuration:

A typical validator configuration, is shown below:

[
	'name' => '<validator_name>',
	'break_chain_on_failure' => <flag>,
	'options' => [
		//Validator options go here
	]
],

The name key(line 2) is the name for the validator. This may be either a fully qualified validator class name (e.g EmailAddress::class
or an alias (e.g EmailAddress))

The break_chain_on_failure optional key, defines the behavior in case the validator check fails. If this is equal to true, subsequent
validators in the list will not be executed; otherwise, every validator in the list will be executed without depending on the result
of other validators.

The options array (line 4) is specific to certain validator class and may contain params for configuring the validator.

Attaching Input Filter to Form Model:

Once you have created and populated the input filter container, you have to attach it to the form model. The form base class
provides the setInputFilter() method intended for this purpose.

Methods provided by the Form base class:

name 							desc

setInputFilter($inputFilter) 	Attaches the input filter container to the form

getInputFilter() 				Retrieves the input filter attached to the form

Creating Input Filter for the Contact Form:

Now that you have a general idea on know how to define the input filter container and populate it with filters and containers
for each form field, let's complete our ContactForm form model class. Below, we add the addInputFilter() private method,
which defines the filtering/validation rules, stores them in input filter container, and attaches the input filter to the form model.

<?php
//...
use Zend\InputFilter\InputFilter;

class ContactForm extends Form
{
	public function __construct()
	{
		//Call this method to add filtering/validation rules
		$this->addInputFilter();
	}

	//...

	//This method creates input filter (used for form filtering/validation)
	private function addInputFilter()
	{
		$inputFilter = new InputFilter();
		$this->setInputFilter($inputFilter);

		$inputFilter->add([
			'name' 	=> 'email',
			'required' => true,
			'filters' => [
				['name' => 'StringTrim'],
			],
			'validators' => [
				[
					'name' => 'EmailAddress',
					'options' => [
						'allow' => \Zend\Validator\Hostname::ALLOW_DNS
						'useMxCheck' => false,
					],
				],
			],
		]
	); //indentation error on this method? uncertain

	$inputFilter->add([
		'name' => 'subject',
		'required' => true,
		'filters' => [
			[ 'name' => 'StringTrim'],
			[ 'name' => 'StringTags'],
			[ 'name' => 'StripNewLines'],
		],
		'validators' => [
			[
				'name' => 'StringLength',
					'options' => [
						'min' => 1,
						'max' => 128
					],
				],
			],
		]
	);

		$inputFilter->add([
			'name' 	=> 'body',
			'required' => true,
			'filters' => [
				['name' => 'StripTags'],
			],
			'validators' => [
				[
					'name' => 'StringLength',
					'options' => [
						'min' => 1,
						'max' => 4096
						],
					],
				],
			]
		);
	}
}

//An error of indention is presnet somewhere in these. Uncertain fo where

We can see, we first declare the alias for the Zend\InputFilter\InputFilter class (line 3).

In the form model's constructor (line 10), we call the addInputFilter() method which we define in lines 16-76

The addInputFilter() method's goal is to create the InputFilter container (line 18), attach it to form model (line 19) and add
filtering/validation rules (lines 21-75). For attaching the input filter to the form model, we use the setInputFilter() method
provided by the Form base class.

For inserting filtering/validation rules into the input filter container, we use the add() method provided by the InputFilter
class, which takes the array specification of an input to create.

We add three inputs (per each field of our form model), except its submit button:

For the email field, we set the required flag to true to make filling this field mandatory. We use the StringTrim filter
to remove white spaces from beginning and the end of the E-mail address, and the EmailAddress validator for checking the user-entered
E-mail address for correctness. 

We configure the EmailAddress validator to allow domain names as E-mail addresses (the \Zend\Validator\Hostname::ALLOW_DNS flag)
and disable MX record checking (set useMxCheck option to false).

For the subject field, by analogy, we make it requried, and use the StringTrim filter to remove the white spaces from the 
beginning and the end. Additionaly, we use the StripNewLines and StripTags filters to filter out the new line chars and HTML tags,
respectively.

We constrain the subject string length to be between 1 and 128 chars in length by using the StringLength validator.

For the body field, we require it to be mandatory, and we use the StripTags filter to strip HTML tags from E-mail text.
We also use the StringLength validator to constrain E-mail text to be between 1 and 4096 chars in length.

A schematical overview of it, can be seen as follows:

Inputs
V
V>>>>>>> Email: input
V				V
V				V
V			StringTrim
V				V
V				V
V			EmailAddress
V
V>>> subject: Input >>>>>>>>>>>>>>
V				V				 V
V			StringTrim			 V
V				V			StringLength
V			StripTags
V				V
V			StripNewLines
V
V>>>> body: input >>>>>>>>>>>>>>
			V 					V
		StripTags 			StringLength

We have briefly gone over the input filet for the form model. For detail info, we will go over these
in the later chapters.

Using the Form in a Controller's Action:

When the form model class is ready, you finally can use the form in a controller's action method.

As you might already know, the way the site user works with form is typically an iterative process, as follows:

				Create Form model
						V
						V
						V
					Is data submitted? >>>>>>>>>>>>>>>>>> Render form
						V						No
					Yes	V
						V
					Retrieve data from POST variables
						V
						V
					Assign data to form model
						V
						V
					Validate Form
						V
						V
					Is Form Valid >>>>>>>>>>>>>>>> Render the form again with error messages
						V				No
					Yes	V
						V
					Retrieve validated
					data from form

First, you display the form and its field on a web page, prompting user for input. Once the user fills the form fields,
he clicks the Submit button and sends teh data to server.

Next, your controller extracts the submitted data and asks teh form model to validate it. If there were input errors,
you display the form again, asking the user to correct input errors. if the data is correct, we process the data
in our business logic layer and (usually) redirect the user to another web page.

The Form base class provides several methods for accomplishing these:

Methods provided by the Form base class:

name 						Desc

setData($data) 		Sets form data for validation

getData($flag) 		Retrieves the validated data

isValid() 			validates the form

hasValidated() 		check if the form has been validated

getMessages($elementName = null) Returns a list of validation failure messages, if any, for a single element or all form elements

So, a generic form usage is the following:

Check wether the form data has been submitted, and if not, display the form on the web page.

If the data has been submitted by site user, the raw data is retrieved from POST (and/or GET) variables in the form of an array.

The data is assigned to the form model's fields using the form's setData() method.

The filtering and validation is performed using the form's isValid() method (this results in executing the input filter attached
to the form). if a certain field(s) is/are invalid, display the form again and ask the user to correct their input.

As soon as the data has been filtered/validated you retrieve the data from the form model using the getData() method
and can pass the data to other models or use it any other way.

The code xample below showcades a typical workflow of a controllers action method:

<?php
namespace Applicaton\Form\ContactForm;
//...

class IndexController extends AbstractActionController
{
	//This action displays the feedbackform
	public function contactUsAction()
	{
		//Create contact us form
		$form = new ContactForm();

		//Check if user has submitted the form
		if($this->getRequest()->isPost())
		{
			//fill the form with POST data
			$data = $this->params()->fromPost();
			$form->setData($data);

			//validate the form
			if($form->isValid()){
				//get filtered and validate ddata
				$data = $form->getData();

				//Do something with the validated data

				//Redirect ot the thank you page
				return $this->redirect()->toRoute('application', ['action' => 'thankYou']);
			}
		}

		//pass form variable to view
		return new ViewModel([
				'form' => $form
			]);
	}
}

In the code above, we define the contactUsAction() action method in the IndexController class (line 10). In teh action method,
we create an instance of the ContactForm class (line 13).

Then, in line 16, we check wether the request is a POST request (checkign the starting line of HTTP request)

in line 19, retrieve the raw data submitted by the user. We extract all teh POST variables with thelp of the Params controller
plugin. The data is returned in the form of an array and saved into the $data variable.

The data submitted by the user may contain mistakes and should be filtered and validated before frther usage. To do that, in line 
20 we set the data to the form model with the setData() method provided by the Form base class. We validate form data with the
isValid() method (line 23) which returns true upen successful validation. 

If the validation succeeds, we retrieve the validate data using the getData() method (line 26) and then can pass the data
to our business logic layer.

Once we have used the validate data, in line 31, we redirect the web user to the Thank You page. The redirect is performed
with the Redirect controller plugin. the Redirect plugin's toRoute() method takes two params. 

The first param is the name of the route "application", and the second is one the array of params to pass to the router.
These identify the web page where we redirect the user.

We will prepare the controller's action and view template for the Thank You page a little bit later.

In line 37, we pass the form model through the $form variable to the view template. The view template will access this
variable and will use it for rendering the form (and possible validation errors).

Passing Form data to a Model:

Tog ive you a real-life example of how you can use teh validated data of the feedback form, in this seciton we will
create a simple MailSender model class which can be used for sending an E-mail message to an E-mail address.

When the user submits teh form, we will validate the form data and pass the validated data to the mailsender model
and ask it to send the E-mail message to the recipient.

In DDD terms, the MailSender can be related to service models, because its goal is to manipulate data, nto to store data.

The MailSender model will internalyl use the Zend\Mail component. The Zend\Mail component is a component provided by
ZF3 and designed to give you the convinient functionality for composing mail messages (the Zend\Mail\Message class)
and several classes for implement available transports for sending emails (in this example, we will use the Mail\Transport\Sendmail
class which uses the sendmail program for delivering emails).

Install the Zend\Mail component with composer:

php composer.phar require zendframework\zend-mail

The sendmail program is a free open-source mail transfer agent for Linx/Unix OS. It accepts messages
that a PHP script passes to it, deciding based upon the message header 	which delivery method it should
use, and then passes the message through the SMTP protocol to the appropiate mail server (like GMAIL)
for delivery to the recipient.

Start with creating the MailSender.php file under the Service directory under the module's source dir:

V formdemo //The base project from Github
	V Source files
		> config
		> data
		V module
			V Application
				> config
				V src
					> controller
					> filter
					> form
					V Service
						ImageManager.php
						MailSender.php
					> Validator
					> View
					Module.php
			> test
			> view
	> public
	> vendor

The following is the code that we should put in the MailSender.php file:

<?php
namespace Application\Service;

use Zend\Mail;
use Zend\Mail\Message;
use Zend\Mail\Transport\Sendmail;

//This class is used to deliver an E-mail message to recipient
class MailSender
{
	//Sends the mail message
	public function sendMail($sender, $recipient, $subject, $text)
	{
		$result = false;
		try{
			//Create e-mail message
			$mail = new Message();
			$mail->setFrom($sender);
			$mail->addTo($recipient);
			$mail->setSubject($subject);
			$mail->setBody($text);

			//Send e-mail message
			$transport = new Sendmail('-f'.$sender);
			$transport->send($mail);
			$result = true;
		} catch (\Exception $e) {
			$result = false;
		}

		//return status
		return $result;
	}
}

In the code above, we define the Application\Service namespace, because the MailSender class can be related
to 	service models (its goal is to manipulate data, not save it)

In lines 4-6, we decalre the aliases for the Mail, Message and Transport\Sendmail classes provided by the Zend\Mail component.

In lines 9-35, we define the MailSender class. The class has the single method sendMail() (line 12) which takes four arguments:
sender's E-mail address, recipient e-mail address, message subject and finally, message body text.

IN line 18, we create an instance of the Message class. We use the methods provided by this class for composing the message 
(set its subject, body etc). in lines 19-22

In line 25, we create an isntance of the Sendmail class, which uses the sendmail program to pass the message to the 
appropaite mail server (see lines 25-26). Since the classes provided by the Zend\Mail compoment may throw an exception
on failure, we enclose the whole thing with a try and catch.

The sendmail() method will return true if the e-mail message sent successfully, otherwise it will return false.

Configuring mail system for your web server is a rather complex task. It typically requires installing sendmail
and configuring the server's MX DNS record to use certain mail servers (either local mail server, e.g Posftix or remove server,
like Google Mail).

Because of the complexity of the topic, it is not discussed in this book, we can find more info on configuring mail of your
system online.

Now register the MailSender service in your module.config.php file as follows:

return [
	//...
	'service_manager' => [
		'factories' => [
			Service\MailSender::class => InvokableFactory::class,
		],
	],

	//...
];

Later, we can instantei the MailSender in our IndexController::contactUsAction() method and pass it the validated form data.

Because we use the MailSender service in our controller, this service is a dependency for the controller. So, we will need
to create a factory for the controller and inject the dependency into controller's constructor. Looks complex, but it is not.

Let's create the factory for the IndexController (put it into the Factory subdir under the Controller subdir). You can see that
the only work of the factory class is creating the controller and passing it the dependency

<?php
namespace Application\Controller\Factory;

use Interop\Container\ContainerInterface;
use Zend\ServiceManager\Factory\FactoryInterface;
use Application\Service\MailSender;
use Application\Controller\IndexController;

class IndexControllerFactory
{
	public function __invoke(ContainerInterface $container,
							$requestedName, array $options = null)
	{
		$mailSender = $container->get(MailSender::class);

		//instansiate the contoller and inject dependencies
		return new IndexController($mailSender);
	}
}

Modify the module.config.php file to use the custom factory we just created:

return [
	//...
	'controllers' => [
		'factories' => [
			Controller\IndexController::class => Controller\Factory\IndexControllerFactory::class,
		],
	],

	//...
];

Next, add the constructor, the contactUsAction(), thankYouAction(), and sendErrorAction() methods to the controller.
Below, the complete code is presented:

<?php
//...
use Application\Service\MailSender;

class IndexController extends AbstractActionController
{
	private $mailSender;

	public function __construct($mailSender)
	{
		$this->mailSender = $mailSender);
	}

	public function contactUsAction()
	{
		//Create contact us form
		$form = new ContactForm();

		//Check if user has submitted the form
		if($this->getRequest()->isPost()) {
			//Fill the form with POST data

			$data = $this->params()->fromPost();

			$form->setData($data);

			//Validate form
			if($form->isValid()) {

				//get filtered and validated data
				$data = $form->getData();
				$email = $data['email'];
				$subject = $data['subject'];
				$body = $data['body'];

				//Send e-mail
				if(!$this->mailSender->sendMail('no-reply@example.com', $email, $subject, $body)) {
					//in case of error, redirect to "ERror sending email" page
					return $this->redirect()->toRoute('application', ['action' => 'sendError']);
				}

				//redirect ot the thank you page
				return $this->redirect()->toRoute('application', ['action'=>'thankYou']);
			}
		}

		//pass form variables to view
		return new ViewModel([
			'form'=> $form
		]);
	}

	//This action displayts the thankyou page. The user is redirected to this page
	// on success emails
	public function thankYouAction()
	{
		return new ViewModel();
	}

	//In case on error, return this
	public function sendErrorAction()
	{
		return new ViewModel();
	}
}

as you can see from the code above, we do the following:

In line 3, we declare an alias for Application\Service\MailSender class. This will allow you to refer to the model class
by its short name.

In lines 32-34, after we've validated the form, we extract the valdiated field values into the $email, $subject and 
$body php vars

In line 37, we call the sendMail() method of the MailSender service and pass it four params, the sender's address
(here we use "no-reply@example.com", but you can replace this with the address of your sendmail), the recipients E-mail
address, the E-mail subject and body.

If mail has been sent succesfully (if the sendMail() method return true), we redirect hte user to the Thank You page (lin 45).
On failure (if sendMail() method returned false), we redirect hte user to the Send Error page (line 40).

In lines 58-61, we have the thankYouAction() method which displays the Thank You page. This page is shown if the
E-mail message is sent successfully.

In line 65-68, we have the sendErrorAction() method which shows the Error Sending Email page. This page is shown 
on E-mail delivery failure.

Form Presentation:

When your controller's action is ready, all you have to do is prepare the .phtml view template file to display your form
on a web page. In the view template, you need to define the markup using <form>, <label>, <input> and possibly other
HTML tags.

Additonaly, you will have to display error messages if the form validation failed. Because this work is rather boring,
ZF3 provides us with a special view helpers intended for rendering the form.

For simple forms, (which do not display error messages), you can use raw HTML tags for rendering teh form and 
ignore ZF3 provided form view helpers. But, form view helpers are really unavoidable when rendering complex
forms that may display validation errors and/or add fields dynamically.

Preparing the Form Model for Rendering:

Before rendering, it is required that you call teh prepare() method on teh form models' instance. If you forget to
call this, there may be unintended effects.

prepare() 		Ensures that hte form state is ready to use

The prepare() method does the following form model preparations:

It calls teh input filter container attached to the form model, to ensure validation error messages are avaialble.

It prepares any elements and/or fieldsets tha require preparation.

Typically, this results in wrapping field names with the form/fieldset name (for example, the "email" fields name will become "contact-form[email]") which
technically results in a more convinient field grouping in a HTTP request body.

Standard Form View Helpers:

Standard form view helpers provided by ZF3 are shown in the upcoming tables. These classes live in the Zend\Form\View\Helper
namespace. As you can see from the table, the view helpers can be divided into the following categories:

Generic form view helpers. These classes are designed to render the whole form (Form helper) or it's single element (FormElement
helper) and possible validation errors (FormElementErrors helper).

View helpers for rendering HTML fields of certain types. These allow you to generate HTML markup for concrete 
form fields (e.g FormButton, FormRadio, etc.) and a text label (FormLabel)

View helpers for rendering form fields introduced in HTML5. These are analogous to the view helpers from the previous
category, but intended for rendering HTML5 fields (e.g FormDate, FormUrl, etc.)

Other view helpers. In this category, we can put the view helper classes designed for rendering ZF3-specific fields, like
FormMultiCheckbox and FormCaptcha, etc.

View Helpers designed for using with forms:

Name 								Desc

Generic Helpers

Form 			Renders the entire form and all its elements

FormElement 	Renders a generic form element

FormElementErrors Renders validation errors for a form element

FormRow 		Renders the label, the field and validation errors.

HTML 4 field helpers:

FormButton 		Renders the <button> form field.

FormCheckBox 	Renders the <input type="checkbox"> field.

FormFile 		Renders the <input type="file"> form field.

FormHidden 		Renders the <input type="hidden"> form field.

FormInput 		Renders an <input> form field.

FormImage 		Renders the <input type="image"> form field.

FormLabel 		Renders the <label> tag.

FormPassword 	Renders the <input type="password"> form field.

FormRadio 		Renders the <input type="radio"> form field.

FormReset 		Renders the <input type="reset"> form field.

FormSelect 		Renders the <select> dropdown field.

FormSubmit 		Renders the <input type="submit"> form field.

FormText 		Renders the <input type="text"> form field.

FormTextArea 	Renders the <textarea> multi-line text field.

HTML 5 field helpers:

FormColor 		Renders the <input type="color"> HTML 5 form field.

FormDate 		Renders the <input type="date"> HTML 5 form field.

FormDateTime 	Renders the <input type="date"> HTML5 form field

FormDateTimeLocal 	Renders the <input type="datetime-local"> HTML5 form field

FormEmail 		Renders the <input type="email"> HTML5 form field

FormMonth 		Renders the <input type="month"> HTML5 form field

FormNumber 		Renders the <input type="range"> HTML5 form field

FormRange 		Renders the <input type="range"> HTML 5 form field

FormTel 		Renders the <input type="tel"> HTML5 form field

FormTime 		Renders the <input type="time"> HTML 5 form field

FormUrl 		Renders the <input type="url"> HTML5 form field

FormWeek 		Renders the <input type="week"> HTML5 form field

FormCaptcha 	Renders the Captcha security field

FormDateSelect 	Renders the date select field

FormDateTimeSelect Renders the datetime select field.

FormMonthSelect Renders the month select field

FormMultiCheckbox Renders the multi checkbox field

FormCollection 	Renders the collection of elements

In the next sections, we will provide an overview of several frequently used form view helpers and their usage
examples.

Rendering a Form Element:

You can render a form field with the FormElement view helper. It is designed to be as flexible as possible and recognize 
as many field types as possible. So, with this view helper you are able to produce HTML markup for text fields, buttons,
dropdown lists and so on.

The methods provided by this view helper are listed as follows:

Methods provided by the FormElement view helper:

render($element) 		PHP magic method which renders the given form field

__invoke($element) 		PHP magic method which renders the given form field (the effect is the same as render())

As we can see, there are two methods doing teh same thing:

The render() method produces the HTML markup for the form field. It accepts the single argument -- the instance of the
element to render. You can retrieve the form element with the form model's get() method.

The __invoke() method is a convenience wrapper which results in less code to write.

<?php
//assuming that the form model is stored in $form variable
//Render the E-mail field with the render() method
echo $this->formElement()->render($form->get('email')); ?>

//The same, but with __invoke
echo $this->formElement($form->get('email'));

When executed, the code above will produce html as follows:

<input type="text" name="email" id="email" value="">

Typically, there is no need to call view helpers for concrete HTML (or HTML5) fields (e.g FormText, FormSubmit, etc.)
Instead, you can use the generic FormElement view helper which determines the field type automatically and produces
the needed HTML code.

Rendering an Element's Validation Errors:

The FormElementErrors view helper class allows you to produce HTML markup for field validation errors (if present).
If there are no validation errors for certain element, this view helper does not produce any output.

An example of using the FormElementErrors view helper is presented below:

<?php
//We assume that the form model is stored in the $form variable
//Render validation errors for the E-mail field.
echo $this->formElementErrors($form->get('email'));

If there were any validation errors, this code will generate the unordered list of errors using the <ul> HTML tag. 
And the list will contain as many items as there are errors for certain field. An example:

<ul>
	<li>&#039;hostname&#039; Is not a valid hostname for the email address</li>
	<li>The input does not match the expected structure for a DNS hostname</li>
	<li>The input appears to be a local network name but local network names are not allowed</li>
</ul>

Rendering an Element's Label:

The FormLabel helper allows you to render the text label for an element:

<?php
//We assume the form model is stored in $form variable.
//Render text label for the E-mail field.
echo $this->formLabel($form->get('email'));

When executed, the code will generate HTML as follows:

<label for="email">Your email</label>

Rendering a Form Row:

The FormRow view helpers is designed to simplify the rendering of a form field, it's label, and validation errors.
With this class, you are able to render these in a single step. This helper is flexibly configurable, so you can apply
a different decoration to the form row. The methods of this view helper class is as follows:

Methods provided by the FormRow view helper:

Method name 								Desc

render($element) 			Renders the form row

__invoke($element, $labelPosition, $renderErrors, $partial) 	Renders the form row (convenience wrapper)

setInputErrorClass($inputErrorClass) 		Sets input error CSS class

setLabelAttributes($labelAttributes) 		Sets label attributes

setLabelPosition($labelPosition) 			Sets label position (before or after the field)

setRenderErrors($renderErrors) 				Set if the errors are rendered by this helper

setPartial($partial) 						Set a partial view script to use for rendering the row.

An example of using the FormRow view helper is as follows:

<?php
//We assume that the form model is stored in the $form variable
//Render the E-mail field, its label and (possible) validation errors
echo $this->formRow($form->get('email'));

When executed, the code above will generate the HTML code as follows:

<label for="email">Your E-mail</label>
<input type="text" name="email" id="email">
<ul>
	<li>&#039;hostname&#039; is not a valid hostname for the email address.</li>
	<li>The input does not match the expected structure for a DNS hostname</li>
	<li>The input appears to be a local network name but local network names
		are not allowed</li>
</ul>

Rendering the Entire Form:

The Form view allows you to render the opening <form> tag and its attributes; and the closing </form>
tag. BUt its major purpose is to render the entire form and all of its fields with a single line of code.

Public methods of the Form view helper class are summarized as follows:

Methods provided by the Form View helper:

render($form) 	Renders the entire form and all it's elements

__invoke($form) PHP magic method which renders the entire form and all it's elements (the effect is the same as render())

openTag($form) 	Renders the opening <form> tag

closeTag() 		Renders the closing </form> tag

You can render the whole form with the help of the Form's render() method as follows:

//We assume that hte form model is stored in $form variable

//render the whole form
echo $this->form()->render($form);

The same effect can be achieved with the __invoke() magic method:

//The same, but with __invoke
echo $this->form($form);

Example: Creating the View Template for the Contact Form:

Now we are ready to define the presentation for our feedback form. If you remember, earlier we added the contact-us.phtml
view template in application/index/ directory under the module's view/ directory. Replace the code in that file with the following:

<?php
$form = $this->form;
$form->prepare();
?>

<?= $this->form()->openTag($form); ?>

<?= $this->formLabel($form->get('email')); ?>
<?= $this->formElement($form->get('email')); ?>
<?= $this->formElementErrors($form->get('email')); ?>

<?= $this->formLabel($form->get('subject')); ?>
<?= $this->formElement($form->get('subject')); ?>
<?= $this->formElementErrors($form->get('subject')); ?>

<?= $this->formLabel($form->get('body')); ?>
<?= $this->formElement($form->get('body')); ?>
<?= $this->formElementErrors($form->get('body')); ?>

<?= $this->formElement($form->get('submit')); ?>

<?= $this->form()->closeTag(); ?>

As you can see from teh code above, we do the following things to render the form:

In line 2, we access the $form variable passed from the controller's action

IN line 3, we call the Form's prepare() method to prepare the form for rendering. Please note that
calling this method is very important. If we forget to do this, we could get unwanted rendering issues.

In line 6, we call the openTag() method of the Form view helper. Its purpose is to render the opening <form>
tag and its attributes. The method takes a single argument -- an instance of the form model. Paired closing </form> 
tag is rendered in line 22 with the help of the closeTag() method of the Form view helper.

In lines 8-10, we render the E-mail fields label, the text field itself and (possible) validation errors with the
help of the FormLabel, FormElement, and FormElementErrors view helpers.

Those helpers take the instance of the form model's element as a single argument.We get an instance of the element
with the get() method provided by the Form base class.

In lines 12-14, by analogy, we render the Subject field, its label and validation errors.

And in lines 16-18, we render the label, the field and the validation errors for the body text area field.

In line 20, we render the Submit button.

When the view template renderer evaluates this code, it will produce the HTML output like below:

<form action="/contact" method="post" name="contact-form">
	<label for="email">Your E-mail</label>
	<input type="text" name="email" id="email" value="">

	<label for="subject">Subject</label>
	<input name="subject" type="text" id="subject" value="">

	<label for="body">Message Body</label>
	<textarea name="body" id="body"></textarea>

	<input name="submit" type="submit" value="Submit">
</form>

In the code above, we mostly use the FormElement, FormElementErrors and FormLabel view helpers.
You may use the generic FormRow or Form view helpers if you want to reduce the amount of code to write,
but it may come at a loss of decoration control.

If certain fields have validation errors, those errors will be outputted below the field in the form of the <ul>
unordered HTML list. for example, if you enter the "123@hostname" into E-mail form field, you would
receive the following validation errors:

<label for="email">Your E-mail</label>
<input type="text" name="email" value="123@hostname">
<ul>
	<li>&039;hostname&#039; is not a valid hostname for the email address</li>
	<li>The input does not match the expected structure for a DNS hostname</li>
	<li>The input appears to be a local network name, but local network names
	are not allowed</li>
<ul>

Applying the BS CSS Styles to Form:

The HTML markup above is missing CSS styling. What we want to acheive is to use Twitter BS classes 
to give the form a nice, professional-looking appearance. To add BS styling, we have to modify the code 
in the .phtml file to make it look like below:

<?php
$form = $this->form;
$form->prepare();

$form->get('email')->setAttributes([
	'class'=>'form-control',
	'placeholder'=>'name@example.com'
	]);

$form->get('subject')->setAttributes([
	'class'=>'form-control',
	'placeholder'=>'Type subject here'
	]);

$form->get('body')->setAttributes([
	'class'=>'form-control',
	'rows'=>6,
	'placeholder'=>'Type message text here'
	]);

$form->get('submit')->setAttributes(['class' => 'btn btn-primary']);
?>

<h1>Contact Us</h1>

<p>
	Please fill out the following form to contact us
	We appreciate your feedback
</p>

<div class="row">
	<div class="col-md-6">
		<?= $this->form()->openTag($form); ?>

		<div class="form-group">
			<?= $this->formLabel($form->get('email')); ?>
			<?= $this->formElement($form->get('email')); ?>
			<?= $this->formElementErrors($form->get('email')); ?>
		</div>

		<div class="form-group">
			<?= $this->formLabel($form->get('subject')); ?>
			<?= $this->formElement($form->get('subject')); ?>
			<?= $this->formElementErrors($form->get('subject')); ?>
		</div>

		<div class="form-group">
			<?= $this->formLabel($form->get('body')); ?>
			<?= $this->formElement($form->get('body')); ?>
			<?= $this->formElementErrors($form->get('body')); ?>
		</div>

		<?= $this->formElement($form->get('submit')); ?>

		<?= $this->form()->closeTag(); ?>
	</div>
</div>

IN the code above, we added the .form-control CSS class to every input field in the form. 
We did taht with the setAttribute() method (see lines 5, 10, 15). With that method, we also
added the "placeholder" attribute to define the PH text when a field is empty.

For the "Body" field, we added the "rows" attribute defining the height of the field (6 rows).

For the form's Submit button, we use the .btn and .btn-primary css classes (see line 21)

We also put label-input pairs inside of <div> elements with .form-group CSS class (lines 35, 41, 47)

We also put a form inside of the 6-column width grid cell, which makes the form half of teh screen in width.

Sometimes, it is impossible to use BS with standard ZF3 form view helpers. For example, standard view
helpers FormCheckbox and FormRadio can't be tweaked to support BS. Fortunately, tehre is a third party
mod called nelime/zf2-twb-bundle that you can install with composer.

This module (despite its name, supports ZF3), provides convenient view helpers for rendering ZF3 forms 
and applying BS styling to them. It works transparently, so once you installed the module, standard
ZF3 form view helpers become replaced with module-provided form view helpers, meaning we need not
replace our view template code.

Styling the Validation Errors List:

The error messages on your form, by default, look like a typical unordered list (<ul>). To give them a nice visual appearaence,
we adda  couple of CSS rules to the style.css file in APP_DIR/public directory

form ul {
	list-style-type: none;
	padding: 0px;
	margin: 0px 5px;
}

form ul li {
	color: red;
}

The CSS rules above remove the bullets and change the color to red for the text.

Adding the "Thank You" & "Error Sending Email" pages:

The last small thing we will do is preparing the view templates for the "Thank You" and "Error Sending Email"
pages.

Add the thank-you.phtml view template in application/index/ directory under the module's view/ directory.
Put the following HTML markup into the view template file:

<h1>Thank you!</h1>

<p>
	<div class="alert alert-success">
		We will respond to the E-mail address you have provided.
	</div>
</p>

next, add the second-error.phtml view template file. The HTML markup for the Error Sending Email page is as follows:

<h1>Error Sending Email!</h1>

<p>
	<div class="alert alert-warning">
		Bla, this is an error
	</div>
</p>

Now, if we visit the http://localhost/contactus url in your web browser, we should get the expected stuff.

We can find the code in the Form Demo sample bundeled with this book.

Summary:

Forms are the way of collecting user-entered data on web pages. A form usually consits of elements (input field + label pairs).
Elements can optionally be grouped into fieldsets.

In a MVC-based web site, form functionality is separated into form models responsible for element definition and validation,
and form presentation implemented with the help of special view helpers.

To create a form model, you write a class deriving from the Form base class. The form model is initialized by
adding it's elements with the help of the base class-provided methods.

To submit form data to the server, the user clicks the Submit button, then the data is sent as part of a HTTP request.
Once the user submits the form, you can extract the form data in your controller and ask the form model to validate it.

For checking and FIltering the user-entered data, filters and validators are utilized. You use the InputFilter class
which is the container for validation rules.

If there are input errors, you display the form again, asking the user to correct the input errors. if the data is 
correct, you process the data with your business logic layer.

Transforming Input Data with Filters:

In this chapter, we will provide an overview of standard filters that can be used with your web forms. A filter 
is a class which takes some input data, processes it, and produces some output data. We will also show how to write
a custom filter.

In general, you can even use filters outside forms to process an arbitrary data. For example, filters may be
used in a controller action to transform the data passed as GET and/or POST variables to certain format.

ZF3 Components covered in this chapter:

Zend\Filter 		Contains various filter classes

Zend\InputFilter 	Implements a container for filters/validators.

About Filters:

Filters are designed to take some input data, process it and produce some output data. ZF3 provides a lot
of standard filters that can be used for creating filtering rules (or if you wish, to filter an arbitrary 
data outside of forms).

FilterInterface:

Technically, a filter is a PHP class implementing the FilterInterface interface (it belongs to Zend\Filter namespace.)
The interface definitons is presented below:

<?php
namespace Zend\Filter;

interface FilterInterface
{
	//returns the result of filtering $value
	public function filter($value);
}

As you can see, the FilterInterface has the single method filter(), which takes the single param $value.
The method transforms the input data and finally returns the resulting (filtered) value.

A concrete filter class implementing the FilterInterface may have additional methods. For example,
many filter classes have methods allowing configuration of the filter (set filtering options).

Standard Filters Overview:

Standard filters implementing the FilterInterface interface belong to Zend\Filter component. 

In this section, we only consider the standard filters belonging to the Zend\Filter namespace, although there are 
other filters that can also be considered standard. For example, the Zend\Filter\File namespace contains several
filters applicable to processing the file uploads (those filters will be covered in the next chapters).
Additionally, the Zend\I18n component defines several filter classes that are aware of the user's locale.

A filter class inheritance diagram follows soon. From that figure, we can see that base concrete class for most
standard filters is AbstractFilter class, which implements the FilterInterface interface.

From the diagram, we will see that there are several more base filters AbstractUnicode filter is the base class
for the StringToUpper and StringToLower filters, because it provides the string conversion functionality common
to both of them. And, the Decompress filter inherits from the Compress filter, because these filters are in fact very similar.

By analogy, the Decrypt filler inherits from the Encrypt filter, because they are the "mirror reflection" of each as well.

We may also notice that there is a Strange filter, called StaticFilter which does not inherit from AbstractFilter bas class.
This is because the StaticFilter class is actually a "wrapper" (it is designed to be a proxy to another filter without
explicit instansiation of that filter).

																						Encrypt <<<< Decrypt
																							V
															FilterInterface 	FilterChain V
																	^ 			V 			V
																	^ 			V			V	StaticFilter
																	^ 	 		V 			V
										>>>>>>>>>>>>>>>>>>>>>>AbstractFilter<<<<<<<<<<<<<<<<<<<<<
									BaseName						^ 		     		^	AbstractUnicode
									ToBoolean						^ 		    		^	 	^
									CallBack						^		    		^		StringToUpper
									DateTimeFormatter			Digits 				Compress	StringToLower
																StringTrim 				^
																Dir 				Decompress
																StripNewLines
																HtmlEntities
																StripTags
																Inflector
																RealPath
																PregReplace
																UriNormalize
																ToInt
																ToNull

Standard filters provided by the Zend\Filter component, along with a brief description of each, are listed in a table shortly.

As we will see from the table, the standard filters can be roughly divided into the following groups:

filters casting input data to a specified type (Integer, boolean, date-time, etc)

filters performing manipulations on a file path (getting the base name, parent directory name, etc.)

filters performing compress and encryption of input data

filters manipulating string data (case conversion, trimming, character replacement and removal, URL normalizing etc.)

proxy filters wrapping other filters(Callback, FilterChain, and StaticFilter)

Standard Filters:

ToBoolean 		Returns a boolean represnetation of $value

ToInt 			Casts the input $value to int

Digits 			Returns the string $value, removing all but digit chars

ToNull 			Returns null if the input value can be treated as null; otherwise returns the $value itself

DateTimeFormatter Takes a date & time String in arbitrary format and produces a date & time string in a given format

BaseName 		Given a string containing the path to a file or directory, this filter will return the trailing name component

Dir 			Given a string containing the path of a file or directory, this filter will return the parent directory's path

RealPath 		Returns canonicalized absolute pathname

Compress 		COmpresses the input data with the specified algorithm (GZ by default)

Decompress 		Decompresses the input data with the specified algorithm (the effect is the inverse to the Compress filter)

Encrypt 		Encrypts the input data with the specified crytographic algorithm

Decrypt 		Decrypts the input data previously encrypted with the specified cryptographic algo

Inflector 		Performs the modification of a word to express different gramatical categories such as tense, mood, voice, aspect,
				person, number, gender and case

PregReplace 	Performs a regex search and replace

StringToLower 	Converts the string to lowercase letters

StringToUpper 	Converts the string to uppercase letters

StringTrim 		Removes white spaces (space, tabs, etc) from the beginning and the end of the string

StripNewlines 	Removes new line chars from string (ASCII codes #13, #10)

HtmlEntities 	Returns the string, converting chars to their corresponding HTML entity equivilants where they exist

StripTags 		Rremoves tags (e.g <a></a>) and comments (eg <!-- -->)

UriNormalize 	Converts a URL string to be "Normalized" form and prepends the schema part (e.g converts
				www.example.com to http://www.example.com)

Callback 		Allows to use a callback function as a filter

FilterChain 	Allows to organize several filters in a chain

StaticFilter 	Returns a value filtered through a specified filter class without requiring separate instansiation of the filter object.

Instansiating a Filter:

In ZF3, you can use several methods of creating a filter:

Instansiating it manually (using the new operator)

creating with a factory class (by passing an array config), a method most frequently used when adding filtering and validaiton
rules in a form

instansiating it implicitly with the StaticFilter wrapper class.

Method 1, Instansiating a Filter Manually:

As we previously said, a filter in general can be used not only with forms but also for filtering an arbitrary data.
To do that, you simple create an instance of the filter class, configure the filter by using the methods it provides
and call the filter() method on the filter.

For example, let's consider the usage of the StringTrim filter which removes the white space characters from the beginning
and the end of a string.

The StringTrim filter is useful for filtering user-entered string data (E-mail adresses, user names, etc.) because site visitors
tend to make typos in those data. For example, a user may misspel in a E-mail field by trailing spaces, StringTrim filter
can cover that.

The methods provided by the filter are listed as follows:

Public methods of the StringTrim filter:

__construct($charlistOrOptions) 		Constructs the filter. Accepts the list of options

filter($value) 							Removes the predefiend chars from the beginning and end of a string

setCharList($charList) 					Defines the list of characters to strip off

getCharList() 							Returns the list of characters to strip off

As you can see from the table, the StringTrim filter, in additon to the filter() method, provides the constructor
method which you can (optionally) pass with the complete list of options to initialize the filter, and the setCharList()
and getCharList() methods which can be used for setting specific filter options.

All standard filters have the constructor method (optionally) accepting an array of options for configuring 
the filter when instansiating it manually.

Below, is two examples of using filters, equivilant in usage, just differentiating in setting the charlist or passing to the
constructor:

Example 1, Passing options to the constructor method:

<?php
//Optionally, define a short alias for the filter class name
use Zend\Filter\StringTrim;

//Create an instance of the filter, passing options to the constructor
$filter = new StringTrim(['charlist'=>"\r\n\t "]);

//performs the trimming operation on the string
$filteredValue = $filter->filter('   name@example.com   ');

//Will give 'name@example.com' string

In the code above, we create the StringTrim filter object with the help of the new operator (line 6).
We pass the array of options to the constructor to set the list of characters the filter will remove.
(Here, we tell the filter to remove teh new line chars, tab chars and space).

Actually, passing the array of options to this filter can be omitted because the filter already has
some defaults it will strip off.

in line 9, we call the filter() method and pass it the string value " name@example.com " to be trimmed. The expected
output of this call is the "name@example.com" string.

Without passing options to the Constructor:

<?php
//Optionally, define a short alias for the filter class name
use Zend\Filter\StringTrim;

//Create an instance of the filter
$filter = new StringTrim();

//Specify which chars to remove
$filter->setCharList("\r\n\t ");

//Perform the trimming operation on the string
$filteredValue = $filter->filter('  name@example.com  ');

//The expected output of the filter is the 'name@example.com' string

in the code above, we create the StringTrim filter object with the help of the new operator (line 6)

In line 9, we (optionally) call the StringTrim filter's setCharList() method to set the list of 
chars the filter will remove (here, we tell the filter to remove newline chars, tab and space).

The call is optional cause the StringTrim already has a default list to strip.

And, in line 12, we call the filter() method and pass it the string value "  name@example.com  " to be trimmed.
The expected output of this call is the "name@example.com" string

Method 2: Constructing a Filter with StaticFilter:

An alternative way of manual filter instansiation is by using the StaticFilter class. The StaticFilter class is
some kind of a "proxy" designed for automatic filter instansiation, configuration and execution. For example,
let's consider how to create the same StringTrim filter, configure it and call it's filter() method:

<?php
//Create and execute the StringTrim filter through the StaticFilter proxy
$filteredValue = \Zend\Filter\StaticFilter::execute('  name@example.com  ',
						'StringTrim', ['charlist' => "\r\n\t "]);

//The expectedo utput is the name@example.com string

The StaticFilter class provides the execute() static method, which takes three arguments, the input value, the name
of the filter to apply, and the array of filter-specific options.

In line 3, we call the execute() method to automatically create the StringTrim filter, call its SetCharList() method
and pass the input value to its filter() method. This is very useful because it can be accomplished in a single line of code.

Method 3: Constructing a Filter from an Array:

When using filters with form's validation rules, you typically do not construct a filter object explicitly as we did
in the previous section, instead, you pass an array configuration to the factory class, which automatically constructs
the filter for you and (optionally) configures it.

We already saw how this works when adding validation rules for the feedback form in Collecting User Input With Forms.

For exmaple, let us show how to consturct the same StringTrim filter with the help of the factory:

<?php
//it is assumed that you call the following code inside of the form model's addInputFilter() method

$inputFilter->add([
	//...
	'filters' => [
		[
			'name' => 'StringTrim',
			'options' => [
				'charlist' => "\r\n\t "
			]
		],
	],
	//...
];


in the code above, we call the add method provided by the InputFilter container class. The add() method takes
an array which has the filters key. You typically register the filters under that key. Filters registered
under that key are inserted in a filter chain in the order they appear in the list.

A filter configuration typically consists of the name and options. The name is a fully qualified class name
(e.g Zend\Filter\StringTrim) or its short alias (StringTrim). 

The options is an array consisting of filter-specific
options. When the factory class instansiates the filter, it passes the list of options to the filter's constructor
method, and the constructor initializes the filter as needed.

About Filter Plugin Management:

In the previous example, we saw that we can use either the full qualified class name or its short alias when
instansiating the filter from the array. The short aliases for the standard filters are defined by the FilterPluginManager
class.

The FilterPluginManager class defines the short aliases for the standard filters.

A standard filter's alias is typically the same as the class name. For example, the class Zend\Filter\StringTrim has teh
short alias of StringTrim

The filter plugin manager is internally used by the InputFilter container class for instansiating the standard filters.

Filter's Behavior in Case of incorrect data:

Different filters behave differently if you pass it input data that the filter cannot process correctly.

Some filters (such as ToInt filter) will process only scalar data. if you pass an array to such a filter, it
will return the array as is.

Some filters can work with data in certain format only (e.g, with dates only). If filtering of input data is impossible
(for example, when you pass the filter some wrong data that it is unable to process), the filter() method may throw
a Zend\Form\Exception\RuntimeException exception.

This behavior can be seen in the DateTimeFormatter filter.

Some filters (e.g ToInt or StringToLower) may raise a PHP warning if the value provided is in incorrect format
and cannot be filtered.

It is recommended to read filter's documentation carefully to know what to expect of the filter you plan to use
in your form.

Filter Usage Examples:

Next, we will consider the usage of the most important standard filters. These describe the methods (and options)
a filter has and provide code examples showing how to instansiate the filter and apply it to input data. If you need
to use a filter not covered in this section, pleaser refer to ZF3 manual of Standard Filters.

Filters Casting Input Data to Specified Type:

In this section, we will consider several filters from the group of filters related to casting input data to the specified
type and provide their usage examples.

toInt Filter:

The ToInt filter is a very simple filter that is designed to cast an arbitrary scalar data to an integer. This filter
may be useful when adding validation rules for form fields that must contain an integer numeric values (e.g a drop-down 
list or a text field containing an amount of something).

The ToInt class has the single filter() method.

The ToInt filter will nto cast a non-scalar value. If you pass an array, it will return it as is.

Below, we find an example of using the ToInt filter:

<?php
//Create ToInt filter
$filter = new \Zend\Filter\ToInt();

//Filter a value casting it to an integer amount
$filteredValue = $filter->filter('10'); //returns (int) 10
$filteredValue2 = $filter->filter(['10', '20']); //Returns the same array as is

if we pass an array to the filter, it will return the array as is and PHP raises a warning.

ToBoolean filter:

The ToBoolean class is a filter that is designed to cast an arbitrary data to a boolean value (true or false).
This filter can be used for filtering check box form fields.

Its public methods are as follows:

Public methods of the ToBoolean Filter:

filter($value) 			Returns a boolean representation of $value

setCasting($flag) 		Sets casting flag

getCasting() 			Returns the casting flag

setType($type) 			Sets type from which to cast

getType() 				Returns types

setTranslations($translations) 	Sets translations

getTranslations() 		Returns the translations

The filter provides several methods to set filtering options (setCasting(), setType(), and setTranslations())

The setCasting() method allows to choose one of two modes in which the filter may operate. If the flag is true,
the filter will behave like the PHP (boolean) cast operator. Otherwise (if the flag is set to false), it will
cast only from types defined by the setType() method, and all other values will be returned as is.

The setType() filter's method allows to define from which types to cast. This method accepts teh single argument $type,
which can be either an OR combination of TYPE_-prefixed constants or an array containing the literal equivilants of 
the constants.

Possible constants accepted by the setType() method and their literal equivilants are listed as follows:

Type constnats:

Constnat 		Numeric Value 		Literal equivilant 			Desc

TYPE_BOOLEAN 	1 					"boolean" 					Returns boolean value as is

TYPE_INTEGER 	2 					"integer" 					Converts an integer 0 value to false

TYPE_FLOAT 		4 					"float" 					Converst a float 0.0 value to false

TYPE_STRING 	8 					"String" 					Converts an empty string " " to false

TYPE_ZERO_STRING 16 				"zero" 						Converts a string containing the single char ('0') to false.

TYPE_EMPTY_ARRAY 32 				"array" 					Converts an empty array to false

TYPE_NULL 		64 					"null" 						Converts a null value to false

TYPE_PHP 		127 				"php" 						Converts values according to PHP when casting them to boolean (default)

TYPE_FALSE_STRING 128 				"false" 					Converts a string containing "false" to boolean false

TYPE_LOCALIZED 	256 				"localized" 				Converts a localized string which contains certain word to boolean

TYPE_ALL 		511 				"all" 						Converts all above types to boolean

The following example shows two equivilant ways you can call the setType() method:

<?php
use Zend\Filter\ToBoolean;

//Call the setType() and pass it a combination of constants
$filter->setType(ToBoolean::TYPE_BOOLEAN|
				 ToBoolean::TYPE_INTEGER|
				 ToBoolean::TYPE_STRING);

//Call the setType() and pass it an array with literal equivilants
$filter->setType(['boolean', 'integer', 'string']);

The setTranslations() method allows to define localized equivilants of boolean true and false values. This method accepts
a single param, which must be an array in form of key=>value pairs, where the key is localized string and the value 
is its boolean representation.

The following code example shows how to use the setTranslations() method:

<?php
$filter->setTranslations([
	'yes' => true,
	'no' => false,
	'ja' => true,
	'nicht' => false,
	etc.
]);

Below, an example of using the ToBoolean filter:

<?php
//Create ToBoolean filter
$filter = new \Zend\Filter\ToBoolean();

//optionally configure the filter
$filter->setCasting(true);
$filter->setType(\Zend\Filter\ToBoolean::TYPE_ALL);
$filter->setTranslation(['yes'=>true, 'no'=>false]);

//Filter a value casting it to a boolean number
$filteredValue = $filter->filter('false');
$filteredValue2 = $filter->filter('1');
$filteredValue3 = $filter->filter('false');
$filteredValue4 = $filter->filter('yes');

ToNull filter:

The ToNull filter is designed to cast an arbitrary data to a null value if it meets a specific criteria. This may be useful
when you work with a DB and want to have a null value instead of any other type. If the value cannot be treated as null,
the filter will return the value as is.

The ToNull filter's public methods are as follows:

Public methods of the ToNull filter:

filter($value) 	Casts the $value to null, if possible; otherwise returns value as is.

setType($type) 	Defines from which types to cast

getType() 		Returns defined types.

By default, the ToNull filter behaves like PHP's empty() function: if the empty function returns a boolean true on the input
data, then the filter will return null value on that data, as well.

The setType() method can be used to set the type from which the filter will cast to null. This method takes a single param,
which can either be a combination of TYPE_-prefixed constants listed as follows, or an array of their literal equivilants:

Type constants:

Constant 		Numeric value 		Literal Equivilant 			Desc

TYPE_BOOLEAN 	1 					"boolean" 					Converts a boolean false value to null

TYPE_INTEGER 	2 					"integer" 					Converts an integer 0 value to null

TYPE_EMPTY_ARRAY 4 					"array" 					Converts an empty array to null

TYPE_STRING 	8 					"string" 					Converts an empty string to null

TYPE_ZERO_STRING 16 				"zero" 						Converts a string containing the single char 0 ('0') to null

TYPE_FLOAT 		32 					"float" 					Converts a float 0.0 value to null.

TYPE_ALL 		63 					"all" 						Converts all above types to null. This is the default.

The following code example illustrates two equivilant ways you can call the setType() method:

<?php
use Zend\Filter\ToNull;

//Call the setType() and pass it a combination of constants
$filter->setType(ToNull::TYPE_ZERO_STRING|Null::TYPE_STRING);

//Call the setType() and pass it an array with literal equivilants
$filter->setType(['zero', 'string']);

Below, a code example showing how to use the ToNull filter is provided:

<?php
//Create the ToNull filter
$filter = new \Zend\Filter\ToNull();

//Optionally configure the filter
$filter->setType(\Zend\Filter\ToNull::TYPE_ALL);

$filteredValue = $filter->filter('0'); //Returns null
$filteredValue2 = $filter->filter('1'); //Returns string '1'
$filteredValue3 = $filter->filter(false); //returns null

DateTimeFormatter Filter:

The DateTimeFormatter filter accepts aw date in an arbitrary format and converts it to the desired format.

This filter can accept a string (e.g '2014-03-22 15:36'), an integer timestamp (like the time() php function returns)
or an instance of the DateTime php class. The DateTimeFormatter filter may throw a Zend\Filter\Exception\InvalidArgumentException
exception if you pass it a date in an incorrect format.

Filters public methods are listed as follows:

Public methods of the DateTimeFormatter filter:

__construct($options) 		Constructs the filter

filter($value) 				Transforms the date into the desired format

setFormat($format) 			Sets the date format

In teh code exmaple below, we show how to create the filter, pass it a string date, and convert it to the desired format.

<?php
//Create DateTimeFormatter filter
$filter = new \Zend\Filter\DateTimeFormatter();

//Set filter's format (optional)
$filter->setFormat('F j, Y g:i A');

//Transform the date to the specified format
$filteredValue = $filter->filter('2014-03-22 15:36');

//The expected output is 'march 22, 2014 3:36 pm'

Internally, the DateTimeFormatter filter uses the DateTime class from the PHP standard lib for converting
and formatting dates. For available date formats, please refer to the PHP documentation for the DateTime
class.

Filters performing manipulations on a file path:

In this section, we will consider usage examples of the filters from the group of filters related to manipulating file paths.

BaseName Filter:

The BaseName filter class is just a wrapper on the basename() PHP function. It takes a string containing the path to a file
or a directory and returns the trailing name component.

Below, you can find an example of the BaseName filter usage:

<?php
//Create basename filter
$filter = new \Zend\Filter\BaseName();

//Filter a file path and return its last part
$filteredValue = $filter->filter('/var/log/httpd/error.log');

//The expected filter's output is the 'error.log'

The Basenmae filter will not process a non-scalar value. If you pass an array, it returns it as it is and 
raises a PHP warning.

Dir Filter:

The Dir filter class is just a warpper around the dirname() php method. it takes a string containing the path to a file 
or directory and returns the parent directory's path.

The Dir filter will not process a non-scalar value. If you pass it an array, it returns it as is.

Below, an example demonstrating the usage of the Dir filter is provided:

<?php
//Create the dir filter
$filter = new \Zend\Filter\Dir();

//Filter a file path and return its dir name pat
$filteredValue = $filter->filter('/var/log/httpd/error.log');

//The expected filter's output is the '/var/log/httpd'

RealPath Filter:

The RealPath filter takes an absolute path or a relative file path as a string input argument. It expands all symbolic links
and resolves references to '/./', '/../' and extra '/' chars in teh input path and returns the canonalized absolute pathname.

The RealPath filter is just a wrapper around the realpath() php function.

The filter's public methods are as follows:

__construct($options) 		Constructs the filter

filter($value) 				Returns canonalized absolute pathanme

setExists($flag) 			Specified if the path must exist for this filter ot succeed. The value true means the path must exist,
							the value false means a nonexisting path can be given.

getExists() 				Returns true if the filtered path must exist.

The RealPath filter returns a boolean false on failure, e.g, if the file does not exist. If a nonexisting path is allowed,
you can call the setExists() method with the false param.

Below, an example of using the RealPath filter:

<?php
//Create Realpath filter
$filter = new \Zend\Filter\RealPath();

//Filter a file path (it is assumed that the current
// working dir is /var/log/httpd and that it contains the
// error.log file)

$filteredValue = $filter->filter('./error.log');

//The expected result is the '/var/log/httpd/error.log'

The RealPath filter will not process an array, it returns it just as it is.

Filters Performing Compression and Encryption of Input Data:

In this section, we will consider several filters from the group of filters related to compressing
and encrypting the input data. These filters are not very usable for filtering form data but can be
used outside of forms with a great success.

Compress Filter:

The Compress filter is designed to compress input data with some compression algorithm. For example, you can use this
filter to compress the data and save it as an archive file.

Filters public methods are as follows:

Publlic methods of teh Compress Filter:

__construct($options) 			Constructs the filter

filter($value) 					Performs data compression using the specified algo

getAdapter() 					Returns the current adapter, instansiating if nessecary

getAdapterName() 				Retrives adapter name

setAdapter($adapter) 			Sets compression adapter

getAdapterOptions() 			Retrieves adapter options

setAdapterOptions($options) 	Sets adapter options

getOptions($option) 			Gets individual option or all options from underlying adapter.

The Compress filter itself cannot compress data. It instead uses the so-called adapter class. The adapter class
must implement the CompressionAlgorithmInterface interface. You attach an adapter to the Compress filter and the 
adapter implements the concrete compression algorithm.

There are several standard adapter classes available. Thoose classes live in the Zend\Filter\Compress namespace.

COmpression adapters:

Bz2 		Bzip2 (burrows-wheeler) compression algo

Gz 			Gzip compression algo is based on the Deflate algorithm, which is a combination of LZ77 and HUffman coding

Zip 		ZIP is a compression algo widely used in Windows OS

Tar 		Tarball file format is now commonly used to collect many files onto one larger file for archiving while preserving file system
			information such as user and group permissions, dates, and dir structures. Widely used in Linux OS.

Lzf 		LZF is a very fast compression algo, ideal for saving space for only slgiht speed cost.

Snappy 		Snappy is a fast data compression and decompresison lib developed by Google based on ideas of LZ77

Rar 		RAR is an archive file format that supports data compression, error recovery, and file spanning.

The following is the Inheritance diagram:

			CompressionAlgorithmInterface
						^
						^
				AbstractCompressionAlgorithm
						^
						Bz2
						Gz
						Snappy
						Tar
						Zip
						Rar
						Lzf

Below, a code example demonstrating the usage of the Compress filter is provided:

<?php
//Create compress filter
$filter = new \Zend\Filter\Compress();

//Configure the adapter
$filter->setAdapter('Zip');
$filter->setAdapterOptions([
		 'archive' => 'example.zip',
	]);

//Compress an inptu data (it is assumed that you ahve the testfile.txt
//file in teh cwd)
$filter->filter('testfile.txt');

In the code above, we create an instance of the Compress filter, set its Adapter, sets adapters options,
and finally compress the input file. The expected result, the example.zip archive file, will be created
in teh current dir. The archive will contain the testfile.txt file.

The Decompress filter is a "mirror reflection" of the Compress filter, and can be used by analogy. By that reason,
we do not cover the Decompress filter in this section.

Encrypt Filter:

The Encrypt filter's purpose is encrypting the input data with the specified algo. Filter's public methods are as follows:

public methods of the Encrypt filter:

__construct($options) 		Constructs the filter

filter($value) 				Performs data compression using the specified algo

getAdapter() 				Returns the current adapter, instansiating it if necessary

setAdapter($adapter) 		Sets compression adapter

The Encrypt filter uses adapter classes to perform actual data encryption. You attach an adapter to the Encrypt filter
with the setAdapter() methodm, and the adapter performs teh concrete encryption.

An adapter class must implement the EncryptionAlgorithmInterface interface.

There are several standard adapter classes available. Those classes live in the Zend\Filter\Encrypt namespace.

BlockCipher -- implements symmetric block cipher algo

Openssl 	-- uses an encryption algo from the OpenSSL lib

					<<<<<<<<<EncryptionAlgorithmInterface>>>>>>>>>>>
				BlockCipher 									Openssl

Below, a code example demonstrating the usage of the Encrypt filter is provided:

<?php
//Create encrypt filter
$filter = new \Zend\Filter\Encrypt();

//Set encryption adapter
$filter->setAdapter('BlockCipher');

//Encrypt an input data
$filteredValue = $filter->filter('some data to encrypt');

The expected result is a string encrypted with the block cipher.

The Decrypt filter is a "mirror reflection" of Encrypt filter, and can be used by analogy. By that reason, we do
not have to cover it here.

Filters Manipulating String Data:

In this section, we will consider usage examples of the filters from the group of filters related to manipulating String data.

StringToLower Filter:

The StringToLower filter class is designed for converting the input string data to lowercase letters. The public methods of the
filter are provided as follows:

Public methods of the StringToLower filter:

__construct($options) 		Constructs the filter

filter($value) 				Converts the string to lowercase letters

setEncoding($encoding) 		Sets the input encoding for the given string

getEncoding() 				Returns the encoding

By default, the filter behaves like the strtolower() PHP function. Given a string, it returns the string with all aphabetic
chars converted to lowercase. The "alphabetic chars" are determined by the system locale. This means, that for example, 
the default "C" locale, chars such as umlaut-A (Ã) will not be converted.

Calling the setEncoding() method on the filter passing it an encoding to use forces this filter to behave like the mb_strtolower()
PHP function. By contrast to strtolower(), "alphabetic" is determined by the Unicode char properties. Thus, the behaviour of this
function is not affected by locale settings, and it can convert any chars that have 'alphabetic' property.


If the value provided is non-scalar, aka array, the value will be unconverted and a E_USER_WARNING is raised.

Below,a code example showing how to use StringToLower filter is provided:

<?php
//Create StringToLower filter.
$filter = new \Zend\Filter\StringToLower();

//(optionally) set encoding on the filter
$filter->setEncoding('UTF-8');

//Filter a string
$filteredValue = $filter->filter('How to start a business in 20000000000000000000 days lol jk fok u');

//The expected filter output is this string in lowercase

The StringToUpper filter (converting a string to all uppercase), is a "mirror case" of the StringToLower filter
and can be used by analogy. By taht reason, we do not cover the StringToUpper filter in this section.

PregReplace Filter:

The PregReplace filter can be used for performing a regex search and replace in a string data. This filter is 
wrapper over the preg_replace() php function. The public methods of the filter is as follows:

Public methods of the PregReplace filter:

__construct($options) 		Constructs the filter

filter($value) 				Performs a regex search and replace

setPattern($pattern) 		Sets the pattern to search for. It can be either a string or an array with strings

getPattern() 				Returns the pattern

setReplacement($replacement) 	Sets the string or an array with strings to replace

getReplacement() 			Gets currently set replacement value

Below, a code example showing how to use the StringToLower filter is provided:

<?php
//Create PregReplace filter
$filter = new \Zend\Filter\PregReplace();

//Configure the filter
$filter->setPattern("/\s\s+/");
$filter->setReplacement(' ');

//Filter a string
$filteredValue = $filter->filter('An example with 	multiple 	spaces.');

//The expected filters output is 'An example with multiple spaces.'

StripTags Filter:

The StripTags filter removes all tags (<!-- -->, <p>, <h1>, <?php ?>) from the input string. 
it allows to explicitly define the tags which should not be stripped out. Additonally, it provides
an ability to specify which attributes are allowed across all allowed tags and/or specific tags only.

Public methods of the StripTags filters are as follows:

Public methods of the StripTags filter:

__construct($options) 			Constructs the filter

filter($value) 					Returns the value with tags stripped off it

getAttributesAllowed() 			Returns list of attributes allowed for the tags

setAttributesAllowed($attributesAllowed) 	Sets the list of attributes allowed for the tags

getTagsAllowed() 				Return the list of tags allowed.

setTagsAllowed($tagsAllowed)  	Sets the list of tags allowed.

Below, an example of how to use the StripTags filter:

<?php
//Create StripTags filter
$filter = new \Zend\Filter\StripTags();

//Configure the filter
$filter->setTagsAllowed(['p']);

//Filter a string
$filteredValue = $filter->filter(
	'<p>Please click the following <a href="example.com">link</a>.</p>');

//The expected filters output is the 
// '<p>Please click the following link.</p>;'

The StripTags will not process a non-scalar value. If the value is non-scalar, it is returned as is.

StripNewLines Filter:

The StripNewLines filter is a very simple filter which returns the input string without any newline control chars ("\r" and "\n")

Below, an code example showing how to use the StripNewLines filter:

<?php
//Create StripnewLine filter
$filter = new \Zend\Filter\StripNewlines();

//Filter a string
$filteredValue = $filter->filter("A multi line\r\n string");

//The expected filter's output is "A multi line string"

The StripNewLines will not process a non-scalar value. If the value is passed to the filter is a non-scalar,
the value will remain unfiltered.

UriNormalize Filter:

The UriNormalize filter can be used for normalizing a URL string nad (optionally) applying a scheme part to it. The public
methods of the filter are provided as follows:

Public methods of the UriNormalize filter:

filter($value) 		Filter the URL by normalizing it and applying a default scheme if set

setDefaultScehem($defaultScheme) 	Set the default scheme to use when parsing schemeless URIs

setEnforcedScheme($enforcedScheme) 	Set a URI scheme to enforce on shcemeless URIs.

THe URL normalization procedure typically consits of the following steps:

1. The URL string is decomposed into its schema, host, port number, path, and query parts. if the scheme part
is missing from the original URL, the default scheme is used.

2. The scheme and host parts are converted to lowercase letters.

3. The port number is checked against the list of allowed port numbers, and if it does not belong to the list, the port number
is cleared.

4. The path part of the URL is filtered, removing redundant dot segments, URL-decoding any over-encoded characters, and
URL-encoding everything that needs to be encoded and is not.

5. The query part is sanitized, URL-decoding everything that does not need to be encoded and URL-encoding everything else.

The URL normalization procedure rules may be different for different protocols (schemes). If the URL does not contain
the scheme part, the http scheme is assumed by default. you may use the UriNormalize filter's setDefaultScheme() method
to set the default scheme for URL normalization.

It accepts any of the following schemes: http, https, file, mailto, urn and tag.

Additonally, the UriNormalize filter's setEnforcedScheme() allows to override the default scheme part by the so-called
"enforced scheme" if the original URL does not contain scheme part.

Below, an example:

<?php
//Create UriNormalize filter.
$filter = new \Zend\Filter\UriNormalize();

//Configure the filter
$filter->setDefaultScheme('http');
$filter->setEnforcedScheme('https');

//Filter an URL string
$filteredValue = $filter->filter('www.example.com');

//The expected filter's output is the 'https://www.example.com'

Organizing Filters in a Chain:

Filters can be organized in a sequence. This is accomplished by the FilterChain class. When such a compound filter
is run, the value filtered by the first filter is passed as an input for the second one, and then the value filtered
by the second filter will be passed to the third one and so on.

The FIlterChain class is interally used by the InputFilter container class for storing the sequence of filters
attached to the form model's field.

Public methods provided by the FilterChain class:

Public methods of the FilterChain filter:

filter($value) 			Returns value filtered through each filter in the chain. Filters are run in the order in which
						they were added to the chain (FIFO)

setOptions($options) 	Sets options

attach($callback, $priority) Attaches an existing filter instance (or a callback function) to the chain.

attachByName($name, $options, Instansiates the filter by class name or alias and inserts it into the chain
$priority)

merge($filterChain) merges the filter chain with another filter chain

getFilters() 		returns all attached filters

count() 			returns the count of attached filters

An example filter chain is shown as follows, it chains StrinStrim, StripTags and StripNewLines:

				V
			StringTrim
				V
			StripTags
				V
			StripNewLines
				V

To construct the filter chain as above, we can use the following code structure:

<?php
use Zend\Filter\FilterChain;

//instansiate the filter chain
$filter = new FilterChain();

//insert filters into filter chain
$filter->setOptions([
	'filters'=>[
		[
			'name'=>'StringTrim',
			'options'=>['charlist'=>"\r\n\t "],
			'priority'=>FilterChain::DEFAULT_PRIORITY
		],
		[
			'name'=>'StripTags',
			'options'=>['tagsallowed'=>['p']],
			'priority'=>FilterChain::DEFAULT_PRIORITY
		],
		[
			'name'=>'StripNewLines',
			'priority'=>FilterChain::DEFAULT_PRIORITY
		]
	]
]);

//Execute all filters in the chain
$filteredValue = $filter->filter("    name@example.com<html>\n");

//The expected output is 'name@example.com'

In the code above, we instansiate the FilterChain filter with the new Operator (line 5). In line 8, we set construct
with chain of filters with the setOptions() method.

The method takes an array configuration which looks the same way as in InputFilter's add() method. The array has
"filters" key where you register the filters you want to insert into the chain. For each attached filter,
you provide the following subkeys:

"name" is the fully qualified class name of the filter (e.g, StringTrim::class) or its short alias (e.g, "StringTrim")

"options" is an array of options passed to the filter

"priority" is the optional key which defines the priority of the filter in the chain. Filters with higher priority
are visited first. The default value for the priority is DEFAULT_PRIORITY.

Finally, in line 28, we call the filter() method, which walks through the chain and passes the filtered value to each
filter in turn.

Custom Filtering with Callback Filter:

Standard filters are designed to be used in frequently appearing situations. For example, you may often need to trim
a string or convert it to lowercase. However, sometimes there are cases where you cannot use a standard filter.
Here, the Callback filter will be handy.

The Callback filter is designed as a wrapper for your custom filtering algorithm. For example, this may be useful
when a standard filter is not suitable, and you need to apply your own filtering algorithm to hte data.

you implement your custom filtering algorithm as a callback function or a callback function class method.
A callback is a function or a public method of a class which is called by the Callback filter and is passed
the value to be filtered and, optionally, user-defined arguments.

The public methods provided by the Callback filter are as follows:

Public methods of the Callback filter:

filter($value) 		Executes a callback function as a filter.

setCallback($callback) 	Sets a new callback for this filter

getCallback() 		Returns callback set for the filter

setCallbackParams($params) 	Sets params for the callback

getCallbackParams() Gets params for the callback

As you can see from the table, the Callback filter provides the setCallback() and setCallbackParams() methods that
can be used to set the callback function (or the callback class method) and, optionally, pass it one or several params.

Example:

To demonstrate the usage of the Callback filter, let's add the phone number field to our ContactForm form model class and
attach a custom filter to it.

An international phone number typically looks like "1 (808) 456-7890". it consists of the country code followed by the three-digit
area code enclosed in braces. The rest of the phone consists of the seven-digit subscriber code divided into two groups
seperated by a dash.

The country code, the area code, and the subscriber code are separated by the space character. We will refer to this
phone format as the "international" format.

The international phone format is required for making telephone calls between different countries (or areas). If the 
calls are made within teh same area, the phone number might have a simple setup as "456-7890" (we just omit the country
code and area code).

We will refer to this phone format as the "local" phone format.

To make our filter as generic as possible, we assume that hte user is required to enter the phone in international 
format for some forms and in local forms for others. Because some visitors may entier their number in a different
format than what is required, we want to "normalize" it.

To do the phone "normalization" that filter will:

Strip out any non-numeric chars of the input value

Pad the digits to the required length if there are too few digits

Add the braces, the space and the dash (when using international format) or simply add the dash (When using the local format)

Because ZF3 does not provide a standard filter for accomplishing such phone filtering operation, we will use the Callback wrapper filter.
To do that, we will make the following changes to the code of our ContactForm class:

<?php
//...
class ContactForm extends Form
{
	//...
	protected function addElements()
	{
		//...

		//Add "phone" field
		$this->add([
			'type' => 'text',
			'name' => 'phone',
			'attributes' => [
				'id' => 'phone'
			],
			'options' => [
				'label' => 'Your phone'
			],
		]);
	}

	private function addInputFilter()
	{
		//...
		$inputFilter->add([
			'name' 	=> 'phone',
			'required' => true,
			'filters' => [
				[
					'name' => 'Callback',
					'options' => [
						'callback' => [$this, 'filterPhone'],
						'callbackParams' => [
							'format'=> 'intl'
						]
					]
				],
			],
		]);
	}

	//Customer filter for a phone number
	public function filterPhone($value, $format)
	{
		if(!is_scalar($value)){
			//Return non-scalar value unfiltered
			return $value;
		}

		$value = (string)$value;

		if(strlen($value)==0) {
			//return empty value unfiltered
			return $value;
		}

		//First, run regex against non-digits
		$digits = preg_replace('#[^0-9]#', '', $value);

		if($format == 'intl') {
			//pad with zeroes if the number of digits is incorrect
			$digits = str_pad($digits, 11, "0", STR_PAD_LEFT);

			//Add the braces, the spaces and the dash.
			$phoneNumber = substr($digits, 0, 1) . ' ('.
						   substr($digits, 1, 3) . ') ' .
						   substr($digits, 4, 3) . '-' .
						   substr($digits, 7, 4);
		} else { //local mode
			//pad with zeros if number is incorrect length
			$digits = str_pad($digits, 7, "0", STR_PAD_LEFT);

			//Add the dash
			$phoneNumber = substr($digits, 0, 3) . '-'. substr($digits, 3, 4);
		}

		return $phoneNumber;
	}
}

IN lines 11-20 of the code above, we add the "phone" field to the ContactForm form model. The field is a usual text
input field and we already had some experience of working with such fields earlier.

Then, in lines 26-40, we add a validation rule for the "phone" field of our form. Under the "filters" key (line 29),
we register the Callback filter (here, we use the short alias Callback, but you can alternatively use the fully qualified class name 
Callback::class)

The filter takes two options (line 32): the "callback" option and the "callback_params" option. The "callback" option is an array
consisting of two elements, which represent the class and the method to call, respectively.

In this example, the callback is the filterPhone() method of the ContactForm class. We pass the "format" parameter to the callback
method with the help of "callbackParams" option (line 34).

In lines 44-79, we define the filterPhone() callback method, which takes two arguments: the $value is the phone number 
to filter and the $format is the desired phone number format. The $format parameter may either be 'local' (for local format)
or 'intl' (for international format)

In the filterPhone() callback method, we do the following:

First, in line 46, we check if the $value parameter is scalar and not an array. If the value is not a scalar, we return it
without change.

In line 53, we check the input value's length. We do nothing if the user entered an empty phone number, we just return it as is.

Then we remove any non-digit chars (line 59)

If phone length is too short, we pad it with zeroes.

We add the braces, the dash and the spaces for the international phone numbers, or just the dash for local phone numbers.

Finally, we return the resulting phone number

To see how this filter works, you can open the "http://localhost/contactus" URL in your web browser. If you enter 
some phone number in an incorrect format, the filter will fix the phone number and transform it to the desired format.

Writing Your Own Filter:

An alternative to using the Callback filter is writing your own filter class implementing the FilterInterface. Then
this filter may be used in forms of your web app (or if you wish, outside of forms)

To demonstrate how to create a filter, we will write the PhoneFilter class encapsulating the phone filtering algorithm
we used with the Callback fitler example.

As you may remember, the base concrete class for all standard filters is the AbstractFilter class. By analogy,
we will also derive our custom PhoneFilter filter from that base class.

We plan to have the following methods in our PhoneFilter filter class:

Public methods of the PhoneFilter filter:

__construct($options) 		Constructor - accepts an optional argument $options, which is needed to set filter options at once

setFormat($format) 			Sets the phone format option

getFormat() 				Returns the phone format option

filter($value) 				Runs the phone filter

To start, create the PhoneFilter.php file in the Filter directory under the module's source directory. Put hte following
code in the said file:

NOTE: The PhoneFilter class may be considered a service model because it does not store data, it processes it. by convention,
we store all custom filters under the Filter directory.

<?php
namespace Application\Filter;

use Zend\Filter\AbstractFilter;

//This filter class is designed for transforming an arbitrary phone number to the local or international format
class PhoneFilter extends AbstractFilter
{
	//phone format constants
	const PHONE_FORMAT_LOCAL = 'local'; //local phone format
	const PHONE_FORMAT_INTL = 'intl'; //international phone format

	//Available filter options
	protected $options = [
		'format' => self::PHONE_FORMAT_INTL
	];

	//Constructor
	public function __construct($options = null)
	{
		//Set filter options (if provided)
		if(is_array($options)) {
			if(isset($options['format']))
				$this->setFormat($options['format']);
		}
	}

	//Sets phone format
	public function setFormat($format)
	{
		//Check input argument
		if( $format!=self::PHONE_FORMAT_LOCAL && $format!=self::PHONE_FORMAT_INTL ) {
			throw new \Exception('Invalid format argument passed.');
		}

		$this->options['format'] = $format;
	}

	//Returns phone format
	public function getFormat()
	{
		return $this->format;
	}

	//Filters a phone number
	public function filter($value)
	{
		if(!is_scalar($value)) {
			//return non-scalar value infiltered
			return $value;
		}

		$value = (string)$value;

		if(strlen($value)==0) {
			//return empty value unfiltered
			return $value;
		}

		//First remove any non-digits
		$digits = preg_replace('#[^0-9]#', '', $value);

		$format = $this->options['format'];

		if($format == self::PHONE_FORMAT_INTL) {
			//pad with zeros if the number of digits is incorrect
			$digits = str_pad($digits, 11, "0", STR_PAD_LEFT);

			//Add the braces, the spaces, and the dash
			$phoneNumber = substr($digits, 0, 1) . ' (' .
						   substr($digits, 1, 3) . ') ' .
						   substr($digits, 4, 3) . '-' .
						   substr($digits, 7, 4);
		} else { // self::PHONE_FORMAT_LOCAL
			//Pad with zeros if the number of digits is incorrect
			$digits = str_pad($digits, 7, "0", STR_PAD_LEFT);


			//add the dash
			$phoneNumber = substr($digits, 0, 3) . '-'. substr($digits, 3, 4);
		}

		return $phoneNumber;
	}
}

From line 2,you can see that the filter class lives in teh Application\Filter namespace.

In line 8, we define the PhoneFilter class. We derive our filter class from the AbstractFilter base class to reuse
the functionality it provides. Line 4 contains the short alias for the AbstractFilter class.

In lines 11-12, for convenience, we define the phone format  constants (PHONE_FORMAT_INTL for international format
and PHONE_FORMAT_LOCAL for local format). These are the equivilants of the "intl" and "local" strings, respectively.

In lines 15-17, we define the $options private variable, which is an array having the single key named "format".
This key will contain the phone format options for our filter.

In lines 20-28, we have the constructor method, which takes the single argument $options. When constructing the filter
manually, you may omit this parameter. However, when the filter is constructed by the factory class, the factory will
pass filter options to the filter's constructor through this argument.

In lines 31-40 and 43-46, we have the setFormat() and getFormat() methods that allows to set and retrieve the current 
phone format, respectively.

In lines 49-86, we have the filter() method. This method encapsulates the phone number filtering algorithm. It takes
the $value parameter, transforms it by taking the selected phone format in account, and returns the formatted phone number.

Using the PhoneFilter class:

When the PhoneFilter filter class is ready, you can easily start using it in the feedback form (or in another form)
as follows.

it is assumed that you call the following code inside of the ContactForm::addInputFilter() method:

$inputFilter->add([
		'name' 		=> 'phone',
		'required' 	=> true,
		'filters 	=> [
			[
				'name' => PhoneFilter::class,
				'options' => [
				'format' => PhoneFilter::PHONE_FORMAT_INTL
				]
			],
			// ...
		],
		//...
	]);

//Indention error, maybe? who knows

We can see the PhoneFilter filter works in the Form Demo sample application bundled with this book.
Open the "http://localhost/contactus" page in your web browser. If you enter some phone number in an incorrect
format, the filter will fix the phone number.

If you wish, you can use the PhoneFilter outside of forms, as follows:

<?php
use Application\Filter\PhoneFilter;

//Create phonefitler filter
$filter = new PhoneFilter();

//Configure the filter
$filter->setFormat(PhoneFilter::PHONE_FORMAT_INTL);

//Filters a string
$filteredValue = $filter->filter('12345678901');

//The expected filter output is the '1 (234) 567-8901'

Summary:

Filters are designed to take some input data, process it, and produce some output data. ZF3 provides a lot of standard
filters that can be used for creating filtering rules of your forms (or, if you wish, to filter an arbitrary data outside of forms).

The standard filters can be roughly divided into several groups:

Filters casting input data to a specified type

Filters performing manipulations on a file path

Filters performing compression and encryption of input data

Filters manipulating string data 

proxy filters wrapping other filters

If a standard filter is not suitable, it is possible to create a custom filter class. In this chapter,
we have provided an example of how to write your own PhoneFilter class capable of filtering phone numbers.

Checking Input Data with Validators:

In this chapter, we will provide an overview of standard ZF validators that can be used with your forms, and will also
show how to write a custom validator. A validator is a class designed to take some input data, check it for correctness,
and return a boolean result telling whether the data is correct (and error messages if the data had some errors).

In generaly, you even can use validators outside forms to process an arbitrary data. For example, validators may be used
in a controller action to ensure that data passed as GET and/or POST variables is secure and conform to certain format.

ZF3 components covered in this chapter:

Zend\Validator 		Implements various validator classes

Zend\InputFilter 	Implements a container for filters\validators

About Validators:

A validator is designed to take some input data, check it for correctness, and return a boolean result telling whether the data
is correct. If the data is incorrect, the validator generates the list of errors describing why the check did not pass.

ValidatorInterface:

In ZF3, a validator is a usual PHP class which implements the ValidatorInterface interface (it belongs to Zend\Validator
namespace). The interface definition is as follows:

<?php
namespace Zend\Validator;

interface ValidatorInterface
{
	//returns true if and only if $value meets the validation requirements
	public function isValid($value);

	//returns an array of messages that explain why the most recent isValid() call returned false
	public function getMessages();
}

As we can see, the internface defines two methods, isValid() and getMessages().

The first one is intended to check the input value. If the validation of the $value
passes, the isValid() method returns boolean true. if it fails, it returns false.

A concrete implementation of this interface may of course have more methods, for example,
many validator classes have methods allowing to configure the validator (set validation options).

Standard Validators Overview:

Standard ZF3 validators are provided by the Zend\Validator component. Standard validator classes inheritance is shown
soon. As we will see, most of them are derived from AbstractValidator base class.

In this specific instance, we only consider the standard validator classes belonging to the Zend\Validator namespace. But
actually there are more validators that can be considered as standard. We will cover them in further chapters.


															StaticValidator
							ValidatorInterface
							^		^
							^		^
							^	ValidatorChain
							^
					AbstractValidator
							^   ^
						>>>>>	^
					Date 		^
					^ 			^
					DateStep 	^
								^
							Callback
							Identical
							InArray
							Ip
							IsInstanceOf
							StringLength
							GreaterThan
							Hex
							Hostname
							Iban
							Isbn
							Step
							Uri
							Regex
							Explode
							EmailAddress
							Digits
							NotEmpty
							Csrf
							CreditCard
							Bitwise
							Between
							Barcode

Standard validators together with their brief description are listed soon. As we will see, they can be 
roughly divided into a number of groups:

validators for checking value conformance to certain format (IP address, host name, E-mail address, credit card number, etc.)

validators for checking if a numerical value lies in a given range (less than, greater than, between etc.)

validators working as "proxies" to other Validators (ValidatorChain, StaticValidator and Callback)

Standard Validators:

EmailAddress 		Returns boolean true if the value is a valid e-mail address, otehrwise returns false.

Hostname 			Checks whether the value is a valid host name

Barcode 			Returns boolean true if and only if the value contains a valid barcode

CreditCard 			Returns true if and only if the value follows the common format of a credit card number (Luhn algo, mod-10 checksum)

Iban 				Returns true if the value is a valid International Bank Acount Number (IBAN); otherwise false

Isbn 				Returns boolean if and only if value is a valid International Standard Book Number (ISBN)

Ip 					Returns true if value is a valid IP address, false otherwise

Uri 				Returns true if and only if the value is an URI. (Uniform Resource Identifier)

Between 			Returns if the value lies in certain range, otherwise returns false

LessThan 			Returns boolean true if value is less than certain number, otherwise false

GreaterThan 		Returns true if and only if value is greater than certain number

Identical 			Returns boolean true if a the value matches a given token

Step 				Checks wether the value is a scalar and a valid step value

Csrf 				This validator checks if the provided token matches the one previously generated and stored in a PHP session

Date 				Returns true if value is a valid date of the certain format

DateStep 			Returns boolean true if a date is within a valid step

InArray 			Returns true if value is contained in the given array, otherwise returns false

Digits 				Returns boolean true if and only if $value only contains digits

Hex 				Retruns true if and only if value contains only hexadecimal digit chars

IsInstanceOf 		Returns true if value is of a certain class, false otherwise

NotEmpty 			Return true if the value is not an empty value

Regex 				Retruns true if value matches against given pattern; otherwise returns false

StringLength 		Returns true if the string length lies within given range

Explode 			Splits the given value in parts and returns true if all parts pass the given check

StaticValidator 	This validator allows to execute another validator without explicitly instansiating it

Callback 			This validator allows to execute a custom validation algo through the user-provided callback function

ValidatorChain 		Wrapper validator allowing to organize several validators in a chain. Attached validators are run in order,
					in which they were added to the chain (FIFO)


Validator Behaviour in Case of Invalid or Unacceptable Data:

If you pass a validator some data that does not pass the check, the validator internally creates the list of error
messages that can be retrieved with the getMessages() method. For example, look below for possible validation errors
that the EmailValidator returns if you pass it the "abc@ewr" value (the backslash char ('\') indicates line breaks where code 
doesn't fit book page):

array(3) {
	["emailAddressInvalidHostname"] =>
		string(51) "'ewr' is not a valid hostname for the email address"
	["hostnameInvalidHostname"] =>
		string(66) "the input does not match the expected structure for a DNS hostname"
	["hostnameLocalNameAllowed"] =>
		string(84) "The input appears to be a local network name but local network names are not allowed"
}

Validator's getMessages() method will return an array of messages that explain why the validation failed. The array
keys are validation failure messages identifiers, and the array values are the corresponding human-readable
message strings.

If isValid() method was never called or if the most recent isValid() call returned true, then the getMessages() method
returns an empty array. Also, when you call isValid() several times, the previous validation messages are cleared,
so we only see the latest iterations messages.

Some validators work with input data in certain format only (for example, a validator may require that the input data
be a string, but not an array). If you pass it data in unacceptable format, the validator may throw an Zend\Validator\Exception\RuntimeException
exception or raise a PHP warning.

It is recommended to check the behaviour of the actual validator to see what data it can handle.

Instansiating a Validator:

In ZF3, there are several methods of creating a validator:

Instansiating it manually (with the new operator)

Creating it with a factory class (by passing an array config), this way is used the most frequently when adding validation
rules in a form

Instansiating it implicitly with the StaticValidator wrapper class

we will cover these, in detail:

Method 1: Manual Instansiation of a Validator:

A validator in general can be used not only with forms, but also for validation of an arbitrary data. In order to do that,
you simply create an instance of the validator class, configure a validator by using the methods it provides and call
the isValid() method on the validator.

For example, let's consider the usage of the EmailAddress validator which checks an E-mail address for conformance to 
RFC-2822 standard. An E-mail address typically consists of the local part (user name) followed by the "@" char,
which is followed by the hostname. For example, in the "name@example.com" email address, name is the local part,
example.com is the hostname

The EmailAddress validator is useful for checking an user-entered Email-address on your forms for correctness.
The validator will check for the correctness of the local part and the host name, for presence of the "at" character
and optionally, will connect to the recipient's host and query the DNS service for existence of the MX (Mail Exchanger)
record.

AN MX record is a type of record used in the Domain Name System (DNS). MX records define one or several mail server 
addresses assigned to recipient's domain.

The methods provided by the EmailAddress validator are as follows:

Public methods of the EmailAddress validator:

__construct($options) 			Constructs the validator. Accepts the list of options allowing to configure it.

isValid($value) 				Returns true if the value is a valid e-mail address according to RFC-2822, otherwise return false.

getMessages() 					If validation failed, get the reasons for that in form of an array

useDomainCheck($domain) 		Tells the validator to check the hostname part for correctness

getDomainCheck() 				Returns true if the host name part check is enabled

setHostnameValidator($hostnameValidator) 	Attaches the validator to use for checking host name part of the E-mail address

getHostnameValidator() 			Returns the validator used for checking host name part of the E-mail address

setAllow($allow) 				Sets the allowed type of host names to be used in an E-mail address

getAllow() 						Returns the allowed types of host names.

useMxCheck($mx) 				Sets wether to perform the check for a valid MX record via DNS service.

getMxCheck($mx) 				Returns true if MX check mode is enabled.

useDeepMxCheck($deep) 			Sets wether to use deep validation for MX records

getDeepMxCheck() 				Returns true if deep validation of MX records is performed, false otherwise

isMxSupported() 				Returns true if MX checking via getmxrr() php function is supported in the system,
								otherwise returns false.

getMxRecord() 					After validation, returns the found MX record information.

AS we can see from the table, the EmailAddress validator, additonally to the isValid() and getMessages() methods,
provides the constructor method to which you can (optionally) pass the complete list of options for initializing
the validator.

All standard validators may have the constructor method (optionally) accepting an array of options for configuring
the validator when instansiating it manually.

The EmailAddress class also provides a number of methods that can be used for setting specific validator options.

The useDomainCheck() methods tells wether to check the hostname for correctness, or not. By default, this check is enabled.
The setAllow() method provides an ability to specify which types of host names are allowed. You can pass an OR combination
of the ALLOW_-prefixed constants to the setAllow() method.

They are as follows:

ALLOW_DNS: allow a domain name (default)

IP_ADDRESS: Allows an IP Address

ALLOW_LOCAL: Allow local network name

ALLOW_ALL: Allows all of the above

The ALLOW_-prefixed constants are provided by the Hostname validator.

Internally, the EmailAddress validator uses the Hostname validator for checking the host name
part of an E-mail address. Optionally, you can attach a custom host name validator by using the
setHostnameValidator() method, however, it is unlikely you will need to do such.

The useMxCheck() methods tells wether the validator should connect to the recipient's host and query 
the DNS server for the MX record(s).

if the server has no MX records, then the validation fails. You can additonally use the useDeepMxCheck() to tell teh
validator to compare the mail server addresses extracted from the MX records against the black list of reserverd
domain names and perform additional checks per each detected address.

It is not recommended to perform MX check (and deep MX check), because that may take a lot of time and increase
load times. By default, they are disabled.

Below, we find examples to how to manually creating an instance of the EmailAddress validator, setting
its options and checking an input value.

Example 1. Passing options to the constructor method:

<?php
//optionally, define a short alias name for the validator class name
use Zend\Validator\EmailAddress;
use Zend\Validator\Hostname;

//Create an instance of the validator, passing options to the constructor
$validator = new EmailAddress([
		'allow' => Hostname::ALLOW_DNS|Hostname::ALLOW_IP||Hostname::ALLOW_LOCAL,
		'mxCheck' => true,
		'deepMxCheck' => true
	]);

//validate an email address
$isValid = $validator->isValid('name@example.com'); //returns true
$isValid2 = $validator->isValid('abc'); //returns false

is(!$isValid2) {
	//Get error messages in case of validation failure
	$errors = $validator->getMessages();
}

In the code above, we create the EmialValidator object with with the help of the new operator. 
We pass the array of options to the constructor. We use the allow key to allow an E-mail address
to be a domain name, an IP address or local network address.

Also, we use the mxCheck and deepMxCheck to enable MX record check and deep MX record check, respectively.

In line 14, we call the isValid() method and pass it the string value "name@example.com" to be checked.
The expected output of this call is the boolean true.

In line 15, we pass the "abc" string value to the validator, we expect this to fail. Given the failure of this,
we get hte messages to illustrate the error message array.

Example 2. Without passing options to the Constructor:

<?php
//optionally, define a short alias for the validator class name.
use Zend\Validator\EmailAddress;
use Zend\Validator\Hostname;

//Create an instance of the validator
$validator = new EmailAddress();

//optionally, configure the validator
$validator->setAllow(
		Hostname::ALLOW_DNS|Hostname::ALLOW_IP|Hostname::ALLOW_LOCAL);
$validator->useMxCheck(true);
$validator->useDeepMxCheck(true);

//Validate an e-mail address
$isValid = $validator->isValid('name@example.com'); //returns true
$isValid2 = $validator->isValid('abc'); //returns false

if(!$isValid2) {
	$errors = $validator->getMessages();
}

In the code above, we create the EmailAddress object, and configure it with the setAllow() method to allow an
E-mail address to be a domain name, an IP address or local network address. Also, we use the useMxCheck() and
useDeepMxCheck() to enable MX record check and deep MX record check, respectively.

In line 16, we call the isValid() method and pass it the string value "name@example.com" to be checked. The expected
output of this call is the boolean true

In line 17, we pass the "abc" string value to the validator. The validation procedure is expected to fail. Then, the 
error messages are retrieved with the getMessages() method (line 21).

Method 2. Using StaticValidator Wrapper:

An alternative way of manual validator instansiation is by using the StaticValidator class. The StaticValidator class
is some kind of a "proxy" designed for automatic validator instansiation,configuration and execution. For example,
let's consider how to create the same EmailAddress validator, configure it and call it's isValid() method.

<?php
//Create and execute the EmailAddress validator through StaticValidator proxy
$validatedValue = \Zend\Filter\StaticValidator::execute('name@example.com',
					'EmailAddress',
					[
						'allow' =>
							Hostname::ALLOW_DNS|
							Hostname::ALLOW_IP|
							Hostname::ALLOW_LOCAL,
						'mxCheck' => true,
						'deepMxCheck' => true
					]);
//The expected output is true

The StaticValidator class provides the execute() static method which takes three arguments: the input value, the name
of the filter to apply and the array of filter-specific options.

In line 3, we call the execute() method to automatically create the EmailAddress() validator, call its setAllowDns(),
useMxCheck() and useDeepMxCheck() methods, and pass the input value to its isValid() method.

This is very useful, because can be accomplished in a single call.

The StaticValidator does not provide an ability to extract the list of human-readable validaiton errors. However, since the
StaticValidator is designed to be used outside forms, and not intended for displaying results to a human, this seems to be 
not a big disadvantage.

Method 3. Using an Array Configuration

When using validators with form's validation rules, you typically do not construct a validator object explicitly as we did
in the previous seciton, instead you pass an array configuration to the factory class which automatically constructs the
validator for you and (optionally) configures it.

We already saw how this works when adding validation rules for the feedback form in Collecting user INput with Forms.

For example, let's show how to construct the same EmailAddress fitler with the help of the factory:

<?php
//It is assumed that you call the folowing code inside of the form model's addInputFilter() method

$inputFilter->add([
	//...
	'validators' => [
		[
			'name' => 'EmailAddress',
			'options' => [
				'allow' => \Zend\Validator\Hostname::ALLOW_DNS,
				'useMxCheck' => false,
				'useDeepMxCheck' => false,
			],
		],
	],

	//...
]);

In the code above, we call the add() method provided by the INputFilter container class. The add() method takes an array
which has the validators key. You typically register the validators under that key (line 7). Validators registered under that
key are inserted into validator chain in the order they appear ni the list.

A validator configuration typically consists of the name (line 9) and options (line 10). The name is fully qualified class name (\Zend\Validator\EmailAddress)
or alias name (EmailAddress). The options an array consisting of validator-specific options.

When the factory class instansiates the validator, it passes the list of options to the validator's constructor and the constructor 
initialies the validator as needed.

About Validator PLugin Manager:

When creating a validator with a factory, you can either use the fully qualified validator class name or its short alias.
THe short aliases for the standard validators are defined by the ValidatorPluginManager class.

The ValidatorPluginManager class defines a validator aliases.

A standard validator's alias is typically the same as a class name. For example, the class Zend\Validator\EmailAddress has
the short alias EmailAddress.

The validator plugin manager is interntally used by the InputFilter container class for instansiating the standard validators.

Validator Usage Examples:

Next, we will consider the usage of the most important standard validators. These describe the methods (and options) a
validator has, and provide a code example showing how to isntansiate and apply the validator to input data.

Validators for Checking Value Conformance to Certain Format:

In this section, we will cosnider the usage examples of the validators from teh group of validators designed for checking
if input value conforms to certain formats.

Ip Validator:

The Ip validator class is designed to check if the input value is a valid IP address. If the input value is an IPv4 address,
IPv6 address, IPvFuture adress or IPv6 literal address, the validator returns boolean true, otherwise it returns false.

On failure, error messages can be extracted with the validator's getMessages() method.

An internet Ipv4 address typically consists of four octets of the address expressed seperated by periods, like "192.168.56.101".

An internet IPv6 address typically consists of eight groups of four hexadecimal digits seperated by colons, such as 
"2001:0db8:85a3:0000:0000:8a2e:0370:7334".

IPvFuture is loosely defined in the Section 3.2.2 of RFC 3986.

A literal Ipv6 address is a modeification of a usual Ipv6 address for using inside of a URL (The problem with the original Ipv6
is that the ":" and "." chars are delimeteres in URLs.)

Public methods provided by the Ip validator are as follows:

Public methods of the Ip validator:

__construct($options) 		Constructs the validator. Accepts the list of options

isValid($value) 			Retruns true if and only if value is avalid IP

getMessages() 				if validation failed, this allows us to return an array of error messages

setOptions($options) 		Sets validator options

The setOptions() method provides an ability to set allowed types of IP addresses:

allowipv4 to allow IPv4

allowipv6 to allow ipv6

allowipvfuture to allow ipvfuture

allowliteral to allow ipv6 literals

By default, all the above are allowed except the ipv6 literal

An example of how to use the IP validator:

<?php
use Zend\Validator\Ip;

//Create IP validator
$validator = new Ip();

//Configure the validator
$validator->setOptions([
		'allowipv4' 		=> true,
		'allowipv6' 		=> true,
		'allowipvfuture' 	=> false,
		'allowliteral' 		=> true,
	]);

//Check if the input value is a valid ip address (ipv4)
$isValid = $validator->isValid('192.168.56.101');

//Check if input value is a valid IP address (ipv6)
$isValid2 = $validator->isValid('2001:0db8:85a3:0000:8a2e:0370:7334');

//pass an invalid string 
$isValid3 = $validator->isValid('bla');

Hostname Validator:

The Hostname validator is designed to check if a given value is a hostname belonging to set of allowed host name types.
The types are:

a DNS hostname (e.g "example.com")

an IP address (e.g "192.168.0.1");

a local host name (eg "localhost")

The public methods provided by the validator are listed as follows:

Public methods of the Hostname validator:

__construct($options) 		Constructs the validator. Accepts a list of options

isValid($value) 			Returns ture when the value is a valid host name, otherwise return false

getMessages() 				If validation failed, get the error messages

setIpValidator($ipValidator) Optionally, allows to set own IP address validator

getIpValidator() 			Retrieves attached IP address validator

setAllow() 					Defines the type(s) of host names which are allowed

getAllow() 					Returns allowed host names types

useIdnCheck() 				Defines if Internationalized Domain Names (IDN) check is enabled. This options default is true.

getIdnCheck() 				Returns true if IDN check is enabled.

useTldCheck() 				Defines if Top Level Domain (TLD) check is enabled. This option defaults to true

getTldCheck() 				Returns true if TLD check is enabled

We can set which host names types are allowed with the setAllow() method. It accepts a combination of the following commands:

ALLOW_DNS : Allows Internet domain names (example.com)

ALLOW_IP : Allows IP addresses

ALLOW_LOCAL : Allows local network names (localhost, www.localdomain)

ALLOW_URI 	: Allow URI host names

ALLOW_ALL 	: Allows all types of host names

By default, only INternet domain names are allowed.

The host name check consists of several stages, some of which may be omitted based on validator options:

If the input value looks like an IP address, it is checked with the internal IP address validator. You can override
which IP address validator to use for this by the setIpValidator() method

The host name is separated into domain parts (separated with "." char)

The top-level domain is checked against the white list of available TLDs (You can disable this check with the useTldCheck()
method)

Each domain part is checked based on the rules for acceptable domain names. If a domain name is an IDN, it is checked against
for the rules of valid IDNs. (We can disable this with useIdnCheck() method)

An internationalized domain name (IDN) is a internet domain name that ocnsits of at least one label that is dispalyed, in whole
or part in a language-specific script or alphabet, like Arabic, Chinese or Russian.

Below, an example of using the Hostname validator:

<?php
use Zend\Validator\Hostname;

//Create the hostname validator
$validator = new Hostname();

//Configure the validator
$validator->setAllow(Hostname::ALLOW_DNS|Hostname::ALLOW_IP);

//Check the host name
$isValid = $validator->isValid('site1.example.com');
//Returns true

$isValid2 = $validator->isValid('abc');
//returns false, not a vlaid hostname

Uri Validator:

The uri validator is designed to check wether the input value is a URI. On failure, error messages can be 
extracted with the getMessages() method.

don't be confused with the Term of URI. In most cases, you may think of URI as a normal URL.

A URI is a compact sequence of chars that identifeis an abstract or physical resource. An URL
(UNiform Resource Lcoator) is a type of URI, but not all URIs are URLs.

The public methods provided by the Uri validator are as follows:

Public methods of the Uri validator:

__construct($options) 			Construct the validator. Accepts the list of options.

isValid($value) 				Returns true when the value is a valid URI, otehrwise returns false.

getMessages() 					If validation failed, we can retrieve all the errors in an array

setUriHandler($uriHandler) 		Sets the URI handler object for this validator

getUriHandler() 				Retrieves the URI handler for the validator

setAllowAbsolute($allowAbsolute) Tells the validator wether absolute URIs are accepted.

getAllowAbsolute() 				Retruns true if absolute URIs are accepted

setAllowRelative($allowRelative) Tells the validator wether relative URIs are accepted

getAllowRelative() 				Returns true if relative URIs are accepted.

Internally, the Uri validator uses so called URI handler object, which is responsible for parsing an URI string.
By default, Zend\Uri\Uri class is used as the URI handler. (You can set your custom URI handler with the setUriHandler()
method, if you wish).

An URI can be absoltue or relative. For example, an absolute URI is "http://example.com/blog/2014/02/02/edit", while a relative URI
is "2014/02/02/edit". You can specify wether the validator should consider absolute and/or relative URIs acceptable. For that, you use
the setAllowAbsolute() and setAllowRelative() methods, respectively.

By default, both are treated as acceptable URI types.

Below, a code example demonstrating the usage of the Uri validator is provided:

<?php
use Zend\Validator\Uri;

//Create the URI validator
$validator = new Uri();

//Configure the validator
$validator->setAllowAbsolute(true);
$validator->setAllowRelative(true);

//Check an URI
$isValid = $validator->isValid('http://site1.example.com/application/index/index');
//returns true

$isValid2 = $validator->isValid('index/index');
//returns true

Date Validator:

The Date validator is intended for checking wether the data is a date in a given format. On failure, error messages
can be extracted with the validator's getMessages() method.

Public methods provided by the Date validator are listed as follows:

Public methods of the Date validator:

__construct($options) 		Constructs teh validator. Accepts the list of options

isValid($value) 			Returns true when the value is a string containing a date in expected format; otherwise returns false.

getMessages() 				If validation failed, this method will return an array of error messages.

setFormat($format) 			Sets an acceptable date format

getFormat() 				Retrieves the expected format

To set the expected format, you can use the setFormat() method.

Internally, the DateTimeFormatter filter uses the DateTime class from the PHP standard lib for converting and formatting
dates. For avaialble date formats, please refer to the PHP documetnation on the DateTime class.

Below a code example demonstrating usage of the Date validator is shown:

<?php
use Zend\Validator\Date;

//Create validator instane
$validator = new Date();

//Configure the validator
$validator->setFormat('Y-m-d');

//Check if the input value is a date having expected format
$isValid = $validator->isValid('2014-04-04'); //returns true
$isValid2 = $validator->isValid('April 04, 2014'); //False, unexpected format

Regex Validator:

This validator allows you to validate if a given string conforms to some regex pattern. It returns true if
the String matches the regex, otherwise it returns false. On failure, error messages can be extracted with 
the validator's getMessages() method.

The public methods provided by the Regex validator are as follows:

public methods of the Regex validator:

__construct($options) 		Constructs the validator. Accepts the list of options

isValid($value) 			Returns true if and only if $value matches the given regex pattern

getMessages() 				Returns array of error messages 

setPattern($pattern) 		Sets the regex pattern

getPattern() 				Retrieves the regex pattern

The setPattern() method allows to set the regex to match against.

For regex syntax and examples, it is recommended that you refer to the PCRE Patterns section of the
PHP documentation.

Below, a code example demonstrating the usage of the Regex validator is provided. It uses the Regex to check
if the input string is a valid IPv4 address (Such address typical consist of 4 grotups of digits separated by .):

<?php
use Zend\Validator\Regex;

//Create regex validator
$validator = new Regex();

//Set regex to check for an IP address
$validator->setPattern('\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b');

//Check for regex expression match
$isValid = $validator->isValid("127.0.0.1"); //returns true
$isValid2 = $validator->isValid("123"); //returns false

Validators for Checking if a Numerical Value lies in a Given range:

In this section, we will consider usage exampels of the validators from group of validators designed for checking
if input value lies in a range.

NotEmpty Validator:

The NotEmpty validator allows to check if the input is not empty. This is often useful when working with form elements or other
forms of input where you can use it to ensure required elements have values associated with them.

The public methods provided by the NotEmpty validator is as follows:

Public methods of the NotEmpty validator:

__construct($options) 			Constructs the validator. Accepts the list of options

isValid($value) 				Returns true if and only if $value is not an empty value

getMessages() 					If validation failed, this method will return an array of error mesages.

setType($type) 					Sets the value of types that to consider as empty values

getType() 						returns the types

getDefaultType() 				Returns the default types

The setType() method specifies which variable types to consider as an empty value. This method accepts the single
argument $type which can be either an OR combination of the constants listed or an array containing the literal equivilants
of those constants.

Type constants:

Constant 		Numeric Value 			Literal equivilant 				Desc

BOOLEAN 		1 						"boolean" 						Consider boolean false as an empty value

INTEGER 		2 						"integer" 						Consider integer 0 as an empty value

FLOAT 			4 						"float" 						Consider float 0.0 as an empty value

STRING 			8 						"string" 						Consider an empty string as an empty value

ZERO 			16 						"zero" 							Consider string containg the single char 0 to be an empty value

EMPTY_ARRAY 	32 						"array" 						Consider an empty array as an empty value

NULL 			64 						"null" 							Consider null as an empty value

PHP 			127 					"php" 							Consider the value empty if the empty() PHP function returns true on it

SPACE 			128 					"space" 						Consider a string which constaints only spaces as empty

OBJECT 			256 					"object" 						Returns true. False will be returned, when object is not allowed, but an object is given.

OBJECT_STRING 	512 					"objectstring" 					Returns false when an object is given and it's __toString() method returns an empty string.

OBJECT_COUNT 	1024 					"objectcount" 					Returns false when an object is given, it has an Countable interface and it's count is 0

ALL 			2047 					"all" 							Consider all above types as empty values.

Below, a code example demonstrating the usage of the NotEmpty validator is provided:

<?php
use Zend\Validator\NotEmpty;

//Create validator instance
$validator = new NotEmpty();

//Configure validator
$validator->setType(NotEmpty::ALL);

//Check if input value not empty
$isValid1 = $validator->isValid('some string'); //Returns true
$isValid2 = $validator->isValid(''); //False
$isValid3 = $validator->isValid(0); //returns false

Between Validator:

The Between validator checks wether a number lies in a certain range (min, max), either incusively (by default) or exclusively

The public methods provided by the Between validator are listed as follows:

Public methods of the Between validator:

__construct($options) 		Constructs the validator. Accepts the list of options

isValid($value) 			Returns true if and only if value's length is within the given range

getMessages() 				if validation failed, this method will return an arrayf of error messages.

setMin($min) 				Sets the minimum limit

getMin() 					Retrieves the minimum limit

setMax($max) 				Sets the maximum limit

getMax() 					Retrives the maximum limit

setInclusive($inclusive) 	Sets wether to compare if the value lies in the given boundaries inclusively.

getInlcusive() 				Returns the inclusive option

The range can be set between min and max, with setMin() and setMax().

By default, the validator performs inclusive comparisons (to check if the value belongms to the given range, it compares if the vlaue
is greater or equal to its lower bound and less than or equal to its upper). You can change this with the setInclusive()
method. It tells the validator to perform inclusive comparisons (pass true as the argument) or exclusive comparisons (
pass false as the argument)

Below a code example demonstrating the usage of the Between validator is provided:

<?php
use Zend\Validator\Between;

//Create validator instance
$validator = new Between();

//Configure validator
$validator->setMin(1);
$validator->setMax(10);
$validator->setInclusive(true);

$isValid = $validator->isValid(5); //True
$isValid2 = $validator->isValid(10); //returns true
$isValid3 = $validator->isValid(0); //returns false (value is too small)
$isValid4 = $validator->isValid(15); //false, too big

InArray Validator:

The InArray validator checks wether the input value belongs to the given array of values. The public methods provided by the
InArray validator is as follows:

Public methods of the InArray validator:

__construct($options) 		Consturcts the validator. Accepts the list of options

isValid($value) 			Returns true if and only if value belongs to the given array

getMessages() 				If validation failed, this method will return an array of error messages

setHaystack($haystack) 		Sets the array to search in

getHaystack() 				Returns the array of allowed values

setStrict($strict) 			Sets strict comparison mode

getStrict() 				Wether strict comparison mode enabled

setRecursive($recursive) 	Tells teh validator to search recursively

getRecursive() 				Wether the recursive search is enabled

The setHaystack() method allows to set the array of allowed values. The isValid() method will search
through this array for the presence of the input $value

If the array contains nested values and you want to search among them recursively, then use setRecursive()
method. This method takes the single boolean flag. If the flag is true, then the search will be performed recursively,
otherwise nested levels will be ignored.

The setStrict() method provides an ability to tell the validator how to compare the input value and the values in array.
This may be a combination of the following constants:

COMPARE_NOT_STRICT : Do not perform strict check of variable type

COMPARE_NOT_STRICT_AND_PREVENT_STR_TO_INT_VULNERABILITY : Do not perform strict check of variable type, but prevent false psotiive
comparisons of strings to int (e.g "asdf" == 0). This is default

COMPARE_STRICT : Check both value and type

Below, an example of using the inArray validator:

<?php
use Zend\Validator\InArray;

//Create validator instance.
$validator = new InArray();

//Configure validator
$validator->setHaystack([1, 3, 5]);

//perform validation
$isValid1 = $validator->isValid(1); //returns true
$isValid2 = $validator->isValid(2); //False

StingLength Validator:

The StringLength validator checks wether the input string length belongs to the given range, inclusively. It returns true,
if and only if the string length of value is at least the min option and no greater than the max option (when the max option is not null).

The public methods are as follows:

Public methods of the StringLength validator:

__construct($options) 		Consturcts the validator. Accepts the list of options

isValid($value) 			Returns true if and only if value's length is within the given range

getMessages() 				if validation failed, this method will return an array of the error messages

setMin($min) 				Sets the minimum limit

getMin() 					Retrieves the minimum limit

setMax($max) 				Retrieves the maximum limit

getMax() 					Retrieves the maximum limit

setEncoding($encoding) 		Sets a new encoding to use

getEncoding() 				Retrieves the encoding

By default, the StringLength validator considers any string length as valid. Use the setMin() and/or setMax() methods
to set lower and upper limits for the allowable string length. There are three possible ways you can do that:

Use only the setMin() method to allow strings with a lower-bound min length, but unbound upper length

Use only setMax() method to allow string with zero minimum length and an upper-bound max length

Use both setMin() and setMax() methods to allow strings with a length laying between lower and upper

By default, teh PHP engine uses UTF-8 encoding for strings. If you input strings using a different encoding, you should
specify it encoding with the setEncoding() validator's method.

An example of using the StringLength validator:

<?php
use Zend\Validator\StringLength;

//Create validator instnace
$validator = new StringLength();

//Configure the vlaidator
$validator->setMin(1);
$validator->setMax(10);

$isValid1 = $validator->isValid("string"); //True
$isValid2 = $validator->isValid(""); //False, value was under min
$isValid3 = $validator->isValid("This is a very long string lol lolololoo"); //False, too long

Organizing Validators in a Chain:

Validators can be organized in a sequence. This is accomplished by the ValidatorChain class. When such a compound
validator is run, the input value is passed to all validators in turn. The ValidatorChain validator's isValid()
method returns true if all the validators in the chain return true, otherwise it returns false.

The ValidatorChain class is internally used by the InputFilter container class for storing the sequence of
validators attached to a form model's field.

Public methods provided by the ValidatorChain class are as follows:

Public methods of the ValidatorChain validator:

isValid($value) 		Returns true if all validators in the chain return true

getMessages() 			Returns the array of validation error messages

getValidators() 		Returns the array of validators in the chain

count() 				Returns count of validators in the chain

attach($validator, $breakChainOnFailure) 	Attaches a validator to the end of the chain

prependValidator($validator, $breakChainOnFailure) 	Adds a validator the beginning of the chain

attachByName($name, $options, $breakChainOnFailure) Use the plugin manager to add a validator by name.

prependByName($name $options, $breakChainOnFailure) Use the plugin manager to prepend a validator by name

merge($validatorChain) 	Merge the validator chain with the one given in the param

An example validator chain is shown soon. It consists of the NotEmpty validator followed by the StringLength validator,
which in turn is followed by teh Date validator. When thsi chain is executed, first, the "NotEmpty" validator is run
checking that the value is a non-empty value, then the StringLength validator is run checking that the length of the
input string belongs to the range (1,16), inclusively, finally, the date validator is run checking that the input
value is a format of "YYYY-MM-DD".

				V
			NotEmpty
				V
			StringLength
				V
			Date
				V

To construct the filter chain as above, we do:

<?php
//instansiate the validator chain
$validator = new \Zend\Validator\ValidatorChain();

//Insert validators into validator chain
$validator->attachByName('NotEmpty');
$validator->attachByName('StringLength', ['min'=>1, 'max'=>16]);
$validator->attachByName('Date', ['format'=>'Y-m-d']);

//Execute all validators in teh chain
$isValid = $validator->isValid('2014-04-04'); //Returns true

Custom Validation with the Callback Validator:

The Callback validator can be a wrapper for your custom validation algorithm. For example, this may be useful when a
standard validator is not sutiable, and you need to apply your own checking algorithm to the data.

THe public methods provided by the Callback validator are as follows:

Public methods of the Callback validator:

isValid($value, $context) 		Executes a callback function as a validator

getMessages() 					If validation failed, this allows us to get the errors 

setCallback($callback)			Sets a new callback for this filter

setCallbackOptions($options) 	Sets options for the callback

getCallbackOptions() 			Get parameters for the Callback

As you can see from the table, the Callback validator provides the setCallback() and setCallbackOptions() methods 
that can be used to set the callback function or class method and (optionally) pass it one or several parameters.

Example:

To demonstrate the usage of the Callback validator, let's add the phone number validator to our ContactForm
form model class. The validator would check a telephone number entered by a site visitor.

The validator needs to be able to check for two common phone number formats:

international format looking like "1 (234) 567-8901"

local format, which looks like "567-8901"

Because ZF3 does not have a standard validation against htis, we will use the Callback wrapper validator.
To do that, we will make the following changes to the code of our ContactForm class:

<?php
//...
class ContactForm extends Form
{
	//...
	protected function addElements() {
		//...

		// Add "Phone" field
		$this->add([
			'type' => 'text',
			'name' => 'phone',
			'attributes' => [
				'id' => 'phone'
			],
			'options' => [
				'label' => 'Your Phone',
			],
		]);
	}

	private function addInputFilter()
	{
		//...

		$inputFilter->add([
				'name' 		=> 'phone',
				'required' 	=> true,
				'validators' => [
					[
						'name' => 'Callback',
						'options' => [
							'callback' => [$this, 'validatePhone'], //This refers to the Form class which we are in, validatePhone is the CB
							'callbackOptions' => [ //The options
								'format' => 'intl'
						]
					]
				]
			]
		]);
	}

	//Custom validator for a phone number
	public function validatePhone($value, $context, $format)
	{
		//determine the correct length and pattern of the phone number
		// depending on format
		if($format == 'intl') {
			$correctLength = 16;
			$pattern = '/^\d\ (\d{3}\) \d{3}-\d{4}$/';
		} else { // 'local'
			$correctLength = 8;
			$pattern = '/^\d{3}-\d{4}$/';
		}

		//Check phone number length
		if(strlen($value)!=$correctLength)
			return false;

		//Check if the value matches the pattern
		$matchCount = preg_match($pattern, $value);

		return ($matchCount!=0)?true:false;
	}
}

In the code above, we create the phone field in our ContactForm (if you already have such a field, ignore this).

In lines 26-40, we add the Callback validator to the input filter's validator chain for the "phone" field.

In lines 44-64, we have the validatePhone() callback method. The method accepts three arguments: the $value parameter
is the phone number to validate, the $context parameter receives the values of every field of the form (it may be needed for
some validators to refer to the values of other form fields, too) and the $format parameter is expected format of the 
phone numbner (intl or local)

Inside of the Callback method, we do the following:

1. Calculate the correct length of the phone, check wether the length is correct for the selected phone number format

2. Match the phone number against the regex pattern for the selected phone format.

Writing Own Validator:

An alternative of using the Callback validator is writing your own validator class implementing the ValidatorInterface interface.
Then, this validator may be used in forms of your web application.

To demonstrate how to create your own validator, we will write the PhoneValidator class encapsulating the phone validation
algorithm we used with the Callback validator example.

As you might remember, the base concrete class for all standard validators is the AbstractValidator class. By analogy,
we will also derive our custom PhoneValidator validator from that base class.

We plan to have the following methods in our PhoneValidator validator class:

Public methods of the Callback validator:

__construct($options) 		Constructor. Accepts an optional argument $options which is needed to set validators options at once

setFormat($format) 			Sets the phone format option

getFormat() 				Returns the phone format option

isValid($value) 			Returns true when the value is a valid phone number, otherwise returns false

getMessages() 				If validation failed, this method will return an array of error messages.

For the phoneValidator, we will ahve three possible error messages:

if a non-scalar value is passed to teh validator, it will generate the error message "The phone number must be a scalar value"

If the international format is selected and the phone number is not, the validation will generate the message "THe phone number must be in an international format"

if the local phone format is selected and the phone number entered does not match the format, the validator will generate the 
message "The phone number must be in local format".

To start, create the PhoneValidator.php file in the Validator dir under the module's source directory. Put the following
code into that file:

NOTE: The PhoneValidator class may be considered as a service model, because it's goal is to manipulate data, not store it. by convention,
we store custom validators under the Validator directory.

<?php
namespace Application\Validator;

use Zend\Validator\AbstractValidator;

//This validator class is designed for checkign a phone number for conformacne to the local or to the
//international format
class PhoneValidator extends AbstractValidator
{
	//phone format constants
	const PHONE_FORMAT_LOCAL = 'local'; //Local phone format
	const PHONE_FORMAT_INTL = 'intl'; //international phone format

	//Available validator options
	protected $options = [
		'format' => self::PHONE_FORMAT_INTL
	];

	//Validaiton failure message IDs
	const NOT_SCALAR = 'notScalar';
	const INVALID_FORMAT_INTL = 'invalidFormatIntl';
	const INVALID_FORMAT_LOCAL = 'invalidFormatLocal';

	//Validaiton failure messages
	protected $messageTemplates = [
		self::NOT_SCALAR => "The phone number must be a scalar value.",
		self::INVALID_FORMAT_INTL => "The phone number must be in international format",
		self::INVALID_FORMAT_LOCAL => "The phone number must be in local format",
	];

	//Constructor
	public function __construct($options = null)
	{
		//set filter options (if provided)
		if(is_array($options)) {

			if(isset($options['format'])) 
				$this->setFormat($options['format']);
		}

		//Call the parent class constructor
		parent::__construct($options);
	}

	//Sets phone format
	public function setFormat($format)
	{
		//Check input argument
		if($format!=self::PHONE_FORMAT_LOCAL && $format!=self::PHONE_FORMAT_INTL) {
			throw new \Exception('Invalid format argument passed.');
		}

		$this->options['format'] = $format;
	}

	//Validates a phone number
	public function isValid($value)
	{
		if(!is_scalar($value)) {
			$this->error(self::NOT_SCALAR);
			return $false; //phone number must be a scalar
		}

		//Convert value to stirng
		$value = (string)$value;

		$format = $this->options['format'];

		//determine the correct length and pattern of the phone number
		//depending on the format
		if($format == self::PHONE_FORMAT_INTL) {
			$correctLength = 16;
			$pattern = '/^\d \(\d{3}\) \d{3}-\d{4}$/';
		} else { //Self::PHONE_FORMAT_LOCAL
			$correctLength = 8;
			$pattern = '/^\d{3}-\d{4}$/';
		}

		//First check phone number length
		$isValid = false;
		if(strlen($value)==$correctLength) {
			//check if the value matches the pattern
			if(preg_match($pattern, $value))
				$isValid = true;
		}

		//if there was an error set the error message
		if(!$isValid) {
			if($format==self::PHONE_FORMAT_INTL)
				$this->error(self::INVALID_FORMAT_INTL);
			else
				$this->error(self::INVALID_FORMAT_LOCAL);
		}

		return $isValid;
	}
}

From line 2, we can see that the validator class lives in the Application\Validator namespace.

In line 8, we define the PhoneValidator class. We derive our validator class from the AbstractValidator base
class to reuse the functionality it provides. Line 4 contains the short alias for the AbstractValidator class.

In lines 11-12, for convinience, we define the phone format constants (PHONE_FORMAT_INTL for international and
PHONE_FORMAT_LOCAL for local format). These are the equivalents of the "intl" and "local" strings, respectively.

In lines 15-17, we define the $options private array variable which is an array having the single key named "format".
This key will contain the phone format option for our validator.

In lines 20-22, we define the error message identifiers. We have three identifiers (NOT_SCALAR, INVALID_FORMAT_INTL and
INVALID_FORMAT_LOCAL), because our validator may generate three different error messages. These identifiers
are intended for distingushing different error messages by machine, not by human.

In lines 25-29, we have the $messageTemplates array variable that contains mapping before error message identifiers
and their textual representations. The textual messages are intended for displaying to a human.

In lines 32-43, we have the constructor method which takes the single argument $options. When constructing
the validator manually, you may omit this param. but when the validator is constructed by facotry, the factory
passes options to the validator through this param.

In lines 46-55, we have the setFormat() method that allow to set the current phone format, respectively.

In lines 58-98, we have the isValid() method. This method encapsulates the phone number checking algorithm.
It takes the $value parameter, performs regex and returns true on success.

On failure, the isValid() method returns the boolean false, and the list of errors can be retrieved by the getMessages()
method.

You might notice that we did not define the getMessages() method in our PhoneValidator class. This is because we inherited
it from AbstractValidator. Inside of our isValid() method, for generating error messages, we also used the error()
protected method provided by the base class.

Using the PhoneValidator Class:

When the PhoneValidator validator class is ready, you can easily start using it in the feedback form (or another form), 
as follows. It is assumed that you call the following code inside of the ContactForm::addInputFilter() method:

$inputFilter->add([
		'name' => 'phone',
		'required' => true,
		'validators' => [
			[
				[
				'name' => PhoneValidator::class,
				'options' => [
					'format' => PhoneValidator::PHONE_FORMAT_INTL
				]
			],
		],
	//...
	],	
]);

We can see how the PhoneValidator validator works in the Form Demo sample application bundeled with this book.
Open the "http://localhost/contactus" page in your web browser. If you enter some phone number in an incorrect format,
the validator will display an error.

If you wish, you can use the PhoneValidator outside of forms, as follows:

<?php
use Application\Validator\PhoneValidator;

//Create PhoneValidator validator
$validator = new PhoneValidator();

//Configure the validator
$validator->setFormat(PhoneValidator::PHONE_FORMAT_INTL);

//Validate a phone number
$isValid = $validator->isValid('1 (234) 567-8901'); //Returns true
$isValid2 = $validator->isValid('12345678901'); //returns false

if(!$isValid2) {
	//Get validation errors
	$errors = $validator->getMessages();
}

Using Filters & Validators Outside a Form:

In this section, we will provide an example of how you can use filters and/or validators in your controller to transform
and check the data extracted from GET and/or POST variables.

Let's assume we implement a payment gateway system and need to create a web page displaying a payment history
for the given credit card on given date. This page can be handled by some paymentHistoryAction() action of a controller class,
and the credit card number and date will be extracted from GET variables.

For the paymentHistoryAction() method, we need to implement some security checks:

We want to ensure that the credit card number looks like a typical credit card number "4532-7103-4122-1359" (Conforms to ISO/IEC 7812 standard)

And that the date is in 'YYYY-MM-DD' format.

Below, we find the code of an action method:

<?php
namespace Application\Controller;

use Zend\Mvc\Controller\AbstractActionController;
use Zend\View\Model\ViewModel;
use Zend\Filter\StaticFilter;
use Zend\Validator\StaticValidator;

class IndexController extends AbstractActionController
{
	//An action which shows the history of a credit
	// card operations on certain date
	public function paymentHistoryAction()
	{
		//Get params from GET
		$cardNumber = (string)$this->params()->fromQuery('card', '');
		$date = (string)$this->params()->fromQuery('date', date("Y-m-d"));

		//Validate credit card number
		$isCardNumberValid = StaticValidator::execute($cardNumber, 'CreditCard');
		if(!$isCardNumberValid) {
			throw new \Exception('Not a credit card number');
		}

		//Convert date to the right format
		$date = StaticFilter::execute($date, 'DateTimeFormatter', ['format'=>'Y-m-d']);

		// The rest of the action code goes here

		return new ViewModel();
	}
}

Inside the action method, we use the params() controller plugin (line 16-17) to retrieve two variables from $_GET super-global array:
the card variable (credit card number) and the date variable (the date).

In line 20, we validate the credit card number with hte help of the CreditCard validator. If the card number is not acceptable,
we throw an exception indicating an error (line 22).

In line 26, we use the DateTimeFormatter filter to convert the date to teh right format.

Summary:

Validators are designed to take some input data, check it for correctness, and return a boolean result telling whether the data
is correct (and error messages if the data has some errors).

In ZF3, there are several groups of standard validators:

Validators for checking value conformance to certain format.

Validators for checking a numerical value lies in a given range

Validators working as "proxies" to otehr validators.

In some cases, a standard one is not enough. In that case, we use the Callback validator
or write our own custom Validator class.

Uploading Files with Forms:

In this chapter, you will learn about uploading files with forms. First, we will review the basic theory like HTTP
file upload capability and binary content transfer encoding, and then provide a complete working Image Gallery example
showing how to upload images to web server.

ZF3 components covered in this chapter:

Zend\Form 		Contains base form model classes

Zend\Filter 	Contains various filters classes

Zend\Validator 	Implements various validator classes.

Zend\InputFilter Implements a container for filters/validators.

About HTTP File Uploads:

HTML forms have capability for uploading files of arbitrary large size. The files are typically transmitted through
HTTP POST method.

HTTP file uploads are described in RFC-1867. This mechanism allows to upload large files by using binary content 
transfer encoding. The "mutlipart/form-data" encoding type is utilized for this purpose.

The HTTP GET method is inefficient for file uploads, because URL length has some upper limit. Also, URL-encoding
the file data greatly increases the URL length.

By default, HTTP uses the URL encoding for transfers of form data, and you could see how that encoding looks like
in previous chapters. However, this encoding is inefficient for uploading large files, since URL-encoding binary
data dramatically increases the length of the HTTP request.

For the purpose of uploading files, it is instead recommended to use the so called "binary transfer encoding" described
in the next section.

HTTP Binary Transfer Encoding:

A simple HTML form capable of file uploads is shown in the code example below. The binary encoding type is enabled
by setting the enctype attribute of the form with the value of "multipart/form-data".

<form action="upload" method="POST" enctype="multipart/form-data">
	<input type="file" name="myfile">
	<br/>
	<input type="submit" name="Submit">
</form>

In line 1, we explicitly set form encoding (enctype attribute) to "multipart/form-data" to utilize effective binary content
transfer encoding for the form.

IN line 2, we define an input field with the type "file" and name "myfile". This input field will allow site visitor to select
the file for upload.

If you now save the above mentioned markup to an .html file and open it in your browser, we would see a form for uploading.

THe file element has the Browse.. button, allowing to pick a file for upload. When the site user picks some file and clicks
the Submit button on the form, the web browser will send an HTTP request to the web server, and the request will contain the
data of the file being uploaded.

The example below illustrates how the HTTP request may look like:

POST http://localhost/upload HTTP/1.1
Host: localhost
Content-Length: 488
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64)
Content-Type: multipart/form-data; boundary=----<bla>
Accept-Encoding: gzip, deflate, sdch

------<bla>
Content-Disposition: form-data; name="myfile"; filename="Somefile.txt"
Content-type: text/html

(file binary data goes here)
------<bla>
Content-Disposition: form-data; name="Submit"

Submit Request
------<bla>

As you can see from the example above, the HTTP request with "multipart/form-data" encoding type looks analogous
to a usual HTTP request (has the status line, the headers, and the content area), however, it has the following important differences:

Line 5 sets the "Content-Type" header with "multipart/form-data" value; The form is assembled of the fields marked by the
"boundry" -- a unique randomly generated sequence of characters delimiting form fields of each other.

Lines 8-17 represent the content of the HTTP request. The form fields are delimieted by the "boundary" sequences (lines 8, 13, 17)
The data of the file being uploaded are transmitted in binary format, which allows to reduce content size to it's minimum.

By default, PHP's engine settings do not allow to upload large files (larger than 2MB). In order to upload large files,
you may need to edit the php.ini configuration file and modify the post_max_size and upload_max_filesize parameters
(Please refer to Appendix A for seeing how that is done).

Setting these with 100M allows files up to 100 MB in size, and this would typically be sufficient.

If we plan to upload very large files, such as 1Gb, set it to 1024M. Do not forget to restart the Apache Web Server after editing
the config file.

$_FILES Super-Global Array in PHP:

When a site visitor uploads some files to your Apache Web Server, the files are placed to a temporary location (usually to
system temporary directory that is /tmp in Linux and C:\Windows\Temp in Windows). The PHP script receives the file information
to the special super-global array named $_FILES.

The $_FILES array is analogous to the $_GET and $_POST super-globals. The latter two are used to store the GET and POST 
variables, respectively, while the first one is used to store information about uploaded files.

For example, for the above mentioned simple upload form, the $_FILES super-global array will look as follows (the output is 
generated with the var_dump() PHP function):

array (size=1)
	'myfile' => 
		array (size=5)
			'name' => string 'somefile.txt' (length=12)
			'type' => string 'text/plain' (length=10)
			'tmp_name' => string '/tmp/phpDC66.tmp' (length=16)
			'error' => int 0
			'size' => int 18

As you can see from the example above, the $_FILES array contains an entry per each uploaded file. For each uploaded file,
it contains the following information:

name -- Original file name

type -- MIME type of the file 

tmp_name -- temporary name for the uploaded file

error -- error code signaling about the status of the upload, error code zero means the file was uploaded correctly

size -- file size in bytes

MIME type, also known as "content-type" is a standard identifier on the Internet to indicate the type of data that a file
contains. For example, the "text/plain" MIME type is assigned to a text file, while the "application/octet-stream" MIME
type is assigned to a binary file.

PHP engine stores the uploaded file in a temporary location which is cleaned up as soon as the PHP script execution
ends. So, if you want to save the uploaded files to some directory for later use, you need to utilize the move_uploaded_file()
PHP function. The move_uploaded_file() function takes two arguments: teh first one is the name of the temporary file,
the second is the destionation file name.

You might be confused why you cannot use the usual rename() PHP function for moving the temporary uploaded file 
to its desitnation path. PHP has special function for moving uplaoded files for security reasons.

The move_uploaded_file() function is analogous to rename() function, but it takes some additonal checks to ensure
the file was really transfered through HTTP POST request, and that the upload process has finished without errors.

The following code example shows how to move the file uploaded with the simple form we have considered above:

$destPath = '/path/to/your/upload/dir';
$result = move_uploaded_file($_FILES['myfile']['tmp_name'], $destPath);
if(!$result) {
	//Some error occured
}

Above, in line 1, we set the $destPath with the directory name where to save the uplaoded file.

In line 2, we call the move_uploaded_file() function and pass it two arguments: the path to the temporary file
and the destination path.

Specifying the directory name as the second argument of the move_uploaded_file() function is sutiable when
you do not want to rename the file. if you need to save the uploaded file under another name than its original name,
you can specify the full path instead of the directory name.

In line 3, we check the returned value of the function. If the operation is successful, the function will return
true. If some error occurs (for example, if directory permissions are insufficient to save the file), the boolean
false will be returned.

Accessing Uploaded Files in ZF3:

In your controller class, you typically do not communicate with the $_FILES array directly, instead you may use the 
Request class or the Params controller plugin, as shown in the example below:

<?php
//...
class IndexController extends AbstractActionController
{
	//An example controller action intended for handling file uploads
	public function uploadAction()
	{
		//Get the whole $_FILES array
		$files = $this->getRequest()->getFiles();

		//The same, but with Params controller plugin
		$files = $this->params()->fromFiles();

		//get a single entry of the $_FILES array
		$files = $this->params()->fromFiles('myfile');
	}
}

IN line 9 of the code above, we use the getRequest() method of the controller class for accessing the Request object,
and the getFiles() method of the request object to retrieve the information about all upload files at once.

In line 12, we do the same thing with the Params controller plugin. We use its fromFiles() method to get the information
about all uploaded files.

If needed, you can extract the information for the specific file only. In line 15, we use the same fromFiles() method and 
pass it the name of the file to retrieve. This retrieves the single file entry from the $_FILES super-global array.

File Uploads & ZF3 Form Model:

To add uploading capability to your form model, you need to add an element of the Zend\Form\Element\File class as follows:

//Add the following code inside of Form's addElements() method.
//If doing this alias form, add the usage of namespace:

use Zend\Form\Element\File;

//Add the "file" field

	$this->add([
		'type' => 'File',
		'name' => 'File',
		'attributes' => [
			'id' => 'File'
		],
		'options' => [
			'label' => 'Upload file',
		],
	]);

IN the code above, we call teh add() method provided by the Form base class and pass it the configuration array describing
the element. The type key of the array must be either Zend\Form\Element\File class name or using alias, go with 'file'.

NOTE: Might be "file" instead of "File", but i suspect that it is "File", since alias rules.

Validating Uploaded Files:

Uploaded files needs to be checked for correctness as any other form data. For example, you may need to check that:

the file(s) were really uploaded through HTTP POST request, and were not just copied from some directory.

The files(s) were uploaded successfully (the error code is zero)

the file names and/or extensions are acceptable (e.g, you may want to save JPEG files only, and reject all others);

the file size lies in the allowed range (e.g, you may want to ensure that the file is not too big)

total count of uploaded files does not exceed some allowed limit

For doing the checks like above, ZF3 provides a number of useful file validators (listed as follows), those validator
classes belong to Zend\Validator and live in the Zend\Validator\File namespace:

Standard File Validators:

Class name 			Short Alias 			Desc

Count 				FileCount 				Checks whether the file count is in a given range (min, max)

WordCount 			FileWordCount 			Calculates the number of words in a file and checks wether it lies in a given range

Upload 				FileUpload 				Performs checks ensuring that all given files were really uploaded through HTTP POST and there 
											were no upload errors.

UploadFile 			FileUploadFile 			Performs security checks ensuring that a file really was uploaded through HTTP POST and there
											were no upload errors.

Size 				FileSize 				Checks wether the file size lies in a given range

FilesSize 			FileFilesSize 			Checks that the summary size of all given files lies in a given range

Extension 			FileExtension 			Checks that the extension of a file belongs to a set of allowed extensions.

ExcludeExtension 	FileExcludeExtension 	Checks that the extension of a file DOES NOT belong to a set of extensions.

MimeType 			FileMimeType 			Checks that the MIME type of a file belongs to the list of allowed MIME types.

ExcludeMimeType 	FileExcludeMimeType 	Checks taht the MIME type of a file DOES NOT belong to the list of MIME types.

IsImage 			FileIsImage 			Checks that the file is a graphical image (JPEG, PNG, GIF, etc.)

ImageSize 			FileImageSize 			Checks taht the image file's dimensions lie in a given range.

Exists 				FileExists 				Checks wether the file exists on Disk.

NotExists 			FileNotExists 			Checks wether the file does not exist on Disk.

IsCompressed 		FileIsCompressed 		Checks that the File is an archive (ZIP, Tar, etc.)

Hash 				FileHash 				Checks that the file content matches the given hash(es)

Crc32 				FileCrc32 				Checks that the file content has the given CRC32 check sum

Sha1 				FileSha1 				Checks that hte file content has the given SHA-1 hash

Md5 				FileMd5 				Checks taht hte file content has the given MD5 hash

As you can see from the table above, file validators may be roughly divided into the following groups:

validators checking whether the file(s) were really uploaded through HTTP POST and upload status is OK.

validators checking the uploaded file count and file size.

validators checking the file extension and MIME type.

validators checking whether the file is a graphical image and checking image dimensions.

and validators checking the file hash (or check sum)

A file hash is used for checking file data integrity (for example, to ensure that file data is not corrutped). There are several hash algos
available (MD5, SHA-1, CRC-32 etc.)

PLease note that since file validators live in Zend\Validator\File namespace, their short aliases (that you use when
creating a validator with the factory) start with File prefix. For example, the IsImage validator has FileIsImage alias.

We will show how to use some of these file validators in teh Image Gallery code example later in this chapter.

Filtering Uploaded Files:

ZF3 provides several filters intended for "transforming" file fields. Those filter classes (listed soon), belong to
Zend\Filter component and lives in the Zend\Filter\File namespace.

Standard File Filters:

class name 			Short alias 			Desc

Rename 				FileRename 				Renames/moves an arbitrary file

RenameUpload 		FileRenameUpload 		Renames/moves the uploaded file with security checks

Encrypt 			FileEncrypt 			Encrypts a given file and stores the encrypted file content

Decrypt 			FileDecrypt 			Decrypts a given file and stores the decrypted file content

LowerCase 			FileLowerCase 			Converts file content into lower case letters.

UpperCase 			FileUpperCase 			Converts file content to upper case letters.

From the table, you can see that the filters can be divided into the following groups:

filters for moving uploaded files from a temporary location to their persistent dir

filters for encryption and decryption of files

filters for converting text files to upper-case and lower-case letters

Please note that since file filters live  in Zend\Filter\File namespace, their short aliases (that you use
when creating a Filter with the factory) start with the File prefix. For example, RenameUpload has FileRenameUpload alias.

The Encrypt and Decrypt filters allow to apply various encryption/decryption algos to the uploaded file (concrete algorithm
is attached by specifying the certain adapter). The LowerCase and UpperCase filters are suitable for converting text files
to lower and upper case respectively.

In the Author's opinion, the above mentioned four filters are not very useful when working with Uploaded FIles, cause
no real need.

The Rename filter allows to rename and/or move an arbitrary file (not only uploaded file). It uses the rename() php
functiron internally, and that is why it is in generally not recommended to use thsi filter with uploaded files 
because of security reasons.

The RenameUpload filter seems to be much more useful than other filters, because it allows to encapsulate the
call of the move_uploaded_file() function and move/rename the uploaded file from the temporary location to
it's permanent persistence directory. We will show how to use the RenameUpload filter, later.

InputFilter Container & File Uploads:

As you might remember, the filters and validators attached to a form model are typically stored in an InputFilter container
which consists of inputs (an input is typically represented by the Input class belonging to the Zend\InputFilter namespace).
For usual form fields, the filters are executed BEFORE validators, and validators are executed AFTER filters.

However, for file uploads, there are some important differences:

For storing validation rules for uploaded files, a special class called FileInput should be utilized instead of teh Input class.

Validators are applied BEFORE filters.

FileInput:

For storing validation rules for uploaded files, you must use the FileInput class instead of the usual Input class.

In your form model's addInputFilter() private method, you add the validation rules for the file input as follows:

		$inputFilter->add([
			'type' 		=> 'Zend\InputFilter\FileInput',
			'name' 		=> 'file', //elements name
			'required' 	=> true, //Wether the field is required
			'filters' 	=> [ //Filters
				//Put filters info here
			],
			'validators' => [ //Validators
				//Put validator info here
			]
		]);

Above, we set the type key (line 2) with the value Zend\InputFilter\FileInput class name. The rest of keys is analogous
to those we used before when adding validation rules for a form model.

The behaviour of FileInput class differs from the Input in the following aspects:

It expects data you pass as input to be in the $_FILES array format (an array entry with tmp_name, error, type keys).

A Zend\Validator\File\Upload validator is automatically inserted before all other validators into the validator 
chain of the input

The validators inserted to the validator chain of the input are executed before the filters inserted into its 
filter chain. This is opposite to the behaviour of the Input class.

Executing Validators before Filters:

For usual form fields, the filters are typically executed before validators, and validators are executed after filters.
However, for file uploads, this sequence is the opposite.

For file uploads, validators are executed before filters. This behaviour is inverse to the usual behaviour.

When working with uploaded files, we first need to check that data extracted from $_FILES super-global array
is correct, and then do anything else with the files (moving the file into a storage directory, renaming it, etc.).

Because of that, file validators need to be run first turn and filters to be executed last.

To see how this is performed, recall the typical workflow for a form:

First, we call the setData() method to fill the form with data

Call the isValid() method to execute filters and validators in the input filter attached to form

On successful validation, call the getData() to extract the filtered and validated data from the input filter
attached to form.

On failure, call the getMessages() to retrieve the validation error messages.

When using a FileInput input, the workflow is the same, however, it is important to understand what happens on
each of its steps:

Call the setData() method to fill in the form with data.

Call the isValid() method to execute validators in the input filter attached to form

On successful validation, call the getData() to execute filters and extract their filtered
data from the input filter attached to form.

On failure, call the getMessages() to retrieve the validation error messages.

Please note that for FileInput input, the attached filters are only run if the getData() method is called.

When you use both Input and FileInput inputs in your form's input filter (which is a common case), the filters
are still executed first for usual inputs, but validators are executed first for file inputs.

Controller Action & File Uploads:

In this section, we will provide a short code example showing how to handle file uploads in a controller 
action method. We will attract reader's attention to the aspects specific to file uploads.

Assume we want to add a web page displaying a form (Let's name it YourForm) capable of file uploads. For that page,
we need to add the uploadAction() method to a controller class.

<?php
//...
class IndexController extends AbstractActionController
{
	//This is the "Upload" action displaying the upload page
	public function uploadAction()
	{
		//Create the form model
		$form = new YourForm();

		//Check if user has submitted the form
		if($this->getRequest()->isPost()) {
			//Make certain to merge the files info

			$request = $this->getRequest();
			$data = array_merge_recursive(
				$request->getPost()->toArray(),
				$request->getFiles()->toArray()
			);

			//pass data to form
			$form->setData($data);

			//Execute file validators
			if($form->isValid()) {

				//Execute file filters
				$data = $form->getData();

				//Redirect the user to another page
				return $this->redirect()->toRoute('application', ['action' => 'index']);
			}
		}

		//Render the page
		return new ViewModel([
				'form' => $form
			]);
	}
}

As you can see from the code above, the uploadAction() looks like a usual controller action implementing a typical form workflow,
however it has some aspects specific to file uploads.

In line 9, we create an isntance of the YourForm form model with the help of the new Operator (assuming we defined such a form and used the Alias).

In line 12, we check whether the request is an HTTP POST request. If so, we get the data from $_POST and $_FILES super-global PHP arrays and merge
them into the single array (line 15-19). This is required to correctly handle uploaded files, if any.

Then we pass this array to the form model with setData() method (line 22).

In line 25, we call the form model's isValid() method. This method runs the input filter attached to the form model. For FileInput
inputs, this will execute attached validators only.

If the data is valid, we call the getData() method (line 28). For the FileInput inputs, this will run the attached file filters.
The file filters, for example, could move the uploaded files to the directory of residence.

On success, line 31, we redirect the user to the "index" action of the controller.

In the controller action above, you should remember three things: 

1) merge $_POST and $_FILES super-global arrays before you pass them to the form's setData() method. 

2) use isValid() form's method to check uploaded files for correctness (run validators)

3) use getData() form's method to run file filters.

Example: Image Gallery:

To demonstrate the usage of file uploads in ZF3, we will create an Image Gallery that will consist of two web pages:
the image upload page allowing to upload an image and the gallery page containing the list of uploaded images.

We can see the working Image Gallery example in the Form Demo sample application bundled with this book.

For this example, we will create the following things:

the ImageForm model capable of image file uploads

the ImageManager service class designed for getting the list of uploaded images, retrieving information about 
an image and resizing an image.

the ImageController class which will contain action methods serving the web pages.

the ImageControllerFactory factory that will instansiate the controller and inject dependencies into it

a view template .phtml file per each controller's action method

Adding ImageForm Model:

For this example, we will need a form model which will be used for image file uploads. We will call that form
model class the ImageForm. This class will allow us to upload an image file to the server. The form will have the following fields:

the file field will allow the user to pick an image file for upload

the submit button field allowing to send the form data to server

The code of the ImageForm form model is presented below. It should be put to ImageForm.php file stored in Form directory under the
module's source directory:

<?php
namespace Applicaton\Form;

use Zend\Form\Form;

//This form is used for uploading an image file
class ImageForm extends Form
{
	//Constructor
	public function __construct()
	{
		//Define form name
		parent::__construct('image-form');

		//Set POST method for this form
		$this->setAttribute('method', 'post');

		//Set binary content encoding
		$this->setAttribute('enctype', 'multipart/form-data');

		$this->addElements();
	}

	//This method adds elements to form
	protected function addElements()
	{
		//add "file" field
		$this->([
			'type' => 'file',
			'name' => 'file',
			'attributes' => [
				'id' => 'file'
			],
			'options' => [
				'label' => 'Image file',
			],
		]);

		//add the submit button
		$this->add([
			'type' => 'submit',
			'name' => 'submit',
			'attributes' => [
				'value' => 'Upload',
				'id' 	=> 'submitbutton',
			],
		]);
	}
}

We have already discussed the form model creation and the code above should not cause 
any problems in its understanding. We just want to attract the attention of the reader 
that in line 19, we set the "multipart/form-data" value for the "enctype" attribute of
the form to make the form use binary encoding for its data.

Actually, explicitly setting the "enctype" attribute in form's constructor is optional, because
Zend\Form\Element\File element performs that automatically when you call the form's prepare() method.

Adding Validation Rules to ImageForm Model:

To demonstrate the usage of validators and filters designed to work with file uploads, we will add those
to the ImageForm form model class.

We want to achieve the following goals:

check if the uploaded file really was uploaded through HTTP POST method using the UploadFile validator

check that the uploaded file is an image (JPEG, PNG, GIF, etc) using the IsImage validator

check that the image dimensions are within some allowed boundaries, we will do that with the ImageSize validator

move the uploaded file to its residence directory using the RenameUpload filter.

To add form validation rules, modify the code of the ImageForm class as follows:

<?php
namespace Application\Form;

use Zend\InputFilter\InputFilter;

//This form is used for uploading an image file
class ImageForm extends Form
{
	//Constructor
	public function __construct()
	{
		//...

		//Add validation rules
		$this->addInputFilter();
	}

	//...

	//This method creates input filter (used for form filtering/validation)
	private function addInputFilter()
	{
		$inputFilter = new InputFilter();
		$this->setInputFilter($inputFilter);

		//Add validation rules for the "file" field
		$inputFilter->add([
				'type' 	=> 'Zend\InputFilter\FileInput',
				'name' 	=> 'file',
				'required' => true,
				'validators' => [
					['name' => 'FileUploadFile'],
					[
						'name' 	=> 'FileMimeType',
						'options' => [
							'mimeType' => ['image/jpeg', 'image/png']
						]
					],
					[ 'name' => 'FileIsImage'],
					[
						'name' 	=> 'FileImageSize',
						'options' => [
							'minWidth' => 128,
							'minHeight' => 128,
							'maxWidth' => 4096,
							'maxHeight' => 4096
						]
					],
				],
				'filters' => [
					[
						'name' => 'FileRenameUpload',
						'options' => [
							'target' => './data/upload',
							'useUploadName'=>true,
							'useUploadExtension' => true,
							'overwrite' => true,
							'randomize' => false
						]
					]
				],
			]);
	}
}

In the code above, we add the following file validators:

UploadFile validator (line 32) checks whether the uploaded file was really uploaded using the HTTP POST method.

MimeType validator (line 34) checks whether the uploaded file is a JPEG or PNG image. It does that by extracting the
MIME information from file data.

IsImage validator (line 39) checks whether the uploaded file is an image file (PNg, JPG, etc.). It does that by extracting 
the MIME information from file data.

ImageSize validator (line 41) allows to check that image dimensions lie in an allowed range. In the code above, we check
that the image is between 128 pixels and 4096 pixels width/height.

In line 52, we add the RenameUpload filter and configure it to save teh uploaded file to the APP_DIR/data/upload directory.
The filter will use the same file for the destination file as the name of the original file (useUploadName option).

If the file with such a name already exists, the filter will overwrite it (overwrite option).

For the MimeType and IsImage validator to work, you have to enable PHP fileinfo extension. This extension is already
enabled in Linux Ubuntu, but not in Windows. After we do that, restart the Apache server.

Writing ImageManager Service:

Because we strive to write code conforming to Domain Driven Design pattern, we will create a service model 
class encapsulating the functionality for image management. We will call this class ImageManager and put it to
Applicaton\Service namespace.

We will also register this service in the service manager component of the web application.

The ImageManager service class will have the following public methods:

Public methods of the ImageManager class:

getSaveToDir() 				Returns path to teh directory where we save the image files.

getSavedFiles() 			Return the array of saved file names

getImagePathByName($fileName) Returns the path to the saved image file

getImageFileInfo($filePath)   Retrieves the file information (size, MIME type) by image path.

getImageFileContent($filePath) Returns the image file content. On error, returns boolean false.

resizeImage($filePath, $desiredWidth) 	Resizes the image, keeping its aspect ratio.

In fact, we could put the code we plan to add into the service into the controller actions, but that
would make the controller fat and purely testable. By introducing the service, we improve the separation
of concerns and code reusability.

Add the ImageManager.php file to the Service directory under the module's source directory. Add the following
code to the file:

<?php
namespace Application\Service;

//The image manager service
class ImageManager
{
	//The directory where we save image files
	private $saveToDir = './data/upload/';

	//Returns path to the directory where we save the image files
	public function getSaveToDir()
	{
		return $this->saveToDir;
	}
}

As you can see from teh code above, we define the ImageManager clas in line 5. It has the private $saveToDir property
which contains the path to the directory containing our uploaded files (line 8) (We store uploaded files in
APP_DIR/data/upload directory)

The getSaveToDir() public method (line 11) allows to retrieve the path to the upload directory

Although the ImageManager class is a service class and focused on providing services, it can have properties
intended for its internal use.

Next, we want to add the getSavedFiles() public method to the service class. The method will scan the upload
directory and return an array containing the names of the uploaded files. To add the getSavedFiles() method,
modify the code in the following way:

<?php
//...

//The image manager service
class ImageManager
{
	//...

	//Returns the array of uploaded file names
	public function getSavedFiles()
	{
		//The dir where we plan to save uploaded files

		//Check wether the dir already exists and if not, make it
		if(!is_dir($this->saveToDir)) {
			if(!mkdir($this->saveToDir)) {
				throw new \Exception('Could not create dir for uploads: ' . error_get_last());
			}
		}

		//Scan the directory and create the list of uploaded files
		$files = [];
		$handle = opendir($this->saveToDir);
		while (false !== ($entry = readdir($handle))) {

			if($entry=='.' || $entry=='..')
				continue; //Skip current dir and parent dir

			$files[] = $entry;
		}

		//return the list of uploaded files
		return $files;
	}
}

In the getSavedFiles() method above, we first check if the upload directory exists (line 16), and if not, we try to create it
(line 17). Then, we get the list of files in the directory (lines 24-32) and return it to the caller.

Next, we add the three methods for getting information about an uploaded file.

the getImagePathByName() method will take the file name and prepend the path to upload directory to that file name

the getImageFileInfo() method will retrieve MIME information about the file and its size in bytes

and the getImageFileContent() will read file data and return them as string.

To add those three methods, change the code as follows:

<?php
//...

//The image manager service
class ImageManager
{
	//...

	//returns the path to the saved image file
	public function getImagePathByName($fileName)
	{
		//Take some precautions to make file name secure
		$fileName = str_replace("/", "", $fileName); //Remove slashes
		$fileName = str_replace("\\", "", $fileName); //Remove backslashes

		//return concatenated directory name and file name
		return $this->saveToDir . $fileName;
	}

	//returns the image file content. On error, returns boolean false.
	public function getImageFileContent($filePath)
	{
		return file_get_contents($filePath);
	}

	//retrieves the file information (size, MIME type) by image path
	public function getImageFileInfo($filePath)
	{
		//Try to open the fiel
		if (!is_readable($filePath)) {
			return false;
		}

		//Get file size in bytes
		$fileSize = filesize($filePath);

		//Get MIME type of the file
		$finfo = finfo_open(FILEINFO_MIME);
		$mimeType = finfo_file($finfo, $filePath);
		if($mimeType===false)
			$mimeType = 'application/octet-stream';

		return [
			'size' => $fileSize,
			'type' => $mimeType
		];
	}
}

Finally, we want to add the image resizing functionality to the ImageManager class. The image resizing functionality
will be used for creating small thumbnail images. Add the resizeImage() method to the ImageManager class as follows:

<?php
//...
class ImageManager
{
	//...

	//Resizes the image, keeping its aspect rati
	public function resizeImage($filePath, $desiredWidth = 240)
	{
		//Get original image dimensions
		list($originalWidth, $originalHeight) = getimagesize($filePath);

		//calculate aspect ratio
		$aspectRatio = $originalWidth/$originalHeight;

		//calculate the resulting height
		$desiredHeight = $desiredWidth/$aspectRatio;

		//get image info
		$fileInfo = $this->getImageFileInfo($filePath);

		//Resize teh image
		$resultingImage = imagecreatetruecolor($desiredWidth, $desiredHeight);
		if (substr($fileInfo['type'], 0, 9) == 'image/png')
			$originalImage = imagecreatefrompng($filePath);
		else
			$originalImage = imagecreatefromjpeg($filePath);

		imagecopyresampled($resultingImage, $originalImage, 0, 0, 0, 0,
			$desiredWidth, $desiredHeight, $originalWidth, $originalHeight);


		//Save the resized image to temporary location
		$tmpFileName = tempname("/tmp", "FOO");
		imagejpeg($resultingImage, $tmpFileName, 80);

		//Return the Path to the resulting image
		return $tmpFileName;
	}
}

The resizeImage() method above takes two arguments, $filePath (the path to the image file) and $desiredWidth (the width
of the thumbnail image). Inside the method, we first calculate an apporpiate thumbnail image height (lines 11-16) preserving
its aspect ratio. Then, we resize the original image as needed and save it to a temporary file.

As the ImageManager class is ready, we need to register the ImageManager service in the service manager component of the
web application by adding the following lines to the module.config.php configuration file:

<?php
return [
	//...
	'service_manager' => [
		//...
		'factories' => [
			//register the ImageManager service
			Service\ImageManager::class => InvokableFactory::class,
		],
	],
	//....
];

Adding ImageController:

For the Image Gallery example, we will create the ImageController controller class. The controller will have the following
action methods:

Action methods of the ImageController class:

__construct() 		Will allow to inject ImageManager dependency into the controller

uploadAction() 		Shows the image upload page allowing to upload a single image

indexAction() 		Displays the image gallery page with the list of uploaded images

fileAction() 		Provides an ability to download a full-size image or a small thumbnail for an image.

To start, create the ImageController.php file in the Application/Controller directory under the module's source
directory. Put the following stub code into the file:

<?php
namespace Application\Controller;

use Zend\Mvc\Controller\AbstractActionController;
use Zend\View\Model\ViewModel;
use Application\Form\ImageForm;

//This controller is designed for managing image file uploads
class ImageController extends AbstractActionController
{
	//The image manager
	private $imageManager;

	//The constructor method is used for injecting the dependencies into the ocntroller
	public function __construct($imageManager)
	{
		$this->imageManager = $imageManager;
	}

	//This is the default "index" action of the controller. It displays the image Gallery
	// page which contains the list of uploaded images
	public function indexAction()
	{
	}

	//This action shows the image upload form. This page allows to upload a single file
	public function uploadAction()
	{
	}

	//This is the 'file' action that is invoked when a user wants to 
	// open the image file in a web browser or generate a thumbnail
	public function fileAction()
	{
	}
}

In the code above, we defined the ImageController class living in the Application\Controller namespace and added
the constructor method and three action method stubs into the class: indexAction(), uploadAction() and fileAction().
Next, we will populate those action methods with the code.

Adding Upload Action & Corresponding View Template:

First, we will complete the uploadAction() method of our controller. This action method will handle the Upload a 
New Image web page containing the upload form. The form will provide an ability to upload an image file to the
gallery.

Change the ImageController.php file as follows:

<?php
//...
class ImageController extends AbstractActionController
{
	//...
	public function uploadAction()
	{
		//Create the form model
		$form = new ImageForm();

		//Check if user has submitted the form
		if($this->getRequest()->isPost()) {

			//Make certain to merge the files info
			$request = $this->getRequest();
			$data = array_merge_recursive(
				$request->getPost()->toArray(),
				$request->getFiles()->toArray()
			);

			//pass data to the form
			$form->setData($data);

			//Validate form
			if($form->isValid()) {

				//move uploaded file to its destination directory
				$data = $form->getData();

				//Redirect the user to "image Gallery" page
				return $this->redirect()->toRoute('images');
			}
		}

		//Render the page
		return new ViewModel([
					  'form' => $form
				]);
	}
}

In the uploadAction method above, we do the following:

In line 9, we create an instance of the ImageForm form model with the help of the new operator.

In line 12, we check whether the request is an HTTP POST request. If so, we get the data from $_POST
and $_FILES super-global PHP arrays and merge them into a single array (lines 15-19).

This is required to correctly handle uploaded files, if any. Then we pass this array to the form model 
with the setData() method (line 22)

In line 25, we call the form model's isValid() method. This method runs the input filter attached to the form
model. Since we have only one file input in the input filter, this will only run our three file validators:

UploadFile, IsImage and ImageSize

if the data is valid, we call the getData() method (line 28). For our file field, this will run the RenameUpload filter, which
moves our uploaded file to its persistent directory.

After that, in line 31, we redirect the user to teh "index" action of the controller (we will populate that action method a little
bit later).

Now, its time to add teh view template for the "upload" action. Add the upload.phtml view template under the application/image directory
under the module's view directory.

<?php
$form = $this->form;
$form->get('submit')->setAttributes(['class' => 'btn btn-primary']);
?>

<h1>Upload a New Image</h1>

<p>
	Please fill out the following form and press the <i>Upload</i> button.
</p>

<div class="row">
	<div class="col-md-6">
		<?= $this->form()->openTag($form); ?>

		<div class="form-group">
			<?= $this->formLabel($form->get('file')); ?>
			<?= $this->formElement($form->get('file')); ?>
			<?= $this->formElementErrors($form->get('file')); ?>
			<div class="hint">(PNG and JPG formats are allowed)</div>
		</div>

		<?= $this->formElement($form->get('submit')); ?>
		<?= $this->form()->closeTag(); ?>
	</div>
</div>

In the code of the view template, we first set "class" attirbute (line 3). This is to apply nice-looking Twitter Bootstrap styles
to the form's Submit button.

Then, we render the form with the common view helpers that we discussed in Collecting User Input with Forms. For rendering the "file"
field, we use the generic FormElement view helper.

Typically, you use the FormElement generic view helper for rendering the file field. The FormElement internally calls
the FormFile view helper, which performs the actual rendering.

Adding Index Action & Corresponding View Template:

The second action method we will complete is the indexAction(). This action will handle the Image gallery page containing the list
of uploaded files and their small thumbnails. For each image, there will be a button "Show In natural Size" for opening the image
in another tab of the web browser.

Change the ImageController.php file as follows:

<?php
//...
class ImageController extends AbstractActionController
{
	//...
	public function indexAction()
	{
		//get the list of already saved files
		$files = $this->imageManager->getSavedFiles();

		//Render the view template
		return new ViewModel([
			'files'=>$files
		]);
	}
}

In the code above, we use the getSavedFiles() method of the ImageManager class for retrieving the list of uploaded images
and pass them to the view for rendering.

Please note how "slim" this controller is. THis is because we moved the image management to the ImageManager service model.

Add the index.phtml view template to application/image directory under the module's view directory. The contents of the file
is shown as below:

<h1>Image Gallery</h1>

<p>
	This page displays the list of uploaded images
</p>

<p>
	<a href="<?= $this->url('images', ['action'=>'upload']); ?>"
		class="btn btn-primary" role="button">Upload More</a>
</p>

</hr>

<?php if(count($files)==0): ?>

<p>
	<i>There are no files to display.</i>
</p>

<?php else: ?>

<div class="row">
	<div class="col-sm-6 col-md-12">
		<?php foreach($files as $file): ?>

		<div class="img-thumbnail">
			<img src="<?= $this->url('images', ['action' => 'file'],
				['query'=>['name'=>$files, 'thumbnail'=>true]]); ?>">

			<div class="caption">
				<h3><?php echo $file; ?></h3>
				<p>
				<a target="_blank" href="<?= $this->url('images', ['action' => 'file'],
					['query' => ['name' => $file]]); ?>"
					class ="btn btn-default" role="button">Show in Natural Size</a>
				</p>
			</div>
		</div>

		<?php endforeach; ?>
	</div>
</div>

<?php endif; ?>

<hr/>

In the code above, we create the HTML markup for the Upload More button.

Under the button, we use check whether the $files array is empty. If the array is empty, we output the "There are no files to display"
message: otherwise, we walk through the files and output the thumbnails of each uploaded images.

For rendering a thumbnail, we use the <img> tag. We set it's src attribute with the URL pointing to the "file" action of our
ImageController controller. We pass two parameters to the action via the query part of the URL: the image name and thumbnail flag.

For styling the thumbnails, we use the Twitter BS provided "img-thumbnail" CSS class.

For additional information about these twitter BS styles, please refer to the BS official documentation.

Below, each thumbnail, we put the "Show in Natural Size" link, which points to the "file" action of our ImageController controller.
When site visitors click the link, he will be shown with the image in natural size, and the image will be opened in another 
browser's tab (note the target="_blank" attribute of the link).

Adding File Action:

The last action we will populate is the ImageController::fileAction() method. That method will allow to preview
an uploaded image or generate a small thumbnail of the image. The action method will take two GET params:

the "name" param defines the file name for preview

the "thumbnail" param is a flag telling where we want to dump the full image or its small copy

Change the ImageController.php as follows:

<?php
//...
class ImageController extends AbstractActionController
{
	//...
	public function fileAction()
	{
		//Get the file name from GET variable
		$fileName = $this->params()->fromQuery('name', '');

		//Check whether the user needs a thumbnail or a full-size image
		$isThumbnail = (bool)$this->params()->fromQuery('thumbnail', false);

		//get the path to image file
		$fileName = $this->imageManager->getImagePathByName($fileName);

		if($isThumbnail) {

			//Resize the image
			$fileName = $this->imageManager->resizeImage($fileName);
		}

		//Get image file info (size and mime type)
		$fileInfo = $this->imageManager->getImageFileInfo($fileName);
		if ($fileInfo===false) {
			//Set 404 not found status code
			$this->getResponse()->setStatusCode(404);
			return;
		}

		//Write HTTP headers
		$response = $this->getResponse();
		$headers = $response->getHeaders();
		$headers->addHeaderLine("Content-type: " . $fileInfo['type']);
		$headers->addHeaderLine("Content-length: " . $fileInfo['size']);

		//Write file content
		$fileContent = $this->imageManager->getImageFileContent($fileName);
		if($fileContent!==false) {
			$response->setContent($fileContent);
		} else {
			//Set 500 server error status code
			$this->getResponse()->setStatusCode(500);
			return;
		}

		if($isThumbnail) {
			//Remove temporary thumbnail image file
			unlink($fileName);
		}

		//return response to avoid default view rendering
		return $this->getResponse();
	}
}

In teh code above, we first get the "name" and "thumbnail" params from $_GET super-global array (lines 9, 12). If the params are
missing, their defaults are used instead.

In line 15, we use the getImagePathByName() method provided by the ImageManager service to get the absolute path to the image by its
name.

If a thumbnail is requested, we resize the image with the resizeImage() method of the ImageManager (line 20). That method returns path
to a temporary file containing the thumbnail image.

Then, we get the information about the image file (its MIME type and file size) with the getImageFileInfo() method of the ImageManager
(line 24).

Finally, we create a Response object, fill its headers with image information, set its content with data of the image file (lines 32-45),
and return the Response object form the controller action (line 53).

Note that returning the Response object disables the default rendering of teh view template for this action method. By this reason, we 
do not create the file.phtml view template file.

Creating Factory for the Controller:

Because our ImageController uses the ImageManager service, we need to somehow pass it the instance of the ImageManager (to inject
the dependency into the controller's constructor). We do this with the help of factory.

Create the ImageControllerFactory.php file under the Controller/Factory subdirectory under the module's source directory. Put the
following code into the file:

<?php
namespace Application\Controller\Factory;

use Interop\Container\ContainerInterface;
use Zend\ServiceManager\Factory\FactoryInterface;
use Application\Service\ImageManager;
use Application\Controller\ImageController;

/**
  * This is the factory for ImageController. Its purpose is to instansiate the controller
  */
class ImageControllerFactory implements FactoryInterface
{
	public function __invoke(ContainerInterface $container, $requestedName, array $options = null)
	{
		$imageManager = $container->get(ImageManager::class);

		//instansiate the controller and inject dependencies
		return new ImageController($imageManager);
	}
}

Registering the ImageController:

To let ZF3 know about our controller, register the ImageController in the module.config.php configuration file:

<?php
return [
	//...
	'controllers' => [
		'factories' => [
			Controller\ImageController::class => 
					Controller\Factory\ImageControllerFactory::class,
			//...
		],
	],
	//...
];

Creating Route:

We need to add a route for our ImageController controller. To do that, modify the module.config.php file as follows:

<?php
return [
	//...
	'router' => [
		'routes' => [
			'images' => [
				'type' 	=> Segment::class,
				'options' => [
					'route' 	=> '/images[/:action]',
					'constraints' => [
						'action' => '[a-zA-Z][a-zA-Z0-9_-]*'
					],
					'defaults' => [
						'controller' => Controller\ImageController::class,
						'action' 	 => 'index',
					],
				],
			],
		],
	],
	//...
];

After that, we can access our image gallery by teh URL like "http://localhost/images", "http://localhost/images/upload" or
"http://localhost/images/file"

Results:

Finally, adjust directory permissions to make the APP_DIR/data directory writable by teh Apache Web Server. In Linux, Ubuntu,
this is typically accomplished by the following shell commands (replace the APP_DIR placeholder with the actual directory
name of your web application):

chown -R www-data:www-data APP_DIR/data

chmod -R 775 APP_DIR/data

Above, the chown and chmod commands set the Apache user to be the owner of the directory and allow teh web server to write to
the directory, respectively

If we now enter the URL http://localhost/images into your web browser's navigation bar, you will see the image gallery
page and everything is as expected.

Clicking the Upload more button will open the Upload a New Image page where we can pick an image file for upload.
if we pick an unacceptable one, we get an error message.

If the upload is successful, we are redirected back to the Image Gallery page and see the uploaded image in the list
of thumbnails. Clicking the View Full Size button will open the image in a new browser tab.

We may find the Image Gallery complete example in teh Form Demo sample web application bundeled with this book.

Advanced Usage of Forms:

In previous chapters, we learned about the basic usage of forms: what HTML forms are and how you define form models
and form presentation in ZF3. In this chapter, you will learn some advanced form usage topics such as security
form elements (CAPTCHA and CSRF) and so on.

ZF3 Components covered in this chapter:

Zend\Captcha 		Implements various CAPTCHA algorithms

Zend\Form 			Contains base form model classes

Zend\Filter 		Contains various filter classes

Zend\Validator 		Implements various validator classes

Zend\InputFilter 	Implements a container for filters/validators

Form Security Elements:

We will consider the usage of two form security elements provided by ZF3: Captcha and Csrf (both classes belong to
Zend\Form\Element namespace). By adding those elements to your form model (and rendering them in a view template),
you will make your form resistant to hacker attacks (lol).

CAPTCHA:

A CAPTCHA (stands for "Completely Automated Public Turing Test to tell Computers and Humans Apart") is a challenge-response test
used in web sites for determining wether the user is a human or a robot.

There are several types of CAPTCHA. The most widely used one requires that the user type the letters of a disrtorted
image taht is shown on the web page.

A typical captcha test works using the following algorithm:

Some secret sequence of characters (word) is generated server-side.

The secret word is saved in a PHP session variable.

The distorted image is generated based on the secret word. The image is then displayed on the web page to site users.

The site user is asked to type characters shown on the image.

If the characters typed by user are the same as the secret word saved in the session, the test is considered passed.

The goal of the CAPTCHA test is to protect your form from filling and submission by an automated process (so called robot).
Usually, such robots send spam messages to forums, hack passwords on site login forms, or perform malicious actions.

The CAPTCHA test allows to reliably distinguish humans from robots, because humans are easily able to recognise and
reproduce characters from the distorted image, while robots are not. (lol no)

CAPTCHA types:

In ZF3, there are several CAPTCHA types available (they all belong to the Zend\Captcha component):

Dumb. This is a very simple CAPTCHA algorithm which requires that site user enter the word letters in reverse order.
We will not consider this type in details here, because it's too low protection value.

Image. A CAPTCHA algorithm distorting an image with addition of some noise in form of dots and line curves.

Figlet. An unusual CAPTCHA type using FIGlet program instead of an image distortion algorithm. The FIGlet is an
open-source program which generates the CAPTCHA image of many small ASCII letters.

The Zend\Captcha component provides a unified interface for all CAPTCHA types (the AdapterInterface interface).
The AbstractAdapter base class implements that interface, and all other CAPTCHA algorithms are derived from
the abstract adapter class.

The class inheritance diagram is as follows:

							AdapterInterface
									^
									^
							AbstractAdapter
									^
									^
				Dumb   >>>>>>>AbstractWord<<<<<<<<<  Image
									^
									^
								Figlet

The adapter is a design pattern that translates one interface for a class into a compatible interface , which 
helps two (or several) incompatible interfaces to work together. Typically, CAPTCHA algorithms have different
public methods, but since they all implement AbstractAdapter interface, the caller may use any CAPTCHA algorithm
in the same common manner (by calling the methods provided by the base interface)

As you can see from the figure above, there is another base class for all CAPTCHA types that utilize some secret
word of chars: the AbstractWord class provides methods for generating random sequence of chars and for adjusting 
word generation options.

CAPTCHA Form Element & View Helper 

ZF3 provides the dedicated form element class and view helper class for letting you use CAPTCHA fields
on your forms.

To add a CAPTCHA field to a form model, you use the Captcha class that belongs to Zend\Form component and lives in 
Zend\Form\Element namespace.

The Captcha element class can be used with any CAPTCHA algorithm (listed in the previous section) from Zend\Captcha
component. For this purpose, the element class has the setCaptcha() method which takes either an instance of a class
implementing Zend\Captcha\AdapterInterface interface, or an array containing CAPTCHA configuration. By the 
setCaptcha() method, you can attach the desired CAPTCHA type of the element.

In the latter case (configuration array), the CAPTCHA algorithm will be automatically instansiated and initialized by the
factory class Zend\Captcha\Factory

You add the Captcha element to a form model as usual, with the add() method provided by the Zend\Form\Form base class.
As usual, you can pass it eitehr an instance of the Zend\Form\Element\Captcha class or provide an array of configuration
options specific to certain CAPTCHA algorithm (in that case, the element and its associated CAPTCHA algorithm will automatically
be instansiated and configured by the factory class).

THe code example below shows how to use the latter method (passing a configuration array). We prefer this method because
it requires less code to write. It is assumed that you call this code inside of form model's addElements()
protected method:

<?php
//Add the CAPTCHA field to the form model
$this->add([
	'type' 	=> 'captcha',
	'name' => 'captcha',
	'options' => [
		'label' => 'Human check',
		'captcha' => [
			'class' => '<captcha_class_name>',
			//Certain class-specific options follow here
		],
	],
]);

In the example above, we call teh add() method provided by the Form base class and pass it an array describing
the element to insert (line 3):

The type key of the array (line 4) as usual, may either be a fully qualified class name of the element (Zend\Form\Element\Captcha)
or its short alias ("captcha").

The name key (line 5) is the value for the "name" attribute of the HTML form field

The options contains the options for the attached CAPTCHA algorithm. The class key (line 9) may either contain
the full CAPTCHA class name (e.g. Zend\Captcha\Image) or its short alias (e.g "Image"). Other adapter-specific,
options may be added to the key as well. We will show how to do this a bit later.

For generating HTML markup for the element, you may use the FormCaptcha view helper class (belonging to Zend\Form\View\Helper
namespace). But as you might learn from the previous chapters, typically we use teh generic FormElement view helper instead
like show in the code below:

<?= $this->formElement($form->get('captcha')); ?>

It is assumed that you call the view helper inside of your view template.

Next, we provide two examples illustrating how to use different CAPTCHA types provided by ZF3: the Image and 
Figlet. We will show to add a CAPTCHA field to the feedback form that we used in examples of the previous chapters.

Example 1: Adding Image CAPTCHA to the ContactForm:

Image CAPTCHA requires that you have PHP GD extension installed with PNG support and FT fonts.

To add the Image CAPTCHA to your form model, call the form's add() method as folllows:

<?php
namespace Application\Form;
//...

class ContactForm extends Form
{
	//...
	protected function addElements()
	{
		//...

		//Add the CAPTCHA field
		$this->add([
			'type' => 'captcha',
			'name' => 'captcha',
			'attributes' => [
			],
			'options' => [
				'label' => 'Human check',
				'captcha' => [
					'class' => 'Image',
					'imgDir' => 'public/img/captcha',
					'suffix' => '.png',
					'imgUrl' => '/img/captcha/',
					'imgAlt' => 'CAPTCHA Image',
					'font' => './data/font/thorne_shaded.ttf',
					'fsize' => 24,
					'width' => 350,
					'height' => 100,
					'expiration' => 600,
					'dotNoiseLevel' => 40,
					'lineNoiseLevel' => 3
				],
			],
		]);
	}
}

Above, the captcha key of the configuration array (see line 20) contains the following parameters
for configuring the Image CAPTCHA algorithm attached to the form element.

the class parameter (line 21) should be either the fully qualified CAPTCHA adapter class name (\Zend\Captcha\Image)
or its short alias (Image)

the imgDir parameter (line 22) should be the path to the directory where to save the generated distorted images (in this 
example, we will save the images to the APP_DIR/public/img/captcha dir)

the suffix parameter (line 23) defines the extension for a generated image file (".png") in this example

the imgUrl parameter (line 24) defines the base part of the URL for opening generated CAPTCHA images in a web
browser. In this example, site visitors will be able to access CAPTCHA images using URLs like "http://localhost/img/captcha/<id>",
where ID is a specific ID of a picture.

the imgAlt parameter (line 25) is an optional alternative text to show if CAPTCHA image can't be loaded by the web browser
(the "alt" attribute of <img> tag)

the font parameter (line 26) is the path toe fhont file. We can download free ttf fonts and then put then for instance
in APP_DIR/data/font/

the fsize parameter (line 27) is a positive integer number defining the font size

the width (line 28) and height parameters (29) define the wdith and height in pixels of teh generated image, respectively.

The expiration parameter (line 30) defines the expiration period (in seconds) of the CAPTCHA images. Once an image expires,
it is removed from disk.

the dotNoiseLeve parameter (line 31) and lineNoiseLevel parameter (line 32) define the image generation options (dot noise level
and line noise level, respectively).

To render the CAPTCHA field, add the following lines to your contact-us.phtml view template file:

<div class="form-group">
	<?= $this->formLabel($form->get('captcha')); ?>
	<?= $this->formElement($form->get('captcha')); ?>
	<?= $this->formElementErrors($form->get('captcha')); ?>
	<p class="help-block">Enter the letters above as you see them</p>
</div>

Finally, create the APP_DIR/public/img/captcha directory that will store generated CAPTCHA images.
Adjust directory permissions to make the directory writable by the Apache Web Server. In Linux Ubuntu, this is typically
accomplished by the following shell commands (replace the APP_DIR ph with the actual dir name of your web app)

mkdir APP_DIR/public/img/captcha

chown -R www-data:www-data APP_DIR

chmod -R 775 APP_DIR

above, the mkdir command creates the directory and chown and chmod commands set the Apache user to be the owner of the
directory and allow the web server to write to the directory, respectively.

Now, if you open the "http://localhost/contactus" page in your web browser, the CAPTCHA image will be generated based on
a random sequence of letters and digits saved in session. You should see the expected result.

When you fill the form fields in and press the Submit button, the letters entered into the Human check field will be
transferred to server as part of HTTP request. Then, on form validation, the Zend\Form\Element\Captcha class will compare
the submitted letters to those stored in PHP session.

If the letters are identical, the form is considered valid; otherwise, the validation fails.

Once the PHP renderer processes teh view template, it generates HTML markup for the CAPTCHA element as shown below:

<div class="form-group">
	<label for="captcha">Human check</label>
	<img width="350" height="100" alt="CAPTCHA Image"
			src="/img/captcha/<bla>.png">
	<input name="captcha[id]" type="hidden"
			value="<bla>">
	<input name="captcha[input]" type="text">
	<p class="help-block">Enter the letters above as you see them.</p>
</div>

Example 2: Adding a FIGlet CAPTCHA to the ContactForm

To use the FIGlet CAPTCHA element with your form, replace the form element definition from the previous example
with the following code:

<?php
//Add the captcha field
$this->add([
	'type' => 'captcha',
	'name' => 'captcha',
	'attributes' => [
	],
	'options' => [
		'label' => 'Human check',
		'captcha' => [
			'class' => 'Figlet',
			'wordLen' => 6,
			'expiration' => 600,
		],
	],
]);

Above, the captcha key of the configuration array contains the following params for configuring the Figlet CAPTCHA
algorithm attached to the form element.

The class parameter should be either the full CAPTCHA adapter class name (\Zend\Captcha\Figlet) or its short alias
(Figlet)

the wordLen parameter (line 12) defines the length of the secret word to be generated

the expiration parameter (line 13) defines the CAPTCHA expiration period (in seconds)

Now, open the "http://localhost/contactus" page in your web browser. Once that is done, we should see a figure as expected.

Once the PHP renderer processes the view template, it generates HTML markup for the CAPTCHA element as follows:

<div class="form-group">
	<label for="captcha">Human check</label>
		<pre>
			//stuff
</pre>
<input name="captcha[id]" type="hidden"
		value="<bla>">
<input name="captcha[input]" type="text">
<p class="help-block">Enter the letters above as you see them</p>
</div>

CSRF Prevention:

Cross-site request forgery (CSRF) is a kind of hacker attack which forces the user's browser to transmit an HTTP request
to an arbitrary site. Through the CSRF attack, the malicious script is able to send unauthorized commands form a user that the
website trusts. This attack is typically performed on pages containing forms for submission of some sensitive data (money transfers etc.)

To beter understand how it works, here is a chart:


User logs into a payment system; the PHP session information is saved as a cookie >>>>> https://payment.com
																								V
																								V
						User performs a payment through a CSRF-unprotected form	https://payment.com/moneytransfer.php

Then user visits an infected site in teh same web browser window >>>>>> http://coolpictures.net
																					V
																					V
																		<img src="image.php"/><<<< While the infected page is loaded, an CSRF attack is initiated by
																		the image.php script which gains access to PHP session info
								https://payment.com/moneytransfer.php	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
								^^
								The malicious image.php script runs moneytransfer.php script on a payment gateway site on behalf of the logged in user

The figure illustrates an example CSRF attack on a payment gateway website:

1. You log into your account at payment gateway web site https://payment.com. Please note that hte SSL protected connection is used here,
but it does not prevent such attacks.

2. Typically, you set to check the "Remember Me" check box of the login form to avoid entering again. You logged in, your web browser
saves your session info to a cookie variable on your machine.

3. On your payment gateway site, you use the payment from https://payment.com/moneytransfer.php to buy some goods. Please note
that this payment form will later be used as a vulnerability allowing to perform the CSRF attack

4. next, you use the same web browser to visit some website you like. Assume the website contains cool pictures 
http://coolpictures.com. Unfortunately, this website is infected with a maliciuous script, masquared as an <img src="image.php">
HTML tag. Once you open the HTML page, it executes the script.

5. The malicious script checks the cookie variable and if it presents, it performs the "session riding" and can act on behald of the
logged in user. It is now able to submit the payment form to the payment gateway site.

The above described CSRF attack is possible if the web form on the payment gateway site does not check the source of the
HTTP request. The people who maintain the payment gateway site must put more attention in making its forms secure.

To prevent CSRF attacks to a form, one has to require a special token with the form, as follows:

1. For certain form, generate a random sequence of bytes (token) and save it server-side in PHP session data.

2. Add a hidden field to form and set its value with hte okten.

3. once the form is submitted by the user, compare the hidden value passed in the form with the token saved server-side.
If they match, consider the form data secure.

If a malicious attacker will try to attack the site by submitting the form, he will not be able to put the right otken
in the form submissions, because the otken is not stored in cookies.

Example: Adding a CSRF Element to Form:

In Zf3, to add a CSRF protection to your form model, you use the Zend\Form\Element\Csrf form element class.

The Csrf element has no visual representaiton (you will not see it on the screen).

To insert a CSRF element to your form model, add the following lines in its addElements() method:

//Add the CSRF field
$this->add([
	'type' => 'csrf',
	'name' => 'csrf',
	'options' => [
		'csrf_options' => [
			'timeout' => 600
		]
	],
]);

Above, we use the Form's add() method to which we pass a configuration array describing the CSRF element.
The element will be automatically instansiated and initalized by the factory.

In line 3, we specify the class name for the CSRF element. This either may be the fully qualifiedn class name 
(Zend\Form\Element\Csrf) or a short alias ('csrf')

In line 4, we set the name attribute for the element. In this example, we use "csrf" name, but you may use any 
other name, of our choise.

In line 6, inside of csrf_options array, we specify the options specific to Zend\Form\Element\Csrf class. We 
set the timeout option to 600, which means the CSRF check expires in 600 seconds (10 mintues) after form creation.

ot render the csrf field in your view tempalte .phtml file, add the following line:

<?= $this->formElement($form->get('csrf')); ?>

When the PHP renderer evaluates the view template, it generates the HTML markup for the CSRF field like 
shown below:

<input type="hidden" name="csrf" value="<bla>">

As you can see from teh HTML code above, the form now contains a hidden field with a randomly generated token.
Since the attacker knows not hte token, it won't be able to submit its content value, thus the CSRF attack becomes
prevented.

What happens if CSRF element validation fails?

if during the form validation CSRF fails, the form is consdiered invalid and user will see it again to fix input
errors, but he won't see the error that caused it (we do not wish hackers to know what is wrong with the form).

Using Validation Groups:

Sometimes it may be useful to temporarily disable validation of some form elements. You can do that with a feature called
validation groups.

By default, all form elements are validated. A validation group allows to disable validation of certain fields.

For example, assume you implement a form named "PaymentForm", which allows you to select a payment method 
fo several alternatives (credit card, bank transfer and cash).

if the user selects CC, you also want him to enter the credit card number, else if the user selects bank transfer,
you want him to enter bank account number, and finally is cache (? cash) use does not enter any additional info.

For this form, you will have to dynamically hide and display dependant fields in client's browsers with JS.

how would you validate such form in your controller's action? The problem is that some fields depend on others.
The card_number field is requried only when payment_method is "creditcard", otehrwise it is optional.

The same is for the bank_account field, it is required only when payment_method is the "bank account".

We can handle this case elegantly with the validation group. The Form class provides the setValidationGroup()
method, which accepts the list of fields that you want to validate; all otehr fields will be surpressed and not validated.

//First, we will validate the "payment_method" field
$form->setValidationGroup(['payment_method']);
if ($form->isValid())
{
	$data = $form->getData();

	$paymentMethod = $data['payment_method'];

	//next, validate the dependent fields
	if ($paymentMethod=='credit_card') {
		$form->setValidationGroup(['payment_method', 'card_number']);
	} else if ($paymentMethod=='bank_account') {
		$form->setValidationGroup(['payment_method', 'bank_account']);
	}

	if ($form->isValid()) {
		$data = $form->getData();

		//Do something with the data
	}
}

We can see an example of this in the Form Demo sample web app, bundeled with this book. just type
"http://localhost/payment" URl in your browser.

Implementing Multi-Step Forms:

In this seciton, we will provide instructions on how to implement a multi-step form with ZF3. A multi-step
form is a form having a lot of fields, and which is displayed in several steps. To store the current step
and user-entered data between page requests, PHP sessions are used.

For example, user registration can be performed in several steps: on the first step you display the page
allowing to enter login and password, on the second step you display the page where the site visitor can
enter his personal information and on the third step, the visitor can enter billing info.

Another example of a multi-step form is a Survey form. This form would display a question and possible
variants of the answer. This form would have as many steps as questions are in the survey.

In this section, we implement the User Registration form allowing to collect information about the
user being registered.

You can see this compelted working example in action as part of Form Demo sample web application bundled with
this book.

Enabling Sessions:

Since this section requires knowing sesisons, we will cover that first.

Working with Sessions:

In this chapter, you will learn about sessions. The HTTP protocol is stateless, so you can't share data between
two HTTP requests by default. PHP sessions allows to workaround this by saving data on server during one page request
and retrieve it later during another page request.

For example, you can remember that the user has logged in, and show a personalized web page the next tiem 
he visits the website. ZF internally uses the PHP sessions, but additonally provides a convenient wrapper around
PHP sessions, so you don't access $_SESSION super-global array directly.

ZF3 Components covered in this chapter:

Zend\Session 			Implements a wrapper around PHP sessions

PHP Sessions:

First, let's give some theory on what PHP sessions are. In PHP, sessions work as follows:

When a site visitor opens the website for the first time, PHP sets a cookie in the client browser.

The website may save any information to session with the help of special super-global array named $_SESSION.
The data saved to session is stored on server in form of disk files.

When the same visitor opens the website again, the web browser sends the saved cookie to server, so PHP determines
that this is the same visitor and loads the session data again to the $_SESSION array.

An HTTP cookie is a small piece of data sent from a website and stored in the user's web browser while the user is browsing.
Cookies are used to remember some state between HTTP requests.

From PHP application developer's point of view, the work with sessions is simple. First, initialise the session by calling
session_start() PHP function. Then, use $_SESSION super-global array for setting/retrieving session data.

For example, to save some data to session, use the following code:

session_start();
$_SESSION['my_var'] = 'Some data';

To later retrieve the data from session, use the following code:

session_start();
if (isset($_SESSION['my_var']))
	$sessionVar = $_SESSION['my_var'];
else
	$sessionVar = 'Some default value';

To clear the data, use the unset() PHP function, as follows:

unset($_SESSION['my_var']);

Note that sessions do not last forever (they expire sooner or later when the user's cookie expires or when PHP engine
cleans up the session storage files). How long the session lasts is defined in php.ini configuration file. It is possible
to override the default expiration parameters with the help of ini_set() function as follows:

//Set session cookie lifetime (in seconds) to be 1 hour
ini_set('session.cookie_lifetime', 60*60*1);

//store session data on server for maximum 1 month
ini_set('session.gc_maxlifetime', 60*60*24*30);

There are several other "advanced" session-related PHP configuration settings in php.ini. We do not cover them here,
ecause they are usually not needed.

So, if PHP sessions are so simple, why do we need additonal wrappers provided by ZF3?

ZF3-provided wrappers around the PHP sessions is useful, because:

ZF3 session wrapper is object-oriented, so you can use it consistently in your MVC application.

ZF3 provides the concept of session namespaces, so different models can store data without naming conflicts.

ZF3 provides security features (session validators), so it is more difficult for a malicious user to hack
and substitute your session data.

Using $_SESSION super-global array directly is not good, because it makes testing your website more difficutl.
When you use a wrapper around PHP sessions, it is easier to supply test data.

With ZF3 session classes, it is possible to implement custom session data storages (for example, store session
data in DB instead of files).

Installing Zend\Session Component:

In Zf3, the session functionality is implement inside of Zend\Session component. If you have not yet installed
this component in your web application, do this now with Composer by typing the following:

php composer.phar require zendframework/zend-session

The command above downloads the component code from GitHub and installs it in the APP_DIR/vendor dir.
it also injects the information about the installed module inside of your APP_DIR/config/modules.config.php
config file.

also, we should add the Zend\Session to our application config.

Session Manager:

ZF3 provides a special service called SessionManager which belongs to Zend\Session namespace. This service is a usual
ZF3 service and is automatically registered in service manager. You can get an instance of the SessionManager 
service in a factory class with the following code:

//Use an alias for the SessionManager class
use Zend\Session\SessionManager;

//Retrieve an instance of the session manager from the service manager
$sessionManager = $container->get(SessionManager::class);

So, what does the SessionManager do? Actually, it does everything for sessions to run. The summary of its most
useful methods is provided below:

Methods provided by the SessionManager class:

sessionExists() 		Checks whether session exists and currently active

start($preserveStorage = false) 	Starts the session (if not started yet)

destroy(array $options = null) 		Ends the session

getId() 							Returns session ID

setId() 							Sets session ID

regenerateId() 						Regenerates the session ID

getName() 							Returns session name

setName() 							Overrides the default session name from php.ini

rememberMe($ttl = null) 			Sets session cookie lifetime (in seconds)

forgetMe() 							Sets a zero lifetiem for the session cookie (The cookie will expire when the browser is closed)

expireSessionCookie() 				Expires the session cookie immedeatly 

isValid() 							Executes session validators

As you can see from the table above, the SessionManager can start the session and end it, check if session exists,
and set session parameters (such as cookie expiration). It also provides a validator chain that may contain 
session validators (those validators allow to prevent hacker attacks on session data).

Providing Session COnfiguration:

The SessionManager class on initialization reads the application configuration, so you can set up the session 
parameters conventionally. To do that, modify your APP_DIR/config/autoload/global.php as follows:

<?php
use Zend\Session\Storage\SessionArrayStorage;
use Zend\Session\Validator\RemoteAddr;
use Zend\Session\Validator\HttpUserAgent;

return [
	//Session confinguration
	'session_config' => [
		//Session cookie will explire in 1 hour
		'cookie_lifetime' => 60*60*1,
		//Session data will eb stored on server for maximum of 30 days
		'gc_maxlifetime' => 60*60*24*30,
	],
	//session manager config
	'session_manager' => [
		//Session validators (used for security)
		'validators' => [
			RemoteAddr::class,
			HttpUserAgent::class,
		]
	],

	//SEssion storage configuration
	'session_storage' => [
		'type' => SessionArrayStorage::class
	],
	//...
];

We modify global.php file here, because sessions may be used by any module in your website and do not depend on
environemtn.

As you can see, the session configuration is stored under three keys:

The session_config key allows to define how long the session cookie will live and how long the PHP engine will store
your session data on server. Actually, this key may contain additional session options, but we omit them for simplicitly
(if you'd like to override those advanced options, please refer ZF docuemtnation)

the session_manager key allows to set session validators. These are used to enhance the security. It is recommended
that you always specify these validators here.

The session_storage key allows to specify the session storage class. We use the SessionArrayStorage class,
which is the default storage and is sufficient for the msot cases.

Making the Session Manager the Default One:

In ZF3, many ccomponents uses the session manageri mplicitly (for example, FlashMessenger controller plguin and 
view helper uses session to save mesages between HTTP requests). To let such components use the session manager
you just configured, you'll have to make it "the default one" by instansiating it as early as possible.

For example, you can instansiate the session manager in your module's onBootstrap() moethod as follows:

<?php
namespace Application;

use Zend\Mvc\MvcEvent;
use Zend\Session\SessionManager;

class Module
{
	//...

	/**
	  * HTis method is called once the MVC btoostrapping is complete
	  */
	public function onBootstrap(MvcEvent $event)
	{
		$application = $event->getApplication();
		$serviceManager = $application->getServiceManager();

		//The following line instansiates the SessionManager nad autoamtically
		// makes the SessionManager the "default" one.
		$sessionManager = $serviceManager->get(SessionManager::class);
	}
}

Making the session manager the default one is very important, because otherwise you'll ahve to explicitly
pass it to every component depending on teh session manager, which is rather boring.

Session Containers:

Once you have configured the session manager, you can actually store and retrieve data to/from session.
To do that, you use session containers. Session containers are implemented by the Container class living Zend\Session
namespace.

The session container can be used to save your data to session and retrieve it from session. To avoid naming conflicts
between different classes, modules and components that use sessions, the session container allows you to 
specify the namespace under which the data will be stored. A container namespace may contain upper-case and 
lower-case chars, underscores and back-slashes.

So, for example, "Session\ContainerName", "session_container_name" and "SessionContainerName" are valid container namespaces.

Session containers work closely with the session manager. When you create a session container, it calls the 
session manager's start() method automatically, so session is started and initialized.

NOw, let's start using session containers, with the new operator, but you need to pass an instance of the session
manager service to container's constructor:

Method 1: Manual Instansiation of a Session Container

You can just create a session controller with the new operator, but you need to pass an instance of
the session manager service to container's constructor:

use Zend\Session\Container;

//We assume that $sessionManager variable is an instance of the session amanger
$sessionContainer = new Container('ContainerNamespace', $sessionManager);

So, before you create the container, be sure you ahve injected the session amanger in your controller,service or whereever
you need to create the container.

Method 2: Create a Session Container using a Factory:

This method is equivilant to the firsto ne, but the session container is created by teh factory. You just need to 
regsiter what container namespaces you need. To do that, add the session_containers key to your module.config.php file as follows:

<?php
return [
	//...
	'session_containers' => [
		'ContainerNamespace'
	],
];

You may list the allowable container names under this key. Choosing a container name is up to you, just be sure
it is unique among all otehr service names.

Once you registered a container name (or several container names), you can create the container and work wit hit.
You typically do that in a factory with the help of the service manager:

// The $container variable is the service manager.
$sessionContainer = $container->get('ContainerNamespace');

AS we can see, we can retrieve the container from the service manager by its registered name.

Saving Data to Session with Session Container:

When you created the session container, you are able to save data to it as follows:

$sessionContainer->myVar = 'Some Data';

To retrieve the data from session container, you use the following code:

if(isset($sessionContainer->myVar))
	$myVar = $sessionContainer->myVar;
else
	$myVar = null;

To remove data from session, use the following code:

unset($sessionContainer->myVar);

For some practical examples of using session containers, we will cover that in Implementing Multi-Step Forms.

PHP session is a useful feature allowing you to store some data between page requests. PHP engine stores 
session data on your server in form of files, and uses browser cookies to identify the same visitor 
the next time and load his session data to memory. For exmaple, you can remember the user and show him
personalized pages.

The session does not last forever, it expires in some time.

ZF provides a convinient wrapper around PHP sessions. With this wrapper, you can store data in session
containers in object-oriented way. Zf3 also provides security features allowing to automatically
validate session and prevent hacker attacks.

Having covered the sessions chapter, we go back to the chapter about Implementing Multi Step Forms.

Enabling Sessions:

Session support is implemented in Zend\Session component, so you have to install it if you had not done that before.

Next, modify your APP_DIR/config/global.php as follows:

<?php
use Zend\Session\Storage\SessionArrayStorage;
use Zend\Session\Validator\RemoteAddr;
use Zend\Session\Validator\HttpUserAgent;

return [
	//Session config
	'session_config' => [
		//Session cookie will expire in 1 hour

		'cookie_lifetime' => 60*60*1;

		//store session data on server maximum of 1 month
		'gc_lifetime' => 60*60*24*30,
	],
	// session manager configuration
	'session_manager' => [
		//Session validators (used for security)
		'validators' => [
			RemoteAddr::class,
			HttpUserAgent::class,
		]
	],
	//Session storage configuraiton
	'session_storage' => [
		'type' => SessionArrayStorage::class
	],

	//....
];

Then add the following to your module.config.php to register the UserRegistration session container:

<?php
return [
	//...
	'session_container' => [
		'UserRegistration'
	]
];

Done! Now we can use session container in our code. Next,we implement the RegistrationForm form model.

Adding RegistrationForm:

The RegistrationForm form model will be used for collecting data about the user (email, full name, PW, personal info and
billing info). We will add elements to this form in three portions, thus allowing to use it as a multi-step form.

To add the form model, create the RegistrationForm.php file in the Form directory under the Application module's source dir:

<?php
namespace Application\Form;

use Zend\Form\Form;
use Zend\InputFilter\InputFilter;
use Application\Validator\PhoneValidator;

/**
  * This form is used to collect user registration data. This form is multi-step
  * It determiens which fields to create based on the $step argumetn you pass to
  * its constructor
  */
class RegistrationForm extends Form
{
	/**
	  * consturctor
	  */
	public function __construct($step)
	{
		//Check input
		if (!is_int($step) || $step<1 || $step>3)
			throw new \Exception('Step is invalid!');


		//Define form name
		parent::__construct('registration-form');

		//Set POST method for htis form
		$this->setAttribute('method', 'post');

		$this->addElements($step);
		$this->addInputFilter($step);
	}

	/**
	  * This method adds elements to form (input fields and submit button)
	  */
	protected function addElements($step)
	{
		if ($step==1) {
			//add "email" field
			$this->add([
				'type' => 'text',
				'name' => 'email',
				'attributes' => [	
					'id' => 'email'
				],
				'options' => [
					'label' => 'Your e-mail',
				],
			]);

			//Add "full-name" field
			$this->add([
				'type' => 'text',
				'name' => 'full_name',
				'attributes' => [
					'id' => 'full_name'
				],
				'options' => [
					'label' => 'Full Name',
				],
			]);

			//Add "password" field
			$this->add([
				'type' => 'password',
				'name' => 'password',
				'attributes' => [
					'id' => 'password'
				],
				'options' => [
					'label' => 'Choose Password',
				],
			]);

			//Add "confirm_password" field
			$this->add([
				'type' => 'password',
				'name' => 'confirm_password',
				'attributes' => [
					'id' => 'confirm_password'
				],
				'options' => [
					'label' => 'Type Password Again',
				],
			]);
		} else if ($step==2) {
			//Add "Phone field"
			$this->add([
				'type' => 'text',
				'name' => 'phone',
				'attributes' => [
					'id' => 'phone'
				],
				'options' => [
					'label' => 'Mobile Phone',
				],
			]);

			//Add "Street address "field
			$this->add([
				'type' => 'text',
				'name' => 'street_address',
				'attributes' => [
					'id' => 'street_address',
				],
				'options' => [
					'label' => 'Street addres',
				],
			]);

			//ADd "city" field
			$this->add([
				'type' => 'text',
				'name' => 'city',
				'attributes' => [
					'id' => 'city'
				],
				'options' => [
					'label' => 'City',
				],
			]);

			//Add "state" field
			$this->add([
				'type' => 'text',
				'name' => 'state',
				'attributes' => [
					'id' => 'state'
				],
				'options' => [
					'label' => 'State',
				],
			]);

			//Add "Post_code" field
			$this->add([
				'type' => 'text',
				'name' => 'post_code',
				'attributes' => [
					'id' => 'post_code',
				],
				'options' => [
					'label' => 'Post Code',
				],
			]);

			//Add "countrY" field
			$this->add([
				'type' 	=> 'select',
				'name' => 'country',
				'attributes' => [
					'id' => 'country',
				],
				'options' => [
					'label' => 'Country',
					'empty_option' => '-- Please Select --',
					'value_options' => [
						'US' => 'United States',
						'CA' => 'Canda',
						'BR' => 'Brazil',
						'GB' => 'Great Britian',
						'FR' => 'France',
						'IT' => 'Itality',
						'DE' => 'Germany',
						'RU' => 'Russia',
						'IN' => 'India',
						'CN' => 'China',
						'AU' => 'Australia',
						'JP' => 'Japan'
					],
				],
			]);
		} else if ($step==3) {

			//Add "billing_plan" field
			$this->add([
				'type' => 'select',
				'name' => 'billing_plan',
				'attributes' => [
					'id' => 'billing_plan',
				],
				'options' => [
					'label' => 'Billing Plan',
					'empty_option' => '-- Please Select --',
					'value_options' => [
						'Free' => 'Free',
						'Bronze' => 'Bronze',
						'Silver' => 'Silver',
						'Gold' => 'Gold',
						'Platinum' => 'Platinum'
					],
				],
			]);

			//Add "payment method" field
			$this->add([
				'type' => 'select',
				'name' => 'payment_method',
				'attributes' => [
					'id' => 'payment_method',
				],
				'options' => [
					'label' => 'Payment Method',
					'empty_option' => '-- Please Select --',
					'value_options' => [
						'Visa' => 'Visa',
						'MasterCard' => 'Master Card',
						'PayPal' => 'PayPal'
					],
				],
			]);

		}

		//Add the CSRF field
		$this->add([
			'type' => 'csrf',
			'name' => 'csrf',
			'attributes' => [],
			'options' => [
				'csrf_options' => [
					'timeout' => 600
				]
			],
		]);

		//Add the submit button
		$this->add([
			'type' => 'submit',
			'name' => 'submit',
			'attributes' => [
				'value' => 'next Step',
				'id' => 'submitButton',
			],
		]);
	}

	/**
	  * THis method creates input filter (used for form filtering/validation)
	  */
	private function addInputFilter($step)
	{
		$inputFilter = new InputFilter();
		$this->setInputFilter($inputFilter);

		if ($step==1) {
			$inputFilter->add([
					'name' 		=> 'email',
					'required' 	=> true,
					'filters' 	=> [
						['name' => 'StringTrim'],
					],
					'validators' => [
						[
							'name' => 'EmailAddress',
							'options' => [
								'allow' => \Zend\Validator\Hostname::ALLOW_DNS,
								'useMxCheck' 	=> false,
							],
						],
					],
				]);

			$inputFilter->add([
				'name' 		=> 'full_name',
				'required' => true,
				'filters' => [
					['name' => 'StringTrim'],
					['name' => 'StripTags'],
					['name' => 'StripNewLines'],
				],
				'validators' => [
					[	
						'name' 	=> 'StringLength',
						'options' => [
							'min' => 1,
							'max' => 128
						],
					],
				],
			]);

			//Add input for "password" field
			$inputFilter->add([
					'name' 	=> 'password',
					'required' => true,
					'filters' => [
					],
					'validators' => [
						[
							'name' => 'StringLength',
							'options' => [
								'min' => 6,
								'max' => 64
							],
						],
					],
				]);

			//Add input for confirm password
			$inputFilter->add([
					'name' => 'confirm_password',
					'required' => true,
					'filters' => [
					],
					'validators' => [
						[
							'name' => 'Identical',
							'options' => [
								'token' => 'password',
							],
						],
					],
				]);


		} else if ($step==2) {
			$inputFilter->add([
				'name' 	=> 'phone',
				'required' 	=> true,
				'filters' => [
				],
				'validators' => [
					[
						'name' => 'StringLength',
						'options' => [
							'min' => 3,
							'max' => 32
						],
					],
					[
						'name' => PhoneValidator::class,
						'options' => [
							'format' => PhoneValidator::PHONE_FORMAT_INTL
						]
					],
				],
			]);

			//Addi nptu for the "street_address" field
			$inputFilter->add([
					'name' 	=> 'street_address',
					'required' => true,
					'filters' => [
						['name' => 'StringTrim'],
					],
					'validators' => [
						['name'=>'StringLength', 'options'=>['min'=>1, 'max'=>255]]
					],
				]);

			//Addi nput for city field
			$inputFilter->add([
					'name' => 'city',
					'required' => true,
					'filters' 	=> [
						['name' => 'StringTrim'],
					],
					'validators' => [
						['name'=>'StringLength', 'options'=>['min'=>1, 'max'=>255]]
					],
				]);


			//addi nput for state field
			$inputFilter->add([
					'name' => 'state',
					'required' => true,
					'filters' => [
						['name' => 'StringTrim'],
					],
					'validators' => [
						['name' => 'StringLength', 'options'=>['min'=>1, 'max'=>32]]
					],
				]);


			//Add input for "post_code" field
			$inputFilter->add([
					'name' => 'post_code',
					'required' => true,
					'filters' => [
					],
					'validators' => [
						['name' => 'IsInt'],
						['name'=>'Between', 'options'=>['min'=>0, 'max'=>999999]]
					],
				]);

			//Addi nput for "country" field
			$inputFIlter->add([
					'name' 	=> 'country',
					'required' => false,
					'filters' => [
						['name' => 'Alpha'],
						['name' => 'StringTrim'],
						['name' => 'StringToUpper'],
					],
					'validators' => [
						['name'=>'StringLength', 'options'=>['min'=>2, 'max'=>2]]
					],
				]);
		} else if ($step==3) {

			//Add input for "billing_plan" field
			$inputFilter->add([
					'name' => 'billing_plan',
					'required' => true,
					'filters' => [
					],
					'validators' => [
						[
							'name' => 'InArray',
							'options' => [
								'haystack' =>[
									'Free',
									'Bronze',
									'Silver',
									'Gold',
									'Platinum'
								]
							]
						]
					],
				]);



			//Add input for "payment_method" field
			$inputFilter->add([
					'name' 	=> 'payment_method',
					'required' => true,
					'filters' => [
					],
					'validators' => [
						[
							'name' => 'InArray',
							'options' => [
								'haystack'=>[
									'PayPal',
									'Visa',
									'MasterCard',
								]
							]
						]
					],
				]);
		}

	}
}

As we can see from the code above, the RegistrationForm is a usual form model, but it accepts the $step argument 
in its constructor allowing to specify what form elements to use on the current step.

Adding RegistrationController:

Next, we'll add the RegistrationController controller class. To do that, create the RegistrationController.php file under
the Controller directory and following code into it:

<?php
namespace Application\Controller;

use Zend\Mvc\Controller\AbstractActionController;
use Zend\View\Model\ViewModel;
use Application\Form\RegistrationForm;
use Zend\Session\Container;

/**
  * This is the contoller class displaying a page with the User Registration form.
  * User registration has several steps, so we display different form elements on
  * each step. We use session container to remember user's choices on the previous
  * steps.
  * /
class RegistrationController extends AbstractActionController
{
	/**
	  * Session container
	  * @var Zend\Session\Container
	  */
	private $sessionContainer;

	/**
	  * Constructor. Its goal is to inject dependencies into controller
	  */
	public function __construct($sessionContainer)
	{
		$this->sessionContainer = $sessionContainer;
	}

	/**
	  * This is the default "index" action of the controller. It displays the
	  * User Registration page.
	  */
	public function indexAction()
	{
		//determine the current page
		$step = 1;
		if (isset($this->sessionContainer->step)) {
			$step = $this->sessionContainer->step;
		}

		//Ensure the step is correct (between 1 and 3)
		if ($step<1 || $step>3)
			$step = 1;


		if ($step==1) {
			//init user choices
			$this->sessionContainer->userChoices = [];
		}

		$form = new RegistrationForm($step);

		//Check if user has submitted the form
		if($this->getRequest()->isPost()) {

			//Fill in teh form with POST data
			$data = $this->params()->fromPost();

			$form->setData($data);

			//Validatre fomr
			if($form->isValid()) {

				//get filtered and validated data
				$data = $form->getData();

				//save user choices in session
				$this->sessionContainer->userChoices["step$step"] = $data;

				//increase step
				$step ++;
				$this->sessionContainer->step = $step;

				//if we compelted all 3 steps, redirect to review page
				if ($step>3) {
					return $this->redirect()->toRoute('registration', ['action'=>'review']);
				}

				//Go to the next page
				return $this->redirect()->toRoute('registration');
			}
		}

		$viewModel = new ViewModel([
			'form' => $form
		]);
		$viewModel->setTemplate("application/registration/step$step");

		return $viewModel;
	}

	/**
	  * The "review" action shows a page allowing to review data entered on previous
	  * three steps
	  */
	public function reviewAction()
	{
		//Validate session data
		if(!isset($this->sessionContainer->step) || $this->sessionContainer->step<=3 || !isset($this->sessionContainer->userChoices)) {
			throw new \Exception("Sorry, the data is not avaialble for review yet.");
		}

		//Retrieve user choices from session
		$userChoices = $this->sessionContainer->userChoices;

		return new ViewModel([
			'userChoices' => $userChoices
		]);
	}
}

In the class baove, we have three methods:

The __construct() is used to inject the dependency - the session container - into the controller.

the indexAction() method extracts the current step form session and initializes the form model. If the user has
submitted the form, we extract the data from form and save it to session, incrementing the step. If the step
is greater than 3, we redirect the user to the "Review" page.

The reviewAction() action methods extracts the data entered by the user on all three steps and passes it to the
view for rendering.

Adding RegistrationControllerFactory:

Next, we add the factory for the RegistrationController. To do that, add the RegistrationControllerFactory.php file inside
the Controller/Form directory under the module's source direcotry. Put hte following code into it:

<?php
namespace Application\Controller\Factory;

use Interop\Container\ContainerInterface;
use Zend\ServiceManager\Factory\FactoryInterface;
use Application\Controller\RegistrationController;

/**
  * This is the factory for RegistrationController. Its purpose is to instansiate the 
  * controller and inject dependencies into it
  */
class RegistrationControllerFactory implements FactoryInterface
{
	public function __invoke(ContainerInterface $container, $requestName, array $options = null)
	{
		$sessionContainer = container->get('UserRegistration');


		//instansiate the contorller and inject dependencies
		return new RegistrationController($sessionController);
	}
}

Do not forget to register the controller in the module.config.php file!

Adding View Templates:

Now, let's add the view templates for the controller actions. We have four view templates: step1.phtml, step2.phtml,
step3.phtml and review.phtml. The first three ones are used by the indexAction() and the last is used by reviewAction().

add step1.phtml file inside the application/registration directory and put the following code into it:

<?php
$form->get('email')->setAttributes([
	'class'=>'form-control',
	'placeholder'=>'name@yourcompany.com'
	]);

$form->get('full_name')->setAttributes([
	'class'=>'form-control',
	'placeholder'=>'John Doe'
	]);

$form->get('password')->setAttributes([
	'class'=>'form-control',
	'placeholder'=>'Type password here (6 chars at minimum)'
	]);

$form->get('confirm_password')->setAttributes([
	'class'=>'form-control',
	'placeholder' => 'Repeat Password'
	]);

$form->get('submit')->setAttributes(array['class'=>'btn btn-primary']);

$form->prepare();
?>

<h1>User Registration - Step 1</h1>

<div class="row">
	<div class="col-md-6">
		<?= $this->form()->openTag($form); ?>

		<div class="form-group">
			<?= $this->formLabel($form->get('email')); ?>
			<?= $this->formElement($form->get('email')); ?>
			<?= $this->formElementErrors($form->get('email')); ?>
		</div>

		<div class="form-group">
			<?= $this->formLabel($form->get('full-name')); ?>
			<?= $this->formElement($form->get('full-name')); ?>
			<?= $this->formElementErrors($form->get('full_name')); ?>
		</div>

		<div class="form-group">
			<?= $this->formLabel($form->get('password')); ?>
			<?= $this->formElement($form->get('password')); ?>
			<?= $this->formElementErrors($form->get('password')); ?>
		</div>

		<div class="form-group">
			<?= $this->formLabel($form->get('confirm_password')); ?>
			<?= $this->formElement($form->get('confirm_password')); ?>
			<?= $this->formElementErrors($form->get('confirm_password')); ?>
		</div>

		<div class="form-group">
		<?= $this->formElement($form->get('submit')); ?>
		</div>

		<?= $this->formElement($form->get('csrf')); ?>

		<?= $this->form()->closeTag(); ?>
	</div>
</div>

Next, add step2.phtml file inside the application/registration directory and put
the following code into it:

<?php
$form->get('phone')->setAttributes([
	'class'=>'form-control',
	'placeholder'=>'Phone Number in International Format'
	]);

$form->get('street_address')->setAttributes([
	'class'=>'form-control',
	]);

$form->get('city')->setAttributes([
	'class'=>'form-control',
	]);

$form->get('state')->setAttributes([
	'class'=>'form-control',
	]);

$form->get('post_code')->setAttributes([
	'class'=>'form-control',
	]);

$form->get('country')->setAttributes([
	'class'=>'form-control'
	]);

$form->get('submit')->setAttributes(array('class'=>'btn btn-primary'));

$form->prepare();
?>

<h1>User Registration - Step 2 - Personal information</h1>

<div class="row">
	<div class="col-md-6">
		<?= $this->form()->openTag($form); ?>

		<div class="form-group">
			<?= $this->formLabel($form->get('phone')); ?>
			<?= $this->formElement($form->get('phone')); ?>
			<?= $this->formElementErrors($form->get('phone')); ?>
		</div>

		<div class="form-group">
			<?= $this->formLabel($form->get('street_address')); ?>
			<?= $this->formElement($form->get('street_address')); ?>
			<?= $this->formElementErrors($form->get('street_address')); ?>
		</div>

		<div class="form-group">
			<?= $this->formLabel($form->get('city')); ?>
			<?= $this->formElement($form->get('city')); ?>
			<?= $this->formElementErrors($form->get('city')); ?>
		</div>

		<div class="form-group">
			<?= $this->formLabel($form->get('state')); ?>
			<?= $this->formElement($form->get('state')); ?>
			<?= $this->formElementErrors($form->get('state')); ?>
		</div>

		<div class="form-group">
			<?= $this->formLabel($form->get('post_code')); ?>
			<?= $this->formElement($form->get('post_code')); ?>
			<?= $this->formElementErrors($form->get('post_code')); ?>
		</div>

		<div class="form-group">
			<?= $this->formLabel($form->get('country')); ?>
			<?= $this->formElement($form->get('country')); ?>
			<?= $this->formElementErrors($form->get('country')); ?>
		</div>

		<div class="form-group">
		<?= $this->formElement($form->get('submit')); ?>
		</div>

		<?= $this->formElement($form->get('csrf')); ?>

		<?= $this->form()->closeTag(); ?>
	</div>
</div>

Next, add step3.phtml inside the application/registration directory and put the following code in it.

<?php
$form->get('billing_plan')->setAttributes([
	'class'=>'form-control',
	]);

$form->get('payment_method')->setAttributes([
	'class'=>'form-control',
	]);

$form->get('submit')->setAttributes(array('class'=>'btn btn-primary'));

$form->prepare();
?>

<h1>User Registration - Step 3 - Billing Information</h1>

<div class="row">
	<div class="col-md-6">
		<?= $this->form()->openTag($form); ?>

		<div class="form-group">
			<?= $this->formLabel($form->get('billing_plan')); ?>
			<?= $this->formElement($form->get('billing_plan')); ?>
			<?= $this->formElementErrors($form->get('billing_plan')); ?>
		</div>

		<div class="form-group">
			<?= $this->formLabel($form->get('payment_method')); ?>
			<?= $this->formElement($form->get('payment_method')); ?>
			<?= $this->formElementErrors($form->get('payment_method')); ?>
		</div>

		<div class="form-group">
		<?= $this->formElement($form->get('submit')); ?>
		</div>

		<?= $this->formElement($form->get('csrf')); ?>

		<?= $this->form()->closeTag(); ?>
	</div>
</div>

And finally, we add the review.phtml inside the application/registration directrory and put the following int oit:

<h1>User Registration - Review</h1>

<p>Thank you! Now please review the data you entered in the previous three steps.</p>

<pre>
<?php print_r($userChoices); ?>
</pre>

Adding Route:

'registration' => [
	'type' 		=> Segment::class,
	'options' 	=> [
		'route' 	=> '/registration[/:action]',
		'constraints' => [
			'action' => '[a-zA-Z][a-zA-Z0-9_-]*'
		],
		'defaults' => [
			'controller' => Controller\RegistrationController::class,
			'action' 	 => 'index',
		],
	],
],

We would get everything as expected from this.

Summary:

In this chapter, we have discussed some advanced form usage capabilities.

ZF3 provides two classes whose purpose is enhancing form security: Captcha and Csrf.
A CAPTCHA is a type of challenge-response test used to determine wether or not the user is a human.

CAPTCHA elements are used on form to prevent form submission by malicious automated processes. 
Csrf is used against Cross-Site Request Forgery.

We also learned how to implement multi-step forms with sessions.

Database Management with Doctrine ORM:

Doctrine is an open-source PHP lib providing convenient methods for managing your DB in a object-oriented
way. For working with relational DBs, Doctrine provides a component named Object Relational Mapper (ORM).

With Doctrine ORM you map your DB table to a PHP class (in terms of DDD (Domain Driven Design), we also call it an entity)
and a row from that table is mapped to an instance of the entity class. If you are new to Doctrine, it is suggested
we go to Appendix D. Introduction to Doctrine for info about Doctrine lib architechture.

Doctrine is a third-party lib, it is not part of ZF3. We cover it in this book because it provides an easy
way of adding DB support to your ZF3 based web apps.

Components covered in this chapter:

Doctrine\ORM 			Implements Object-Relational Mapper

DoctrineORMModule 		Easy integration of Doctrine ORM with ZF3.

Zend\Paginator 			Support of pagination.

We will cover appendix D, first.

Appendix D. introduction to Doctrine:

In this appendix, we provide overview of the Doctrine lib, such as its architechture and components. Since in this book
we concentrate mainly on Doctrine's Object Relational Mapper (ORM) component, reading this appendix may give you the
bigger picture of other Doctrine capabilities.

Doctrine and Database Management Systems:

There are many database management systems (DBMS) on the market. Those systems can be divided into two groups:
traditional relational databases utilizing SQL language for querying and manipulating data, and NoSQL databases
utilizing "not only SQL" methods for accessing and managing the data.

In each particular project you may prefer certain DBMS because of its capabilities and competetive advantages.

Relational Databases:

In a relational database, you have a collection of tables (relations) consisting of rows. A row may have one or several
columns. A row (or several rows) of a table may be linked to a row (or several rows) of another table, thus forming
relationships between data.

For example, assume you have a blog website whose database contains two tables: the post table and the comment table.
The post table would have columns named id, title, content, author, date_created, and the comment table would have
columns named id, post_id, author, content and date_created.

The post table is related to comment table as one-to-many, because one post has zero or more (many)
comments, while a certain comment may only relate to a certain post only.

On the market, there is a number of major relational databases. Among them: SQLite, MySQL, PostgreSQL, Oracle, Microsoft
SQL Server etc.

Each database system has its own features specific to that DBMS and which are not part of other systems. For example:

SQLite is designed as an embed extension of PHP engine and does not require installation, however, it works well
for simple sites only.

MySQL is a free system which is very simple in installation and administration and good for using in systems varying
from small to middle scale.

Commercial Oracle DBMS is mainly targeted on large-scale systems and has sophisticated administrative tools.

PostgreSQL supports indefinitly large DBs and can be considered as an open-source replacement of Oracle.

Doctrine library is designed to work with all major databases using a unified programming interface. This programming
interface is implement in two levels:

1. At the lower level, Doctrine provides the unified mechanism for building SQL queries to any supported relational
database and manipulating database schema. This mechanism is implemented in the Database Abstraction Layer (DBAL) component.

2. At the higher level, the Object Relational Mapper (ORM) component of Doctrine provides an ability to query and manage
database data in object-oriented way, by mapping the tables to PHP classes. This component also provides its custom
database query language called DQL allowing to build queries in object-oriented style.

Typically, you use the API provided by high-level ORM component. At the same time, you can easily work with lower-level
DBAL component, if you find that more suitable for your particular needs.

Doctrine is database-agnostic. In theory, when you use Doctrine you are able to abstract of database type and
switch between databases more easily than when you use your database-dependant solution.

SQL vs DQL:

When using a relation database system, you typically use SQL language as a standard way of accessing database data and
managing database schema. However, each DBMS usually has its own specific SQL language extension (dialect).

Doctrine library is designed to work with all major relational database systems that use SQL language, but it is
obvious that it supports only some subset of their functionality and SQL language capabilities.

Doctrine is built on top of the PHP PDO extension (and other database-specific PHP extensions, like sqlite, mysqli, oci8, etc.)
Those extensions provide drivers for all major relational database systems. You specify which driver to use when configuring
a database connection.

The PHP Data Objects (PDO) extension defines a lightweight, consistent interface for accessing databases in PHP. To make it
in database-agnostic way, PDO uses the concept of database drivers. Each database driver that implements the PDO interface
can expose database-specific features as regular extension functions.

Since the Object Relational Mapper component of Doctrine is designed to work with objects instead of tables, it provides
its own "object-oriented" query language called DQL. It is similar to SQL in sense that it allows to write and execute
queries to DB, but result of a query is an array of objects rather than an array of table rows.

DQL stands for Doctrine Query Language.

NoSQL Databases:

In contrast to a relational database system, a NoSQL database system - as its name assumes - uses a not-only-SQL method
of accessing the data. This means that each NoSQL system may provide its own custom methods and API for accessing 
and manipulating the data.

Technically, NoSQL databases can be divided into the following groups:

Document Store: A document database operates the concept of documents and their fields. This is useful, for example,
if you have an hierarchical document tree in a content manager system (CMS). Documents are addressed in the database
via a unique key that represents the document. 

One of the other defining characteristics of a document-oriented database is that, beyond the simple key-document lookup
that you can use to retrieve a document, the database will offer an API or query language that will allow retrieval
 of documents based on their contents.

Column Store: Frequently used in web indexing. A column-oriented DBMS is a database management system that stores data
tables as sections of columns of data rather than as rows of data. In comparison, most relational DBMSs store
data in rows. 

This column-oriented DBMS has advantages for data warehouses, customer relationship management (CRM) systems,
and library card catalogues, and other ad hoc inquiry systems where aggregates are computed over large numbers of
similar data items.

Key-Value Store: This is the simplest data storage using unique keys for accessing certain data. Such database 
systems provide a simple key-value lookup mechanism.

And others.

Doctrine provides support only to the Document Store subset of the NoSQL database systems. Column store and key-value
store database systems typically have very specific field of applications, and is not covered by Doctrine.

Document Databases:

Doctrine supports a number of NoSQL document store databases: MongoDB, CouchDB, OrientDB and PHPCR.

For example, in a blog website, you would have a document named post and a document named comment. The post document
would have fields named id, title, content, author, date_created; and the comment document would have fields 
named id, author, content and date_created.

This is very similar to the tables you would have in a relational DB.

In this book, we do not address the Doctrine-provided API to the NoSQL documetn databases. If you want to learn
about these capabilities, please refer to the Corresponding sections of Doctrine project documentation.

Doctrine Architechture:

The Doctrine Project consists of several libraries (components). Each Doctrine component is distributed as a 
Composer-installable package and registered in Packagist.org catalogue.

This is very similar to the way that ZF3 uses for installing its components..

Here, we will provide you with a brief description of Doctrine library architechtures to let you a 
general idea of its capabilities.

Components Supporting Relational Databases:

Main Doctrine components designed for working with relational databases are shown As follows,
where of the last two are the PHP Engine and PHP Extensions to which Doctrine is built upon:

				DoctrineModule 		DoctrineORMModule

								ORM
				DataFixtures 	Common 		DBAL

				Migrations 		Annotations Collections

				Inflector 		Lexer 		Cache

This build on top of the PHP Engine and PHP Extensions (PDO and other relational DB extensions (msqli, oci8, etc.))

As you can see from the figure, Doctrine is based on PHP engine features and on PHP extensions that are actually
used as drivers to particular database management systems. Above that base layer, there are core Doctrine components
(like Annotations, Common, etc) providing essential functionality for other top-level components.

The DBAL component provides an abstraction layer of database type. And on top of all that there is the ORM component
providing API for working with data in object-oriented way.

DoctrineModule and DoctrineORMModule components are designed for integration with ZF3.

Doctrine ORM component uses the so called Data Mapper pattern. This pattern tells a database table can be
represented as a PHP entity class. The database in this pattern is considered as some kind of repository
(storage of entities).

When you retrieve an entity from the repository, an SQL query is performed internally and an instance of the
PHP entity class is constructed and its properties are filled with data.

By analogy with ZF3 components, Doctrine component names consist of two parts: the vendor name ("Doctrine")
and the component name (e.g "Common"). Below, you can find the list of Doctrine components together with their Composer-installable
package names and brief descriptions.

Doctrine\Common. Common Library for Doctrine projects. This component contains commonly used functionality. Its Composer-installable
package name is doctrine/common.

Doctrine\Annotations. Docblock Annotations Parser. Its Composer-installable package name is doctrine/annotations.

Doctrine\Inflector. Common String Manipulations with regards to casing and singular/plural rules. Its Composer-installable
package name is doctrine/inflector.

Doctrine\Lexer. Base library for a lexer that can be used in Top-Down, Recursive Descent Parses. Its Composer-installable
package name is doctrine/lexer.

Doctrine\Cache. Caching library offering an object-oriented API for many cache backends. Its Composer-installable package
name is doctrine/cache.

Doctrine\DBAL. Databse Abstraction Layer. This is a lightweight and thin runtime layer around a PDO-like API and a lot of
additional, horizontal features like database schema introspection and manipulation through an object oriented API.
Its Composer-installable package name is doctrine/dbal.

Doctrine\Collections. Collections Abstraction library. Its Composer-installable package name is doctrine/collections.

Doctrine\ORM. Object-Relational-Mapper for PHP. This is a Doctrine component providing a way to work with entity models
in object-oriented way instead of raw SQL queries. Its composer installable package name is doctrine/orm.

Doctrine\Migrations. Database Schema migrations using Doctrine DBAL. Provides a consistent way to manage database schema
and update it. Its composer installable package name is doctrine/migrations.

Doctrine\DataFixtures. Data Fixtures for all Doctrine Object Managers. Provides a framework for making database fixtures.
Its composer installable package name is doctrine/data-fixtures.

Since Doctrine uses PHP autoloading and PSR-4 standard, classes belonging to certain component live in that component's
namespace. For example, the EntityManager class belonging to Doctrine\ORM component, lives in Doctrine\ORM namespace.

Components Supporting NoSQL Document Databases:

Doctrine components designed for working with NoSQL document databases (MongoDB, CouchDB, etc) are shown in the
following figure.

DoctrineMongoODMModule

MongodbODM 		CouchdbODM

MongoDB 		CouchDB 	OrientdbODM 	PhcrODM 	Common

These build ontop of the PHP components as follows:

Mongo extension 			libxml extension

PHP Engine

As you can see from above, Doctrine NoSQL components are based on PHP engine features and on
PHP extensions that can be considered as "drivers" to particular database management systems.

Above that base layer, there are middle level components. The Common component is the same component
that was shown earlier, it provides commonly used functionality. The Mongodb and CouchDB
are components providing low-level API to corresponding databases.

The MongodbODM, CouchdbODM, OrientdbODM and PhpcrODM components provide Object Document Mappers (ODM)
for corresponding databases. ODM concept is very similar to ORM in the sense that it provides an ability
to work with a NoSQL database in object oriented way by mapping a document to a PHP entity class.

The DoctrineMongoODMModule component is intended for integration with ZF3.

Below, you can find the list of components together with their Composer-installable package names and brief descs:

Doctrine\MongoDB is Doctrine MongoDB Abstraction Layer. Its Composer-installable package name is doctrine/mongodb

Doctrine\MongodbODM (Object Document Mapper) provides a way to map NoSQL documents to PHP entity models. Its composer-installable
package name is doctrine/mongodb-odm

Doctrine\MongoODMModule is ZF3 module that provides Doctrine MongoDB ODM functionality. It serves for easy integration with ZF3.
It's Composer-installable package name is doctrine/doctrine-mongo-odm-module.

Doctrine\CouchDB component provides Simple API that wraps around CouchDBs HTTP API. Its Composer-installable package name
is doctrine/couchdb

Doctrine\CouchdbODM component is CouchDB Document Object Mapper. Its analogous to Doctrine ORM in the sense that it provides
the way to access database in object oriented ways. Its Composer-installable package name is doctrine/couchdb-odm

//NOTE ON THE ABOVE; ASSUMING THERE WAS AN TYPO DUE TO REPETION OF SAME COMPONent name twice.

Doctrine\OrientdbODM is a set of PHP libs in order to use OrientDB from PHP. Its Composer-installable package
name is doctrine/orientdb-odm

Doctrine\PhpcrODM is Object-Document-Mapper for PHPCR. Its composer-installable package is doctrine/phpcr-odm

Summary:

In this appendix, we've provided the overview of Doctrine library architechture and components. Doctrine is a large project
consisting of multiple components mainly targeted on data persistence.

On the market, there are two big groups of database management systems: traditional relational databases and so called
NoSQL databases. Although most relational databases uses SQL language for querying and manipulation of data,
each DB system has its own specific features. The same thing can be seen with NoSQL databases, where each system provides
its own custom method for accessing data.

Doctrine is designed to work with data in database-agnostic way by providing sophisticated abstraction layers.

The most useful component of Doctrine, Object Relational Manager (ORM) is designed to let developers an ability
to work with data in an Object Oriented way.

This is when instead of writing an SQL query, you load an entity object (or an array of entity objects) from a repository.
With this approach, a database table is mapped to a PHP class (also called an entity), and a row from that table is mapped
to an instance of that entity class.

We now go back to the Database Management with Doctrine ORM.

Get Blog Example from GitHub:

For demonstration of Doctrine ORM usage, in this chapter, we will create a real-life Blog website. Its main features 
are as follows:

It will store blog posts in a database and provide a user interface for accessing and managing those posts.

It is assumed that the blog has the single author of its posts, while comments can be added by multiple blog readers.

The website will have two pages: Home Page and Admin page. The first one will display the list of recently added posts,
while the latter one will allow to add, edit, view and delete posts.

To download the Blog application, visit the respective page in this chapter.

Download, unpack it to some dir, access to the blog directory containing the source code.

The Blog is a sample website which can be installed on your machine. To install the sample, you can either edit your default
Apache virtual host file or create a new one. After editing the file, restart the Apache HTTP server and open the website
in your web browser.

For detailed info on installation, please refer to the README.md file located in the blog directory.

For the Blog sample to work, you have to create a MySQL database. Instructions on how to do that is provided
in the next section.

Creating a Simple MySQL DB:

For the Blog sample to work, we need to have a DB. In this book, we use MySQL DB management system, which is very
simple in installation and adminsitration.

Due to installation depending on OS versions, we will cover Appendix A first.

Appendix A. Configuring Web Development Environment:

Here we will provide on how to prepare your environment for developing ZF3-based applications. If you already have
the configured environment, you can skip this.

Configuring the development environment is the first thing you have to do when beginning with creating your 
first web-site. This includes installing the web server, the PHP engine with required extensions and a database.

For the purpose of running the code examples created in teh book, we will use Apache HTTP server (>= 2.4), PHP engine
(5.6 >=) with XDebug extension and MySQL DB (>= 5.6)

We also provide instructions for installing NetBeans IDE, which is a convenient integrated development environment
for PHP development. It allows an easier navigation, editing and debugging of your PHP application. The NetBeans IDE
is written in Java and can be installed on Windows, Linux and other platforms supporting a compatible Java machine.

Installing Apache, PHP and MySQL in Linux:

In general, it is recommended that you use a popular and well supported Linux distribution, either 32-bit (x86) or 64-bit (amd64).
A 64-bit version can give a great performance, but deliver more problems (like driver compability issues).

32-bit systems are with us for a longer time and have less problems, which is important for novice users.

There are two big families of Linux distributions: Debian and Red hat. Debian is a free and open-source project,
which has several branches, the most popular one being Linux Ubuntu. Red Hat is commercially distributed OS, which 
has "free" branches named Linux CentOS and Linux Fedora.

Red Hat Linux is being developed by Red Hat Inc. Red Hat Linux (or its "free" modification CentOS) is known as a "corporate"
OS. Its main advantage is "stability" (low rate of system crashes). However, the stability is achieved through carefully
choosing the software which is installed out of the box.

When you install such an OS for the purose of PHP development, this "stability" may become a problem, because you ahve
access to some old but "stable" version of PHP and other software.

They do not include a new "Bleeding-edge" software into their repo, so if you want one, you will need to download it from
somewhere, read the manual and possibly (if you are not lucky) compile it yourself.

There is another Linux distribution, which, in the authors opinion, suits better for PHP development. Its name is Linux
Ubuntu. Ubuntu is being developed by Canonical Ltd. Linux Ubuntu has two editions. Desktop edition and Server edition.

Ubuntu Desktop is a distribution containing graphics env, while Ubuntu Server has console only.
For the purpose of PHP development, we should go with the Desktop version.

Canonical typically releases a new version of Linux Ubuntu each 6 months, in April and October and a Long Term Support
version every 2 years. 

Non-LTS releases have short support period (about 9 months), but they have the newest versions of teh PHP software out of
the box. On the other hand, LTS releases have longer support period (5 years), but a little outdated PHP out of the box.

For PHP development, the author would recommend to use the latest Ubuntu Desktop, because it has the newest version of
PHP and other software available from repository. The disadvantage of using such a version is that you will need to upgrade
to the next release every 9 months (as support period expires). If you do not like that, go for the latest LTS release.

An example of listings:
 											PHP version
Linux Ubuntu 16.04 Xenial Xerus LTS 			7.0

Linux Ubuntu 15.10 Wily Werewolf 				5.6

Linux Ubuntu 15.04 Vivid Vervet 				5.6

Linux Ubuntu 14.10 Utopic Unicorn 				5.5

Linux Ubuntu 14.04 Trusty Tahr 					5.5

We will need at least PHP 5.6 for the books stuff.

When choosing between 32-bit and 64-bit versions of the system, remember that the 64 bit version of Linux Ubuntu
will have more compability issues than its 32-bit counterpart. The support of drivers can also cause problems
on the 64-bit platform.

If you are new to Linux Ubuntu, watch these excellent video tutorials by LearnLinux.tx YouTube user.
//Links exist on the website. Also, we'd probably do best in installing a VM with the Ubuntu Desktop Edition

Installing Apache and PHP:

In modern Linux distrus, you can easily download and install software from a centralized repository. The repository
contains so called packages. A package has a name (for example, php, apache2) and a version.

In general, you can install a package with a single command. However, the command (and a package name) may differ based
on linux distribution you use. For example, to download and install packages in Debian-based Linux distributions (e.g
Ubuntu Linux), you use Advanced Packaging Tool (APT).

In Red Hat provided distributions, (e.g Fedora or CentOS), you use YUM (RPM package manager)
Below, detailed installation instructions for these OS systems are provided.

Debian or Linux Ubuntu:

First of all, it is recommended that you update your system by installing the latest available updates. To do this,
from a cmd shell, run the following updates:

sudo apt-get update

sudo apt-get upgrade

The commands above run the APT tool and install the newest system packages updates. The sudo command (stands for Super
User DO) allows to run another command, apt-get in our case, as sys admin (root).

You typically use sudo when you need to elevate your privs to install a package or edit some config file.

The sudo Command may request you for a pw. When prompted, enter the PW under which you log into the
system and press enter.

Next, from a cmd shell, run the following commands:

sudo apt-get install apache2

sudo apt-get install php

sudo apt-get install libapache2-mod-php

The commands above download from repository and install the latest available versions of Apache HTTP server, PHP engine
and PHP extension module for Apache.

The commands above may ask you for confirmation when isntalling a package. It is recommended to answer Yes (press y and hit enter).

Fedora, CentOS or Red Hat Linux:

First of all, we run system updates:

sudo yum update

The command above runs the YUM tool and installs the newest system package updates.

Next, from the cmd shell, run the following commands:

sudo yum install httpd

sudo yum install php

The commands above download from repository and install the latest version of Apache HTTP server and PHP engine.

Next, run the following commands to add Apache HTTP Server to system autorun and start it:

sudo chkconfig --level 235 httpd on

sudo service httpd start

Checking Web Server Installation:

After you set up your Apache HTTP web server, check that it is installed correctly and that the server sees the 
PHP engine. To do that, create phpinfo.php file in Apache document root directory.

The document root is a directory where you can (by default) store the web files. Typically, the Apache document root directory
is /var/www/html

To be able to navigate the directory structure and edit files, it is recommended to install Midnight Commander
(convenient file manager and text editor). To install Midnight Commander in Debian or Linux Ubuntu, type the following:

sudo apt-get install mc

The following command installs Midnight Commander in Fedora, CentOS or Red Hat Linux:

sudo yum install mc

After installation, you can launch the file manager with the mc command, and edit a text file with the command liek this:

mcedit /path/to/file

If we need admin rights, just prepend sudo.

In the phpinfo.php file, just enter:

<?php
	phpinfo();
?>

Open it in our browser.

Editing PHP Configuration:

To configure PHP for your development environment, you need to edit the PHP config file (php.ini) and adjust some parameters:

In different distributions of Linux, PHP Configuration file can be located in different paths. To edit the PHP config file
in Debian or Linux Ubuntu, type the following:

sudo mcedit /etc/php/7.0/apache2/php.ini

Type the following to edit php.ini in Fedora, CentOS or Red Hat Linux:

sudo mcedit /etc/php.ini

For the development environment, it is recommended to set the following error handling and logging parameters as below.
This will force PHP to display errors on your PHP pages to screen:

error_reporting = E_ALL

display_errors = on

display_startup_errors = on

To conveniently search within the file, press F7 in Midnight Commander's editor window and enter the search
string (the name of the parameter to search for)

Set your time zone settings (replace <your_time_zone> ph with your time zone, for example UTC or America/New_York)

date.timezone = <your_time_zone>

Set max_execution_time, upload_max_filesize and post_max_size params to allow large file uploads through POST.
For example, setting upload_max_filesize with 128M allows to upload files up to 128 MB in size.

Setting max_execution_time with zero allows to execute the PHP script indefinitly long.

max_execution_time = 0

post_max_size = 128M

upload_max_filesize = 128M

When ready, save your changes by pressing the F2 key and then press F10 to exit the MC editor.

Restarting Apache Web Server:

After editing configuration files, you usually have to restart Apache HTTP Server to apply your changes.
You do this with the following command (in Debian or Linux Ubuntu):

sudo service apache2 restart

or the following (in Fedora, CentOS or Red Hat):

sudo service httpd restart

Enabling Apache's mod_rewrite module:

ZF3 requires that you have Apache's mod_rewrite module enabled. The mod_rewrite module is used to rewrite
requested URLs based on some rules, redirecting site users to another URL.

In Debian or Ubuntu Linux:

To enable Apache mod_rewrite module, type the following command:

a2enmod rewrite

Finally, restart Apache web server to apply the changes.

In Fedora, CentOS or Red Hat Linux:

In these Linux distrus, mod_rewrite is enabled by default, so you don't need to do anything.

Creating Apache Virtual Host:

ZF3 requires that you create a virtual host for your web site. A virtual host term means that you can run
several web-sites on the same machine.

The virtual sites are differentiated by domain name (like site.mydomain.com and site2.mydomain.com). Each VH
has its own document root directroy, allowing you to place web files anywhere on the system (not only to /var/www/html dir)

please note that right now, you do not need to create a virtual host, we did that in the Skeleton App chapter.
These are just examples.

In Debian or Ubuntu Linux:

You have an example default virtual host at /etc/apache2/sites-available/000-default.conf (see below):

<VirtualHost *:80>
	# The ServerName directive sets the request scheme, hostname and port that
	# the server uses to identify itself. This is used when creating redirection URLs.
	#
	# In teh context of virtual hosts,  the ServerName specifies what hostname must appear
	# in teh request's Host: header to match this virtual host. For the default virtual host (this file)
	# this value is not decisive as it is used as a last resort host regardless.
	# However, you must set it for any further virtual host explicitly.
	#ServerName www.example.com

	ServerAdmin webmaster@localhost
	DocumentRoot /var/www/html

	# Available loglevels: trace8, ..., trace1, debug, info, notice, warn,
	# error, crit, alert, emerg.
	# It is also possible to configure the loglevel for particular modules, e.g
	#LogLevel info ssl:warn

	ErrorLog ${APACHE_LOG_DIR}/error.log
	CustomLog ${APACHE_LOG_DIR}/access.log combined

	# For most configuration files from conf-available/, which are
	# enabled or disabled at a global level, it is possible to 
	# include a line for only one particular virtual host. For example the
	# following line enables the CGI configuration for this host only
	# after it has been globally disabled with "a2disconf"
	#Include conf-available/server-cgi-bin.conf
</VirtualHost>

# vim: syntax=apache ts=4 sw=4 sts=4 sr noet

All you ahve to do is edit the VH file when needed and restart Apache to apply changes.

You can also copy this file and create another virtual host, when you need several web sites to operate
on the same machine. For example, to create another virtual host file named 001-vhost2.conf, type the following
from cmd shell:

cd /etc/apache2/sites-available

sudo cp 000-default.conf 001-vhost2.conf

sudo a2ensite 001-vhost2.conf

The virtual host's name starts with a prefix (like 000, 010, etc.) which defines the priority. Apache web server
tries to direct an HTTP request to each virtual host in turn (first to 000-default, then to 001-vhost2), and if
a certain virtual host cannot serve the request the next one is tried and so on.

In Fedora, CentOS or Red Hat Linux:

There is an example virtual host in /etc/httpd/conf/httpd.conf file. Scroll down to the very bottom of the document 
to the section called Virtual Hosts. You can edit this section as you need and restart Apache to apply your changes.

Installing XDebug PHP extension:

To be able to debug your web sites, it is recommended that you install the XDebug extension. The XDebug extension
allows to look inside a running program, see the variables passed from the client, walk the call stack and profile
your PHP code.

XDebug also provides the code coverage analysis capabilities, which are useful when you write unit tests for your code.

In Debian or Ubuntu Linux:

To install XDebug, simply type the following command:

sudo apt-get install php-xdebug

Then edit the /etc/php/7.0/mods-available/xdebug.ini file by typing the following:

sudo mcedit /etc/php/7.0/mods-available/xdebug.ini

Add the following lines to the end of the file (replace the remote IP address PH with the IP address you plan to debug
your website from):

xdebug.remote_enable=1
xdebug.remote_handler=dbgp
xdebug.remote_mode=req
xdebug.remote_host=<remote_ip_address>

Finally, restart the Apache server to apply your changes. Then open the phpinfo.php in your browser and look for XDebug
section.

In Fedora, CentOS or Red Hat Linux:

In these Linux distributions, installing XDebug is a little more difficult. Install XDebug package with the following command:

yum install php-pecl-xdebug

After install, it is required to create the file xdebug.ini in /etc/php.d directory.

mcedit /etc/php.d/xdebug.ini

Add the following lines to the end of file (replace the remote IP address placeholder with the IP address you plan to debug your
website from):

[xdebug]

zend_extension = /usr/lib/php/modules/xdebug.so
xdebug.remote_enable=1
xdebug.remote_handler=dbgp
xdebug.remote_mode=req
xdebug.remote_host=<remote_ip_address>
xdebug.remote_port=9000

Restart the Apache web server to apply your changes. Then check the phpinfo.php in your browser. If installation was succesful,
you'll see some XDebug-related information.

Installing MySQL Database Server:

MySQL is a free relational DB management system being developed and supported by Oracle. MySQL is the most popular
database system used with PHP. In this book, we will be using MySQL.

Debian or Linux Ubuntu:

In order to install MySQL DB, type the following:

sudo apt-get install mysql-server

sudo apt-get install mysql-client

sudo apt-get install php-mysql

The commands above install MySQL server component, MySQL client component and MySQL extension module for PHP, respectively.

Fedora, CentOS, or Red Hat Linux:

In order to install MySQL DB, type the following:

sudo yum install mysql-server

sudo yum install mysql

sudo yum install php-mysql

The commands above install MySQL server component, MySQL client component and MySQL extension module for PHP, respectively.

Run the following commands to add MySQL server to autostart and start the server:

sudo chkconfig --level 235 mysqld on

sudo service mysqld start

Configuring the MySQL Database Server:

During the installation of the MySQL server, a root user is created. By default the root user has no pw, so you ahve to 
set it manually. You will need that pw for creating other MySQL Db users.

To connect to the MySQL server enter the following command:

mysql -u root -p

The MySQL command prompt will appear. In the command prompte nter the following commadns and press enter (in the cmd below,
replace <your password> with the real pw):

SET PASSWORD FOR 'root'@'localhost' = '<insert_your_password>';

If the command is executed successfully, the following message is dispalyed:

Query OK, 0 rows affected.

Create a new DB:

CREATE DATABASE test_db;

The command above creates the empty schema that we will populate later.

Next, we want to create another database used named test_user that will be used by the ZF3 based website
for connecting to the DB. To create the user, type the following (in the cmd below, replace the PH) with some PW:

GRANT ALL PRIVILEGES ON test_db.* TO 'test_user'@'localhost' IDENTIFIED BY '<insert_your_password>';

The command above creates the user named 'test_user' and grants the user all privilages on the 'test_db' db.

Finally, type quit to exit the MySQL prompt.

Installing NetBeans IDE in Linux:

You can install NetBeans IDE using two methods: either from repository as you did with Apache, PHP and MySQL, or by downloading
the installer from NetBeans web site and running it. The first method is simpler.

To install NetBeans IDE in Debian or Linux Ubuntu, type the following CMD in your cmd shell:

sudo apt-get install netbeans

or the following command to install it in Fedora, CentOS or Red Hat Linux:

sudo yum install netbeans

The command above downloads from the repo and installs NetBeans and all its dependant packages. To run it, just write:

netbeans

To be able to create PHP projects, you need to activate PHP plugin for NetBeans. To do that, open menu Tools->Plugins,
the Plugins dialog appears. In the dialog, click Settings tab, and set check marks to all Update Centers. 

Then, click the Available Plugins tab. On that tab, click the Check for Newest Button to build the list of all available
plugins. Then in the list, set check mark to PHP plugin and click the install button.

When the installation is complete, reboot the IDE. Then we can create new projects for PHP in Netbeans.

Appendix B. Introduction to PHP Development in NetBeans IDE:

In this book, we use NetBeans IDE for developing ZF3 based apps. Since we installed NetBeans, we will cover usage of NetBeans here.

Run Configuration:

To be able to run and debug a website, you first need to edit the site's properties. To do that, in NetBeans' Projects pane,
right click on the projects name, and from context menu, select Properties item. THe project's Properties Dialog 
will appear.

In the left pane of the dialog that appears, click the Sources node. In the right pane, edit the Web Root field to point
to your website's APP_DIR/public directory. You can do this by clicking the Browser button. (Just select Public dir from the APP_DIR)

Next, click the Run Configuration node in the left pane. The right pane should display the run settings for your site.

In the right pane, we can see the current config is "default". As an option, we can create several run configurations.

Edit the fields as follows:

In the Run As field, select "Local Website (running on local web server)".

In the Project URL field, enter "http://localhost". If you configured your VH to listen on a differen port, say 8080,
then format it as "http://localhost:8080"

Keep the index file field empty, because the Apache's mod_rewrite module will mask our actual index.php file

In the arguments field, you can specify which GET parameters to pass to your site through the URL string. Typically,
you keep this field empty.

Click OK.

Running the Website:

Just hit the Run button (F6).

Site Debugging in NetBeans:

The "conventional" debugging technique in PHP is putting the var_dump() function in the code block that you want to examine:

var_dump($var);

exit;

The lines above would print out the $var variable to the browser's output and then stop program execution. Whilst this can be
used for debugging even complex sites, it makes the debugging a pain, because you have to type variable dump commands in 
your PHP source file, then refresh your page, edit source again etc.

In contrast, when you debug your website in NetBeans IDE, the PHP interpeter pauses program execution flow at every line
where you set a breakpoint. This makes it possible to conviniently retrieve info about the current state of the program,
like the values of the local variables and teh call stack.

To start the debugging session, in NetBeans window, click the Debug button on the Run toolbar. Alternatively,
you can press the CTRL+F5 key combo on your keyboard.

If everything is ok, you should be able to see the current program counter on the first code line of the index.php file.

While the program is in paused state, your web browser's window is frozen, because the browser is waiting for data
from the web server. Once you continue program execution, the browser receives the data, and displays the web page.

Debug Toolbar:

You can resume/suspend program execution with the Debug Toolbar.

The Finish Debugger session of the toolbar allows to stop the debugger. Press the button when you are done
with debugging the program. The same effect would have pressing the SHIFT+F5 combo.

Clicking the Continue button (or pressing F5 key) continues the program execution until the next breakpoint,
or until the end of the program, if there are no more breakpoints.

The Step Over toolbar button (or pressing F8 key) moves the current program counter to the next line of the program.

The Step Into toolbar button (or pressing F7 key) moves the current program counter to the next line of the program,
and if it is the function entry point, enters the function body. Use this when you want to investigate your code in-depth.

The Step Out toolbar button (CTRL + F7) allows to continue program execution until returning from the current function.

And Run to Cursor (F4) allows to continue program execution until the line of code where you place the cursor.
This may be convenient if you want to skip some code block and pause at a certain line of your program.

Breakpoints:

Typically, you set one or several breakpoints to the lines which you want to debug in step-by-step mode. To set a breakpoint,
put your mouse to the left of the line of code where you want the breakpoint to appear and click on the line number.

Alternatively, you can put the cursor caret to the line where you want to set a breakpoint and press CTRL+F8 key combo

When you set the breakpoint, the line is marked with red color and a small red rectangle appears to the left of it.

Be careful not to set a breakpoint on an empty line or a comment line. Such a breakpoint will be ignored by XDebug and
it will be marked by the "broken" square.

You can travel between breakpoints with the F5 key press. This button continues program execution until it encounters
the next breakpoint. Once the program flow comes to the breakpoint, the PHP interpeter becomes paused, and you can review
the state of the program.

We can see the complete list of breakpoints that we set in the Breakpoints window. The Breakpoints window is located in the
bottom part of NetBeans window. In this window you can add new breakpoints or unset breakpoints that have already been set.

Watching Variables:

When the PHP interpeter is paused, you can conveniently watch the values of PHP variables. A simple way to 
browse a variable is just positioning the mouse cursor over the variable name inside of the code and waiting for a 
second.

If the variable value can be evaluated, it will be displayed inside of a small pop up window.

Another way to watch variables is through the Variables window, which is displayed in the bottom part of NetBeans
window. The Variables window has three columns, Name, Type, Value.

Mainly, you will be faced with three kinds of variables: super globals, locals and $this:

Super global variables are special PHP variables like $_GET, $_POST, $_SERVER, $_COOKIES and so on.
They typically contain server information and parameters passed by the web browser as part of HTTP request.

Local variables are variables living in the scope of the current function (or class method). For example,
in the Hello World application, if you place a breakpoint inside of the IndexController::aboutAction(), the variable
$appName will be a local variable.

$this variable points to the current class instance, if the current code is being executed in context of a PHP class.

Some variables can be "expanded" (to expand a variable, you need to click on a triangle icon to the left of the
variable's name). For example, by clicking and expanding $this variable, you can watch all fields of the class instance.

If you expand an array variable, you will be able to watch array items.

Using the variables window it is possible not only to watch variable's value, but also to change the value on the
fly. To do that, place your mouse cursor over the value column and click over it. The edit box appears,
and we can edit the value on the fly.

Call Stack:

The call stack displays the list of nested functions whose code is being executed at the moment. Each line
of the call stack (also called a stack frame) contains the full name of the class, the name of the method
within the class and line number.

Moving down the stack, you can get a better understanding of the current execution state of the program.

This would lead us to have a chain to follow backwards to find the root of what called what etc.

Debugging Options:

NetBeans allows you to configure some aspects of the debugger's behavior. To open the Options dialog,
select menu Tools->Options. In the dialog that appears, click the PHP tab and in that tab, select
Debugging subtab.

You typically do not change most of these options, you just need to have an idea of what they do.
These are the following debugging options:

The Debugger Port and Session ID parameters define how NetBeans connects to XDebug. By default, the port
number is 9000. The port numer should be the same as the debugger port you set in php.ini when installing
XDebug. The session name is by default "netbeans-xdebug". You typically do not change this value.

The Stop at First Line parameter makes the debugger to stop at teh first line of your index.php file,
instead of stopping at the first breakpoint. May be annoying.

The Watches and Balloon Evaluation option group is disabled by default, because these may cause XDebug fault.
You can enable these options only when you know what you are doing.

The Maximum Depth of Structures parameters sets wheter nested structures (like nested arrays, objects in objects, etc.)
will be visible or not. By default, the depth is set to 3.

The Maxium Number of Children option defines how many array items to display in Variables window. If you set this
to, say 30, you will see only the first 30 items when the array has more than 30 items.

The Show Requested URLs option, when enabled, displays the URL which is currently being processed. It prints the
URL to an Output window.

The Debugger Console option allows to see the output of PHP scripts being debugged. The output is shown
in the Output window. If you plan to use this feature, it is recommended to add output_buffering = off 
parameter in [xdebug] section of your php.ini file, otherwise hte outpt may appear with delays.

Profiling, Appendix B:

When your site is ready and working, you are typically interested in making it as fast and performing as possible.
XDebug provides you with an ability to profile your website. Profiling means determining which class methods 
(or functions) spends what time to execute. This allows you to determine the "bottle neck" places in your code
and address performance issues.

For each HTTP request, the XDebug extension measures the amount of time a function executed, and writes the profiling 
information to a file. Typically, the profiling into files are placed into the system temporary directory 
(in Linux, to /tmp directory) and have names like xdebug.out.<timestamp>, where the <timestamp> PH is the 
timestamp of the HTTP request.

All you have to do is to open a profiling file and analyze it.

To enable XDebug profiler, you should set the following XDebug configuration parameter in your xdebug.ini file:

xdebug.profiler_enable = 1

Unfortunately, NetBeans for PHP does not have an embedded tool for visualizing the profiling results. That's
why you need to install a third-party visualizer tool. Below, we will provide instructions on how to install
a simple web-based tool named Webgrind. Webgrind can work on any platform, because this tool itself is written
in PHP.

Webgrind's installation is very straightforward.

First, you need to download webgrind from its project page and unpack it to some folder. In Linux, we can
do this with the following commands:

cd ~

wget https://github.com/jokkedk/webgrind/archive/master.zip

unzip master.zip

The commands above will change your working directory to your home directory, then will download the Webgrind
archive from the Internet and then unpack the archive.

Next, you need to tell Apache web server where to find Webgrind files. This means you need to configure a 
separate virtual host. Do not forget to restart the server after modifying it.

Finally, open Webgrind in your browser by navigating to the URL of your Webgrind install. For example, if
you configured the virtual host to listen on port 8080, enter "http://localhost:8080" in your browser's navbar and hit enter.

At the top of the Webgrind page, you can select the percentage of the "heaviest" function calls to show. By default,
it is set to 90%. Setting it to a lower % will hide functions called less often.

The drop-down list to the right of percent field allows to select the profiling data file to analyze. By default,
it is set to "Auto (newest)", which forces Webgrind to use the file with the most recent timestamp.

You may need to select another file, for example, if your web pages use AJAX.

The right-most-drop-down list allows to set the units which should be used for measuring the data. Possible options
are: percent (default), milliseconds, and microseconds.

When you have selected the percentage, file name and units, click the Update button to let Webgrind to visualize
the data for you (the calculation may take a few seconds). As the calculations finishes, you should be able to
see the table of function calls, sorted in descending order by function "weight".

The heaviest functions will be displayed at the top.

The table has the following columns:

The first column (Function), displays the class name followed by method name (in case of a method call) or function name
(in case of a regular function)

The second column contains the "paragraph" icons, which can be clicked to open the corresponding PHP source file that 
function is defined in the web browser.

Invocation Count column displays the number of times the function was called.

Total Self Cost column shows the total time it took to execute the built-in PHP code in the function (excluding the time
spent on executing other non-standard functions).

Total Inclusive Cost column contains the total execution time for the function, including built-in PHP code and any other
user functions called.

Clicking a column header changes ascending/descending order.

You can click the triangle icon next to a function name to expand a list of function invocations. This list allows you
to see who called this function and what the amount of time spent is, and contains the following columns.

Calls is the "parent" functions or class methods invoking this (child) function.

Total Call Cost is the total time executing this function, when called from the parent function.

Count - number of times the parent calls the child function.

The coloured bar at the top of the page displays the contribution of differnet function types:

Blue denotes PHP internal (built-in) functions,

Lavender is time taken to include (or require) PHP files,

Green shows the contribution of your own class methods,

Orange denotes time taken on traditional "procedural" functions (functions that are not part of a PHP class).

Please note that the profiler creates a new data file in your /tmp directory for each HTTP request to the website.
This may cause disk space exhaustion, which can be fixed only by rebooting the system. So, when you are finished
profiling the website, disable the profiling by going to php.ini file, commenting the xdebug.profiler_enable
parameter as follows and rebooting Apache:

;xdebug.profiler_enable = 0

Summary:

In this appendix, we learned how to use the NetBeans IDE to run the website and debug it in interactive step-by-step mode.
To be able to run a website, we first need to edit the site's properties (run configuration)

To debug the site, you need to have the XDebug PHP extension installed. When you debug your website in NetBeans, the PHP
engine pauses program execution at every line where you set a breakpoint. You see the debugging information (like
local variables and call stack) in NetBeans window in graphical form.

Along with debugging, XDebug extension also provides the ability to profile websites. With profiling, you see how much
time was spent for execution of a certain function or class method. This allows us to weed out bottlenecks in performance.

Appendix C. Introduction to Twitter BS:

Twitter BS is a popular CSS framework allowing to make your website proffessionally looking and visually appealing,
even if we do not have advanced designer skills.

Overview of Bootstrap Files:

The source code of Bootstrap framework's components is spread across many CSS files. It is known that downloading
multiple smaller files is slower than downloading just one large.

For this reason, Bootstrap CSS are "concatenated" with the special tool and distributed in form of a single
file named bootstrap.css

However, this bootstrap.css file has a disadvantage: it contains many characters (white space chars, new lines,
comments, etc.) unneeded for code execution, wasting network bandwidth when downloading the file, thus increasing
page load time.

To fix this problem, the minification is used.

The minification process is the process of removing all unecessary characters from the source code without changing
its functionality. The minified Bootstrap file is called bootstrap.min.css

It is generally recommended to use the minified file, especially in production environment, because it reduces
the page load time. However, if you plan to dig into Bootstrap code to understand how it works, you better use the
usual (non-minified) file, or even download the original source files (non concatenated ones).

Let's look in more details at the files stored inside the APP_DIR/public directory.

V public
	V css
		bootstrap-theme.css
		bootstrap-theme.css.map
		bootstrap-theme.min.css
		bootstrap-theme.min.css.map
		bootstrap.css
		bootstrap.css.map
		bootstrap.min.css
		bootstrap.min.css.map
		style.css
	V fonts
		glyphicons-halflings-regular.eot
		glyphicons-halflings-regular.svg
		glyphicons-halflings-regular.ttf
		glyphicons-halflings-regular.woff
		glyphicons-halflings-regular.woff2
	> img
	V js
		bootstrap.js
		bootstrap.min.js
		jquery-2.2.4.min.js

The css directory contains the CSS stylesheets:

The bootstrap.css and bootstrap.min.css files are the usual and minified version of Bootstrap, respectively.

The bootstrap-theme.css is the optional Bootstrap theme file for a "visually enhanced experience". The bootstrap-theme.min.css
is its minified version.

The style.css file is the stylesheet that can be used and extended by you to define your own CSS rules which will be applied
on top of Bootstrap rules. This way we can customize the looks of our web app.

You may also notice various files with .map extension, which is the MAP files taht can be used for debugging the CSS code.

After the concatenation and minification, the CSS code is difficult to read and debug. A MAP file (source map) allows to restore
the minified file back to its usual state.

The fonts directory contains several files (e.g glyphicons-halflings-regular.svg) needed by Bootstrap for rendering icons.
These icons (also called Glyphicons) can be used to enhance the appearance of the buttons and dropdown menus.

The APP_DIR/public/js subdirectory contains JavaScript extensions of the Bootstrap framework. They are implemented as jQuery plugins:

The bootstrap.js is the file containing the JS code of the Bootstrap extensions. The bootstrap.min.js file is its minified version.

Because Bootstrap extensions are implemented as jQuery plugins, they require the latest version of jQuery library to be present.
Thus, the js directory includes the jQuery library file jquery-2.2.4.min.js

Grid System:

In most websites, content is required to be organized in a table-like structure having rows and columns. In the following figure,
we will show this. It has a header block with a logo, a sidebar at the left, page content area in the middle, an ads bar at the right,
and a footer at the bottom of the page. These blocks are arranged in a grid, although grid cells have unequal width (Some cells can
span several columns).

<logo> 		< 										>

<Sidebar> 	< 					Page Content  ><  ads >


<							Page Footer 			 >

BS provides a simple layout grid system to make it easy to arrange content on your pages in rows and columns.

Each row consits of up to 12 columns. Column width is flexible and depends on the width of the grid container 
element. Column height may vary depending on the height of the content of the cell. The space between columns is 
30 pixels (15 padding at both sides).

You are not required to put 12 columns in a row, there may be fewer. If you have fewer, the space to the right of
the last column will be empty.

<1><1><1><1><1><1><1><1><1><1><1><1>
< 2  ><    4     ><     4    ><  2 >

Colums can be spanned, so a single cell takes the space of several columns. For example, as per above, the upper grid consists
of 12 columns, and each cell spans a single column. In the bottom row, the first cell spans 2 columns, the second and third 4 each,
and the last 2.

Why does BS grid consist of 12 columns?

Probably because 12 is enough for most websites. If you have more fine-grained grid with lots of columns, it will be more
difficult to compute column spans without the calculator. Fortunately, BS allows for customizing the amount of columns
per row, so you can have as many as you want.

Defining the Grid:

To arrange elements in a grid on your web page, you start from defining the container by adding a <div> element having
the .container CSS class. To add a new row to the grid, use a <div> element having the .row CSS class:

<div class="container">
	<div class="row">
		...
	</div>
</div>

To add columns, you use <div> elements with CSS class names varying from .col-md-1 to .col-md-12. The number in the class
name specifies how many columns each grid will span:

<div class="container">
	<div class="row">
		<div class="col-md-1">Cell 1</div>
		<div class="col-md-5">Cell 2</div>
		<div class="col-md-6">Cell 3</div>
	</div>
</div>

In the example above, we have three cells. The first cell has a width of 1 (it uses the .col-md-1 class), the second spans 5,
the last 6 etc.

As another example, we make one with a header, a main conntent area and sidebars/ads bars:

<div class="container">
	<!-- Header -->
	<div class="row">
		<div class="col-md-3">Logo</div>
		<div class="col-md-9"></div>
	</div>
	<!-- Body -->
	<div class="row">
		<div class="col-md-3">Sidebar</div>
		<div class="col-md-7">Page Content</div>
		<div class="col-md-2">Ads</div>
	</div>
	<!-- Footer -->
	<div class="row">
		<div class="col-md-12">Page Footer</div>
	</div>
</div>

Offsetting Columns:

In real web pages, sometimes the grid needs to contain "empty spaces". You can define such spaces by offsetting cells to the right
with the help of CSS classes named from .col-md-offset-1 to .col-md-offset-12. The number is the class name specifies how many
columns should be skipped.

For example:

< 2 wide grid> <2 wide space>< 4 wide grid ><2 wide space>< 2 wide grid>

The grid above has three cells, the latter two cells are offsetted to the right, making empty holes. To define the grid 
as per above, we can use the following HTML code:

<div class="container">
	<div class="row">
		<div class="col-md-2">Cell 1</div>
		<div class="col-md-4 col-md-offset-2">Cell 2</div>
		<div class="col-md-2 col-md-offset-2">Cell 3</div>
	</div>
</div>

Nesting Grids:

We can create complex page layouts by nesting grids. To nest your content, you add a new <div>
element containing .row class, and set of .col-md-* columns within an existing .col-md-* column.

^ 				 <   4 wide grid  > <  4 wide grid  > 		^
< 2 grid width > < 	 4 wide grid  > <  4 wide grid  > < 2 grid width >


To produce the above pattern, we do as follows:

<div class="container">
	<div class="row">
		<div class="col-md-2">Cell 1</div>
		<div class="col-md-8">
			<!-- nested grid -->
			<div class="row">
				<div class="col-md-4">Cell 21</div>
				<div class="col-md-4">Cell 22</div>
			</div>
			<div class="row">
				<div class="col-md-4">Cell 23</div>
				<div class="col-md-4">Cell 24</div>
			</div>
		</div>
		<div class="col-md-2">cell 3</div>
	</div>
</div>

In the example above, we defined the grid consist of three cells, the first and last spanning
2 width, the middle 8. Then we put the nested grid rows inside of the middle one, the width
being inherited, and since the parent is 8 width, the child is 8-width

"Mobile First" Concept:

Twitter Bootstrap is designed to support different devices varying from wide displays to tablets and phones.
By this reason, the layout grid is different screen resolutions.

This is also called the responsiveness, or the "mobile first" concept. Bootstrap is mobile-first, which means
your website will be viewable and usable on any-sized screen. However, this does not free you of painstaking
preperation and planning the layout.

This adaptation is performed in two ways. The first way is that the column width within the grid is flexible.
For example, if you increase the size of the browser window, the grid will be scaled accordingly to fill
the whole space.

But what will happen if your web page is too wide for the display? To see the hidden part, the site visitor
will need to scroll to the right. For mobile phones and other low-res devices, this is not a good approach.

Instead, it would be better for teh grid to become "stacked" below some screen width. When the grid is stacked,
its rows are transformed, making cells to be positioned one below another.

To better control when the grid becomes "stacked", Bs provides you with additional CSS classes:

.col-xs-1 to .col-xs-12 (xs means extra small devices or phones), .col-sm-1 to .col-sm-12 (small devices or tablets)
and .col-lg-1 to .col-lg-12 (large devices).

These classes can be used together with the .col-md-1 -- .col-md-12 classes taht we already used.
(md is medium)

The breakpoint rules are as follows, if it's under the breakpoint, they become stacked under the breakpoints,
and horizontal past them.

The class layouts as follows:

CSS classes for defining layout grids:
 					Breakpoints
.col-xs-* 			<768px

.col-sm-* 			>=768px

.col-md-* 			>=992px

.col-lg-* 			>=1200px

BS's grid system greatly simplifies the positining of elements on a web page. However, using the 
grid system is not mandatory. For example, sometimes you may need a much more complex layout,
to which we can then use <table> or <div> elements instead.

Bootstrap's Interface Components:

In this section, we will give a summary on useful interface components provided by Twitter BS. We plan to use
some of these components in our further examples, and this section should give an idea of how you can use 
these widgets in your own website.

Navigation bar:

Navigation bar is usually positioned on the top of the website and contains links to main pages, like, Home, Download, etc.

An example code of a predictable navbar:

<nav class="navbar navbar-default" role="navigation">
	<div class="navbar-header">
		<a class="navbar-brand" href="#">Hello World</a>
	</div>
	<ul class="nav navbar-nav">
		<li><a href="#">Home</a></li>
		<li><a href="#">Download</a></li>
		<li><a href="#">Support</a></li>
		<li><a href="#">About</a></li>
	</ul>
</nav>

in line 1 above, we used the <nav> element, which contains all the navigation bar information. The assocaited
CSS class .navbar is defined by BS and provides the base nav bar's appearance. The .navbar-default CSS class specifies
the "default" theme for the nav bar.

The optional role attribute is an HTML attribute allowing to annotate the page elements with machine-extractable
semantic information about the purpose of an element. In this example, the attribute tells that the <nav> element
is used for navigation.

In lines, 2-4, we define the navbar header area, which contains the Hello World hyerplink. The brand hyperlink
typically points to the main page of our site. The hyperlink has the .navbar-brand class that visually enhances the text.

In lines 5-10, we specify the navigation links for the Home, Download, Support and About pages. These links are organized
inside an <ul> unordered list element. The element has CSS classes .nav and .navbar-nav that place list items in line
and provides the hover item state.

Dropdown Menu:

With Bootstrap navigation bar, it is possible to use the dropdown menu as a navigation item. For example, if the Support
section of your site can be subdivided into Documentation and Help pages, these can be implemented as dropdown menus.

We can define a dropdown, for example, by replacing the Support tab since before:

<li class="dropdown">
	<a href="#" class="dropdown-toggle" data-toggle="dropdown">
		Support <b class="caret"></b>
	</a>
	<ul class="dropdown-menu">
		<li><a href="#">Documentation</a></li>
		<li><a href="#">Help</a></li>
	</ul>
</li>

In the code above, we use the <li> element with CSS class .dropdown that indicates the dropdown menu (line 1). In lines 2-4,
the <a> element defines the hyperlink to show when the menu is hidden (the Support text is shown followed by the triangle caret).

When the site user clicks the hyperlink, the dropdown menu (lines 5-8) appears. The <ul> unordered list element with class
.dropdown-menu defines its visual appearance. The dropdown menu contains two items: the Documentation and Help hyperlinks.

Collapsible Navbar:

As with the grid system, the navbar component supports different types of screen resolutions. On low-resolution devices,
the navbar can be collapsed.

As you can see, in the collapsed mode, only the navbar header is displayed, and the three horizontal bars at the right
denote the Toggle button. Clicking the button would expand the hidden anvbar items.

You define the collapsible navbar as follows:

<nav class="navbar navbar-default" role="navigation">
	<!-- Brand and toggle get grouped for better mobile display -->
	<div class="navbar-header">
		<button type="button" class="navbar-toggle" data-toggle="collapse"
				data-target=".navbar-ex1-collapse">
			<span class="sr-only">Toggle navigation</span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		</button>
		<a class="navbar-brand" href="#">Hello World</a>
	</div>

	<!-- Collect the nav links, forms, and other content for toggling -->
	<div class="collapse navbar-collapse navbar-ex1-collapse">
		<ul class="nav navbar-nav">
			<li><a href="#">Home</a></li>
			<li><a href="#">Download</a></li>
			<li class="dropdown">
				<a href="#" class="dropdown-toggle" data-toggle="dropdownt">
					Support <b class="caret"></b>
				</a>
				<ul class="dropdown-menu">
					<li><a href="#">Documentation</a></li>
					<li><a href="#">Help</a></li>
				</ul>
			</li>
			<li><a href="#">About</a></li>
		</ul>
	</div><!-- /.navbar-collapse -->
</nav>

Above in lines 3-12, we define the navbar header which will be displayed independelty on screen resolution.
The header contains the Toggle button with three horizontal bars and description text "Toggle Navigation".

The collapsible part of the menu can be seen in lines 15-30. In this area, we put our navigation links and the dropdown menu items.

Inverse Navbar Style:

The navigation bar can be displayed using two standard "themes": the default theme (as above) and the inverse theme.
The inverse theme makes the navbar elements be displayed in dark colors. You probably saw such an inverse bar
in the Zend Skeleton App demo.

The inverse theme is defined by simply replacing the .navbar-default class of the <nav> element by the .navbar-inverse class:

<nav class="navbar navbar-inverse" role="navigation">
	...
</nav>

Breadcrumbs:

Breadcrumbs is a useful interface component which can be used together with the navbar to give the site visitor an idea
of his current location.

They are link items pointing to locations and highlighting the current one.

To define the breadcrumbs, you can use the ordered list <ol> element with the .breadcrumb CSS class:

<ol class="breadcrumb">
	<li><a href="#">Home</a></li>
	<li><a href="#">Support</a></li>
	<li class="active">Documentation</li>
</ol>

Paginations:

The pagination component is useful when you have a long list of items to display. Such a long list, if displayed on a 
single page, would requrie the user to scroll the page down several times to see the bottom of the list.

To improve user experience, you would break the output into pages, and use the pagination component for navigation between
the pages:

<< Newest || < Newer || 1 || 2 || 3 || 4 || 5 || Older > || Oldest >>

To define the pagination like in the figure above, use the following HTML code:

<ul class="pagination">
	<li><a href="#">&laquo; Newest</a></li>
	<li><a href="#">&lt; Newer</a></li>
	<li><a href="#">1</a></li>
	etc.
	<li><a href="#">Older &gt;</a></li>
	<li><a href="#">Oldest &raquo</a></li>
</ul>

NOTE: The order is reversed here, lol.

Buttons & Glyphicons:

We can stylize buttons as well:

<p>
	<button type="button" class="btn btn-primary">Save</button>
	<button type="button" class="btn btn-default">Cancel</button>
</p>

In the code above, we use the .btn CSS class to assign the button its visual style.
Addtionally, we use the .btn-primary class for the Save button or the btn-default one
for a non-primary button Cancel.

We of course, have other gradients as well:

<p>
	<button type="button" class="btn btn-default">Default</button>
	<button type="button" class="btn btn-primary">Primary</button>
	<button type="button" class="btn btn-success">Success</button>
	<button type="button" class="btn btn-info">Info</button>
	<button type="button" class="btn btn-warning">Warning</button>
	<button type="button" class="btn btn-danger">Danger</button>
</p>

BS includes 180 icons (called Glyphicons) that you can use together with your buttons, dropdown menus, navigation links.
To add an icon on a button, you can use the code as follows:

<p>
	<button type="button" class="btn btn-default">
		<span class="glyphicon glyphicon-plus"></span> Create
	</button>
	<button type="button" class="btn btn-default">
		<span class="glyphicon glyphicon-pencil"></span> Edit
	</button>
	<button type="button" class="btn btn-default">
		<span class="glyphicon glyphicon-remove"></span> Delete
	</button>
</p>

In the code above, we defined a simple toolbar containing three buttons: Create, Edit and Delete. We placed an icon on
each button with the help of <span> element. The <span> element should have two classes: the .glyphicon class is common
for all icons, the second class represents the icon name. In the example above, we used .glyphicon-plus class for the Create
button, the glyphicon-pencil for Edit button and glyphicon-remove for Delete.

We can vary the button size by specifying the .btn-lg class for large buttons, btn-sm for small buttons, or btn-xs class
for extra-small buttons. 

For example, to define a large download button:

To define such a button, use the following HTML code:

<button type="button" class="btn btn-success btn-lg">
	<span class="glyphicon glyphicon-download"></span> Download
</button>

Customizing Bootstrap:

To finish the introduction to BS, we will describe about how to modify some aspects of BS framework.
You can customize the BS look and feel using the Customize page of the BS website.

On the customize page, you can choose which BS source files to include into the "concatenated" resulting file
bootstrap.css. If you don't need some functionality, you can exclude it from the file, thus reducing network
traffic and page load time.

You can also remove some unused JS code components from the resulting bootstrap.js file

Additionally, you can choose different CSS parameters like background color, base text color and font family,
and so on. There are more than a hundred customizable parameters available.

CSS customization is possible, because BS source files are stored in LESS format, which allows to define variable
parameters (like @bodyBackground or @textcolor). Once the params are defined, the LESS Files are compiled into
usual CSS files, minified and made available for downloading.

When you have finished with tuning parameters, you can scroll the Customize page down and press the Compile and Download
button. As a result, the bootstrap.zip archive will be downloaded, which contains all the customized Bootstrap files
(both usual and minified CSS and JS files and glyphicons fonts).

LESS is a dynamic stylesheet language extending standard CSS with features like variables, mixins (embedding all teh properties
of a CSS class into another CSS class), code block nesting, arithmetic operations and functions.


GOING BACK TO 12.2 SINCE WE COVERED ALL APPENDIXES:

12.2 Creating a Simple MySQL Database:

Once you install MySQL, type the following command from cmd shell to log into the MySQL client console:

mysql -u root -p

When asked for, type the pw of the root user.

Now, assuming its the right pW, we can do the MySQL commands.

Creating New Database:

Let's create a database and name it blog. To do that, type the following SQL statements and press enter:

CREATE DATABASE blog;

The expected output of this command is the following is as per usual.

MySQL commands are case-insensitive, so you could type create database blog; with the same result.
We recommend using upper case for SQL queries, since this is a common convention.

Next, we create the user named blog and grant it all privileges for accessing and modifying the 
blog DB and all its tables:

GRANT ALL PRIVILEGES ON blog.* TO blog@localhost IDENTIFIED BY '<passwd>';

In the command above, replace the PW PH with the new PW for the blog user. It should be different than for the root user.

Here, we create a second user blog, because it is not recommended to give the web application ability to log into
database under the root user. The root user has unlimited rights and it is poor security practice to give an application
the ability to do any actions it wants. The blog user will have permissions to modify the blog DB only, which is sufficient
in our case.

You can check that the DB has been created by just running the normal commands:

show databases;

This should allow us to see it.

Creating Tables:

Next, we will create three tables typical for any simple blog: the post table will contain posts, the comment table will
contain comments to posts and finally, the tag table will contain tags (a tag is some kind of a key word describing a blog post well).

Additionally, we will create the fourth auxiliary table post_tag that will be used to create many-to-many relations between the post
and the tag tables.

Make the blog database current by typing the following from the MySQL prompt:

use blog;

To create the post table, type the following SQL statement:

CREATE TABLE `post` (
	`id` int(11) PRIMARY KEY AUTO_INCREMENT,
	`title` text NOT NULL,
	`content` text NOT NULL,
	`status` int(11) NOT NULL,
	`date_created` datetime NOT NULL
);

MySQL client allows easy entering of multi-line commands. Just press Enter when you want to move the caret
to the next line. The command is considered to be fully entered when the semicolon(;) char is encountered.

Next, create the comment table by typing the following:

CREATE TABLE `comment` (
	`id` int(11) PRIMARY KEY AUTO_INCREMENT,
	`post_id` int(11) NOT NULL,
	`content` text NOT NULL,
	`author` varchar(128) NOT NULL,
	`date_created` datetime NOT NULL
);

Then, create the tag table:

CREATE TABLE `tag` (
	`id` int(11) PRIMARY KEY AUTO_INCREMENT,
	`name` VARCHAR(128)
);

And finally, create the post_tag table:

CREATE TABLE `post_tag` (
	`id` int(11) PRIMARY KEY AUTO_INCREMENT,
	`post_id` int(11) NOT NULL,
	`tag_id` int(11) NOT NULL
);

Let's fill the tables we have created with some sample data:

INSERT INTO tag(`name`) VALUES('ZF3');
INSERT INTO tag(`name`) VALUES('book');
INSERT INTO tag(`name`) VALUES('magento');
INSERT INTO tag(`name`) VALUES('bootstrap');

INSERT INTO post(`title`, `content`, `status`, `date_created`) VALUES (
	'A Free Book about Zend Framework',
	'I''m pleased to announce that now you can bla bla bla', 2, '2016-08-09 10:10');

INSERT INTO post(`title`, `content`, `status`, `date_created`) VALUES (
	'Title goes here',
	'bla', 2, '2016-10-10 10:10');

INSERT INTO post(`title`, `content`, `status`, `date_created`) VALUES (
	'Title goes here',
	'bla', 2, '2016-10-10 10:10');

etc.

INSERT INTO post_tag(`post_id`, `tag_id`) VALUES(1, 1);
INSERT INTO post_tag(`post_id`, `tag_id`) VALUES(1, 2);
INSERT INTO post_tag(`post_id`, `tag_id`) VALUES(2, 2);
INSERT INTO post_tag(`post_id`, `tag_id`) VALUES(2, 3);
INSERT INTO post_tag(`post_id`, `tag_id`) VALUES(3, 4);

INSERT INTO comment(`post_id`, `content`, `author`, `date_created`) VALUES
	1, 'Shit post!', 'Shituser', '2010-10-10 10:10');

A mapping of the tables:

	post 							comment
id 							   id
title 						 ^ post_id
content 	>>>>>>>>>>>>>>>>>> content
status 						 v author
date_created 				   date_created
	V
	V
   <V>
   post_tag
id 
post_id
tag_id
   >^<
    ^
    ^
    tag
id
name

AS we can see from above, the post table is related to comment table as one-to-many, because a single post
may have many comments.

The post table is also related to the tag table as many to many. A single post may have many tags, and a single tag
may belong to many posts as well. Many-to-many relationships is typically implemented through an auxiliary table (post_tag table in our case).

Importing Ready Database Schema:

In the previous section, we've shown how to create teh complete db schema that is used in the Blog sample
web app. IRL, we typically do not write all of those things in teh SQL prompt. Instead, you could type the CREATE TABLE statements
to a file and save it to disk. Then we could import that file and have the ready schema.

For your convinience, the ready schema for Blog sample can be found in APP_DIR/data/schema.mysql.sql file. This file is 
a plain text file containing SQL statements. To import the file, go to the APP_DIR/data/directory and type the following
command from your cmd shell (not MySQL prompt):

mysql -u root -p blog < schema.mysql.sql

When prompted for password, enter the password of the root user and hit enter.

Once this is done, log into the MySQL client and type the following commands:

use blog;

show tables;

We know what to expect. (Showcasing of tables in blog)

Also consider using database migrations for initializing database schema. For additional info about migrations,
please refer to the Database Migrations chapter.

Integrating Doctrine ORM with Zend Framework 3:

For easy integration with ZF3, Doctrine project provides the following two components (that are actually ZF3 modules):

DoctrineModule is a ZF3 module that provides Doctrine basic functionality required by the ORM component

DoctrineORMModule integrates Doctrine Object Relation Manager (ORM) with ZF3.

Each of the above Doctrine components is distributed as a Composer-installable package and is registered in 
Packagist.org catalogue. This is very similar to the way that ZF3 uses for install its components.

Since Composer packages may depend on each other, it is enough to declare dependency only on DoctrineORMModule.
This package depends on DoctrineModule and on some other Doctrine components (Doctrine\ORM, Doctrine\DBAL, Doctrine\Common,
Doctrine\Annotations, etc.).

So, when you install this component, Composer will install other required components automatically.

Installing Doctrine Components with Composer:

In order to install required Doctrine components, we first add a dependency to the composer.json file located in
the root directory of the web application (in this book, we typically denote that directory as APP_DIR).

To add the dependency, type the following commands from your command shell (replace the APP_DIR PH with the actual dir name of your app):

cd APP_DIR

php composer.phar require doctrine/doctrine-orm-module

The cd command above is used to make the APP_DIR directory to the cwd.

And the require command tells Composer to add the package doctrine/doctrine-orm-module as a dependency to your web app,
and to download and install that dependency.

Once you run the commands above, Composer will first modify the composer.json file and create the line like below under its require key:

{
	...
	"require": {
		"doctrine/doctrine-orm-module": "^1.0.9",
		...
	},
	...
}

Then Composer will try to locate the dependency packages, download them to the local machine and install the files into the
APP_DIR/vendor directory.

Composer will output lines indicating installation process to the terminal. As you can see from the Composer output, when you
install DoctrineORMModule component, Composer automatically installs the DoctrineModule and all necessary Doctrine components
(Doctrine\DBAL, Doctrine\ORM, etc.)

As a "bonus" at the end of installation, Composer suggests that you install some additional packages that might be 
useful for you (doctrine/migrations, doctrine/data-fixtures, etc.) if you strongly wish, you can add these with the
Composer's require command as well.

When the installation has finished, you can find the Doctrine files in your APP_DIR/vendor directory:

V vendor
	> bin
	> composer
	> container-interop
	v doctrine
		> annotations
		> cache
		> collections
		> common
		> dbal
		> doctrine-module
		> doctrine-orm-module
		> inflector
		> instansiator 
		> lexer
		> orm
	> symfony
	> zendframework
	> zfcampus

You use the php composer.phar require command for the first time you install Doctrine. Once the composer.json
and composer.lock files have been modified by Composer, you are able to install (or update) all dependencies
as usual by typing the php composer.phar install or php composer.phar update commands, from the cmd shell.

Loading Doctrine Integration Modules on Application Start Up:

Once you have installed the DoctrineORMModule and all its dependencies, you need to add the following lines to your
APP_DIR/config/modules.config.php to enable the modules:

The lines above let ZF3 know that it should load the DoctrineModule module and DoctrineORMModule module on application start up.

Doctrine Configuration Overview:

To use Doctrine with your ZF3-based web app, you have to provide its configuration. The configuration tells Doctrine what
databases present, how to connect to a DB (what db driver, host, user name and pw), where to locate entity classes
and how to extract their annotations (metadata),how to store cached data (in the file system or to use a caching
extension), and so on.

This section's goal is to give you a general idea of how Doctrine configuration looks like.

The default Doctrine configuration is located in the module.config.php config file of the DoctrineORMModule. Look at the figure
below to have an idea of how the Doctrine config "tree" may look like. You may also refer to the module.config.php file of
DoctrineORMModule for the same reason.

Some of the keys from this tree has been omitted for simplicity:

doctrine

	V>>>>>>>>>Connection >>>>>>>>>>> orm_default <<< //The default database connections configuration
	V
	V
	V>>>>>>>>>configuration >>>>>>>>> orm_default <<<< //Configuration details for the ORM
	V
	V
	V>>>>>>>>> driver >>>>>>> orm_default <<<<<< //Metadata mapping driver configuration
	V
	V
	V>>>>>>>> entitymanager >>>>>>>> orm_default <<<<< //Entity manager instansiation settings
	V
	V
	V>>>>>>>> eventmanager >>>>>>>>>> orm_default <<<<<< //Event manager configuration
	V
	V
	V>>>>>> migrations_configuration >>>>>>> orm_default <<<<<<< //Database migrations configuration

As you can see from above, there is the top-level key named doctrine. Under that key, there is a number of
subkeys containing the following settings:

the connection key contains the list of all databases that the web application is able to connect to. For each database
connection it contains parameters like driver class name, host, user name, password and database name.

By default, there is only one connection named orm_default, and you may add more database connections if required.

the configuration key contains ORM settings like caching configuration and locations of auto-generated entity proxy
classes for each available connection.

the driver key contains the information about where to locate the entity classes for each available database connection

the entitymanager key contains settings used for instansiating an entity manager for each database connection

the eventmanager  key contains settings for Doctrine event manager for each available connection

Doctrine uses its own implementation of event manager. If you want, you can create an event listener class
and hook some events. However, this is an advanced topic and is not covered here.

the migrations_configuration key contains settings for database migrations. Database migrations are used for
initializing and updating database schema in a standard and consistent way.

Overriding the Default Doctrine Configuration:

As you already know from Website Operation chapter, in a ZF3-based web app configuration is typically
divided into two categories: application-wide configuration and module-specific configuration.

For storing application-wide Doctrine settings, you typically use the APP_DIR/config/autoload/global.php
or APP_DIR/config/autoload/local.php config files. The first one suits well for storing settings not depending
on particular environment, while the latter suits well for storing environment-dependant settings (like DB connection params).

For storing Doctrine settings specific to certain module, you use the module.config.php config file located inside the
config directory of that module. This is suitable, for example, for storing the entity location settings.

When ZF3 based websites load its configuration, it merges all configs into a single big array, thus forming the final
Doctrine config "tree".

By adding your application-specific Doctrine configuration, you extend and/or override the default configuration 
tree provided by the DoctrineORMModule.

Specifying Database Connection Parameters:

Below we provide content of the autoload/local.php file of the Blog web application. This config file contains the
application-wide database connection settings for the blog MySQL database that we created earlier in this chapter.

This connection is shared between all modules of the web application. If you want to create module-specific connection,
consider adding the key to the module.config.php file instead:

<?php
use Doctrine\DBAL\Driver\PDOMySql\Driver as PDOMySqlDriver;

return [
	'doctrine' => [
		'connection' => [
			'orm_default' => [
				'driverClass' => PDOMySqlDriver::class,
				'params' => [
					'host' 	=> '127.0.0.1',
					'user' => 'blog',
					'password' => '<password>',
					'dbname' => 'blog',
				]
			],
		],
	],
];

Above, we have the doctrine key and connection subkey. The connection subkey contains the orm_default subkey which is
the default connection.

The driverClass key provides the class name to use as a driver to the database. Since we use MySQL db, we specify
the Doctrine\DBAL\Driver\PDOMySql\Driver class name.

For our reference, In the upcoming talbe, we will see several other often used DB drivers. Each driver class supports its
own set of parameters, so please refer to certain driver's code (and related documentation) for additional information.

The params key contains the connection parameters:

host may be either the domain name or IP address of the database server,

user is the MySQL user name with granted permissions to the database,,

password is the PW for said user,

dbname is the name of the DB.

Often Used Database Driver Classes:

Doctrine\DBAL\Driver\PDOSqlite\Driver 			SQLite driver using PDO PHP extension

Doctrine\DBAL\Driver\PDOMySql\Driver 			MySQL driver using PDO PHP extension

Doctrine\DBAL\Driver\PDOOracle\Driver 			Oracle driver using PDO PHP extension

Doctrine\DBAL\Driver\PDOPgSql\Driver 			PostgreSQL driver using PDO PHP extension

Doctrine\DBAL\Driver\PDOSqlsrv\Driver 			MS SQL Server driver using PDO PHP extension

Because the autoload/local.php file contains enviroment specific parameters, you only store its "distribution template",
local.php.dist file, in version control. Each dev in your team then renames the local.php.dist to local.php
and enters his PW into it.

The local.php should not be version controlled, because we do not share PWs.

What happens if i need several database connections:

You can easily add more database connections by adding other keys below the orm_default key. For example,
let's assume that you have another database for testing purposes. To let Doctrine know about this database, 
you create the orm_test subkey below the orm_default key and fill it iwth ocnnection params.

About Doctrine Entities:

An entity is a PHP class that is designed for storing data. For example, below you can find several oftenly used
examples of entities:

User entity is designed to store information about a website visitor. It may contain properties like username, password,
first name, last name etc.

License entity is designed to store information about a software license. It may contain data like unique license key,
reference to user who purchased the license, license creation date, etc.

Payment entity may contain properties related to a purchase of some goods. The properties are: transaction ID, money amount,
money currency, etc.

In terms of DDD (Domain Driven Design) pattern, entities are a kind of model designed for storing data. For additonal
examples of entities and other types of models, please refer to Model-View-Controller.

In Doctrine ORM, an entity class is mapped on a certain database table. For example, the User entity is usually mapped
on the user table (if needed, the table name may be arbitrary).

For our Blog example application, we will create three entity classes:

Post entity will contain data related to specific blog post. Its properties are exactly the same that we used when
defining the post table in blog db schema. The entity class will also have public getter and setter methods designed
for retrieving/setting the data.

by analogy, Comment entity will contain data related to a comment to a blog post.

And the Tag entity will contain data related to a tag.

Annotations:

An annotation is a special kind of a PHP comment that is preprocessed by Doctrine ORM. In other words, annotations
is metadata attached to an entity class that can be read by the Doctrine ORM at run-time.

Annotations provide verbose information about an entity. Annotations describe an entity and tell Doctrine ORM how to
map it on a database table.

A Docblock annotation is a C++ comment starting with / and two **. These starting chars are required,
otherwise Doctrine won't recognize the annotation. An example of an annotation:

/**
  * This is a Docblock annotation comment
  */

Doctrine reads Docblock annotations with the help of its Doctrine\Annotations component.

You might have already seen Docblock annotations if you've used phpDocumentor or Doxygen documentation
generation tools. In those tools, annotation comments are serving teh same goal: to describe a PHP class
and its properties and methods. Then the tool goes through your code and builds HTML documentation 
automatically based entirely on code and annotation analysis.

For example, below, we provide the basic example of a Doctrine entity class. You can see that the class
and its properties are marked with Docblock annotations with special tags (a tag starts with '@' char):

<?php
namespace Application\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
  * @ORM\Entity
  * @ORM\Table(name="post")
  */
class Post
{
	/**
	  * @ORM\Id
	  * @ORM\GeneratedValue
	  * @ORM\Column(name="id")
	  */
	protected $id;

	/**
	  * @ORM\Column(name="title")
	  */
	protected $title;

	/**
	  * @ORM\Column(name="content")
	  */
	protected $content;

	/**
	  * @ORM\Column(name="status")
	  */
	protected $status;

	/**
	  * @ORM\Column(name="date_created")
	  */
	protected $dateCreated;
}

Let's review the code above:

In line 2, we declared the Application\Entity namespace in which entity classes for the Application module live.

In line 4, you may notice that we use the Doctrine\ORM\Mapping class and its short ORM alias for Doctrine annotations

Doctrine-provided annotation tags are implemented as classes living inside of Doctrine/ORM/Mapping namespace.
This is to avoid annotation naming colissions  (assume the case when some other component has an annotation
named Entity or Table, the collision would happen).

In lines 6-9, you can see a Dockblock annotation for the Post class. Each annotation tag begins with the  @ character,
has the name and (optional) parameters enclosed in ()'s.

Doctrine-provided tags used in annotations may be of two types: class-level and property-level. In the code above,
we use the following class-level tags (describing the whole entity class):

@ORM\Entity tag ( line 7) declares that this class is a Doctrine ORM entity

@ORM\Table(name="post") tag (line 8) tells Doctrine ORM that this entity class is mapped on the post database table.

Entity's properties are described with the following property-level tags:

@ORM\Id tells that this property is actually a unique identifier of the entity (see line 13)

@ORM\GeneratedValue is used to tell Doctrine ORM that this property uses some auto-generated sequence for initializing
itself (line 14). In MySQL, this typically means that the corresponding table column uses AUTO_INCREMENT initializer.

@ORM\Column(name="<column_name>") is used to tell the Doctrine ORM on which table column to map this particular property
(lines 15, 20, 25, 30, 35).

What follows, is the complete listing of all the annotations within the Doctrine ORM:

@Column: Marks an annotated instance variable as "persistent". It has to be inside the instance variable PHP
DocBlock comment. Any value hold inside this variable will be saved to and loaded from the DB as part of the
lifecycle of the instance variable entity-class.

Required Attributes: 

type: Name of the Doctrine Type which is converted between PHP and Database representation.

Optional attributes:

name: By default the property name is used for the database column name also, however the "name"
attribute allows you to determine the column name.

length: Used by the "string" type to determine its maximum length in the database. Doctrine does
not validate the length of string values for you.

precision: The precision for a decimal (exact numeric) column (applies only for decimal column),
which is the maximum number of digits that are stored for teh values.

scale: The scale for a decimal (exact numeric) column (applies only for decimal column), which represents
the number of digits to the right of the decimal point and must not be greater than precision.

unique: Boolean value to determine wether the value of the column should be unique across all rows of the
underlying entities table.

nullable: Determines if NULL values allowed for this column.

options: Array of additional options:
	
	default: The default value to set for the column if no value is supplied

	unsigned: Boolean value to determine if the column should be capable of representing only
	non-negative integers (applies only for integer column and might not be supported by all vendors)

	fixed: Boolean value to determine if the specified length of a string column should be fixed 
	or varying (applies only for string/binary column and might not be supported by all vendors)

	comment: The comment of the column in the schema (might not be supported by all vendors)

	collation: The collation of the column (only supported by Drizzle, Mysql, PostgreSQL>=9.1, Sqlite
	and SQLServer)

	check: Adds a check constraint type to the column (might not be supported by all vendors)

columnDefinition: DDL SQL snippet that starts after the column name and specifies the complete
(non-portable) column definition. This attribute allows to make use of advanced RMDBS features.
However, you should make careful use of this feature and the consequences. SchemaTool will not
detect changes on the column correctly anymore if you use "columnDefinition".

Additionally, you should remember that the "type" attribute still handles the conversation
between PHP and Database values. If you use this attribute on a column that is used for joins
between tables you should also take a look at @JoinColumn

Some examples of using Column identification:

<?php
/**
 * @Column(type="string", length=32, unique=true, nullable=false)
 */
protected $username;

/**
 * @Column(type="string", columnDefinition="CHAR(2) NOT NULL")
 */
protected $country;

/**
 * @Column(type="decimal", precision=2, scale=1)
 */
protected $height;

/**
 * @Column(type="string", length=2, options={"fixed":true, "comment":"Initial letters of first and last name"})
 */
protected $initials;

/**
 * @Column(type="integer", name="login_count", nullable=false, options={"unsigned":true, "default":0})
 */
protected $loginCount;

@ColumnResult: References name of a column in the SELECT clause of a SQL query. Scalar result types can be
included in the query result by specifying this annotation in the metadata.

Required attributes:

name: The name of a column in the SELECT clause of a SQL query

@Cache: Add caching stratergy to a root entity or a collection.

Optional attributes:

usage: One of READ_ONLY, READ_WRITE or NONSTRICT_READ_WRITE, By default this is READ_ONLY.

region: An specific region name

ChangeTrackingPolicy: The Change Tracking Policy annotation allows to specify how the Doctrine 2 UnitOfWork
should detect changes in properties of entities during flush. 

By default each entity is checked according to a deferred implicit stratergy, which means upon flush
UnitOfWork compares all the properties of an Entity to a previously stored snapshot.

This works out of the box, however you might want to tweak the flush performance where using another
change tracking policy is an interesting option.

The Change Tracking Policies are as follows:

Change tracking is the process of determining what has changed in managed entities since the last time
they were synchronized with the DB.

Doctrine provides 3 different change tracking policies, each having its particular advantages and 
disadvantages. The change tracking policy can be defined on a per-class basis (or more precisely,
per-hierarchy).

Deferred Implicit:

The deferred implicit policy is the default change tracking policy and the most convenient one.
With this Policy, Doctrine detects the changes by a property-by-property comparsion at commit time
and also detects changes to entities or new entities that are referenced by other managed entities
("persistence by reachability").

Althought most convinient, it can affect performance negatively, if we are dealing with a large
amount of units of work. Since Doctrine can't know what has changed, it needs to check all managed
entities for changes every time you invoke the EntityManager#flush(), making this operation
rather costly.

Deferred Explicit:

The deferred explicit policy is similar to the deferred implicit policy in that it detects changes
through a property-by-property comparison at commit time. The difference is that Doctrine 2 only
considers entities that have been explicitly marked for change detection through a call to
EntityManager#persist(entity) or through save cascade.

All other entities, are skipped. This policy therefore, gives improved performance for larger units
of work while sacrificing the behavior of "automatic dirty checking".

Therefore, flush() operations are potentionally cheaper with this policy. The negative aspect
this has is that if you have a rather large application and you pass your objects through
several layers for processing purposes and business tasks you may need to track yourself
which entities have changed on the way so you can pass them to EntityManager#persist().

It can be configured as follows:

<?php
/**
 * @Entity
 * @ChangeTrackingPolicy("DEFERRED_EXPLICIT")
 */
class User
{
	//...
}

Notify:

This policy is based on the assumption that the entities notify interested listeners of
changes to their properties. For that purpose, a class that wants to use this policy needs
to implement the NotifyPropertyChanged interface from the Doctrine namespace.

As a guideline, an example:

<?php
use Doctrine\Common\NotifyPropertyChanged,
	Doctrine\Common\PropertyChangedListener;

/**
 * @Entity
 * @ChangeTrackingPolicy("NOTIFY")
 */
class MyEntity implements NotifyPropertyChanged
{
	//...

	private $_listeners = array();

	public function addPropertyChangedListener(PropertyChangedListener $listener)
	{
		$this->_listeners[] = $listener;
	}
}

Then, in each property setter of this class or derived classes, you need to notify all the 
PropertyChangedListener instances. As an example, we add a convenience method on MyEntity that
shows this behaviour:

<?php
//...

class MyEntity implements NotifyPropertyChanged
{
	//...

	protected function _onPropertyChanged($propName, $oldValue, $newValue)
	{
		if ($this->_listeners) {
			foreach ($this->_listeners as $listener) {
				$listener->propertyChanged($this, $propName, $oldValue, $newValue);
			}
		}
	}

	public function setData($data)
	{
		if ($data != $this->data) {
			$this->_onPropertyChanged('data', $this->data, $data);
			$this->data = $data;
		}
	}
}

You have to invoke the _onPropertyChanged inside every method that changes the persistence state of MyEntity.

The check whether the new value is different from the old one is not mandatory but recommended. That way
you also have full control over when you consider a property changed.

The negative point of this policy is obvious: You need to implement the interface and do some of the code yourself.
But also note, taht we treid to keep hard ot keep this notification functionality abstract. STrictly speaking,
it has nothing to do with the persistence layer and teh Doctrine ORM or DBAL. You may find that property 
notification events come in handy in many other scenarios as well.

As mentioned earlier, the Doctrine\Common namespace is not that evil and consists solely of very small classes
and interfaces that have almost no external dependencies (none to the DBAL and none to the ORM)  and that you can
easily take with you should want to swap out the persistence layer.

This change tracking policy does not introduce a dependency on the Doctrine DBAL/ORM or the persistence layer.

THe positive point and main advantage of this policy is its effectiveness. It has the best performance 
of the 3 policies with larger units of work and a flush() operation is very when nothing has changed.

Example of putting in ChangeTrackingPolicy:

<?php
/**
 * @Entity
 * @ChangeTrackingPolicy("DEFERRED_IMPLICIT")
 * @ChangeTrackingPolicy("DEFERRED_EXPLICIT")
 * @ChangeTrackingPolicy("NOTIFY")
 */
class User {}

@CustomIdGenerator:

This annotation allows you to specify a user-provided class to generate identifiers. This annotation only
works when both @Id and @GeneratedValue(stratergy="CUSTOM") are specified.

Required attributes:

class: Name of the class which should extend DoctrineORMIdAbstractIdGenerator

Example:

<?php
/**
 * @Id
 * @Column(type="integer")
 * @GeneratedValue(strategy="CUSTOM")
 * @CustomIdGenerator(class="My\Namespace\MyIdGenerator")
 */
public $id;

@DiscriminatorColumn:

This annotation is an optional annotation for the topmost/super class of an inheritance hierarchy.
It specifies the details of the column which saves the name of the class, which the entity is
actually instansiated as.

If this annotation is not specified, the discriminator column defaults to a string column of length
255 called dtype.

Required Attributes:

name: The column name of the discriminator. This name is also used during Array hydration as key to specify
the class-name.

Optional attributes:

type: By default this is string

length: By default this is 255

@DiscriminatorMap:

The discriminator map is a required annotation on the topmost/super class in an inheritance hierarchy.
Its only argument is an array which defines which class should be saved under which name in the database.

Keys are the database value and values are the classes, either as fully- or as unqualified class names
depending on whether the classes are in the namespace or not.

<?php
/**
 * @Entity
 * @InheritanceType("JOINED")
 * @DiscriminatorColumn(name="discr", type="string")
 * @DiscriminatorMap({"person" = "Person", "employee" = "Employee"})
 */
class Person
{
	//...
}

@Embeddable:

The embeddable is required on an entity targeted to be embeddable inside another.
It works together with the @Embedded annotation to establish the relationship between two entities.

<?php

/**
 * @Embeddable
 */
class Address
{
	//...

class User
{
	/**
	 * @Embedded(class = "Address")
	 */
	private $address;
}

@Embedded:

The embedded annotation is required on a member class variable targed to embed it's class argument inside
it's own class.

Required attributes:

class: The embeddable class

<?php

//...
class User
{
	/**
	 * @Embedded(class = "Address")
	 */
	private $address;

/**
 * @Embeddable
 */
class Address
{
//...

@Entity:

Required annotation to mark a PHP class as an entity. Doctrine manages the persistence of all classes marked
as entities.

Optional Attributes:

repositoryClass: Specifies the FQCN of a subclass of the EntityRepository. Use of repositories for entities
is encouraged to keep specialized DQL and SQL oeprations separated from Model/Domain layer.

readOnly: (>= 2.1) Specifies that this entity is marked as read only and not considered for change-tracking.
Entities of this type can be persisted and removed though.

Example:

<?php
/**
 * @Entity(repositoryClass="MyProject\UserRepository")
 */
class User
{
	//...
}

@EntityResult:

References an entity in the SELECT clause of a SQL query. If this annotation is used, the SQL statement
should select all of the columns that are mapped to the entity object. This should include foreign key columns
to related entities. The results obtained when insufficient data is available are undefined.

Required Attributes:

entityClass: The class of the result.

Optional attributes:

fields: Array of @FieldResult, Maps the columns specified in the SELECT list of the query to the properties
or fields of the entity class.

discriminatorColumn: Specifies the column name of the column in the SELECT list that is used to determine
the type of the entity instance.

@FieldResult:

Is used to map the columns specified in the SELECT list of the query to the properties or fields of the
entity class.

Required attributes:

name: Name of the persistent field or property of the class.

Optional attributes:

column: Name of the column in the SELECT clause.

@GeneratedValue:

Specifies which stratergy is used for identifier generation for an instance variable which is annotated
by @Id. This annotation is optional and only has meaning when used in conjunction with @Id.

If this annotation is not specifeid with @Id the NONE stratergy is used as default.

Optional attributes:

strategy: Set the name of the identifier generation strategy. Valid values are AUTO, SEQUENCE, TABLE,
IDENTITY, UUID, CUSTOM and NONE. If not specified, default value is AUTO.

<?php
/**
 * @Id
 * @Column(type="integer")
 * @GeneratedValue(strategy="IDENTITY")
 */
protected $id = null;

@HasLifecycleCallbacks:

Annotation which has to be set on the entity-class PHP DocBlock to notify Doctrine that this
entity has entity lifecycle callback annotations set on at least one of its methods. Using @PostLoad,
@PrePersist, @PostPersist, @PreRemove, @PostRemove, @PreUpdate, @PostUpdate without this marker,
will make Doctrine ignore the callbacks:

<?php
/**
 * @Entity
 * @HasLifecycleCallbacks
 */
class User
{
	/**
	 * @PostPersist
	 */
	public function sendOptinMail() {}
}

@Index:

This annotation is used inside of the @Table annotation on the entity-class level. It provides
a hint to the SchemaTool to generate a database index on the specified table columns. It only has
meaning in the SchemaTool schema generation context.

Required attributes:

name: Name of the index

columns: Array of columns

Optional attributes:

options: Array of platform specific options:
	
	where: SQL WHERE condition to be used for partial indexes. It will only have effect on supported platforms.

Basic example:

<?php
/**
 * @Entity
 * @Table(name="ecommerce_products",indexes={@Index(name="search_idx", columns={"name", "email"})})
 */
class ECommerceProduct
{
}

Example with partial indexes:

<?php
/**
 * @Entity
 * @Table(name="ecommerce_products",indexes={@Index(name="search_idx", columns={"name", "email"}, 
 	options={"where": "(((id IS NOT NULL) AND (name IS NULL)) AND (email IS NULL))"})})
 */
class ECommerceProduct
{
}

@Id:

The annotated instance variable will be marked as entity identifier, the primary key in the database.
This annotation is a marker only and has no required or optional attributes. For entities that have
multiple identifier columns each column has to be marked with @Id:

<?php
/**
 * @Id
 * @Column(type="integer")
 */
protected $id = null;

@InheritanceType:

In an inheritance hierarchy you have to use this annotation on the topmost/super class to define which
 strategy should be used for inheritance. Currently Single Table and Class Table Inheritance are supported.

This annotation has always been used in conjunction with the @DiscriminatorMap and @DiscriminatorColumn
annotations.

Examples:

<?php
/**
 * @Entity
 * @InheritanceType("SINGLE_TABLE")
 * @DiscriminatorColumn(name="discr", type="string")
 * @DiscrimnatorMap({"person" = "Person", "employee" = "Employee"})
 */
class Person
{
	//...
}

/**
 * @Entity
 * @InheritanceType("JOINED")
 * @DiscriminatorColumn(name="discr", type="string")
 * @DiscrimnatorMap({"person" = "Person", "employee" = "Employee"})
 */
class Person
{
}

@JoinColumn:

This annotation is used in the context of relations in @ManyToOne, @OneToOne
fields and in the context of @JoinTable nested inside a @ManyToMany.

This annotation is not required. If it is not specified the attributes name and 
referencedColumnName are inferred from the table and primary key names.

Required attributes:

name: Column name that holds the foreign key identifier for this relation. In the context
of @JoinTable it specifies the column name in the join table.

referencedColumnName: Name of the primary key identifier that is used for joining of this
relation.

Optional Attributes:

unique: Determines whether this relation is exclusive between the affected entities, and should be enforced
as such on the database constraint level. Defaults to false.

nullable: Determins wether the related entity is required, or if null is an allowed state for the
relation. Defaults to true.

onDelete: Cascade Action (Database-level)

columnDefinition: DDL SQL snippet that starts after the column name and specifies the complete
(non-portable) column definition. This attribute enables the use of advanced RMDBS features.

Using this attribute on @JoinColumn is necessary if you need slightly different column definitions
for joining columns, for example regarding NULL/NOT NULL defaults. However by default a "columnDefinition"
attribute on @Column also sets the related @JoinColumn's columnDefinition. This is necessary for making
foreign keys work.

Example:

<?php
/**
 * @OneToOne(targetEntity="Customer")
 * @JoinColumn(name="customer_id", referencedColumnName="id")
 */
private $customer;

@JoinColumns:

An array of @JoinColumn annotations for a @ManyToOne or @OneToOne relation with an entity that has
multiple identifiers.

@JoinTable:

Using @OneToMany or @ManyToMany on the owning side of the relation requires to specify the
@JoinTable annotation which describes the details of the database join table. If you do not
specify @JoinTable on these relations reasonable mapping defaults apply using the affected
table and the column names.

Optional Attributes:

name: Database name of the join-table

joinColumns: An array of @JoinColumn annotations describing the join-relation between the owning
entities table and the join table.

inverseJoinColumns: An array of @JoinColumn annotations describing the join-relation between the
inverse entities table and the join table.

Example:

<?php
/**
 * @ManyToMany(targetEntity="PhoneNumber")
 * @JoinTable(name="users_phonenumbers",
 * 		joinColumns(@JoinColumn(name="user_id", referencedColumnName="id")},
 * 		inverseJoinColumns=(@JoinColumn(name="phonenumber_id", referenceColumnName="id", unique=true)}
 * )
 */
public $phonenumbers;

@ManyToOne:

Defines that the annotated instance variables holds a reference that describes a many-to-one relationship
between two entities.

Required attributes:

targetEntity: FQCN of the referenced target entity. Can be unqualified class name if both classes are in
the same namespace. IMPORTANT: No leading backslash!

Optional attributes:

cascade: Cascade Option

fetch: One of LAZY or EAGER

inversedBy - The inversedBy attribute designates the field in the entity that is the inverse side of the
relationship.

<?php
/**
 * @ManyToOne(targetEntity="Cart", cascade={"all"}, fetch="EAGER")
 */
private $cart;

@ManyToMany:

Defines that the annotated instance variable holds a many-to-many relationship between two entities.
@JoinTable is an additonal, optional annotation that has reasonable default configuration values using
the table and names of the two related entities.

Required attributes:

targetEntity: FQCN of the referenced target entity. Can be the unqualified class name if both classes
are in the same namespace. IMPORTANT: No leading backslash!

Optional attributes:

mappedBy: This option specifies the property name of the targetEntity that is the owning side of 
this relation. It is a required attribute for the inverse side of a relationship.

inversedBy: The inversedBy attribute designates the field in the entity that is the inverse side
of the relationship.

cascade: Cascade Option

fetch: One of LAZY, EXTRA_LAZY or EAGER.

indexBy: Index the collection by a field on the target entity.

For ManyToMany bidirectional relationships either side may be the owning side (the side that 
defines the @JoinTable and/or does not make use of the mappedBy attribute, thus using a default
join table).

<?php
/**
 * Owning Side
 *
 * @ManyToMany(targetEntity="Group", inversedBy="features")
 * @JoinTable(name="user_groups",
 * 		joinColumns={@JoinColumn(name="user_id", referencedColumnName="id")},
 * 		inverseJoinColumns={@JoinColumn(name="group_id", referencedColumnName="id")}
 * 		)
 */
private $groups

/**
 * Inverse Side
 * 
 * @ManyToMany(targetEntity="User", mappedBy="groups")
 */
private $features;

@MappedSuperclass:

A mapped superclass is an abstract or concrete class that provides persistent entity state and
mapping information for its subclasses, but which is not itself an entity.

This annotation is specified on the Class docblock and has no additional attributes. The @MappedSuperclass
annotation cannot be used in conjunction with @Entity. See the Inheritance Mapping section for more details on
the restrictions of mapped superclasses.

Optional Attributes:

repositoryClass: (>= 2.2) Specifies the FQCN of a subclass of the EntityRepository. That will be inherited
for all subclasses of that Mapped Superclass.

Example:

<?php
/**
 * @MappedSuperclass
 */
class MappedSuperclassBase
{
	//... fields and methods
}

/**
 * @Entity
 */
class EntitySubClassFoo extends MappedSuperclassBase
{
	//...
}

@NamedNativeQuery:

Is used to specify a native SQL named query. The NamedNativeQuery annotation can be applied to an entity
or mapped superclass.

Required attributes:

name: The name used to refer to the query with the EntityManager methods that create query objects

query: The SQL query string

Optional attributes:

resultClass: The class of the result.

resultSetMapping: The name of a SqlResultSetMapping, as defined in metadata.

example:

<?php
/**
 * @NamedNativeQuery({
 * 		@NamedNativeQuery(
 * 			name 			= "fetchJoinedAddress",
 * 			resultSetMapping= "mappingJoinAddress",
 * 			query 			= "SELECT u.id, u.name, u.status, a.id AS a_id, a.country, a.zip,
 a.city FROM cms_users u INNER JOIN cms_addresses a ON u.id = a.user_id WHERE u.username = ?"
 * 		),
 * })
 * @SqlResultSetMappings({
 * 		@SqlResultSetMapping(
 * 			name 	= "mappingJoinedAddress",
 * 			entities= {
 * 				@EntityResult(
 * 					entityClass = "__CLASS__",
 * 					fields 		= {
 * 						@FieldResult(name ="id"),
 * 						@FieldResult(name ="name"),
 * 						@FieldResult(name = "status"),
 * 						@FieldResult(name = "address.zip"),
 * 						@FieldResult(name = "address.city"),
 * 						@FieldResult(name = "address.country"),
 * 						@FieldResult(name = "address.id", column = "a_id"),
 * 					}
 * 				)
 * 			}
 * 		)
 * })
 */
class User
{
	/** @Id @Column(type="integer") @GeneratedValue */
	public $id;

	/** @Column(type="string", length=50, nullable=true) */
	public $status;

	/** @Column(type="string", length=255, unique=true) */
	public $username;

	/** @Column(type="string", length=255) */
	public $name;

	/** @OneToOne(targetEntity="Address") */
	public $address;
}

@OneToOne:

The @OneToOne annotation works almost exactly as the @ManyToOne with one additional option which can be specified.
The configuration defaults for @JoinColumn using the target entity table and primary key column names apply here too.

Required attributes:

targetEntity: FQCN of the referenced target entity. Can be the unqualified class name if both classes are in the same 
namespace. IMPORTANT: No leading backslashes!

Optional attributes:

cascade: Cascade Option

fetch: One of LAZY or EAGER

orphanRemoval: Boolean that specifies if orphans, inverse OneToOne entities that are not connected to any
owning instance, should be removed by Doctrine. Defaults to false.

inversedBy: The inversedBy attribute designates the field in the entity that is the inverse side of the 
relationship.

Example:

<?php
/**
 * @OneToOne(targetEntity="Customer")
 * @JoinColumn(name="customer_id", referencedColumnName="id")
 */
private $customer;

@OneToMany:

Required attributes:

targetEntity: FQCN of the referenced target entity. Can be the unqualified class name if both classes are in
the same namespace. IMPORTANT: No leading backslashes!

Optional attributes:

cascade: Cascade option

orphanRemoval: Boolean that specifies if orphans, inverse OneToOne entities that are not connected to any
owning instance, should be removed by Doctrine. Defaults to false.

mappedBy: This option specifies the property name on the targetEntity that is the owning side of this 
relation. Its a required attribute for the inverse side of a relationship.

fetch: One of LAZY, EXTRA_LAZY or EAGER.

indexBy: Index the collection by a field on the target entity.

Example:

<?php
/**
 * @OneToMany(targetEntity="PhoneNumber", mappedBy="user", cascade={"persist", "remove", "merge"}, orphanRemoval=true)
 */
public $phonenumbers;

@OrderBy:

optionan annotation that can be specified with a @ManyToMany or @OneToMany annotation to specify by which
criteria the collection should be retrieved from the database by using an ORDER BY clause.

This annotation requires a single non-attributed value with an DQL snippet:

<?php
/**
 * @ManyToMany(targetEntity="Group")
 * @OrderBy({"name" = "ASC"})
 */
private $groups;

The DQL Snippet in OrderBy is only allowed to consist of unqualified, unquoted field names and of an optional
ASC/DESC positional statement. Multiple Fields are separated by a comma (,). The referenced field names have to 
exist on the targetEntity class of the @ManyToMany or @OneToMany annotation.

@PostLoad:

Marks a method on the Entity to be called as a @PostLoad event. Only works with @HasLifecycleCallbacks in
the entity class PHP DocBlock

@PostPersist:

Marks a method on the entity to be called as a @PostPersist event. Only works with @HasLifeCycleCallbacks in
the entity class PHp DocBlock

//Same goes for PostRemove, PostUpdate, PrePersist, PreRemove, PreUpdate

@SequenceGenerator:

For use with @GeneratedValue(strategy="SEQUENCE") this annotation allows to specify details about the 
sequence, such as the increment size and initial values of the sequence.

Required attributes:

sequenceName: Name of the sequence

Optional attributes:

allocationSize: Increment the sequence by the allocation size when its fetched. A value larger than 
1 allows optimization for scenarios where you create more than one new entity per request. Defaults to 10

initialValue: Where the sequence starts, defaults to 1.

Example:

<?php
/**
 * @Id
 * @GeneratedValue(stratergy="SEQUENCE")
 * @Column(type="integer")
 * @SequenceGenerator(sequenceName="tablename_seq", initialValue=1, allocationSize=100)
 */
protected $id = null;

@SqlResultSetMapping:

The SqlResultSetMapping annotation is used to specify the mapping of the result of a native SQL query.
The SqlResultSetMapping annotation can be applied to an entity or mapped superclass.

Required attributes:

name: The name given to the result set mapping, and used to refer to it in the methods of the Query API.

Optional attributes:

entities: Array of @EntityResult, Specifies the result set mapping to entities.

columns: Array of @ColumnResult, Specifies the result set mapping to scalar values.

Example:

<?php
/**
 * @NamedNativeQueries({
 * 		@NamedNativeQuery(
 * 			name 			= "fetchUserPhonenumberCount",
 * 			resultSetMapping= "mappingUserPhonenumberCount",
 * 			query 			= "SELECT id, name, status, COUNT(phonenumber) AS numphones FROM cms_users INNER JOIN cms_phonenumbers ON id 
 * 			= user_id WHERE username IN (?) GROUP BY id, name, status, username ORDER BY username"
 * 		),
 * 		@NamedNativeQuery(
 * 			name 			= "fetchMultipleJoinsEntityResults",
 * 			resultSetMapping= "mappingMultipleJoinsEntityResults",
 * 			query 			= "SELECT u.id AS u_id, u.name AS u_name, u.status AS u_status, a.id AS a_id, a.zip AS a_zip, a.country AS a_country,
 COUNT(p.phonenumber) AS numbphones FROM cms_users u INNER JOIN cms_addresses a ON u.id = a.user_id INNER JOIN cms_phonenumbers p ON u.id = p.user_id
 GROUP BY u.id, u.name, u.status, u.username, a.id, a.zip, a.country ORDER BY u.username"
 * 		),
 * })
 * @SqlResultSetMappings({
 * 		@SqlResultSetMappin(
 * 			name 		= "mappingUserPhonenumberCount",
 * 			entities = {
 * 				@EntityResult(
 * 					entityClass = "User",
 * 					fields 		= {
 * 						@FieldResult(name = "id"),
 * 						@FieldResult(name = "name"),
 * 						@FieldResult(name = "status"),
 * 					}
 * 				)
 * 			},
 * 			columns = {
 * 				@ColumnResult("numphones")
 * 			}
 * 		),
 * 		@SqlResultSetMapping(
 * 			name 		= "mappingMultipleJoinEntityResults",
 * 			entities = {
 * 				@EntityResult(
 * 					entityClass = "__CLASS__",
 * 					fields 		= {
 * 						@FieldResult(name = "id", 		column="u_id"),
 * 						@FieldResult(name = "name", 	column="u_name"),
 * 						@FieldResult(name = "status", 	column="u_status"),
 * 					}
 * 				),
 * 				@EntityResult(
 * 					entityClass = "Address",
 * 					fields 		= {
 * 						@FieldResult(name = "id", 		column="a_id"),
 * 						@FieldResult(name = "zip", 		column="a_zip"),
 * 						@FieldResult(name = "country", 	column="a_country"),
 * 					}
 * 				)
 * 			},
 * 			columns = {
 * 				@ColumnResult("numphones")
 * 			}
 * 		)
 *})
 */
class User
{
	/** @Id @Column(type="integer") @GeneratedValue */
	public $id;

	/** @Column(type="string", length=50, nullable=true) */
	public $status;

	/** @Column(type="string", length=255, unique=true) */
	public $username;

	/** @Column(type="string", length=255) */
	public $name;

	/** @OneToMany(targetEntity="Phonenumber") */
	public $phonenumbers;

	/** @OneToOne(targetEntity="Address") */
	public $address;

	//...
}

@Table:

Annotation describes the table an Entity is presisted in. It is placed on the entity-class PHP DocBlock
and is optional. If it is not specified the table name will default to the entity's unqualified classname.

Required attributes:

name: Name of the table

Optional attributes:

indexes: Array of @Index annotations

uniqueConstraints: Array of @UniqueConstraints annotations

schema: (>= 2.5) Name of the schema the table lies in.

Example:

<?php
/**
 * @Entity
 * @Table(name="user",
 * 		uniqueConstraints={@UniqueConstraint(name="user_unique",columns={"username"})},
 * 		indexes={@Index(name="user_idx", columns={"email"})}
 * 		schema="schema_name"
 * )
 */
class User {
}

@UniqueConstraint:

Annotation is used inside the @Table annotation on the entity-class level. It allows ot hint the
SchemaTool to generate a database unique constraint on the specified table columns. 
It only has meaning in the SchemaTool schema generation context.

Required attributes:

name: Name of the Index

columns: Array of columns.

Optional attributes:

options: Array of platform specific options:
		where: SQL WHERE condition to be used for partial indexes. It will only have effect on supported
		platforms.

Basic Example:

<?php
/**
 * @Entity
 * @Table(name="ecommerce_products",uniqueConstraints={@UniqueConstraint(name="search_idx", columns={"name", "email"})})
 */
class ECommerceProduct
{
}

Example with Partial Indexes:

<?php
/**
 * @Entity
 * @Table(name="ecommerce_products",uniqueConstraints={@UniqueConstraint(name="search_idx", columns={"name", "email"}, options={"where": "(((id IS NOT NULL) AND 
 (email IS NULL))"})})
 */
class ECommerceProduct
{
}

@Version:

Marker annotation that defines a specified column as version attribute used in an optimistic locking scenaro.
It only works on @Column annotations that have the type integer or datetime. Combining @version with
@Id is not supported.

<?php
/**
 * @Column(type="integer")
 * @Version
 */
protected $version;

Creating Entities:

For the Application module, entities are (by convention) stored inside the Entity directory under the module's source directory.
Entity classes live inside the Application\Entity namespace.

Adding Post Entity:

We start with creating the Post entity. Create the Post.hp file under module's Entity directory. If you have not created the
Entity directory yet, it is time to do that. Put hte following codein to that file:

<?php
namespace Application\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
 * This class represents a single post in a blog
 * @ORM\Entity
 * @ORM\Table(name="post")
 */
class Post
{
	//Post status constants
	const STATUS_DRAFT 		= 1; //Draft
	const STATUS_PUBLISHED 	= 2; //Published

	/**
	 * @ORM\Id
	 * @ORM\GeneratedValue
	 * @ORM\Column(name="id")
	 */
	protected $id;

	/**
	 * @ORM\Column(name="title")
	 */
	protected $title;

	/**
	 * @ORM\Column(name="content")
	 */
	protected $content;

	/**
	 * @ORM\Column(name="status")
	 */
	protected $status;

	/**
	 * @ORM\Column(name="date_created")
	 */
	protected $dateCreated;

	//Returns ID of this post
	public function getId()
	{
		return $this->id;
	}

	//Sets ID of this Post
	public function setId($id)
	{
		$this->id = $id;
	}

	//Returns title
	public function getTitle()
	{
		return $this->title;
	}

	//Sets title
	public function setTitle($title)
	{
		$this->title = $title;
	}

	//Returns status
	public function getStatus()
	{
		return $this->status;
	}

	//Sets status
	public function setStatus($status)
	{
		$this->status = $status;
	}

	//Return post content
	public function getContent()
	{
		return $this->content;
	}

	//Sets post content
	public function setContent($content)
	{
		$this->content = $content;
	}

	//Returns the date when this post was created
	public function getDateCreated()
	{
		return $this->dateCreated;
	}

	//Sets the date when this post was created
	public function setDateCreated($dateCreated)
	{
		$this->dateCreated = $dateCreated;
	}
}

In the code above, we have the following things:

Status constants (lines 14 and 15). These constants conveniently represent possible values the $status property
may receive (1 for Draft, 2 for Published)

Protected properties ($title, $content, $dateCreated, etc.) These are data that a typical blog post has.

Please note that for properties we (by convention) use camel-case names (like $dateCreated), while for database columns
we use "canonicalized" names (in lower-case and with underscores separating words in a name, like date_created).

Properties of the Post Entity:

Property 		Mapped on Column 			Desc

$id 			id 							Unique ID of this post

$title 			title 						Title of this post

$content 		content 					Content of this post

$status 		status 						Status (draft/published) of this post

$dateCreated 	date_created 				Date when this post was created

Entity class and its properties are marked with Docblock annotations read by Doctrine ORM
at run-time, allowing it to know how to map this entity and its properties on the database
table and its columns.

Entity class has getter and setter methods (lines 45-102) allowing to access/modify the protected
properties.

There is no need to mark class methods with Doctrine entity annotations. Albeit, we can comment them
in DocBlocks, if we wish.

Adding the Comment and Tag Entities:

By analogy with the Post entity, we next create the Comment and the Tag entity classes in the Entity directory.
To do that, first, create Comment.php file and put hte following code inside of it:

<?php
namespace Application\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
 * This class represents a comment related to a blog post
 * @ORM\Entity
 * @ORM\Table(name="comment")
 */
class Comment
{
	/**
	 * @ORM\Id
	 * @ORM\Column(name="id")
	 * @ORM\GeneratedValue
	 */
	protected $id;

	/**
	 * @ORM\Column(name="content")
	 */
	protected $content;

	/**
	 * @ORM\Column(name="author")
	 */
	protected $author;

	/**
	 * @ORM\Column(name="date_created")
	 */
	protected $dateCreated;

	//Returns ID of this comment
	public function getId()
	{
		return $this->id;
	}

	//Sets ID of this comment
	public function setId($id)
	{
		$this->id = $id;
	}

	//Returns comment text
	public function getContent()
	{
		return $this->content;
	}

	//Sets status
	public function setContent($content)
	{
		$this->content = $content;
	}

	//Returns authors name
	public function getAuthor()
	{
		return $this->author;
	}

	//Sets authors name
	public function setAuthor($author)
	{
		$this->author = $author;
	}

	//Returns the date when this comment was created
	public function getDateCreated()
	{
		return $this->dateCreated;
	}

	//Sets the date of when this comment was created
	public function setDateCreated($dateCreated)
	{
		$this->dateCreated = $dateCreated;
	}
}

Next, we create the Tag.php with the following content:

<?php
namespace Application\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
 * This class represents a tag
 * @ORM\Entity
 * @ORM\Table(name="tag")
 */
class Tag
{
	/**
	 * @ORM\Id
	 * @ORM\GeneratedValue
	 * @ORM\Column(name="id")
	 */
	protected $id;

	/**
	 * @ORM\Column(name="name")
	 */
	protected $name;

	//returns id of this tag
	public function getId()
	{
		return $this->id;
	}

	//Sets id of this tag
	public function setId($id)
	{
		$this->id = $id;
	}

	//Returns name
	public function getName()
	{
		return $this->name;
	}

	//Sets name
	public function setName($name)
	{
		$this->name = $name;
	}
}

Please note, that we do nto create an Entity for the forth auxiliary table post_tag. That table
will be indirectly used further in this chapter when defining relationships between entities.

Specifying Relationships between Entites:

Now its time to use annotations to define relationships between entities. If you remember, we have two
relationships between our entities.

The post and Comment entities are related as "one-to-many"

The Post and Tag entities are related as "many-to-many"

In Doctrine, to express a relationship between two entities, you add a private property paired with
Docblock annotation.

For detailed information about relationships between entities in Doctrine, please read this page of Doctrine
Documentation.

OneToMany/ManyToOne:

First, let's one-to-many relationship between the Post and Comment entities. Modify the Post.php file and add the 
following lines:

<?php
//...
use Doctrine\Common\Collections\ArrayCollection;
use Application\Entity\Comment;

/**
 * This class represents a single post in a blog.
 * @ORM\Entity
 * @ORM\Table(name="post")
 */
class Post
{
	//...

	/**
	 * @ORM\OneToMany(targetEntity="\Application\Entity\Comment", mappedBy="post")
	 * @ORM\JoinColumn(named="id", referencedColumnName="post_id")
	 */
	protected $comments;

	/**
	 * Constructor.
	 */
	public function __construct()
	{
		$this->comments = new ArrayCollection();
	}

	/**
	 * Adds a new comment to this post.
	 * @param $comment
	 */
	public function addComment($comment)
	{
		$this->comments[] = $comment;
	}
}

As you can see from the code above, we added the $comments property. This proerty will be the 
collection of comments related to certain post.

We initialize the $comments property in class constructor (lines 24-27). By assigning it with a new 
instance of Doctrine\Common\Collections\ArrayCollection class.

A Doctrine ArrayCollection is an array of objects, like usual PHP array, but with additonal featured 
required by Doctrine. It is implemented in Doctrine\Common component.

In lines 15-18, we add Doctrine annotations to the $comments property, so Doctrine knows how to get all
comments associated with the post:

the @ORM\OneToMany tag defines that is the one-to-many relationship between the Post entity and the (target)
Comment entity.

the @ORM\JoinColumn tag specifies which column use for joining the tables associated with the entities.

The getComments() method (lines 33-36) allow to get all comments associated with the post.

We also add the addComment() method (lines 42-45) for adding new comment to post. You can notice that 
we use the [] operator, just like we do with a typical PHP array.

Vice versa, we define the other side of this relationship by modifying the Comment entity as follows:

<?php
//...
use Doctrine\Common\Collections\ArrayCollection;

//...
class Comment
{
	/**
	 * @ORM\ManyToOne(targetEntity="\Application\Entity\Post", inversedBy="comments")
	 * @ORM\JoinColumn(name="post_id", referencedColumnName="id")
	 */
	protected $post;

	/*
	 * Returns associated post.
	 * @return \Application\Entity\Post
	 */
	public function getPost()
	{
		return $this->post;
	}

	/**
	 * Sets associated post
	 * @param \Application\Entity\Post $post
	 */
	public function setPost($post)
	{
		$this->post = $post;
		$post->addComment($this);
	}
}

In the code above, we added the $post private property to the entity class. This is not a collection,
but a single instance of Post class, because single comment always belongs to single post.

The annotation tags @ORM\ManyToOne and @ORM\JoinColumn are analogous to those we covered before..

ManyToMany:

Let's now express the many-to-many relationship between the Post and Tag entities. For this relationship,
we indirect use the auxilliary post_tag table.

Modify the Post entity as follows:

<?php
//...
use Application\Entity\Tag;

//...
class Post
{
	//...

	/**
	 * @ORM\ManyToMany(targetEntity="\Application\Entity\Tag", inversedBy="posts")
	 * @ORM\JoinTable(name="post_tag",
	 * 		joinColumns={@ORM\JoinColumn(name="post_id", referencedColumnName="id")}),
	 * 		inverseJoinColumns={@ORM\JoinColumn(name="tag_id", referencedColumnName="id")}
	 * 		)
	 */
	protected $tags;

	//Constructor
	public function __construct()
	{
		//...
		$this->tags = new ArrayCollection();
	}

	//Returns tags for this post
	public function getTags()
	{
		return $this->tags;
	}

	//adds a new tag to this post
	public function addTag($tag)
	{
		$this->tags[] = $tag;
	}

	//Remove associated between this post and the given tag
	public function removeTagAssociation($tag)
	{
		$this->tags->removeElement($tag);
	}
}


In the code above, we do the following:

add $tags private property

marks the $tags property with DocBlock annotations with @ORM\ManyToMany and @ORM\JoinTable annotaiton tags.

initialize the property in constructor

add three methods getTags(), addTag() and removeTagAssociation() allowing to get/modify the property's value

Finally, modify the Tag entity as follows:

<?php
//...
use Doctrine\Common\Collections\ArrayCollection;

class Tag
{
	//...

	/**
	 * @ORM\ManyToMany(targetEntity="\Application\Entity\Post", mappedBy="tags")
	 */
	protected $posts;

	//Constructor
	public function __construct()
	{
		$this->posts = new ArrayCollection();
	}


	//Returns posts associated with this tag
	public function getPosts()
	{
		return $this->posts;
	}

	//Adds a post into collection of posts related to this tag
	public function addPost($post)
	{
		$this->posts[] = $post;
	}
}

In the code above, we by analogy define the other side of the relationship and getter/setter methods for retrieving
the collection of posts associated with the tag, and adding posts associated with the given tag.

Specifying Entity Locations:

TO let Doctrine know where to find entities for your Application module (or for another module you have), you add the
following lines into your module.config.php file:

<?php
namespace Application;

use Doctrine\ORM\Mapping\Driver\AnnotationDriver;

return [
	//...
	'doctrine' => [
		'driver' => [
			__NAMESPACE__ . '_driver' => [
				'class' => AnnotationDriver::class,
				'cache' => 'array',
				'paths' => [__DIR__ . '/../src/Entity']
			],
			'orm_default' => [
				'drivers' => [
					__NAMESPACE__ . '\Entity' => __NAMESPACE__ . '_driver'
				]
			]
		]
	]
];

ABove in line 2, we specify the namespace Application. This hsould be the name of the current module.

Note that usually we do note specify namespace in config files, but in this particular case it is convenient
to do. When we have namespaced defined, we can use the __NAMESPACE__ placeholder which expands into that namespace.

In line 8, we have doctrine key, under which we have the driver subkey. In lines 13, we tell Doctrine ORM that our
entities are stored inside of Entity directory under the module's src directory.

About Entity Manager:

ENtity manager is the primary access point to ORM functionality provided by Doctrine.

EntityManager is a Doctrine class that lives in Doctrine\ORM namespace and used to retrieve entities from their
repositories using search criteria and save entities back to DB.

EntityManager is registered as a service in the ZF3 service manager. In your factory class, you retrieve the
EntityManager from service manager as follows (if you need a different connection than orm_default, just replace the
orm_default with the required connection name).

//Get Doctrine entity manager
$entityManager = $container->get('doctrine.entitymanager.orm_default');

THe most used methods provided by the EntityManager class are as follows:

Methods of the EntityManager:

persist($entity) 		Places new entity into entity manager (makes it managed)

remove($entity) 		Removes an entity from DB

flush() 				Flushes all changes to objects that have been queued up to now to the DB.

createQuery($dql) 		Creates a new Query Object

getRepository($entityName) 	Gets the repository for an entity class.

Let's review the methods from above.

To add a newly created entity to entity manager (to make the entity "managed"), you use entity manager's persist() method. To
remove an entity from database, you use entity manager's remove() method.

When you call persist() or remove(), EntityManager remembers your changes in memory, but does not apply changes to database
automatically (performance reasons). To apply the changes to the DB in a single transaction, you use flush().

For example, look at the code example below that shows how to create an instance of the Post entity and save it ot the DB:

//Create new Post entity
$post = new Post();
$post->setTitle('Top 10+ Books about ZF');
$post->setContent('Some shit goes here');
$post->setStatus(Post::STATUS_PUBLISHED);
$currentDate = date('Y-m-d H:i:s');
$post->setDateCreated($currentDate);

//Add the entity to the entity manager
$entityManager->persist($post);

//Apply the changes to the DB
$entityManager->flush();

The createQuery method of the enitty manager is designed for creating query from a DQL string. It returns the Query Object.
You then execute the query and get results (an array of entities matching search conditions).

The getRepository() method of the entity manager is designed to get repository by entity class name. Please look below for
an example when we get the repository for our Post entity:

$repository = $entityManager->getRepository(Post::class);

Entity Repositories:

Conceptually, each entity class has its own repository. The repository provides methods for retrieving entities from DB.
The repository can be considered as a collection of all available entities of certain class. For example, tehre are 
repositories for our Post, Comment and Tag entities.

To load data from the database, you retrieve an entity from its repository. When you request the repository
for an entity, it loads the data from the table mapped to the entity, and assigns entity's fields with the data.

The Doctrine\ORM\EntityRepository class implements the default repository. If needed, you can, by extending the
EntityRepository, create your own repository for certain entity class. We will show that later.

THe most used methods provided by the EntityRepository:

findAll() 			Finds all entities in the Repo

find($id) 			Finds an entity by its identifier

findBy($criteria, $orderBy, $limit, $offset) Finds entities by a set of criteria

findOneBy($criteria, $orderBy) 	Finds a single entity by a set of criteria

createQueryBuilder($alias) 		Creates a new QueryBuilder instance that is prepopulated for this entity name

The findAll() method gets all entities from repository. For simple example of its usage, look below:

//Find all posts from repository
$posts = $entityManager->getRepository(Post::class)->findAll();

The find() method is the simplest method of searching for an entity. It retrieves an entity by its
ID (primary key).

in the example below, we select post with ID = 1:

//Find the post by primary key
$post = $entitymanager->getRepository(Post::class)->find(1);

The findBy() takes a search criteria (and optional sorting order and limit) arguments and returns a 
collection of entities matching criteria. The findOneBy() method is very similar to findBy(), but it 
returns the first entity matching the criteria.

In the example below, we use the findBy() method for selecting 50 most recent published posts:

//Find 50 most recent published posts
$posts = $entityManager->getRepository(Post::class)->findBy(
			['status'=>Post::STATUS_PUBLISHED],
			['dateCreated'=>'DESC'], 50);

For your conveinence, the EntityRepository class also provides magic methods allowing you to query entities by
attribute name with the findByX, as follows (Just replace X with attribute name):

//Query a single post by ID attribute
$post = $entityManager->getRepository(Post::class)->findOneById(1);

//Query posts by status attribute
$posts = $entityManager->getRepository(Post::class)
		->findByStatus(Post::STATUS_PUBLISHED);

If standard find methods are not sufficient (or if you have complex search criteria and DQL queries), you can
create your own repository by extending the standard EntityRepository class and encapsulate the search logic there.

We will show you how to do that later, when we implement tag cloud feature for our Blog sample.

Adding Blog Home Page:

To show to use EntityManager class, we will create the main page for the Blog web application.
This page will display the list of posts sorted by date in descending order.

To do that, add the constructor method and indexAction() method to the IndexController controller class,
as follows:

<?php
namespace Application\Controller;

use Zend\Mvc\Controller\AbstractController;
use Zend\View\Model\ViewModel;
use Application\Entity\Post;

class IndexController extends AbstractActionController
{
	/**
	 * Entity Manager
	 * @var Doctrine\ORM\EntityManager
	 */
	private $entityManager;

	//Constructor method is used to inject dependencies to the controller.
	public function __construct($entityManager)
	{
		$this->entityManager = $entityManager;
	}

	//This is teh default "index" action of the controller. It displays the
	// Posts page containing the recent blog posts
	public function indexAction()
	{
		//Get recent posts
		$posts = $this->entityManager->getRepository(Post::class)
						  ->findBy(['status'=>Post::STATUS_PUBLISHED],
						  		   ['dateCreated'=>'DESC']);

		//Render the view template
		return new ViewModel([
			'posts' => $posts
		]);
	}
}

In the code above, we first add the __construct() constructor method which is used to inject the Doctrine
entity manager into the controller (lines 16-19)

Inside of the indexAction() method, we get the repository of the Post entities with entity manager's getRepository()
method (line 26). With the findBy() method provided by repository, we select published posts ordered by date in descending
order.

And, in line 31 we pass the selected posts to teh view for rendering.

Next, create the factory for the IndexController. To do that, add the IndexControllerFactory.php file inside of
Controller/Factory directory under module's source directory. Put the following content to the file:

<?php
namespace Application\Controller\Factory;

use Interop\Container\ContainerInterface;
use Zend\ServiceManager\Factory\FactoryInterface;
use Application\Controller\IndexController;

/**
 * This is teh factory for IndexController. its purpose is to instansiate the controller
 */
class indexControllerFactory implements FactoryInterface
{
	public function __invoke(ContainerInterface $container, $requestedName, array $options = null)
	{
		$entityManager = $container->get('doctrine.entitymanager.orm_default');

		//instansiate the controller and inject dependencies
		return new IndexController($entityManager);
	}
}

In the code above, you can see how we instansiate the Doctrine entity manager and inject it into the controller.

Do not forget to register our controller's factory inside module.config.php file. To do that, do as follows:

//...
return [
	//...
	'controllers' => [
		//...
		'factories' => [
			Controller\IndexController::class => 
							Controller\Factory\IndexControllerFactory::class,
		],
	],
	//...
];

Next, modify the index.phtml view template file in application/index directory under module's view directory and put 
the following content into it:

<h1>Posts</h1>

<?php foreach($posts as $post): ?>

<h3>
	<a href="#">
		<?= $this->escapeHtml($post->getTitle()); ?>
	</a>
</h3>

<p>
	<?= $this->escapeHtml($post->getContent()); ?>
</p>

<?php endforeach; ?>

In the view template above, we go in turn through the posts we selected and render each one's title and content. That simple.

now, if you open the Blog web application in your browser, you should be able to see the following page containing the list of
posts.

Adding New Post:

In this section, we will create Add New Post web page that will allow to add a new post to the blog. For this, we will need
four things:

the PostForm form model will be used for entering and validation of post title, content, status and tags.

the PostManager service model will contain business logic for saving new posts to DB

the PostController controller and its PostController::addAction() action method will be used for getting form data,
and calling PostManager for saving the data to database.

add.phtml view template will render the form

Adding PostForm:

First, we add the PostForm form that will allow to enter data of a single post: its title, content, comma-separated list
of tags associated with the post and status (Published or Draft). To do that, create the PostForm.php file in Form Directory
under module's source directory.

Put the following content in that file:

<?php

namespace Application\Form;

use Zend\Form\Form;
use Zend\InputFilter\InputFilter;
use Application\Entity\Post;

/**
 * This form is used to collect post data
 */
class PostForm extends Form
{
	/**
	 * Constructor
	 */
	public function __construct()
	{
		//Define form name
		parent::__construct('post-form');

		//Set POST method for this form
		$this->setAttribute('method', 'post');

		$this->addElements();
		$this->addInputFilter();
	}

	/**
	 * This method adds elements to form (input fields and submit button)
	 */
	protected function addElements()
	{
		//Add "title" field
		$this->add([
			'type' => 'text',
			'name' => 'title',
			'attributes' => [
				'id' => 'title'
			],
			'options' => [
				'label' => 'Title',
			],
		]);

		//Add "content" field
		$this->add([
			'type' => 'textarea',
			'name' => 'content',
			'attributes' => [
				'id' => 'content'
			],
			'options' => [
				'label' => 'Content',
			],
		]);

		//Add "tags" field
		$this->add([
			'type' => 'text',
			'name' => 'tags',
			'attributes' => [
				'id' => 'tags'
			],
			'options' => [
				'label' => 'Tags',
			],
		]);

		//Add "status "field
		$this->add([
			'type' => 'select',
			'name' => 'status',
			'attributes' => [
				'id' => 'status'
			],
			'options' => [
				'label' => 'Status',
				'value_options' => [
					Post::STATUS_PUBLISHED => 'Published',
					Post::STATUS_DRAFT => 'Draft',
				]
			],
		]);

		//Add the Submit button
		$this->add([
			'type' => 'submit',
			'name' => 'submit',
			'attributes' => [
				'value' => 'Create',
				'id' => 'submitbutton',
			],
		]);
	}

	/**
	 * THis method creates inptu filter (used for form filtering/validation)
	 */
	private function addInputFilter()
	{
		$inputFilter = new InputFilter();
		$this->setInputFilter($inputFilter);

		$inputFilter->add([
				'name' 		=> 'title',
				'required' 	=> true,
				'filters' 	=> [
					['name' => 'StringTrim'],
					['name' => 'StripTags'],
					['name' => 'StripNewLines'],
				],
				'validators' => [
					[
						'name' => 'StringLength',
						'options' => [
							'min' => 1,
							'max' => 1024
						],
					],
				],
			]);

		$inputFilter->add([
				'name' 	  => 'content',
				'required' => true,
				'filters' => [
					['name' => 'StripTags'],
				],
				'validators' => [
					[
						'name' => 'StringLength',
						'options' => [
							'min' => 1,
							'max' => 4096
						],
					],
				],
			]);


		$inputFilter->add([
				'name' 		=> 'tags',
				'required' 	=> true,
				'filters' 	=> [
					['name' => 'StringTrim'],
					['name' => 'StripTags'],
					['name' => 'StripNewLines'],
				],
				'validators' => [
					[
						'name' => 'StringLength',
						'options' => [
							'min' => 1,
							'max' => 1024
						],
					],
				],
			]);

	}
}


As we can see from the code above, the PostForm class defines a ZF3 form with title, content, tags and status fields.
It also has the submit button.

Adding PostManager Service:

According to DDD, we put business logic into service models. In our Blog sample, we will create and register the
PostManager service. This service will have the addNewPost() public method that will contain business logic of
adding Post entity to database and associating it with one or several Tag entities.

The PostManager service will contain business logic of the Blog sample. This business logic includes, but
not limited to, adding new post to the blog.

Create the PostManager.php file inside the Service directory under the module's source directory. Put the following
content into that file:

<?php
namespace Application\Service;

use Application\Entity\Post;
use Application\Entity\Comment;
use Application\Entity\Tag;
use Zend\Filter\StaticFilter;

//The PostManager service is responsible for adding new posts
class PostManager
{
	/**
	 * Doctrine Entity manager.
	 * @var Doctrine\ORM\EntityManager
	 */
	private $entityManager;

	//Constructor is used to inject dependencies into the service
	public function __construct($entityManager)
	{
		$this->entityManager = $entityManager;
	}

	//This method adds a new post
	public function addNewPost($data)
	{
		//Create new Post entity
		$post = new Post();
		$post->setTitle($data['title']);
		$post->setContent($data['content']);
		$post->setStatus($data['status']);
		$currentDate = date('Y-m-d H:i:s');
		$post->setDateCreated($currentDate);

		//Add the enitty to the EM
		$this->entityManager->persist($post);

		//Add tags to post
		$this->addTagsToPost($data['tags'], $post);

		//Apply changes to database
		$this->entityManager->flush();
	}

	//Adds/updates tags in the given post.
	private function addTagsToPost($tagsStr, $post)
	{
		//Remove tag associations (if any)
		$tags = $post->getTags();
		foreach ($tags as $tag) {
			$post->removeTagAssociation($tag);
		}

		//Add tags to post
		$tags = explode(',', $tagsStr);
		foreach ($tags as $tagName) {

			$tagName = StaticFilter::execute($tagName, 'StringTrim');
			if (empty($tagName)) {
				continue;
			}

			$tag = $this->entityManager->getRepository(Tag::class)
						->findOneByName($tagName);

			if ($tag == null)
				$tag = new Tag();

			$tag->setName($tagName);
			$tag->addPost($post);

			$this->entityManager->persist($tag);

			$post->addTag($tag);
		}
	}
}

In lines 25-43, we have the addNewPost() public method which takes the $data variable as argument (this variable should
contain the data entered by the website user into the form). We create a new instance of Post entity (line 28) and fill its
properties with user-provided data.

We use the EntityManager's persist() method (line 36) to add the newly created entity to the entity manager. THe addTagsToPost()
private method is called (line 39) to assign the post with one or several tags. And the flush() method is used for applying
changes to database in a single transaction (line 42).

The addTagsToPost() private method contains logic for removing old associations between the post and tags (lines 49-52), then
parsing comma-separated list of tags (line 55), and assigning new tags to the post (lines 56-73).

Next, add a factory for the PostManager service. To do that, add the PostManagerFactory.php file under the Service/Factory
directory under the module's source directory. Put the following content into that file:

<?php
namespace Application\Service\Factory;

use Interop\Container\ContainerInterface;
use Zend\ServiceManager\Factory\FactoryInterface;
use Application\Service\PostManager;

/**
 * This is the factory for PostManger. Its purpose is to instantiate the service
 */
class PostManagerFactory implements FactoryInterface
{
	public function __invoke(ContainerInterface $container, $reuqestedName, array $options = null)
	{
		$entityManager = $container->get('doctrine.entitymanager.orm_default');

		//Instansiate the service and inject dependencies
		return new PostManager($entityManager);
	}
}

Finally, we register PostManager service by modifying module.config.php configuration file as follows:

<?php
//...
return [
	//...
	'service_manager' => [
		//...
		'factories' => [
			Service\PostManager::class => Service\Factory\PostManagerFactory::class
		],
	],
	//...
];

Creating Controller Action and View Template:

For post management (e.g, adding, editing, viewing and removing posts), we will create the PostController controller class.
We create the addAction() action method inside the PostController controller class that will allow to add a new 
post to blog:

class PostController extends AbstractActionController
{
	/**
	 * Entity Manager
	 * @var Doctrine\ORM\EntityManager
	 */
	private $entityManager;

	/**
	 * Post manager
	 * @var Application\Service\PostManager
	 */
	private $postManager;

	/**
	 * Constructor is used for injecting dependencies into the controller
	 */
	public function __construct($entityManager, $postManager)
	{
		$this->entityManager = $entityManager;
		$this->postManager = $postManager;
	}

	/**
	 * This action displays the "New Post" page. The page contains
	 * a form allowing to enter post title, content and tags. When
	 * the user clicks the submit button, a new Post entity will
	 * be created
	 */
	public function addAction()
	{
		//Create the form
		$form = new PostForm();

		//check whether this post is a POST-request
		if ($this->getRequest()->isPost()) {

			//get POST data
			$data = $this->params()->fromPost();

			//Fill form with data.
			$form->setData($data);
			if ($form->isValid()) {

				//Get validated form data
				$data = $form->getData();

				//use post manager service to add new post to the db
				$this->postManager->addNewPost($data);

				//Redirect the user to "index" page
				return $this->redirect()->toRoute('application');
			}
		}

		//Render the view template
		return new ViewModel([
			'form' => $form
		]);
	}
}

Above, in line 33, we create an instance of PostForm form. In line 36, we check wether this is a POST
request. If the request is a POST request, we will form the input data and validate the data. In case of valid
data, we call the addNewPost() method on the PostManager service (line 49), and redirect the user to list of posts.

To instansiate the PostController, we will need a factory. Create the controller factory by adding the PostControllerFactory.php
file to the Controller/Factory directory under the module's source directory.

<?php
namespace Application\Controller\Factory;

use Interop\Container\ContainerInterface;
use Zend\ServiceManager\Factory\FactoryInterface;
use Application\Service\PostManager;
use Application\Controller\PostController;

/**
 * This is the factory for PostController. Its purpose is to instansiate hte 
 * controller.
 */
class PostControllerFactory implements FactoryInterface
{
	public function __invoke(ContainerInterface $container, $requestedName, array $options = null)
	{
		$entityManager = $container->get('doctrine.entitymanager.orm_default');
		$postManager = $container->get(PostManager::class);

		//instansiate the controller and inject dependencies
		return new PostController($entityManager, $postManager);
	}
}

Next, register the PostController controller inside the module.config.php file:

<?php
//...
return [
	//...
	'controllers' => [
		//....
		'factories' => [
			Controller\PostController::class => 
							Controller\Factory\PostControllerFactory::class,
		],
	],
	//...
];

Then, add the posts route for the new controller (modify the module.config.php as follows):

<?php
//...
return [
	//...
	'router' => [
		'routes' => [
			//...
			'posts' => [
				'type' => Segment::class,
				'options' => [
					'route' 	=> '/posts[/:action[/:id]]',
					'constraints' => [
						'action' => '[a-zA-Z][a-zA-Z0-9_-]*',
						'id' => '[0-9]*'
					],
					'defaults' => [
						'controller' 	=> Controller\PostController:class,
						'action' 		=> 'index',
					],
				],
			],
		],
	],
	//...
];

Finally, we add the view template. Create teh add.phtml file in application/post directory under module's view directory
and put the following content into it:

<?php
$form = $this->form;
$form->get('title')->setAttributes([
	'class'=>'form-control',
	'placeholder'=>'Enter post title here'
	]);
$form->get('content')->setAttributes([
	'class'=>'form-control',
	'placeholder'=>'Type content here',
	'rows'=>6
	]);
$form->get('tags')->setAttributes([
	'class'=>'form-control',
	'placeholder'=>'comma, separated, list, of, tags'
	]);
$form->get('status')->setAttributes([
	'class'=>'form-control'
	]);
$form->get('submit')->setAttributes(['class'=>'btn btn-primary']);
$form->prepare();

?>

<h1>Add New Post</h1>

<p>
	Please fill out the following form and click the <i>Create</i> button.
</p>

<div class="row">
	<div class="col-md-6">
		<?= $this->form()->openTag($form); ?>

		<div class="form-group">
			<?= $this->formLabel($form->get('title')); ?>
			<?= $this->formElement($form->get('title')); ?>
			<?= $this->formElementErrors($form->get('title')); ?>
		</div>

		<div class="form-group">
			<?= $this->formLabel($form->get('content')); ?>
			<?= $this->formElement($form->get('content')); ?>
			<?= $this->formElementErrors($form->get('content')); ?>
		</div>

		<div class="form-group">
			<?= $this->formLabel($form->get('tags')); ?>
			<?= $this->formElement($form->get('tags')); ?>
			<?= $this->formElementErrors($form->get('tags')); ?>
			<p class="help-block">Separate tags with comma.</p>
		</div>

		<div class="form-group">
			<?= $this->formLabel($form->get('status')); ?>
			<?= $this->formElement($form->get('status')); ?>
			<?= $this->formElementErrors($form->get('status')); ?>
		</div>

		<?= $this->formElement($form->get('submit')); ?>

		<?= $this->form()->closeTag(); ?>
	</div>
</div>

Now if we open the URL http://localhost/posts/add in our web browser, we should see the expected result.

Filling the form and clicking the Create button results in saving the new post to database. Then you are able to see
the newly created post in the list of posts at the Home page.

Editing Existing Post:

In this section, we will implement the Edit Post page which contains the form allowing to edit the data of existing post,
send new data to server and apply changes to database. Site visitor will be able to see the page by entering the following
URL in browser's navbar: http://localhost/posts/edit/<id>, where <id> is the unique identifer of the psot.

To implement this page, we need the following things:

create a form that would allow to enter the post title, content, etc. For this page, we can successfully reuse the PostForm
form we created earlier (we just rename the Create button caption to save)

add updatePost() method to the PostManager service. The method would find the post by ID in database and update its data.

add convertTagsToString() method to the PostManager service. This method would take the post entity, and on output produce
string containing comma-separated list of tags.

add the PostController::editAction() action method that would take user input, pass it to models and return data for rendering.

add the edit.phtml view template file that would render the form.

Modifying PostManager:

First, we add the updatePost() and convertTagsToString() methods to the PostManager service model as follows:

<?php
//...
class PostManager
{
	//...

	//This method allows to update data of a single post
	public function updatePost($post, $data)
	{
		$post->setTitle($data['title']);
		$post->setContent($data['content']);
		$post->setStatus($data['status']);

		//Add tags to the post
		$this->addTagsToPost($data['tags'], $post);

		//Apply changes to the db
		$this->entityManager->flush();
	}

	//Converts tags to the given post to comma separated list (string)
	public function convertTagsToString($post)
	{
		$tags = $post->getTags();
		$tagCount = count($tags);
		$tagsStr = '';
		$i = 0;
		foreach ($tags as $tag) {
			$i++;
			$tagsStr = $tag->getName();
			if ($i < $tagCount)
				$tagsStr .= ', ';
		}

		return $tagsStr;
	}
}

Above, we have the updatePost() method (lines 8-19) that takes an existing Post entity, the new title, content, status
and list of tags. It then updates entity's properties and saves changes to database using flush() method.

Note that the updatePost() method does not use the persist() method of the EM, because here we have a existing post, not a
new one.

Adding Controller Action and View Template:

Next, add the editAction to PostController controller class as follows:

<?php
namespace Application\Controller;
//...
use Application\Form\PostForm;
use Application\Entity\Post;

class PostController extends AbstractActionController
{
	//This action displays the page allowing to edit ap ost
	public function editAction()
	{
		//Create the ofmr
		$form = new PostForm();

		///Get post ID
		$postId = $this->params()->fromRoute('id', -1);

		//Find existing post in the db
		$post = $this->entityManager->getRepository(Post::class)
					->findOneById($postId);

		if ($post == null) {
			$this->getResponse()->setStatusCode(404);
			return;
		}

		//Check wether this post is a POST request
		if ($this->getRequest()->isPost()) {

			//Get POST data
			$data = $this->params()->fromPost();

			//Fill form with data
			$form->setData($data);
			if ($form->isValid()) {

				//Get validated form data
				$data = $form->getData();

				//Use post manager service to add new post to the DB
				$this->postManager->updatePost($post, $data);

				//Redirect hte user to "admin" page
				return $this->redirect()->toRoute('posts', ['action'=>'admin']);
			}
		} else {
			$data = [
					  'title' => $post->getTitle(),
					  'content' => $post->getContent(),
					  'tags' 	=> $this->postManager->convertTagsToString($post),
					  'status' 	=> $post->getStatus()
				];

			$form->setData($data);
		}

		//Render the view template
		return new ViewModel([
				'form' => $form,
				'post' => $post
			]);
	}
}

In the code above, we extract the post ID using the fromRoute() method of the params() controller plugin.
Then we search for post having such ID using the findOneBy() provided by the entity repostiory.

Then we check if this is a POST request. If this is the POST request, we will fill in and validate the form
with POST data. Then we use the updatePost() method of the PostManager service.

Finally, create the application/post/edit.phtml file under the module's view directory. Place the following
content here:

<?php
$form = $this->form;
$form->get('title')->setAttributes([
	'class'=>'form-control',
	'placeholder'=>'Enter post title here'
	]);
$form->get('content')->setAttributes([
	'class'=>'form-control',
	'placeholder'=>'Tpye content here',
	'rows'=>6
	]);
$form->get('tags')->setAttributes([
	'class'=>'form-control',
	'placeholder'=>'comma, seperated, list, of, tags'
	]);
$form->get('status')->setAttributes([
	'class'=>'form-control'
	]);
$form->get('submit')->setAttributes(['class'=>'btn btn-primary']);
$form->get('submit')->setValue('Save');
$form->prepare();

?>

<h1>Edit Post</h1>

<p>
	pLease fill out the following form and click the save button
</p>

<div class="row">
	<div class="col-md-6">
		<?= $this->form()->openTag($form); ?>

		<div class="form-group">
			<?= $this->formLabel($form->get('title')); ?>
			<?= $this->formElement($form->get('title')); ?>
			<?= $this->formElementErrors($form->get('title')); ?>
		</div>

		<div class="form-group">
			<?= $this->formLabel($form->get('content')); ?>
			<?= $this->formElement($form->get('content')); ?>
			<?= $this->formElementErrors($form->get('content')); ?>
		</div>

		<div class="form-group">
			<?= $this->formLabel($form->get('tags')); ?>
			<?= $this->formElement($form->get('tags')); ?>
			<?= $this->formElementErrors($form->get('tags')); ?>
			<p class="help-block">Separate tags with comma</p>
		</div>

		<div class="form-group">
			<?= $this->formLabel($form->get('status')); ?>
			<?= $this->formElement($form->get('status')); ?>
			<?= $this->formElementErrors($form->get('status')); ?>
		</div>

		<?= $this->formElement($form->get('submit')); ?>

		<?= $this->form()->closeTag(); ?>
	</div>
</div>

Now, if you open the URL http://localhost/posts/edit/<id> in your web browser, you should be able to see the
Edit Post page that allows to edit an existing post.

Clicking Save saves to the DB.

Deleting a Post:

In this section, we implement the deleteAction() action of the PostController. This action will allow to delete
certain post given its ID. The action will take ID as a GET variable, look if a post with such a ID exists,
and if it exists, deletes the post, its related comments and tag associations.

Site visitor will be able to trigger the action by entering the following URL in browser's navigation bar:

http://localhost/posts/delete/<id>, where <id> is the unique identifier of the post. Finally, the action 
redirects the site visitor to the Admin apge.

Modifying PostManager:

First, we'll add the removePost() method to the PostManager service. This method will remove the post and its 
associated comments. It will also remove associations between post and tags:

<?php
//...
class PostManager
{
	//...

	//Remove post and all associated comments
	public function removePost($post)
	{
		//Remove associated comments
		$comments = $post->getComments();
		foreach ($comments as $comment) {
			$this->entityManager->remove($comment);
		}

		//Remove tag association (if any)
		$tags = $post->getTags();
		foreach ($tags as $tag) {
			$post->removeTagAssociation($tag);
		}

		$this->entityManager->remove($post);

		$this->entityManager->flush();
	}
}

In the code above, we first retrieve all comments associated with the post using the getComments() method of the Post entity.
Then we call EntityManager's remove() and pass it each comment that we want to remove.

Next, we get all tags associated with the post by calling Post's getTags() method. We remove association between the post
and tag (but not tag itself) with the help of the Post's removeTagAssociation() method (see below for the code of the method).

Finally, we remove the post itself by calling the EntityManager's remove() method. We apply changes to database with the
flush() method.

And here is the code of the Post::removeTagAssociation() method:

//Removes association between this post and the given tag
public function removeTagAssociation($tag)
{
	$this->tags->removeElement($tag);
}

Adding Controller Action:

The PostController::deleteAction() method retrieves the ID of the post to be removed, checks wether this is
a valid Post ID. If so, it calls the PostManager::removePost() method to remove the post and apply changes to DB.

Finally, it redirects the site visitor to the Admin page:

<?php

//..
class PostController extends AbstractActionController
{
	//This "delete" action displays the Delete Post page
	public function deleteAction()
	{
		$postId = $this->params()->fromRoute('id', -1);

		$post = $this->entityManager->getRepository(Post::class)
					->findOneById($postId);
		if ($post == null){
			$this->getResponse()->setStatusCode(404);
			return;
		}

		$this->postManager->removePost($post);

		//Redirect the user to index page
		return $this->redirect()->toRoute('posts', ['action'=>'admin']);
	}
}

Implementing Post Preview:

In this section, we will create controller's action and its corresponding view template that would allow site visitors
to preview certain post by entering the following URL in the browser's navbar: http://localhost/posts/view/<id>, where <id>
is the unique identifier of the post.

The page will allow to add comments to the post using the form located at the bottom of the page. For example of what we 
are trying to acheive, look at the page in the book.

For what we want, we need 4 things:

to create the form that would allow to enter the comment and it's author name

to modify the PostManager and add all necessary business logic

to create PostController::viewAction() controller's action

and to create the view.html view template

Adding CommentForm:

First, we implement the CommentForm form that will allow to add a comment to a post. Create the CommentForm.php file in Form
directory under module's source directory. Put the following code into that file:

<?php
namespace Application\Form;

use Zend\Form\Form;
use Zend\InputFilter\InputFilter;

/**
 * This is form used to collect comment data
 */
class CommentForm extends Form
{
	//Constructor
	public function __construct()
	{
		//Define form name
		parent::__construct('comment-form');

		//Set POSt method for this form
		$this->setAttribute('method', 'post');

		$this->addElements();
		$this->addInputFilter();
	}

	//This method add elements to form (input fields and submit button)
	protected function addElements()
	{
		//Add "author" field
		$this->add([	
				'type' 	=> 'text',
				'name' 	=> 'author',
				'attributes' => [
					'id' => 'author'
				],
				'options' => [
					'label' => 'Author',
				],
			]);

		//ADd comments field
		$this->add([
				'type' => 'textarea',
				'name' => 'comment',
				'attributes' => [[
					'id' => 'comment',
				],
				'options' => [
					'label' => 'Comment',
				],
			]);

		//add the submit button
		$this->add([
				'type' => 'submit',
				'name' => 'submit',
				'attributes' => [
					'value' => 'Save',
					'id' => 'submitbutton',
				],
			]);

	}

	//This method creates the InputFilter (used for form filtering/validation)
	private function addInputFilter()
	{
		$inputFilter = new InputFilter();
		$this->setInputFilter($inputFilter);

		$inputFilter->add([
					'name' 		=> 'author',
					'required' 	=> true,
					'filters' => [
						['name' => 'StringTrim'],
					],
					'validators' => [
						[
							'name' => 'StringLength',
							'options' => [
								'min' => 1,
								'max' => 128
							],
						],
					],
				]);

		$inputFilter->add([
					'name' 		=> 'comment',
					'required' 	=> true,
					'filters' => [
						['name' => 'StripTags'],
					],
					'validators' => [
						[
							'name' => 'StringLength',
							'options' => [
								'min' => 1,
								'max' => 4096
							],
						],
					],
				]);
	}
}

As we can see from above, the CommentForm form contains the author, comment fields, and the Submit button.

Since we covered forms since before, we won't cover that here.

Modifying PostManager:

Here, we add two methods:

the getCommentCountStr() method will format the comment count string to the given post (e.g "No comments", "1 comment", "2 comments", etc.)

and the addCommentToPost() method will be used for adding a new comment to post.

<?php
//...

/**
 * The PostManager service is responsible for adding new posts
 */
class PostManager
{
	//...

	//Returns count of comments for given post as properly formatted string
	public function getCommentCountStr($post)
	{
		$commentCount = count($post->getComments());
		if($commentCount == 0)
			return 'No comments';
		else if ($commentCount == 1)
			return '1 comment';
		else
			return $commentCount . ' comments';
	}

	//This method adds a new comment to the post
	public function addCommentToPost($post, $data)
	{
		//Create new commetn entity
		$comment = new Comment();
		$comment->setPost($post);
		$comment->setAuthor($data['author']);
		$comment->setContent($data['comment']);
		$currentData = date('Y-m-d H:i:s');
		$comment->setDateCreated($currentDate);

		//Add the entity to entity manager
		$this->entityManager->persist($comment);

		//Apply cnages
		$this->entityManager->flush();
	}
}

Adding Controller Action and View Template:

Now, add the PostController::viewAction method and pud the following code there:

<?php
//...
use Application\Form\CommentForm;
use Application\Entity\Comment;

class PostController extends AbstractActionController
{
	/**
	 * This action displays the "View Post" page allowing to see the post title
	 * and content. The page also contains a form allowing to add a comment to post
	 */
	public function viewAction()
	{
		$postId = $this->params()->fromRoute('id', -1);

		$post = $this->entityManager->getRepository(Post::class)
					->findOneById($postId);

		if ($post == null) {
			$this->getResponse()->setStatusCode(404);
			return;
		}

		$commentCount = $this->postManager->getCommentCountStr($post);

		//Create the form
		$form = new CommentForm();

		//Check wether this post is a POST request
		if($this->getRequest()->isPost()) {

			//Get POST data
			$data = $this->params()->fromPost();

			//Fill form data with data
			$form->setData($data);
			if($form->isValid()) {

				//Get validated form data
				$data = $form->getData();

				//Use post manager service to add new comment to post
				$this->postManager->addCommentToPost($post, $data);

				//Redirect the user again to "view" page
				return $this->redirect()->toRoute('posts', ['action'=>'view', 'id'=$postId]);
			}
		}

		//Render the view template

		return new ViewModel([
			'post' => $post,
			'commentCount' => $commentCount,
			'form' => $form,
			'postManager' => $this->postManager
		]);
	}
}

Finally, add the view.phtml view template file and put the following content there:

<?php
$form = $this->form;
$form->get('author')->setAttributes([
	'class'=>'form-control',
	'placeholder'=>'Author\'s name'
	]);
$form->get('comment')->setAttributes([
	'class'=>'form-control',
	'rows'=>6,
	'placeholder'=>'Text'
	]);
$form->get('submit')->setAttributes(['class'=>'btn btn-primary']);
$form->prepare();
?>

<a href="
	<?= $this->url('application', ['action'=>'index']); ?>">
	&lt;&lt; Back to list of posts
</a>

<h1>
	<?= $this->escapeHtml($post->getTitle()); ?>
</h1>

<p class="comments-header">
	<?= $this->escapeHtml($postManager->getCommentCountStr($post)); ?> |
	<a href="#comment">
		Add new comment
	</a>
</p>

<p>
	Published: <?= $this->escapeHtml(date('jS \of F Y', strtotime($post->getDateCreated()))); ?>
	| Tags <?= $this->escapeHtml($postManager->convertTagsToString($post)); ?>
</p>

<p>
	<?= $this->escapeHtml($post->getContent()); ?>
</p>

<h3><?= $this->escapeHtml($postManager->getCommentCountStr($post)); ?></h3>

<?php foreach ($post->getComments() as $comment): ?>

<hr>

<p>
	<?= $this->escapeHtml($comment->getAuthor()) ?> on
	<?= $this->escapeHtml($comment->setDateCreated()); ?>
</p>

<?php endforeach; ?>

<hr>

<a name="comment"></a>
<h3>Leave Reply</h3>

<div class="row">
	<div class="col-md-8">
		<?= $this->form()->openTag($form); ?>

		<div class="form-group">
			<?= $this->formLabel($form->get('author')); ?>
			<?= $this->formElement($form->get('comment')); ?>
			<?= $this->formElementErrors($form->get('comment')); ?>
		</div>

		<?= $this->formElement($form->get('submit')); ?>

		<?= $this->form()->closeTag(); ?>
	</div>
</div>

Implementing Admin Page:

Admin page of the Blog sample web application contains the list of all blog posts (either published or drafts), and allows
to view, edit and delete posts.

To implement hte page, add the adminAction() action method to the PostController class:

<?php

//...
class PostController extends AbstractActionController
{
	/**
	 * This is "admin" action displays the Manager Posts page. This page contains
	 * the list of posts with an ability to edit/delete any post.
	*/
	public function adminAction()
	{
		//Get posts
		$posts = $this->entityManager->getRepository(Post::class)
					->findBy([], ['dateCreated'=>'DESC']);

		//Render the view template
		return new ViewModel([
				'posts' => $posts,
				'postManager' => $this->postManager
			]);
	}
}

We will aos need to show a post status in text form ("Draft" or "published"). Conversion of integer post status
to string can be implemented in the getPostStatusAsString() method of PostManager service. Add the getPostStatusAsString()
method to PostManager class as follows:

/**
 * Returns status as string
 */
public function getPostStatusAsString($post)
{
	switch ($post->getStatus()) {
		case Post::STATUS_DRAFT: return 'Draft';
		case Post::STATUS_PUBLISHED: return 'Published';
	}

	return 'Unknown';
}

Finally, add the corresponding view template file admin.phtml to the application/post directory under module's view directory:

<h1>Manage Posts</h1>

<p>
<a class="btn btn-default" href="
	<?= $this->url('posts', ['action'=>'add']); ?>">
	New Post
</a>
</p>

<table class="table table-striped">
	<tr>
		<th>ID</th>
		<th>Post Title</th>
		<th>Date Created</th>
		<th>Status</th>
		<th>Actions</th>
	</tr>

	<?php foreach ($posts as $post): ?>

	<tr>
		<td><?= $this->escapeHtml($post->getId()); ?></td>
		<td>
			<a href="<?= $this->url('posts', ['action'=>'view', 'id'=>$post->getId()]); ?>">
				<?= $this->escapeHtml($post->getTitle()); ?>
			</a>
		</td>
		<td><?= $this->escapeHtml($post->getDateCreated()); ?></td>
		<td><?= $this->escapeHtml($postManager->getPostStatusAsString($post)); ?></td>
		<td>
			<a class="btn btn-info" href="<?= $this->url('posts',
					['action'=>'edit', 'id'=>$post->getId()]); ?>">
				<span class="glyphicon glyphicon-pencil" ></span> Edit
			</a>
			<a class="btn btn-danger" href="<?= $this->url('posts',
					['action'=>'delete', 'id'=>$post->getId()]); ?>">
				<span class="glyphicons glyphicon-remove"></span> Delete
			</a>
		</td>
	</tr>

	<?php endforeach; ?>

</table>

Now, if you open the URL http://localhost/posts/admin in web browsers navbar, you should the expected output.

Implementing Tag Cloud:

Anther major feature we implement in the Blog sample will be the tag cloud. The tag cloud appears on the home page.
The tag cloud contains most popular tags, and tags font sizes depend on popularity of the tag. The most popular tags
appear larger than less popular ones. Clicking the tag in the tag cloud results in filtering posts by this tag.

For this feature, we need the following things:

to create the PostRepository custom entity repository class that would encapsulate the complex logic of filtering
posts by tag.

to modify the the PostManager and add functionality for calculating font sizes for the tag cloud

to add Controller's action and corresponding view template

Adding Custom Post Repository:

Earlier we mentioned that by default Doctrine uses the Doctrine\ORM\EntityRepository as the default
repository class. Custom repository is a class extended from EntityRepository class. It is typically
used when you need to encapsulate complex DQL queries and search logic in a single place of your code.

It is also possible to put the DQL queries to control class, but that would make controllers "fat".
Since we use the MVC pattern, we strive to avoid that.

DQL is similar to SQL in sense that it allows to write and execute queries to db, but the result
of a query is an array of objects rather than an array of table rows. For more info, there is a page ni the book.

For our Blog sample web app, we need a custom repository which allowed to find published posts having at least one
tag (to calculate total count of tagged posts), and, to find published posts filtered by particular tag. We plan
to encapsulate this search logic into the custom PostRepository repository.

Doctrine works with custom repositories transparently. This means, that you retrieve the repository from
the EM as usual and still can use its findBy(), findOneBy() and other methods.

Create the PostRepository.php file inside the Repository directory under the module's source directory.
Below, you can find the code of PostRepository class that has two public methods:

the findPostsHavingAnyTag() method is designed to select all posts that have the status Published and have
>= 1 tag assigned

the findPostByTag() is designed to return all published posts that have the particular tag assigned:

<?php
namespace Application\Repository;

use Doctrine\ORM\EntityRepository;
use Application\Entity\Post;

//This is the custom repo class for repo entity
class PostRepository extends EntityRepository
{
	//Find all published posts having any tag
	public function findPostsHavingAnyTag()
	{
		$entityManager = $this->getEntityManager();

		$queryBuilder = $entityManager->createQueryBuilder();

		$queryBuilder->select('p')
			->from(Post::class, 'p')
			->join('p.tags', 't')
			->where('p.status = ?1')
			->orderBy('p.dateCreated', 'DESC')
			->setParameter('1', Post::STATUS_PUBLISHED);

		$posts = $queryBuilder->getQuery()->getResult();

		return $posts;
	}

	//Finds all published posts having the given tag
	public function findPostsByTag($tagName)
	{
		$entityManager = $this->getEntityManager();

		$queryBuilder = $entityManager->createQueryBuilder();

		$queryBuilder->select('p')
			->from(Post::class, 'p')
			->join('p.tags', 't')
			->where('p.status = ?1')
			->andWhere('t.name = ?2')
			->orderBy('p.dateCreated', 'DESC')
			->setParameter('1', POST::STATUS_PUBLISHED)
			->setParameter('2', $tagName);

		$posts = $queryBuilder->getQuery()->getResult();

		return $posts;
	}
}

In the code above, we use the query builder to conveniently create complex DQL queries.

in lines 17-22, we create a query which selects all published posts ordering them by date created in descending order.
Because we join posts with tags, here we only select posts which have at least one tag. In line 24, we execute the query.
If you are curious what DQL the query builder creates, here it is:

SELECT p FROM \Application\Entity\Post p JOIN p.tags t
WHERE p.status=?1 ORDER BY p.dateCreated DESC

The second one will look as follows:

SELECT p FROM \Application\Entity\Post p JOIN p.tags t
WHERE p.status=?1 AND t.name=?2 ORDER BY p.dateCreated DESC

To let Doctrine know that it should use the custom repository for Post entity, modify the Post entity's annotation as follows:

<?php
//...

/**
 * This class represents a single post in a blog.
 * @ORM\Entity(repositoryClass="\Application\Repository\PostRepository")
 * @ORM\Table(name="post")
 */
class Post
{
	//...
}

Above, in line 6, we use the repositoryClass parameter of the @ORM\Entity tag to tell Doctrine that it should use
PostRepository repository.

Calculating Tag Cloud:

Business logic for the tag cloud feature will be stored inside of the PostManager::getTagCloud() method, as follows:

<?php
//...
class PostManager
{
	//...

	//Calculates frequencies of tag usage
	public function getTagCloud()
	{
		$tagCloud = [];

		$posts = $this->entityManager->getRepository(Post::class)
						->findPostsHavingAnyTag();
		$totalPostCount = count($posts);

		$tags = $this->entityManager->getRepository(Tag::class)
					->findAll();
		foreach ($tags as $tag) {

			$postByTag = $this->entityManager->getRepository(Post::class)
						  ->findPostsByTag($tag->getName());

			$postCount = count($postByTag);
			if($postCount > 0) {
				$tagCloud[$tag->getName()] = $postCount;
			}
		}

		$normalizedTagCloud = [];

		//normalize
		foreach ($tagCloud as $name=>$postCount) {
			$normalizedTagCloud[$name] = $postCount/$totalPostCount;
		}

		return $normalizedTagCloud;
	}
}

In the code above, we have the getTagCloud() method that selects all post having at least one tag attached
and calculates the "frequency" of each available tag (how often the tag appears). Then it normalizes the frequency
values (makes them to be between 0 and 1.0)

Modifying Controller Action:

Here we will modify the IndexController to implement tag filter:

<?php
//...
class IndexController extends AbstractActionController
{
	/**
	 * Post manager
	 * @var Application\Service\PostManager
	 */
	private $postManager;

	//Constructor is used for injecting dependencies into the controller
	public function __construct($entityManager, $postManager)
	{
		$this->entityManager = $entityManager;
		$this->postManager = $postManager;
	}

	public function indexAction()
	{
		$tagFilter = $this->params()->fromQuery('tag', null);

		if ($tagFilter) {

			//Filter posts by tag
			$posts = $this->entityManager->getRepository(Post::class)
					->findPostsByTag($tagFilter);

		} else {
			//Get recent posts
			$posts = $this->entityManager->getRepository(Post::class)
					->findBy(['status'=>Post::STATUS_PUBLISHED],
							 ['dateCreated'=>'DESC']);
		}

		//Get popular tags
		$tagCloud = $this->postManager->getTagCloud();

		//Render the view template
		return new ViewModel([
			'posts' => $posts,
			'postManager' => $this->postManager,
			'tagCloud' => $tagCloud
		]);
	}
}

The action method retrieves posts if they contain tags, otherwise it just returns all.
In case there are tags, we use the custom findPostsByTag.

In lines 36, we call the PostManager::getTagCloud() that returns array of tags and their frequencies. We use this info
for rendering the cloud.

Please note that we are now using the PostManager service in our controller and have to inject it into the constructor.
Do not forget to modify the controller factory to do that.

Rendering Tag Cloud:

<h1>Posts</h1>

<div class="row">
	<div class="col-md-8">
	<?php foreach($posts as $post): ?>

	<h3>
		<a href="<?= $this->url('posts', ['action'=>'view', 'id'=>$post->getId()]); ?>">
			<?= $this->escapeHtml($post->getTitle()); ?>
		</a>
	</h3>

	<p>
		Published: <?= $this->escapeHtml(date('jS \of F Y', strtotime(post->getDateCreated()))); ?>
		| Tags: <?= $this->escapeHtml($postManager->convertTagsToString($post)); ?>
	</p>

	<p class="comments-header">
		<?= $this->escapeHtml($postManager->getCommentCountStr($post)); ?> |
		<a href="<?= $this->url('posts', ['action'=>'view', 'id'=>$post->getId()],
				['fragment'=>'comment']); ?>">
			Add new comment
		</a>
	</p>

	<p>
		<?= $this->escapeHtml($post->getContent()); ?>
	</p>

	<?php endforeach; ?>

	</div>

	<div class="col-md-4">
		<div class="panel panel-default">
			<div class="panel-heading">
				<h3 class="panel-title">Popular Tags</h3>
			</div>
			<div class="panel-body">
				<?php foreach($this->tagCloud as $tagName=>$frequency): ?>

				<a href="<?= $this->url('application', ['action'=>'index'],
					['query'=>['tag'=>$tagName]]); ?>">

					<span style="font-size:{{{PHP12}}}em">
						<?= $this->escapeHtml($tagName); ?>
					</span>
				</a>

				<?php endforeach; ?>
			</div>
		</div>
	</div>
</div>

Implementing Pagination:

For now we have only several posts on our Posts page. But assume that there are many (hundereds) of posts. The page will be
loading very slowly. Also, it would be very inconvinient to scroll the page to read all posts. In this situation, pagination
would help.

Pagination is when you divide your results into pages and navigate through pages by clicking number links on pagination widget.

Doctrine ORM Paginator:

The Doctrine\ORM component provides a paginator class named Paginator living in Doctrine\ORM\Tools\Pagination namespace.
It can take a Doctrine Query object as input and provides several methods for getting paged results (won't be covered here, for simplicity).

But, Doctrine ORM moule does not provide any view helpers to visualize the pagination widget. For that, we can use the pagination functionality
provided by ZF3.

Although we plan to use ZF3 pagination component, we will still use Doctrine ORM paginator internally for consuming data.
ZF3 paginator will be just a wrapper for Doctrine ORM paginator.

ZF3 Paginator:

In ZF3, pagination is implemented in Zend/Paginator component. If you have not installed this component, do so by typing
the following command:

php composer.phar require zendframework/zend-paginator

The Zend\Paginator component provides the Paginator class. Its most useful methods are as follows:

Methods of ZF3 Paginator Class:

setDefaultScrollingStyle($scrollingStyle = 'Sliding') 	Sets scrolling style

setDefaultItemCountPerPage($count) 						Sets maximum count of results per page

setCurrentPageNumber($pageNumber) 						Sets current page number

count() 												returns number of pages.

getTotalItemCount() 									Returns total number of results

getCurrentItems() 										get items on the current page.

The Paginator class is very generic and does not know the underlying data model, so you need to have an adapter
which provides the data to paginator. The DoctrineORMModule provides such adapter (DoctrineORMModule\Paginator\Adapter\DoctrinePaginator class)
which we can use to get data from ORM paginator and pass it to ZF3 paginator.

For example, assume we have a Query with a DQL that selects all published posts. To get the paginated results with this query, we can use
the following code:

<?php
use DoctrineORMModule\Paginator\Adapter\DoctrinePaginator as DoctrineAdapter;
use Doctrine\ORM\Tools\Pagination\Paginator as ORMPaginator;
use Zend\Paginator\Paginator;

//Creates ZF3 paginator
$adapter = new DoctrineAdapter(new ORMPaginator($query, false));
$paginator = new Paginator($adapter);

//Set page number and page size
$paginator->setDefaultItemCountPerPage(10);
$paginator->setCurrentPageNumber(1);

//Walk through the current page of results
foreach ($paginator as $post) {
	//Do something with the current post
}

Now let's apply this example to our Blog application. We want to display the paginated posts on the main page of the Blog website.

Modifying PostRepository:

First of all, we'll have to slightly modify the way we get the list of posts. Previously, we used the findBy() method of the
EntityRepository, which returns array of posts. But now we will have to do that with our custom repository class PostRepository,
because Doctrine ORM paginator takes Query object on input, not an array of posts.

Add the following method to PostRepository class:

public function findPublishedPosts()
{
	$entityManager = $this->getEntityManager();

	$queryBuilder = $entityManager->createQueryBuilder();

	$queryBuilder->select('p')
		->from(Post::class, 'p')
		->where('p.status = ?1')
		->orderBy('p.dateCreated', 'DESC')
		->setParameter('1', Post::STATUS_PUBLISHED);

	return $queryBuilder->getQuery();
}

And change the findPostsByTag() method, because we want it to also return Query instead of array:

public function findPostsByTag($tagName)
{
	$entityManager = $this->getEntityManager();

	$queryBuilder = $entityManager->createQueryBuilder();

	$queryBuilder->select('p')
		->from(Post::class, 'p')
		->join('p.tags', 't')
		->where('p.status = ?1')
		->andWhere('t.name = ?2')
		->orderBy('p.dateCreated', 'DESC')
		->setParameter('1', Post::STATUS_PUBLISHED)
		->setParameter('2', $tagName);

	return $queryBuilder->getQuery();
}

You will also need to slightly modify the PostManager::getTagCloud() method, because it expects an array of 
posts, but now it will receive the Query. It is a simple and obvious modification, so we won't describe how to do that
(check the blog example to see how its done).

Modifying IndexController:

Next, modify the indexAction() method of the IndexController as follows:

<?php
namespace Application\Controller;

//Add aliases for paginator classes
use DoctrineORMModule\Paginator\Adapter\DoctrinePaginator as DoctrineAdapter;
use Doctrine\ORM\Tools\Pagination\Paginator as ORMPaginator;
use Zend\Paginator\Paginator;
//...

class IndexController extends AbstractActionController
{
	//...

	public function indexAction()
	{
		$page = $this->params()->fromQuery('page', 1);
		$tagFilter = $this->params()->fromQuery('tag', null);

		if ($tagFilter) {

			//Filter posts by tag
			$query = $this->entityManager->getRepository(Post::class)
					->findPostsByTag($tagFilter);
		} else {
			//get recent posts
			$query = $this->entityManager->getRepository(Post::class)
					->findPublishedPosts();
		}

		$adapter = new DoctrineAdapter(new ORMPaginator($query, false));
		$paginator = new Paginator($adapter);
		$paginator->setDefaultItemCountPerPage(1);
		$paginator->setCurrentPageNumber($page);

		//get popular tags
		$tagCloud = $this->postManager->getTagCloud();

		//Render the view template
		return new ViewModel([
			'posts' => $paginator,
			'postManager' => $this->postManager,
			'tagCloud' => $tagCloud
		]);
	}
}

You can notice that in line 16 we get the current page number from a GET parameter. So, you can set the page of results
by entering the following URL in the browser: "http://localhost/application/index?page=<page>". The default page number is 1.

In lines 22 and 27, we retrieve the Query object from our PostRepository instead of array of posts. We then pass this Query
object to the ZF3 paginator in line 31.

In lines 33-34, we set the current page number and page size on the paginator.

In line 41, we pass the paginator(!) instead of array of posts for rendering to the view template.

Visualizing the Pagination Widget:

Now it's left the last but not least part of our work. We need to display the pagination widget in our view template.

To do that, with nice BS styling, we will need to first create a partial view template view/application/partial/paginator.phtml
and put the following code into that file:

<?php if ($this->pageCount): ?>

<nav>
<ul class="pagination">

<!-- Previous page link -->
<?php if (isset($this->previous)): ?>
	<li>
		<a href="<?= $this->url($this->route, [], ['query'=>['page'=>$this->previous]]); ?>" aria-label="Previous">
			<span aria-hidden="true">&laquo;</span>
		</a>
	</li>
<?php else: ?>
	<li>
		<span aria-hidden="true">&laquo;</span>
	</li>
<?php endif; ?>

<!-- Numbered Page Links -->
<?php foreach ($this->pagesInRange as $page): ?>
	<?php if ($page != $this->current): ?>
		<li>
			<a href="<?= $this->url($this->route, [], ['query'=>['page'=>$page]]); ?>"><?=$this->escapeHtml($page); ?></a>
		</li>
	<?php else: ?>
		<li>
			<span aria-hidden="true"><b><?= $this->escapeHtml($page); ?></b></span>
		</li>
	<?php endif; ?>
<?php endforeach; ?>

<!-- Next page link -->
<?php if (isset($this->next)): ?>
	<li>
		<a href="<?php echo $this->url($this->route, [], ['query'=>['page'=>$this->next]]); ?>" aria-label="Next">
			<span aria-hidden="true">&raquo;</span>
		</a>
	</li>
<?php else: ?>
	<li>
		<span aria-hidden="true">&raquo;</span>
	</li>
<?php endif; ?>
</ul>
</nav>
<?php endif; ?>

The partial view template will be used by the ZF3 PaginationControl view helper to visualize the pagination widget.
As you can see, this partial view template takes several input variables ($pageCount, pagesInRange, $current, $previous, $next, $route)
that are used to control how the widget will look like.

Now, let's display the widget on our view/application/index/index.phtml view template below the list of posts, as follows:

<?= $this->paginationControl($posts,
			'Sliding',
			'application/partial/paginator',
			['route' => 'application']); ?>

The PaginationControl view helper accepts four arguments:

the $posts is the Paginator object that we passed from controller's action with the ViewModel variable container.

the "Sliding" argument is the style of pagination. For addional info on available pagination styles, please refer to Zf documentation.

the "application/partial/paginator" is teh name of the partial view template containing the markup for the pagination widget

the fourth argument can be used to pass parameters to the partial view template. For example, we pass it the route parameter,
which is used to generate clickable page links.

Results:

It now works. To implement more advanced pagination, we could use the jQuery DataTables plugin (link is on page in book).
It allows for allowing interactively storing results by certain fields.

Database Migrations:

When you are developing your website, you are constantly modifying your database schema: some tables are being added,
others are being modified, unneeded tables are being deleted. Managing database schema may become a very complex task,
because you need to keep it up-to-date on your development, testing and production servers. You can greatly simplify
the task of managing DB Schema with the concept of Migrations.

A migration is some kind of atomic change of state of the DB schema. You can apply a migration to upgrade schema to its
newer state, or you can revert a migration to downgrade secham to its previous state. You can create new migrations
as you develop your website, and you can have as many migrations as you need.

All migrations from a database schema change history, which is very convenient, because you will know when and for what
purpose you changed the schema.

Installing Doctrine\Migrations component:

Doctrine provides a special component Doctrine\Migrations that you can use for implementing database migrations in your
website. To install Doctrine\Migrations component, type the following command:

php composer.phar require doctrine/migrations

The command above will download and install the component files to the vendor directory and modify your composer.json
file as follows:

{
	...
	"require": {
		...
		"doctrine/migrations": "^1.4",
	},
}

Configuring Migrations:

Before you can use migrations, you'll need to provide the configuration describing what database connection to use,
in which table to store migration history, where to store migration classes, etc. To do that, add the following
lines to your config/autoload/global.php file:

<?php
return [
	'doctrine' => [
		//Migration configuration
		'migrations_configuration' => [
			'orm_default' => [
				'directory' => 'data/Migrations',
				'name' 		=> 'Doctrine Database Migrations',
				'namespace' => 'Migrations',
				'table' 	=> 'migrations',
			],
		],
	],
	//...
];

As you can see, we have the doctrine key and its migrations_configuration subkey (line 5). Under this subkey
we provide the configuration for migrations:

In line 6, we provide the name of entity manager to use (orm_default)

in line 7, we tell Doctrine that we want to store migrations under the APP_DIR/data/Migrations directory

in line 8, we provide a user-friendly name for our migrations

In line 9, we tell Doctrine that we want that our migration classes to live in the namespace Migrations. We can specify
the namespace of our choise.

In line 10, we tell Doctrine that we want to store migrations inside of migrations database table. Doctrine will create
and manage that table automatically.

Creating Migrations:

A migration is a change set upgrading or downgrading the schema to its next or previous state, respectively. You generate
 a new empty migration with the help of the following commands:

cd APP_DIR
./vendor/bin/doctrine-module migrations:generate

The commands above make the directory the cwd and then run the migrations:generate console command.

DoctrineModule and DoctrineORMModule provide several console commands that you can use for various database maintenance
tasks (like generating or executing migrations). For the list of available commands, you can use the list command:

./vendor/bin/doctrine-module list

Once you run the migrations:generate command, you will be able to find the newly created migration under the APP_DIR/data/Migrations
directory. The file has a name like VersionYYYYMMDDHHIISS.php where YYYY is year, MM is month, DD is day, HH, II, SS is Hour/Minute/Second.

If we look into the newly created file, we will find the following content:

<?php

namespace Migrations;

use Doctrine\DBAL\Migrations\AbstractMigration;
use Doctrine\DBAL\Schema\Schema;

/**
 * Auto-Generated migration: Please modify to your needs
 */
class Version2016090114333 extends AbstractMigration
{
	/**
	 * @param Schema $schema
	 */
	public function up(Schema $schema)
	{
		//This up() migration is auto-generated, please modify it yto your needs
	}

	/**
	 * @param Schema $schema
	 */
	public function down(Schema $schema)
	{
		//This down() migration is auto-generated, please modify it to your needs
	}
}

If you do not see the newly created migration in NetBeans IDE, you need to open the menu Source and
select the Scan for external changes menu item.

As you can see from the code above, a migration is a usual PHP class inherited from Doctrine\DBAL\Migrations\AbstractMigration
base class. Every migration should have at least two methods: up() and down(). The up() method updrades the schema
to a newer state, the down() method downgrades the schema from its newer state to its previous state.

Both up() and down() methods have a single argument of type Doctrine\DBAL\Schema\Schema, which can be used for 
actual DB schema modifications.

The Schema class is a part of Doctrine\DBAL component. For more info about the method it provides, please refer
to Doctrine DBAL Documentation. ANother better way, is to look at the code inside of our vendor/doctrine/dbal directory.

A migration class may optionally have the following (overriden) methods:

Methods a Migration class may have:

isTransactional() 		If this function returns true (default) the migration will be executed in one transaction,
						otherwise non-transactional state will be used to execute each of the migration SQLs.

getDescription() 		This method should return a string describing the migration (for what purpose this schema change is done)

preUp(Schema $schema) 	This method will be executed before upgrading the schema

postUp(Schema $schema) 	This method will be executed after upgrading the schema

preDown(Schema $schema) Occurs before downgrading the schema

postDown(Schema $schema) Occurs after downgrading schema

The AbstractMigration base class also provides the following useful methods:

Methods provided by the base migration class:

addSql($sql, array $params = [], array $types = []) 		This method allows to execute an arbitrary SQL request

write($message) 											This helper method prints a debug or explanatory message to the screen

throwIrreversibleMigrationException($message = null) 		This helper method is typically called inside of down() method to signal that
															the migration cannot be undone.

As you can see from above, we can also modify the schema by the addSql() method. This method can be used to create a table, to update
a table or to remove a table. it can also be used, for example, to insert some data to a table (however, inserting data is not a schema change)

Doctrine migrations are used for Schema changes, not for inserting data to the DB. Although, inserting some initial
data to a DB is useful in some cases.

Now taht we know how to make migrations, let's create a couple of migrations for our Blog sample.

Creating the Initial Migration:

The first migration we will create is the initial migration. This migration will be applied to empty database schema
and will create four tables: post, comment, tag and post_tag.

Modify the migration class we have created in the following section to look like below:

<?php

namespace Migrations;

use Doctrine\DBAL\Migrations\AbstractMigration;
use Doctrine\DBAL\Schema\Schema;

/**
 * A migration class. It either upgrades the DB schema (moves it to a new state)
 * or downgrades it to the previous state
 */
class Version20160901114333 extends AbstractMigration
{
	/**
	 * Returns the desc. of this migration
	 */
	public function getDescription()
	{
		$description = 'This is the initial migration which creates blog tables.';
		return $description;
	}

	/**
	 * @param Schema $schema
	 */
	public function up(Schema $schema)
	{
		//Create 'post' table
		$table = $schema->createTable('post');
		$table->addColumn('id', 'integer', ['autoincrement'=>true]);
		$table->addColumn('title', 'text', ['notnull'=>true]);
		$table->addColumn('content', 'text', ['notnull'=>true]);
		$table->addColumn('status', 'integer', ['notnull'=>true]);
		$table->addColumn('date_created', 'datetime', ['notnull'=>true]);
		$table->setPrimaryKey(['id']);
		$table->addOption('engine', 'InnoDB');

		//Create 'comment' table
		$table = $schema->createTable('comment');
		$table->addColumn('id', 'integer', ['autoincrement'=>true]);
		$table->addColumn('post_id', 'integer', ['notnull'=>true]);
		$table->addColumn('content', 'text', ['notnull'=>true]);
		$table->addColumn('author', 'string', ['notnull'=>true, 'length'=>128]);
		$table->addColumn('date_created', 'datetime', ['notnull'=>true]);
		$table->setPrimaryKey(['id']);
		$table->addOption('engine', 'InnoDB');

		//Create 'tag' table
		$table = $schema->createTable('tag');
		$table->addColumn('id', 'integer', ['autoincrement'=>true]);
		$table->addColumn('name', 'string', ['notnull'=>true, 'length'=>128]);
		$table->setPrimaryKey(['id']);
		$table->addOption('engine', 'InnoDB');

		//Create 'post_tag' table
		$table = $schema->createTable('post_tag');
		$table->addColumn('id', 'integer', ['autoincrement'=>true]);
		$table->addColumn('post_id', 'integer', ['notnull'=>true]);
		$table->addColumn('tag_id', 'integer', ['notnull'=>true]);
		$table->setPrimaryKey(['id']);
		$table->addOption('engine', 'InnoDB');
	}

	/**
	 * @param Schema $schema
	 */
	public function down(Schema $schema)
	{
		$schema->dropTable('post_tag');
		$schema->dropTable('tag');
		$schema->dropTable('comment');
		$schema->dropTable('post');
	}
}

In the code above, we have three methods:

the getDescription() method provides the description of the migration

the up() method upgrades the schema to its newer state by adding new tables

the down() method drops tables thus downgrading the schema to its previous state

Adding Another Migration:

Now assume we decided to improve the performance of our DB by adding indexes to our tables.

If you want to learn about DB indexes in more detail and why indexes are so helpful, you can refer
to an excellent tutorial (found in book in this page).

We can also improve dataintegrity by adding foreign keys. To do this, we have to add another migration.
Generate another empty migration with the migrations:generate console command. Modify the code to look as follows:

<?php

namespace Migrations;

use Doctrine\DBAL\Migrations\AbstractMigration;
use Doctrine\DBAL\Schema\Schema;

/**
 * A migration class. It either upgrades the DB schema (movesi t to a new state)
 * or downgrades it to the previous state
 */
class Version20160901114938 extends AbstractMigration
{
	/**
	 * Returns the desc of this migration
	 */
	public function getDescription()
	{
		$description = 'This migration adds indexes and foreign keys contraint';
		return $description;
	}

	/**
	 * @param Schema $schema
	 */
	public function up(Schema $schema)
	{
		//Add index to post table
		$table = $schema->getTable('post');
		$table->addIndex(['date_created'], 'date_created_index');

		//Add index and foreign key to comment table
		$table = $schema->getTable('comment');
		$table->addIndex(['post_id'], 'post_id_index');
		$table->addForeignKeyConstraint('post', ['post_id'], ['id'], [], 'comment_post_id_fk');

		//Add indexes and foreign keys to post_tag table
		$table = $schema->getTable('post_tag');
		$table->addIndex(['post_id'], 'post_id_index');
		$table->addIndex(['tag_id'], 'tag_id_index');
		$table->addForeignKeyConstraint('post', ['post_id'], ['id'], [], 'post_tag_post_id_fk');
		$table->addForeignKeyConstraint('tag', ['tag_id'], ['id'], [], 'post_tag_tag_id_fk');

	}

	/**
	 * @param Schema $schema
	 */
	public function down(Schema $schema)
	{
		$table = $schema->getTable('post_tag');
		$table->removeForeignKey('post_tag_post_id_fk');
		$table->removeForeignKey('post_tag_tag_id_fk');
		$table->dropIndex('post_id_index');
		$table->dropIndex('tag_id_index');

		$table = $schema->getTable('comment');
		$table->dropIndex('post_id_index');
		$table->removeForeignKey('comment_post_id_fk');

		$table = $schema->getTable('post');
		$table->dropIndex('date_created_index');
	}
}

We can find the migrations we just created, inside of the Blog sample bundled with this book.

Executing Migrations:

Once our migration classes are ready, you can apply the migrations to DB. To do that, you use the migrations:migrate
console command as follows:

./vendor/bin/doctrine-module migrations:migrate

The command above applies all available migrations in turn. It writes the IDs of the applied migration to the migrations
database table.

After that, the migrations table will look as follows:

mysql> select * from migrations;

version

20160901114333
20160901114938

If you want to upgrade or downgrade to some specific version, specify the Migration ID as the migrations:migrate command
argument as follows:

./vendor/bin/doctrine-module migrations:migrate 20160901114333

YTou can also use the 'prev', 'next' and 'first' alises as version ID's which respectively move DB to its previous state,
next state or the state before the first migration (empty DB).

So, with migrations, we can move through migration history and change the DB schema as needed. Be careful though,
that migrations may remove some of your data, so apply them wisely.

Creating a New Module:

When your website grows in size, you can benefit from using ZF3 feature called modules. Modular applications consists
of pieces that have relativily few dependencies on each other. This allows to install or remove modules on demand.
In this chapter, you will learn what a ZF3 module is, when to create it and how to create it.

When to Create a New Module?

A module is an autonomous and reusable unit of your application. By default your application has the single Application module.
And it is normal to put your models, views and controllers in this module, especially in a simple website.

A module can contain models, views, controllers and assets. Module classes typically live in a separate namespace (the
same as module name). Module has its own configuration file where you can register routes, controllers, controller plugins,
services, view helpers and so on.

You may need to create a new module when any of the following is true:

If your website is relativily large and dividing it into pieces would make it easier to maintain. For example, you can
introduce the Admin module and put your backend functionality into that module.

If the functionality you are implementing is autonomous (has no or few dependencies on other modules of your application.
For example, the Blog functionality in theory can be separated in another module, because it does not depend on the 
rest of the application, but the application depends on it).

If a module can be separated from your application and concurrently used in another project. For example, the Blog module can
be resued in anotehr project without changes (only its configuration may require changes).

In any case, RL is complex, so create one when you judge there is benefit to it.

At the same time, you should not create a huge number of almost empty modules, it is better to combine related functionality
in a single module.

How to Create a New Module:

There are at least two ways of creating a new module in your website. The first way is copying an existing module from
APP_DIR/module directory (such as Application module), removing any unnecessary controllers, models and views, and renaming
the existing namespace into your module name in every source file.

The second way is downloading an empty skeleton module from the official ZF repo in GitHub. You can find this
repo at <page in book>. We can clone or download the code as ZIP.

For example in Linux, use the following commands to download the skeleton module:

cd ~
wget https://github.com/zendframework/ZendSkeletonModule/archive/master.zip
unzip master.zip
cp ZendSkeletonModule-master APP_DIR/module/ZendSkeletonModule

The commands above download the source of the skeleton module to your home dir, unpack the archive and copy
the files to your website's module directory.

Let's look at the structure of the skeleton module:

V ZendSkeletonModule
	V config
		module.config.php
	V src
		V Controller
			SkeletonController.php
		Module.php
	> tests
	V view
		V zend-skeleton-module
			V skeleton
				index.phtml
	LICENSE.md
	README.md

As you can see, we have a typical Dir structure we are already familiar with:

config subdirectory contains module:config.php file which is the configuration file for this module.

src subdirectory is a directory containing module's source files

	Controller subdirectory contains a sample controller class

	Module.php file is the module entry point. We will discuss it a bit later

tests subdirectory contains a stub for unit tests for this module. We do not cover unit tests in this book for simplicity.

view subdirectory contains view scripts (and also may contain module-specific layout templates)

Renaming the Skeleton Module:

Before you can use the new empty module, you should choose a name for it. A good name describes the module well.
For example, the name Admin is good when you need a module for backend stuff. Blog name would be good if you plan
to store blog functionality in this module. A good practice is also prepending some vendor name to the module name,
for example YourCompanyBlog

Once you have chosen the name for the module, you should rename the directory containing module files. For example,
the command below will rename the module into Admin:

mv ZendSkeletonModule Admin

Next, you should rename the SkeletonController.php into something more descriptive. Don't forget to rename subdirs
of view directory to reflect the name of the controller.

Finally, walk through configuraion and source files of the controller and make sure you renamed the namespace
ZendSkeletonModule to the name of your module (this is required to ensure your classes will be found by PHP class autoloader).

Enabling Class Autoloading:

The last step is to enable PHP class autoloading. Our module source files will be organised to conform to PSR-4 standard,
so we will be able to use standard autoloader provided by Composer. To do that, add the following line into your 
composer.json file under the psr-4 key (substitue your module-name)

...
"autoload": {
		"psr-4": {
			...
			"Admin\\": "module/Admin/src"
		}
	},
...

Next, run the following command to update COmposer autoloader files:

php composer.phar dump-autoload

The dump-autoload command just regenerates autoloader code without installing or updating any dependencies.

Great! The module is now ready for use. You can add controllers, models and views into it. Do not forget to modify
the module.config.php file and register your routes, services, controllers, controller plugins, view helpers etc.

Enabling the Module:

To let ZF3 know about the new module and let it load on app start up, do not forget to enable your new module in 
your APP_DIR/config/modules.config.php file as follows:

return [
	'Admin',
	//...
); //Syntax error in the book? compare to other returns

Module.php File & Event Listening:

The Module.php file located inside of module's source directory is some kind of module entry point. The Module class
defined in this file is loaded by Zend\ModuleManager component when it loads all application modules.

One useful thing you can do with this class is registering to events. If you remember since earlier, the application
has several life stages represented by events. You may write an event listener function (or class) and register it
in your module entry point.

When an event is triggered, your listener method (or class) will be called allowing you to do something useful.

Why would i want to register an event listener?

Here are several practical applications of event listening that you may find useful:

Listen to Route event to force the use of HTTPS connection

When your website is in maintenance mode, listen to Route event to catch all requests and redirect the user
to a single page.

Listen to Dispatch event to redirect a user to a different page. For example, if user is not authenticated,
redirect him to the login page.

Listen to Dispatch event to override the default layout template for all controllers belonging to the module.

Listen to Dispatch Error event to log and/or report any exception or error happening in your website.

Listen to Render event to modify the content of the resulting web page.

There are two ways to register an event listener within the Module class: either with the help of Module's init()
method or with the help of its onBootstrap() method. The difference between init() and onBootstrap() is that the 
init() method is called ealiar than onBootstrap(), before all other modules are initialized, while onBootstrap()
calls it after all modules are initialized.

In the following examples, we use the init() method:

Example 1: Switching Layout Template:

To show you how to subscribe to an event, let's create an event listener that will react on Dispatch event
and set a different layout template for all controllers of the module:

<?php
namespace YourCompanyModule;

use Zend\ModuleManager\ModuleManager;
use Zend\Mvc\MvcEvent;

class Module
{
	//The "init" method is called on application start-up and
	// allows to register an event listener
	public function init(ModuleManager $manager)
	{
		//Get event manager
		$eventManager = $manager->getEventManager();
		$sharedEventManager = $eventManager->getSharedManager();

		//Register the event listener method
		$sharedEventManager->attach(__NAMESPACE__, 'dispatch', [$this, 'onDispatch'], 100);
	}

	//Event listener method
	public function onDispatch(MvcEvent $event)
	{
		//Get controller to which the HTTP request was dispatched
		$controller = $event->getTarget();
		//Get fully qualified class name of the controller
		$controllerClass = get_class($controller);

		//Get module name of the controller
		$moduleNamespace = substr($controllerClass, 0, strpos($controllerClass, '\\'));

		//Switch layout only for controllers belonging to our module
		if ($moduleNameSpace == __NAMESPACE__) {
			$viewModel = $event->getViewModel();
			$viewModel->setTemplate('layout/layout2');
		}
	}

	//....
}

In the code above, we add the init() method to the Module class. In that method, we register an event listener
(line 17) with the help of attach() method provided by the Zend\EventManager\SharedEventManager class. The attach()
method takes four arguments: the ID of the emitting component, the event name ("dispatch"), the event listener method
(the onDispatch() method of the current class), and the priority (100).

The onDispatch() method is called on the Dispatch event. In this method, we check (line 32) if the HTTP request
is dispatched to the controller belonging to our module, and if so, switch the layout template. (line 34)

Example 2: Forcing the use of HTTPS:

In this example, we will show how to register an event listener that makes the website always use HTTP connection with
all of your web pages:

<?php
namespace YourCompanyModule;

use Zend\ModuleManager\ModuleManager;
use Zend\Mvc\MvcEvent;

class Module
{
	//The "init" method is called on application start-up and
	// allows to register an event listener
	public function init(ModuleManager $manager)
	{
		//Get event manager
		$eventManager = $manager->getEventManager();
		$sharedEventManager = $eventManager->getSharedManager();

		//Register the event listener method
		$sharedEventManager->attach(__NAMESPACE__, 'route', [$this, 'onRoute'], 100);


	}

	//event listener method
	public function onRoute(MvcEvent $event)
	{
		if (php_sapi_name() == "cli") {
			//Do not execute HTTPS redirect in console mode
			return;
		}

		//Get request URI
		$uri = $event->getRequest()->getUri();
		$scheme = $uri->getScheme();

		//If scheme is not HTTPS, redirect to the same URI, but with HTTPS scheme
		if ($scheme != 'https'){
			$uri->setScheme('https');
			$response=$event->getResponse();
			$response->getHeaders()->addHeaderLine('Location', $uri);
			$response->setStatusCode(301);
			$response->sendHeaders();
			return $response;
		}
	}

	//...
}

In the code above, we register an event listener method that is called on Route event.

Inside the listener, we first check if our website is working in console mode. We do not redirect HTTPS in console mode.

Then, we extrract the URI from the HTTP request and check if the current scheme is HTTPS or not. If the scheme is not
HTTPS, we redirect the user to the same URL, but with HTTPS scheme.

Example 3: Reporting All Exceptions in Your Website:

With this technique, you can easily track all exceptions happening in your website. Reporting exceptions and errors is an
important thing, because it allows to make your website more stable, secure and improve user experience.

<?php
namespace YourCompanyModule;

use Zend\ModuleManager\ModuleManager;
use Zend\Mvc\MvcEvent;

class Module
{
	//The "init" method is called on application start up and
	//allows to register an event listener
	public function init(ModuleManager $manager)
	{
		//Get event manager
		$eventManager = $manager->getEventManager();
		$sharedEventManager = $eventManager->getSharedManager();

		//Register the event listener method
		$sharedEventManager->attach(__NAMESPACE__, MvcEvent::EVENT_DISPATCH_ERROR,
										[$this, 'onError'], 100);

		$sharedEventManager->attach(__NAMESPACE__, MvcEvent::EVENT_RENDER_ERROR,
										[$this, 'onError'], 100);
	}

	//event listener method
	public function onError(MvcEvent $event)
	{
		//Get the exception information
		$exception = $event->getParam('exception');
		if ($exception!=null) {
			$exceptionName = $exception->getMessage();
			$file = $exception->getFile();
			$line = $exception->getLine();
			$stackTrace = $exception->getTraceAsString();
		}
		$errorMessage = $event->getError();
		$controllerName = $event->getController();

		//prepare email message
		$to = 'admin@yourdomain.com';
		$subject = 'Your website exception';

		$body = '';
		if(isset($_SERVER['REQUEST_URI'])) {
			$body .= "Request URI: " . $_SERVER['REQUEST_URI'] . "\n\n";
		}
		$body .= "Controller: $controllerName\n";
		$body .= "Error message: $errorMessage\n";
		if ($exception!=null) {
			$body .= "Exception: $exceptionName\n";
			$body .= "File: $file\n";
			$body .= "Line: $line\n";
			$body .= "Stack trace:\n\n" . $stackTrace;
		}

		$body = str_replace("\n", "<br>", $body);

		//Send an email about the error
		mail($to, $subject, $body);
	}

	//...
}

In the code above, we register an event listener that will be called on every Dispatch Error (route mismatch or
an exception) and Renderer Error. Inside the onError() listener method, we extract some information about the exception/error
and send it as an email to the address of our choice.

Registering the Module as a Composer Package:

If you are writing a reusable module that you plan to make publically available, you may want to publish the code of your
module on GitHub and register it on Packagist.org catalogue as a Composer-installable package. This is absolutely free.

After you register the package, you will be able to add it as a dependency to your web app as follows (replace the vendor
and package PHs with your company name and package names, respectively):

php composer:phar require vendor/package

Composer will download and install your module to the vendor directory, so you will be able to use any third-party module.

14.5 Summary:

In this chapter, you learned of the concept modules in ZF3. A module is an autonomous and reusable unit of your application.
You may create a new module when your website becomes larger and when the functionality has very few dependencies on other 
parts of your application.

Every ZF3 module has an entry point class called Module. You may use that class to register an event listener. Event listenrs
are useful for example, when you want to tweak change the default layout template for the entire module, or tweak the
default content of a web page.

If you are developing a module that we want to publically make available, we can register our module on Packagist.org
catalogue and install it with Composer as third-party package.

User Management, Authentication and Access Filtering:

Most websites on the Internet allow their visitors to register on the site and create a profile. After that, the visitor
can log in and have a personalized experience. For example, in a E-commerce website, a registered user can buy goods,
manage their shopping cart and make a payment with a credit card.

In this chapter, you will learn about how to implement user authentication with login and password in a ZF3 website.
We will show how to manage users (add, edit, view and change/reset password) in your web application and store user's
password in DB securely.

You will also learn how to implement access filter and allow certain pages to be accessed by authorized users only.

Since you have already known a lot about ZF3 from reading previous chapters, in this chapter we will omit discussing
some obvious things and concentrate on conceptual moments only. It is recommended that you refer to the User Demo
sample bundle with this book, which is a complete website that you can run and see everything in action.

All code discussed in this chapter is part of this sample application.

ZF3 compenents covered in this chapter:

Zend\Authencation 	Provides user authentication feature

Zend\Crypt 			Provides functionality for password encryption

Zend\Math 			Provides functionality for generating secure random tokens.

Get User Demo Sample from GitHub:

For demonstration in this chapter, we will create a real-life User Demo website that shows how to:

Create a new module named User. This module will contain the functionality for user authentication
and user management.

Create User entity

Implementing storing user's password in DB securely

Implementing user authentication (with login and pw)

Implementing access filter to provide access to certain pages to authenticated users only

Implementing user management UI that allows to add, edit, view a user and change user's PW.

Implementing main menu items differently based on whether the current user is logged in or not.

To download the User Demo application, visit <page> and click Clone or Download button to download 
the code as a ZIP archive. When download is complete, unpack the archive to some dir.

Then navigate to the userdemo directory containing the source code of the User Demo web app:

/using-zf3-book-samples
	/userdemo
	...

The User Demo is a website which can be installed on your machine.

Detailed instructions on how to install it, can be found in the README.md file located in sample directory.

Creating the User Module:

In the User Demo sample, we create a new module called User and add all functionality related to user management
and authentication to that module. If you are new to the concept of modules, refer to the chapter Creating a New Module.

The User module will have very few dependencies on other modules of the website. The idea behind the User module is to
give you a reusable unit that you can use in your own web application, without any changes or with some modifications.


Ideally, you will be able to use the User module in your own website without any changes. But, in real-life websites,
you'll probably have to add some fields to the user table, modify the user creation workflow, or modify the access
filtering algorithm. If this is the case, you'll have to customize the code of the User module to fit your needs.

The User module will have the following structure:

V User
	V config
		module.config.php
	V src
		V Controller
			> Factory
			AuthController.php
			UserController.php
		V Entity
			User.php
		V Form
			LoginForm.php
			PasswordChangeForm.php
			PasswordResetForm.php
			UserForm.php
		V Service
			> Factory
			AuthAdapter.php
			AuthManager.php
			UserManager.php
		V Validator
			UserExistsValidator.php
		Module.php
	> test
	V view
		V user
			> auth
			> user

Let's briefly describe what classes we will have inside module's directory:

We will have two controllers:

The UserController will contain functionality for managing users (adding, editing, changing password, etc.)

The AuthController will implement user authentication functionality (login/logout)

There will be one Doctrine entity:

The User entity will be used to store information about the user in database (email, full name, password, etc)

We will have four forms used to collect data:

The LoginForm will be used to collect data for authentication (login and password)

The PasswordChangeForm will be used to collect data for changing or resetting user's password

The PasswordResetForm will be used to collect the E-mail of the person who forgot his/her password and wishes to
reset the password.

The UserForm will be used to collect data about the user (email, full name, password, etc.)

We will have several services:

The AuthAdapter service will implement the authentication algorithm. It will check if user login (E-mail address)
and password are correct. For performing that, it will retrieve user information from db.

The AuthManager service will perform actual authentication (login/logout). It will also implement the access filter
allowing or denying unauthorized user access certain web pages.

The UserManager will contain business logic of managing users (adding, editing, changing PW).

Most controllers and services will be instansiated with factories. You can find the factory classes under the Factory subdir.

Inside the view directory, we will have several view templates which will render HTML markup of the web pages present in the
user interface exposed by our module.

As usual, inside the config directory, we will have the module.config.php that will contain routes and registration for our
controllers and services. It will also contain the access_filter key defining which web pages exposed by module will be accessible
by unautorized user (This key will be read by AuthManager service).

As you can see, the User module is a typical ZF3 module with the structure conforming to the MVC pattern.

Setting Up the Database:

We will need to set up a sample "userdemo" database. The database will have a single table named user for storing data associated
with users of our website.

	<user>
id
email
full_name
password
status
date_created
pwd_reset_token
pwd_reset_token_creation_date

The user table contains the following fields:

the id is an auto-incremented integer field (primary key)

the email is a string field containing user's E-mail address. Each user will have a unique E-mail address, so this field, is a unique key.

the full_name string field will contain the full name of a user (like "John Doe")

the status integer field will contain user's status (either "active" or "inactive"). Retired users are not allowed to log in.

the date_created contains date and time when the user was created.

the pwd_reset_token and pwd_reset_token_creation_date fields are used for password resetting (when the user forgets his/her password
and needs to reset it).

In your own website, you will likely want to add more fields to the user table. In this sample, we only define some minimum set of fields.

You can create the user table with the following SQL statement:

CREATE TABLE `user` (
	`id` int(11) NOT NULL AUTO_INCREMENT,
	`email` varchar(128) NOT NULL,
	`full_name` varchar(512) NOT NULL,
	`password` varchar(256) NOT NULL,
	`status` int(11) NOT NULL,
	`date_created` datetime NOT NULL,
	`pwd_reset_token` varchar(32) DEFAULT NULL,
	`pwd_reset_token_creation_date` datetime DEFAULT NULL,
	PRIMARY KEY (`id`),
	UNIQUE KEY `email_idx` (`email`)
);

You can find a migration, which creates the user table, in the User Demo sample app.

Implementing User Entity:

The User Demo sample uses Doctrine ORM for managing DB. we have already learned how to use Doctrine in DB management with Doctrine ORM.

For storing information about users in DB, we will create the User entity. The User entity is mapped onto the user db table. It is 
a typical Doctrine entity class.

Create the User.php file inside the Entity directory under the module's source directory. Put the following code into that file:

<?php
namespace User\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
 * This class represents a registered user.
 * @ORM\Entity()
 * @ORM\Table(name="user")
 */
class User
{
	//User status constants
	const STATUS_ACTIVE 		= 1; //Active user
	const STATUS_RETIRED 		= 2; //Retired user

	/**
	 * @ORM\Id
	 * @ORM\Column(name="id")
	 * @ORM\GeneratedValue
	 */
	protected $id;

	/**
	 * @ORM\Column(name="email")
	 */
	protected $email;

	/**
	 * @ORM\Column(name="full_name")
	 */
	protected $fullName;

	/**
	 * @ORM\Column(name="password")
	 */
	protected $password;

	/**
	 * @ORM\Column(name="status")
	 */
	protected $status;

	/**
	 * @ORM\Column(name="date_created")
	 */
	protected $dateCreated;

	/**
	 * @ORM\Column(name="pwd_reset_token")
	 */
	protected $passwordResetToken;

	/**
	 * @ORM\Column(name="pwd_reset_token_creation_date")
	 */
	protected $passwordResetTokenCreationDate;

	/**
	 * Returns user ID
	 * @return integer
	 */
	public function getId()
	{
		return $this->id;
	}

	/**
	 * Sets user ID
	 * @param int $id
	 */
	public function setId($id)
	{
		$this->id = $id;
	}

	/**
	 * Returns email
	 * @return string
	 */
	public function getEmail()
	{
		return $this->email;
	}

	/**
	 * Sets email
	 * @param string $email
	 */
	public function setEmail($email)
	{
		$this->email = $email;
	}

	/**
	 * Returns full name
	 * @return string
	 */
	public function getFullName()
	{
		return $this->fullName;
	}

	/**
	 * Sets full name
	 * @param string $fullName
	 */
	public function setFullName($fullName)
	{
		$this->fullName = $fullName;
	}

	/**
	 * Returns status.
	 * @return int
	 */
	public function getStatus()
	{
		return $this->status;
	}

	/**
	 * Returns possible status as array
	 * @return array
	 */
	public static function getStatusList()
	{
		return [
			self::STATUS_ACTIVE => 'Active',
			self::STATUS_RETIRED => 'Retired'
		];
	}

	/**
	 * Returns user status as string
	 * @return string
	 */
	public function getStatusAsString()
	{
		$list = self::getStatusList();
		if (isset($list[$this->status]))
			return $list[$this->status];

		return 'Unknown';
	}

	/**
	 * Sets status
	 * @param int $status
	 */
	public function setStatus($status)
	{
		$this->status = $status;
	}

	/**
	 * Returns password
	 * @return string
	 */
	public function getPassword()
	{
		return $this->password;
	}

	/**
	 * @param string $password
	 */
	public function setPassword($password)
	{
		$this->password = $password;
	}

	/**
	 * Returns the date of user creation
	 * @return string
	 */
	public function getDateCreated()
	{
		return $this->dateCreated;
	}

	/**
	 * Sets the date when this user was created.
	 * @param string $dateCreated
	 */
	public function setDateCreated($dateCreated)
	{
		$this->dateCreated = $dateCreated;
	}

	/**
	 * Returns password reset token
	 * @return string
	 */
	public function getResetPasswordToken()
	{
		return $this->passwordResetToken;
	}

	/**
	 * Sets password reset token
	 * @param string $token
	 */
	public function setPasswordResetToken($token)
	{
		$this->passwordResetToken = $token;
	}

	/**
	 * Returns password reset token's creation date
	 * @return string
	 */
	public function getPasswordResetTokenCreationDate()
	{
		return $this->passwordResetTokenCreationDate;
	}

	/**
	 * Sets password reset token's creation date.
	 * @param string $date
	 */
	public function setPasswordResetTokenCreationDate($date)
	{
		$this->passwordResetTokenCreationDate = $date;
	}
}

As we can see from the code above, the User Entity is a typical Doctrine Entity having annotated properties and getters and setters
methods for retrieving/setting those properties.

Adding UserController:

The UserController class will contain several action methods designed for providing administrative user interface for managing
the registered users. It will have the following actions:

The indexAction() action will display a web page containing the list of users. Type "http://localhost/users" in your
web browsers navbar to access this page.

The addAction() will display a page allowing to create a new user. Type "http//localhost/users/add" in your web browsers
navbar to access this page.

The editAction() action will display a page for updating an existing user. Type "http://localhost/users/edit/<id>" in your web
browser's navbar to access this page.

The viewAction() will allow to view an existing user. Type "http://localhost/users/view/<id>" in your web browser's navbar
to access this page.

The changePasswordAction() action will give the admin an ability to change the password of an existing user. Type
"http://localhost/users/changePassword/<id>" in your web browser's navbar to access this page.

The resetPasswordAction() action will allow a user to reset his own password. Type "http://localhost/reset-password"
in your web browser's navbar to access this page.

The UserController controller class is designed to be as "tiny" as possible. It contains only the code responsible for
checking input data, instansiating the needed models, passing input data to the models and returning the output data
for rendering in a view template.

Because it is a typical controller class and because you can see its complete code in the User Demo sample, we will not describe
it here in more details.

Adding UserManager Service:

The UserController works in pair with the UserManager service, which contains all the business logic related to user management.
The service allows to create and update users, change user's password and reset user's password. We will describe some part of it
in more details, omitting the obvious parts (We will see the complete code in the User Demo sample)

Creating a New User & Storing Password Encrypted:

The addUser() method of the UserManager allows to add a new user. It looks as follows:

/**
 * This method adds a new user
 */
public function addUser($data)
{
	//Do not allow several users with the same email address
	if($this->checkUserExists($data['email'])) {
		throw new \Exception("User with email address " . $data['$email'] . " already exists");
	}

	//Create new user entity
	$user = new User();
	$user->setEmail($data['email']);
	$user->setFullName($data['full_name']);

	//Encrypt password and store PW in encrypted state
	$bcrypt = new Bcrypt();
	$passwordHash = $bcrypt->create($data['password']);
	$user->setPassword($passwordHash);

	$user->setStatus($data['status']);

	$currentDate = date('Y-m-d H:i:s');
	$user->setDateCreated($currentDate);

	//Add the entity to the EM
	$this->entityManager->persist($user);

	//Apply changes to DB
	$this->entityManager->flush();

	return $user;
}

You can see that in this method we first check if another user with the same E-mail address already exists (line 7),
and if so, we forbid to create the user by throwing an exception.

If the user with such E-mail address does not exist, we create a new User entity (line 13) and set its properties accordingly.

What is interesting here, is how we save user's password to DB. For security reasons, we do not save the PW as is, but 
calculate a hash of it with the Bcrypt class provided by Zend\Crypt component of ZF (line 18-19).

You can install Zend\Crypt with the following command:

php composer.phar require zendframework/zend-crypt

The Zend\Crypt component also requires that you have mcrypt PHP extension installed.

The Bcrypt algorithm is a hashing algo that is widely used and recommended by security community for storing
user's PW. Encrypting PW with Bcrypt is considered secure nowadays. Some devs encrypt still with MD5 or SHA1,
but these are not safe anymore.

Validating Encrypted Password:

When a user logs in, you will need to check if the password hash stored in the DB is the same as the hash calculated by
the PW, entered by the visitor. You do that with the help of the verify() method provided by the Bcrypt class, as follows:

/**
 * Checks that the given PW is correct
 */
public function validatePassword($user, $password)
{
	$bcrypt = new Bcrypt();
	$passwordHash = $user->getPassword();

	if ($bcrypt->verify($password, $passwordHash)) {
		return true;
	}

	return false;
}

Creating Admin User:

The next important thing to note in UserManager is how we create teh admin user.

The Admin user is an initial user that is created automatically when there are not existing users in teh DB
and allows you to login for the first time.

/**
 * This method checks if at least one user presents, and if not, creates
 * 'Admin' user with 'admin@example.com' and password 'Secur1ty'
 */
public function createAdminUserIfNotExists()
{
	$user = $this->entityManager->getRepository(User::class)->findOneBy([]);
	if ($user==null) {
		$user = new User();
		$user->setEmail('admin@example.com');
		$user->setFullName('Admin');
		$bcrypt = new Bcrypt();
		$passwordHash = $bcrypt->create('Secur1ty');
		$user->setPassword($passwordHash);
		$user->setStatus(User::STATUS_ACTIVE);
		$user->setDateCreated(date('Y-m-d H:i:s'));

		$this->entityManager->persist($user);
		$this->entityManager->flush();
	}
}

We set Admin user's email to admin@example.com and PW to Secur1ty so we can login with these credentials.

Resetting User Password:

Sometimes users forget their password. If that happens, you'll need to let the user to reset the password -
to securly change the password. Password resetting works as follows:

A random password reset token is generated and saved to DB.

The password reset token is sent to user's email address as part of E-mail message.

The user checks his mailbox and clicks the PW reset link in the E-mail message.

The website validates the PW reset token and checks it has not expired.

The user is directed to the form allowing to enter new PW.

Password reset token generation algo is implemented inside the generatePasswordResetToken() method of the
UserManager. To generate a random string, we use the Rand class provided by Zend\Math component.

/**
 * Generates a password reset token for the user. This token is then stored in DB and 
 * sent to the user's Email address. When the user clicks the link in the Email, he is
 * directed to the Set password page.
 */
public function generatePasswordResetToken($user)
{
	// Generate a token
	$token = Rand::getString(32, '0123456789abcdefghijklmnoqrstuvwxyz', true);
	$user->setPasswordResetToken($token);

	$currentDate = date('Y-m-d H:i:s');
	$user->setPasswordResetTokenCreationDate($currentDate);

	$this->entityManager->flush();

	$subject = 'Password Reset';

	$httpHost = isset($_SERVER['HTTP_HOST'])?$_SERVER['HTTP_HOST']:'localhost';
	$passwordResetUrl = 'http://' . $httpHost . '7set-password/' . $token;

	$body = 'Please follow the link below to reset your PW.\n';
	$body .= "$passwordResetUrl\n";
	$body .= "If you have not asked to reset your PW, ignore this.\n";

	//Send email to user
	mail($user->getEmail(), $subject, $body);
}

Configuring mail system for your web server is a rather complex task. It typically requires installing
sendmail and configuring the server's MX DNS record to use certain mail server (either local mail server,
e.g. Postfix, or remote server, like Google Mail).

Because of the complexity of the topic, it is not discussed in this book. You can find additonal information
on configuring mail for your System online.

PW reset token validation is implemented inside the validatePasswordResetToken() method. We check that the
token is the same as we saved in DB and that the token has not expired (expires 1 day after creation):

/**
 * Checks whether the given password reset token is a valid one.
 */
public function validatePasswordResetToken($passwordResetToken)
{
	$user = $this->entityManager->getRepository(User::class)
			->findOneByPasswordResetToken($passwordResetToken);

	if($user==null) {
		return false;
	}

	$tokenCreationDate = $user->getPasswordResetTokenCreationDate();
	$tokenCreationDate = strtotime($tokenCreationDate);

	$currentDate = strtotime('now');

	if ($currentDate - $tokenCreationDate > 26*60*60) {
		return false; //expired
	}

	return true;
}

And finally, the setPasswordByToken() allows to set new password for the user.

/**
 * THis method sets new password by password reset token
 */
public function setNewPasswordByToken($passwordResetToken, $newPassword)
{
	if (!$this->validatePasswordResetToken($passwordResetToken)) {
		return false;
	}

	$user = $this->entityManager->getRepository(User::class)
			->findOneByPasswordResetToken($passwordResetToken);

	if ($user==null) {
		return false;
	}

	//Set new PW for user
	$bcrypt = new Bcrypt();
	$passwordHash = $bcrypt->create($newPassword);
	$user->setPassword($passwordHash);

	//Remove password reset token
	$user->setPasswordResetToken(null);
	$user->setPasswordResetTokenCreationDate(null);

	$this->entityManager->flush();

	return true;
}

Implementing User Authentication:

Authentication is the process when a user provides his login and PW and you decide wheter these credentials
are correct. Authentication typically means you check your DB for the given login, and if such a login exists, you check
if the hash calculated by the given PW matches the hash of the PW stored in the DB.

You typically do not store raw PWs in teh DB. We store hashes. Security reasons.

Once the authentication algorithm determines that the login and pw are correct, it returns user identity - a unique ID
of the user. The identity is typically stored to session, so the visitor does not need to pass authentication for
every HTTP request.

In ZF3, there is a special component allowing you to implement user authentication - Zend\Authentication.
You can install this component with Composer by typing the following command:

php composer.phar require zendframework/zend-authentication

For authentication to work, you also need to have Zend\Session component installed and session manager configured.
For information on how to do that, refer to the Working with Sessions chapter.

AuthenticationService:

The Zend\Authentication component provides the special service class called AuthenticationService living in Zend\Authentication
namespace. Most useful methods of this service are as follows:

Methods of AuthenticationService class:

authenticate() 		performs user authentication using the adapter

getAdapter() 		Gets authentication adapter

setAdapter() 		Sets authentication adapter implementing the actual authentication algorithm

getStorage() 		Returns storage handler

setStorage() 		Sets storage handler

hasIdentity() 		Returns true if user identity is already stored in session

getIdentity() 		Retrieves user identity from session

clearIdentity() 	Removes user identity from session