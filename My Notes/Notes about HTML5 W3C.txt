HTML5 Reference

The Syntax, Vocabulary and APIs of HTML5

W3C Editor's Draft 9 August 2010

This Version: http://www.w3.org/TR/2010/ED-html5-author-2010809

Latest Version: http://www.w3.org/TR/

Previous version: No previous versions

Editors: etc.

Abstract:

This document explains the syntax, vocabulary and the available APIs for HTML5 documents, focusing on simplicity
and practical applications for beginners whilse also providing in depth information for more advanced web devs.
This document is complimentary to the HTMl5 Guide.

As per usual with the Status of the document, legal stuff.

Table of Contents

1. Introduction
2. Basic Templates
3. The HTML and XHTML Syntax
	3.1 Syntactic Overview
	3.2 The Syntax
		3.2.1 DOCTYPE Declaration
			3.2.1.1 Obsolete But Permitted DOCTYPEs
			3.2.1.2 HTML and XHTML Comparison
			3.2.1.3 Historical Notes
		3.2.2 Elements
			3.2.2.1 Tags
			3.2.2.2 Void Elements
			3.2.2.3 Raw Text Elements
			3.2.2.4 RCDATA Elements
			3.2.2.5 Foreign Elements
			3.2.2.6 Normal Elements
			3.2.2.7 Element Type Comparison
			3.2.2.8 HTML and XHTML Comparison
		3.2.3 Attributes
			3.2.3.1 Empty Attribute Syntax
			3.2.3.2 Unquoted Attribute Value Syntax
			3.2.3.3 Double-Quoted Attribute Value Syntax
			3.2.3.4 Signle-Quoted Attribute Value Syntax
			3.2.3.5 HTML and XHTML Comparison
		3.2.4 Comments
		3.2.5 Text
		3.2.6 CDATA Sections
		3.2.7 Character References
	3.3 Understanding MIME Types
	3.4 Character Encoding
	3.5 Choosing HTML or XHTML
	3.6 Polyglot Documents
4 The HTML Vocabulary and APIs
	4.1 Categories
		4.1.1 Metadata Content
		4.1.2 Flow content
		4.1.3 Sectioning root
		4.1.4 Sectioning content
		4.1.5 Heading content
		4.1.6 Phrasing content
		4.1.7 Embedded content
		4.1.8 Interactive content
		4.1.9 Transparent Content Models
	4.2 Global Attributes
	4.3 The Elements
		4.3.1 The Root Element
			4.3.1.1 The html element
		4.3.2 Document Metadata
			4.3.2.1 The head element
			4.3.2.2 The title element
			4.3.2.3 The base element
			4.3.2.4 The link element
			4.3.2.5 The meta element
			4.3.2.6 The style element
		4.3.3 Scripting
			4.3.3.1 The script element
			4.3.3.2 The noscript element
		4.3.4 Sections
			4.3.4.1 The body element
			4.3.4.2 The section element
			4.3.4.3 The nav element
			4.3.4.4 The article element
			4.3.4.5 The aside element
			4.3.4.6 The h1, h2, h3, h4, h5 and h6 elements
			4.3.4.7 The header element
			4.3.4.8 The footer element
			4.3.4.9 The address element
			4.3.4.10 Headings and Sections
		4.3.5 Grouping Content
			4.3.5.1 The p element
			4.3.5.2 The hr element
			4.3.5.3 The br element
			4.3.5.4 The pre element
			4.3.5.5 The dialog element
			4.3.5.6 The blockquote element
			4.3.5.7 The ol element
			4.3.5.8 The ul element
			4.3.5.9 The li element
			4.3.5.10 The dl element
			4.3.5.11 The dt element
			4.3.5.12 The dd element
		4.3.6 Text-Level Semantics
			4.3.6.1 The a element
			4.3.6.2 The q element
			4.3.6.3 The cite element
			4.3.6.4 The em element
			4.3.6.5 The strong element
			4.3.6.6 The small element
			4.3.6.7 The mark element
			4.3.6.8 The dfn element
			4.3.6.9 The abbr element
			4.3.6.10 The time element
			4.3.6.11 The progress element
			4.3.6.12 The meter element
			4.3.6.13 The code element
			4.3.6.14 The var element
			4.3.6.15 The samp element
			4.3.6.16 The kbd element
			4.3.6.17 The sub and sup elements
			4.3.6.18 The span element
			4.3.6.19 The i element
			4.3.6.20 The b element
			4.3.6.21 The bdd element
			4.3.6.22 The ruby element
			4.3.6.23 The rt element
			4.3.6.24 The rp element
		4.3.7 Edits
			4.3.7.1 The ins element
			4.3.7.2 The del element
		4.3.8 Embedded Content
			4.3.8.1 The figure element
			4.3.8.2 The img element
			4.3.8.3 The iframe element
			4.3.8.4 The embed element
			4.3.8.5 The object element
			4.3.8.6 The param element
			4.3.8.7 The video element
			4.3.8.8 The audio element
			4.3.8.9 The source element
			4.3.8.10 The canvas element
			4.3.8.11 The map element
			4.3.8.12 The area element
		4.3.9 Tabular Data
			4.3.9.1 The table element
			4.3.9.2 The caption element
			4.3.9.3 The colgroup element
			4.3.9.4 The col element
			4.3.9.5 The tbody element
			4.3.9.6 The thead element
			4.3.9.7 The tfoot element
			4.3.9.8 The tr element
			4.3.9.9 The td element
			4.3.9.10 The th element
		4.3.10 Forms
			4.3.10.1 The form element
			4.3.10.2 The fieldset element
			4.3.10.3 The label element
			4.3.10.4 The input element
			4.3.10.5 The button element
			4.3.10.6 The select element
			4.3.10.7 The datalist element
			4.3.10.8 The optgroup element
			4.3.10.9 The option element
			4.3.10.10 The textarea element
			4.3.10.11 The output element
		4.3.11 Interactive Elements
			4.3.11.1 The details element
			4.3.11.2 The command element
			4.3.11.3 The bb element
			4.3.11.4 The menu element
		4.3.12 Miscellaneous Elements
			4.3.12.1 The legend element
			4.3.12.2 The div element
	4.4 Microdata
5 Index of Elements
	5.1 Conforming Elements
	5.2 Obsolete Elements
	5.3 Comparison of HTML 4.01 and HTML5 Elements
6 How to Read This Guide
	6.1 Conventions
		6.1.1 Notes, Tips and Warnings
		6.1.2 Example Markup
			6.1.2.1 Attributes
			6.1.2.2 Void Elements
			6.1.2.3 Namespaces

1 Introduction

THis document serves as a reference to the HTML syntax, vocabulary and its associated DOM APIs and is intended for
web site and application devs, publishers, tutorial writers and teachers and their students. That is, people who write
documents using HTML, or who teach others to do so.

This guide is structured into three major sections. The first provides a set of basic templates for authors to get
started with.

The second section provides an in depth look at the syntax of HTML and XHTML documents. This will investigate both
the similarities and differences between the two alternatives and provides guidance on choosing which to use for your
own projects, depending on your needs. Additionaly, this will also provide details about creating polyglot documents 
- that is, documents that conform to both HTML and XHTML simultaneously - including issues related to ensuring
stylesheets and scripts work correctly under both conditions.

The third and final section provides a reference for the HTML vocabulary. Each element is described, providing details
about its meaning, allowed attributes , content models and DOM APIs. Each is accompanied by clear exmaples illustrating
how the element is designed to be useful for a range of different use cases.

2 Basic Templates

The following basic templates are designed to be used as starting points for the documents you create. Several
alternatives are provided, allowing individuals to choose the template that is most appropiate for their needs.

Simple: HTML:

The most basic template recommended for most authors.

<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>HTML Template</title>
	</head>
	<body>
		<p>Insert content here.</p>
	</body>
</html>

Intermediate: HTML and XHTML
Polyglot:

Template suitable for intermediate authors who are producing documents adhering to the polyglot
markup conventions. While this template is safe for beginning to use, it is only recommended for authors
familiar with the techniques for creating polyglot documents.

<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta charset="UTF-8"/>
		<title>Polyglot (X)HTML Template</title>
	</head>
	<body>
		<p>Insert content here.</p>
	</body>
</html>

Advanced: XHTML:

Template suitable for advanced authors who are producing XHTML documents. This template is not suitable
for use as HTML because it lacks the DOCTYPE and does not declare the character encoding. Authors using this
template should be using UTF-8 or UTF-16, or should at least be aware of how to declare the correct encoding
for XML.

<html xmlns="http://www.w3.org/1999/xhmtl">
	<head>
		<title>XHTML Template</title>
	</head>
	<body>
		<p>Insert content here.</p>
	</body>
</html>

Advanced: Minimal HTML:

Template suitable for advanced authors who are producing HTML documents. This templates take advantage of the
ability to omit certain tags for some elements. Authors who are not familiar with, or are uncomfortable with,
these features should avoid this template.

<!DOCTYPE html>
<meta charset="UTF-8">
<title>Minimal HTML Template</title>

<p>Insert content here.</p>

3 The HTML and XHTML Syntax

It is useful to make a distinction between the vocabulary of an HTML document - the elements and attributes,
and their meanings - and syntax in which it is written.

HTML has a defined set of elements and attributes which can be used in a document; each designed for a specific
purpose with their own meaning. Consider this set of elements to be analogous to the list of words in a dictionary.
THis includes elements for headings, paragraphs, lists, tables, links, form controls and many other features.

This is the vocabulary of HTML. Similarly, just as natural languages have grammatical rules for how different words
can be used, HTML has rules for where and how each element and attribute can be used.

THe basic structure of elements in an HTML document is a tree structure. Most elements have at most one parent
element, (except for the root element), and may have any number of child elements. This structure needs to be
reflected in the syntax used to write the document.

3.1 Syntactic Overview

There are two syntaxes that can be used: the traditional HTML syntax, and the XHTML syntax. While these are similar,
each is optimised for different needs and authoring habits. The former is more lenient in its design and handling
requirements, and has a number of convenient shorthands for authors to use. The latter is based on XML and has
much stricter syntactic requirements, designed to discourage the proflieration of syntactic errors.

The HTML syntax is loosely based upon teh older, though very widely used syntax from HTML 4.01. Although it is inspired
by its SGML origins, in practice, it really only shares minor syntactic similarities. This features a range of shorthand
syntaxes, designed to make hand coding more convenient, such as allowing the omission of some optional tags and attribute
values. Authors are free to choose whether or not they wish to take advantage of these shorthand features based upon
their own personal preferences.

HTML Example:
A basic HTML document, demonstrating some shorthand syntax.

<!DOCTYPE html>
<html>
	<head>
		<title>An HTML Document</title>
	</head>
	<body class=example>
		<h1>Example</h1>
		<p>This is an example HTML document.
	</body>
</html>

XHTML, however, is based on the much more strict XML syntax. While this too is inspired by SGML, this syntax reuqires
document to be well-formed, which some people prefer because of its strict error handling, forcing authors to maintain
cleaner markup.

XHTML Example:

A basic XHTML document, demonstrating the stricter XML syntax.

<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<title>An HTML Document</title>
	</head>
	<body class="example">
		<h1>Example</h1>
		<p>This is an example HTML document.</p>
	</body>
</html>

Note: The XHTML document does not need to include the DOCTYPE because XHTML documents that are delivered correctly 
using an XML MIME type and are processed as XML by browsers are always rendered in no quirks mode. However, the
DOCTYPE may optionally be included, and should be included if the document uses the compatible subset of markup
that is conforming in both HTML and XHTML, and is ever expected ot be used in text/html environments.

Due to the similarities of both the HTML and XHTML syntaxes, it is possible to mark up documents using a common
subset of the syntax that is the same in both, while avoiding the syntactic features that are unique to each.

This type of document is said to use polyglot markup, often simply referred to as a polyglot document, because
it simultaneously conforms to both syntaxes and may be treated as either.

There are a number of issues involved with creating such documents and authors wishing to do so should familiarise
themselves with the similarities and differences between HTML and XHTML.

3.2 The Syntax

There are a number of basic components that make up the syntax of HTML, that are used throughout any document.
These include the DOCTYPE declaration, elements, attributes, comments, text and CDATA sections.

3.2.1 DOCTYPE Declaration

The Document Type Declaration needs ot be present at the beginning of a document that uses the HTML syntax.
It may optionally be used within the XHTML syntax, but it is not required. The following DOCTYPE is strongly
recommended for most HTML documents:

Example:

The HTML5 DOCTYPE declaration.

<!DOCTYPE html>

For compability with legacy producers of HTML - that is, software that outputs HTML documents - an alternative
legacy compability DOCTYPE is available. THis is recommended for use by systems that are unable to output the
DOCTYPE given above. THis limitation occurs in software that expects a DOCTYPE to include either a PUBLIC or
SYSTEM identifier, and is unable to omit them.

The canonical form of this DOCTYPE is as follows:

Example:

The HTML5 legacy compability DOCTYPE declaration.

<!DOCTYPE html SYSTEM "about:legacy-compat">

Note: The term "legacy-compat" refers to compability with legacy producers only. In particular, it does not
refer to compability with legacy browsers, which, in practice, ignore SYSTEM identifiers and DTDs.

In HTML, the DOCTYPE is case insensitive, except for the quoted string "about:legacy-compat", which must be
written in lower case. This quoted string, however, may also be quoted with single quotes, rather than 
double quotes. The highlighted fragments below illustrates which parts are case insensitive in HTML.

Example:

The three conforming variants of the HTML5 DOCTYPE declarations, indicating case insensitivity in the HTML syntax.

<!DOCTYPE html>

<!DOCTYPE html SYSTEM "about:legacy-compat">

<!DOCTYPE html SYSTEM 'about:legacy-compat'>

For XHTML, the DOCTYPE may be omitted because it is unessecary. If you choose to use a DOCTYPE, then the canonical
case-sensitive versions of the above DOCTYPEs are recommended. But there are no restrictions placed on the use of
alternative DOCTYPEs. 

You may, if you wish, use a custom DOCTYPE referring to a custom DTD, typically for validation
purposes. Although, be advised that DTDs have a number of limitations compared with other alternative schema languages
and validation techniques.

3.2.1.1 Obsolete But Permitted DOCTYPEs

In order to ease the transitional process from previous editions of HTML, selected legacy DOCTYPEs are grandfathered
into the HTML syntax as conforming, but they are considered obsolete. This does not apply to XHTML.

Warning: When using these DOCTYPEs, some validators may apply conformance requirements from older specifications,
instead of the requirements of HTML5. HTML5 conformance checkers are required to issue a warning if one is present.
Authors are strongly discouraged from using these DOCTYPEs.

For the permitted DOCTYPEs using only a public identifier, the syntax is as follows. The highlighted fragments indicate
case insensitivity in the HTML syntax.

HTML Example:
The obsolete but permitted HTML 4.01 Strict DOCTYPE with only the public identifier.

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">

For the permitted DOCTYPEs that also have a system identifier, the syntax is:

HTML Example:
The obsolete but permitted HTML 4.01 Strict DOCTYPE with both the public and system identifiers.

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
	SYSTEM "http://www.w3.org/TR/html4/strict.dtd">

In addition to those, the following public and system identifiers in the table below may be substituted accordingly.

Allowed values for public and system identifiers in an obsolete permitted DOCTYPE string

Public Identifier 				System Identifier

-//W3C//DTD HTML 4.0//EN 		http://www.w3.org/TR/REC-html40/strict.dtd 	

-//W3C//DTD HTML 4.0//EN									

-//W3C//DTD HTML 4.01//EN 	

-//W3C//DTD HTML 4.01//EN 		http://www.w3.org/TR/html4/strict.dtd

-//W3C//DTD XHTML 1.0 Strict/EN http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd

-//W3C//DTD XHTML 1.1//EN 		http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd

3.2.1.2 HTML and XHTML Comparison

Comparison of the DOCTYPE syntax requirements between HTML and XHTML

							HTML 								XHTML
DOCTYPE 					Required 							Optional

DOCTYPE keyword				Case-insensitive 					Case-sensitive

html keyword 				Case-insensitive 					Case-sensitive

PUBLIC keyword 				Case-insensitive 					Case-sensitive

SYSTEM keyword 				Case-insensitive 					Case-sensitive

Public Identifier 			Optional 							Optional

System Identifier 			Optional 							optional, but required if public identifier is present

Legacy Compability DOCTYPE  Allowed 							Allowed

Other DOCTYPEs 				Obsolete but permitted DOCTYPE list Any XML compliant DOCTYPE (excludes HTML 4.01 and earlier DOCTYPEs)

3.2.1.3 Historical Notes

This section needs revising and may be moved to an external document and simplfy refered to.

The DOCTYPE originates from HTML's SGML lineage and, in previous levels of HTML, was originally used to
refer to a Document Type Definition (DTD) - A formal declaration of the elements, attributes and syntactic
features that could be used within the document.

Those who are familiar with previous levels of HTML will notice that there is no PUBLIC identifier present
in this DOCTYPE, which were used to refer to the DTD.

Also, note that the about: URI scheme in the SYSTEM identifier of the latter DOCTYPE is used specifically
because it cannot be resolved to any specific DTD.

As HTML5 is no longer formally based upon SGML, the DOCTYPE no longer serves this purpose, and thus no longer
needs to refer to a DTD. However, due to legacy constraints, it has gained another very important purpose:
triggering no-quirks mode in browsers.

HTML5 defines three modes: quirks mode, limited quirks mode and no quirks mode, of which only the latter is considered
conforming to use. The reason for this is due to backwards compability. The important thing to understand is that there
are some differences in the way documents are visually rendered in each of the modes; and to ensure the most standards
compliant rendering, it is important to ensure no-quirks mode is used.

3.2.2 Elements

There are five different kinds of elements: normal, void, raw, text, RCDATA and foreign elements. Each is represented
syntactically by a tag. While the types have some similarities to each other, they are distinguished by their syntatic
requirements for their content models and types of tags that may be used.

3.2.2.1 Tags

All elements are identified by their tag name and are marked up using either start tags and end tags or self-closing
tags. A start tag marks the beginning of an element, while an end tag marks the end. Start tags are delimited using
angle brackets with the tag name and any attributes in between. End tags are delimited by angle brackets with a slash
before the tag name.

Example:
The markup for the start and end tags of the p element.

<p>The quick brown fox jumps over the lazy dog.</p>

A Self-closing tag is a special form of start tag with a slash immediately before the closing right angle bracket.
These indicate that the element is to be closed immediately, and has no content. Where this syntax is permitted
and used, the end tag must be omitted. In HTML, the use of this syntax is restricted to void elements and foreign
elements. If used for other elements, it is treated as a start tag. 

In XHTML, it is possible for any element to use this syntax. But note that it is only conforming for elements with
content models that permit them to be empty.

Example:

A br element using the self-closing tag syntax.
<p>The quick brown fox<br/>
jumps over the lazy dog.</p>

In HTML, tag names are case insensitive. It is conventional to use their canonical case, but this is not required.
For example, they could be written in all uppercase or mixed case, depending on your own preferences.

HTML Example:

Uppercase tag names are permitted in the HTML syntax

<DIV>...</DIV>

In XHTML, tag names are case sensitive and must be written in their canonical case. In general, the canonical case
is lowercase for HTML and MathML elements, and camel case for SVG. Refer to the definition of each element if in
doubt.

In both HTML and XHTML, within each tag, whitespace is permitted after the tag name, but it is not permitted before
the tag name. Some authors choose to include a space before the slash in the self-closing tag. This practice is
based upon a convention that originated within the compability guidelines in XHTML 1.0, Appendix C. However, adherence
to this convention is unnecessary.

The permitted syntax of each element and its content model varies based on the type of element. The term empty element
is used to describe an element that contains no content. Elements of any type can be empty, depending on their content
model. Depending on the type, these are represented either by a start tag that is immediately closed, either implicitly
or by the presence of an end tag, or by using the self-closing tag syntax.

Example:

An empty span element.

<span></span>

3.2.2.2 Void Elements

The term void elements is used to designate elements that must be empty. These requirements only apply to the HTML
syntax. In XHTML, all such elements are treated as normal elements, but must be marked up as empty elements.

These elements are forbidden from containing any content at all. In HTML, these elements have a start tag only.
The self-closing tag syntax may be used. The end tag must be omitted because the element is automatically
closed by the parser.

HTML Example:

A void element in the HTML syntax. This is not permitted in the XHTML syntax.

<hr>

Example:

A void element using the HTML-and XHTML-compatible self-closing tag syntax.

<hr/>

XHTML Example:

A void element using the XHTML-only syntax with an explicit end tag. This is not permitted for void 
elements in the HTML syntax.

<hr></hr>

Such elements include, among others, br, hr, link and meta.

3.2.2.3 Raw Text Elements

The term raw text elements refers to elements within which the content is treated as raw text instead of markup.
These requirements only apply to the HTML syntax. In XHTML, all such elements are treated as normal elements.

These require a start tag and an end tag. Neither the self-closing tag syntax, nor optional tags are supported.

These elements can only contain raw text. This means that other content like comments, character references and
other elements cannot be represented in the HTML syntax. That is, the markup for such constructs is treated as
text instead of markup. All occurences of special characters do not need to be escaped as character references,
as they otherwise would within normal elements.

HTML Example:

A script element containing some functions. Special characters do not need to be escaped using character
references or a CDATA section.

<script>
function isLeap(year) {
	return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
}

function compare(a, b) {
	if (a < b)
		return -1;
	else if (a > b)
		return 1;
	return 0;
}
</script>

There is, however, one additional restriction that the text cannot contain a string like the element's
end tag. Specifically, a string that matches the pattern of "</" followed by a case insensitive match
for the element's tag name, followed by either "/", ">", or whitespace.

Example error:

A script element cannot contain a string that is indistinguishable from the end tag.

<scrip>
if (condition) {
	document.write("<script src=\"example.js\"></script>");
}
</script>

In the previous example, an HTML conformance checker would report the error as relating to the second
end tag, believing that the first is in fact teh end tag. Care must be taken to ensure such strings
do not occur within the script.

HTML Example:

THe javascript can be modified by escaping the slash, to workaround the HTML syntax error.

<script>
if (condition) {
	document.write("<script src=\"example.js\"><\/script>");
}
</script>

In XHTML, because such elements are treated as normal elements, markup like comments, character references and
other elements can be represented. It is therefore necessary to escape all special characters using either character
references or by enclosing the content within a CDATA section.

XHTML Example:
Special characters within a scrip element may be escaped using character references in the XHTML Syntax.

<script>
function isLeap(year) {
	return year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0;
}

function compare(a, b) {
	if (a &lt; b)
		return -1;
	else if (a &gt; b)
		return 1;
	return 0;
}
</script>

XHTML Example:

Special characters within a script element may be escaped using a CDATA section in the XHTML syntax.

<script><![CDATA[
function isLeap(year) {
	return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
}

function compare(a, b) {
	if (a < b)
		return -1;
	else if (a > b)
		return 1;
	return 0;
}
]]</script>

The above does not work in HTML because the strings "<![CDATA[" and "]]>" are treated as text instead of
markup. However, by taking advantage of the scripting language's comment syntax, those strings can be commented
so that they are ignored by the script in HTML, but still processed as markup in XHTML. THis provides us with an
HTML- and XHTML- compatible syntax for scripts.

Example:

The HTML-and XHTML-compatible syntax for including javascript

<script>//<![CDATA[
function isLeap(year) {
	return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
}

function compare(a, b){
	if (a < b)
		return -1;
	else if (a > b)
		return 1;
	return 0;
}
//]]></script>

3.2.2.4 RCDATA Elements

The term RCDATA elements refers to elements within which character references are supported, but all other content is
treated as raw text instead of markup. These requirements only apply to the HTML syntax. In XHTML, all such elements are
treated as normal elements.

These require a start tag and an end tag. Neither the self-closing tag syntax, nor optional tags are supported.

THese elements can only contain text or character references. This means that only character references are treated
as markup, whereas all other content like comments and other elements cannot be represented in the HTML syntax.
That is, the markup for such constructs is treated as text.

Occurences of special characters may, but generally do not need to be escaped as character references, as they otherwise
would within normal elements. BUt this is subject to the additional restriction that hte text cannot include an ambigious
ampersand. That is, an ampersand followed by a sequence of characters that look like a named character reference, but which
is not valid.

HTML Example:

A textarea element can contain text and char references

<textarea>
This can contain char references like &amp; &lt; and &gt;,
but such chars can also be written directly as &, < and >.
Strings that look like <!-- comments --> or other elements <span>
are treated as plain text, instead of markup.
</textarea>

Example error:

An ambigious ampersand cannot occur within a textarea element.

<textarea>
An unknown named character references like &this
gives an ambigious ampersand error.
</textarea>

Another additional restriction that the text cannot contain a string that looks like the element's end tag. 
Specifically, a string that matches the pattern of "</" followed by a case insensitive match for the 
element's tag name, followed by either "/", ">", or whitespace.

Example Error:

A textarea element cannot contain a string that is indistinguishable from teh end tag.

<textarea>
This text cannot contain a string like </textarea because
it looks like an end tag for the element.
</textarea>

In XHTML, because such elements are treated as normal elements, markup like comments and other elements
can also be represented. It is therefore necessary to escape all special characters using either character
references or by enclosing the content within a CDATA section.

XHTML Example:

A textarea element can contain text and character references and comments in the XHTML syntax.

<textarea>
This can contain character references like &amp;, and &lt; and &gt;.
Unlike the HTML syntax, this can also contain comments.
<!-- just like other normal elements -->

If the string is intended to be rendered, the special characters must be escaped
&lt;!-- like --&gt;.
</textarea>

XHTML Example:

The content of a textarea element can also be contained within a CDATA section.

<textarea><![CDATA[This can contain special characters like &, < and >.
Strings that look like markup, like <!-- comments -->,
character references &amp; &lt; and &gt;,
or other elements <span> are treated as plain text, instead of markup.
]]></textarea>

3.2.2.5 Foreign Elements

The term foreign elements refers to elements that are in the SVG and MathML namespaces.

These require a start tag and an end tag. The self-closing tag syntax may be used, where teh element's
content model permits. Optional tags are not supported.

These elements can contain text, character references, CDATA sections, other elements, and comments,
but the text must not contain the less-than sign char (<) or an ambigious ampersand.

//Need examples

3.2.2.6 Normal Elements

Normal Elements refers to all other HTML elements that are not categorised in any of the other 
types.

These have a start tag and an end tag. These elements do not support the self-closing tag syntax.
Certain elements have optional tags, meaning that one or both tags may be omitted in specific
circumstances where the presence of the tag will be implied by surrounding markup.

Consult the element definitions to see which tags may be omitted.

Normal elements can contain text, character references, other elements, and comments, but the
text must not contain the less-than sign character (<) or an ambigious ampersand. Some additional
restrictions apply on a per-element basis to some specific elements. Consult the element definitions
for details.

//Need examples

3.2.2.7 Element Type Comparison

Comarpsion of the element type syntax requirements in HTML. (This does not apply to XHTML).

Element Type 			Start Tag 					End Tag 					Self-Closing 			Allowed Content Syntax

Normal Element 			Yes (sometimes optional) 	Yes (sometimes optional) 	No 						Text, elements, comments, char references

Void Element 			Yes 						No 							Yes (Optional) 			Empty

Raw Text Element 		Yes (Required) 				Yes (Required) 				No 						Text

RCDATA Element 			Yes (Required) 				Yes (Required) 				No 						Text, character references

Foreign Element 		Yes 						Yes 						Yes 					Text, elements, CDATA sections, comments,
																										char references

3.2.2.8 HTML and XHTML Comparison

Comparison of the element and tag syntax requirements between HTML and XHTML

				HTML 																	 				XHTML
Start Tag 	Optional for selected elements; required for others, unless an empty element tag is used 	Required for all elements

End Tag 	Optional for selected elements; forbidden for void elements or if empty element tag is used; Required for all elements with matching start tag,
			required for others 																		unnecessary and forbidden if empty element tag is used

Self-Closing Allowed for void elements and foreign content elements (if content model permits) 			Allowed for all elements (if content model permits) 
Tag

Tag Name 	Case-insensitive 																			Case-sensitive

Namespace 	Forbidden 																					Allowed 
Prefixes for 
Tag Name

Normal Elm. Yes 																						Yes

Void Elm. 	Yes, use start tag with no end tag, or empty elm. tag 										Yes, use start tag immediately closed by an end tag,
																										or empty elem tag

Raw Text Elms. Yes 																						No (treated as normal elements)

RCDATA Elems.  Yes 																						No (treated as normal elements)

Foreign Elements SVG and MathML only 																	Any

Line feed immediately Normalised 																		Allowed
after start tag

3.2.3 Attributes

Elements may have attributes that are used to specify additional information about them. Some attributes are defined globally
and can be used on any HTML element, while others are defined for specific elements only.

Every attribute must have an attribute name that is used to identify it. Every attribute also has an associated attribute value,
which, depending on the attribute's definition, may represent one of several different types. The permitted syntax for each
attribute depends on the given value.

A typical attribute in HTML has a name and a value separated by an equals sign (=). Attributes are placed within a start tag
and are separated from the tag name and from each other by whitespace. They must not be specified within an end tag.

Example:

The syntax of two typical attributes.

<div class="example" lang="en">...</div>

Example error:

Attributes cannot be placed within end tags.

<section id="example">...</section id="example">

In HTML, attribute names are case insensitive. It is conventional to use their canonical case, but this is
not required. For example, they could be written in all uppercase or mixed case, depending on your own 
preferences.

For custom attributes, attribute names must consist of one or more characters other than the space chars,
control chars, NULL, one of the chars: double quote ("), single quote ('), greater-than sign(>), solidus(/),
equals sign (=), nor any characters that are NOT defined by Unicode. It is, however, recommended that authors
use the lowercase letters in the ranges a-z and 0-9.

HTML Example:

Attribute names in HTML are case-insensitive, and can be written in uppercase or mixed case

<div CLASS="example" Lang="en">...</div>

In XHTML, attribute names are case sensitive and must be written in their canonical case. In general,
the canonical case is lowercase for most attributes on HTML and MathML elements, and camel case for SVG.
Refer to the definition of each element if in doubt.

Attribute Values may contain text and character references, subject to the restriction that the text
cannot contain an ambiguous ampersand, and to any additional restrictions imposed by the syntax being
used.

There are four slightly different syntaxes that may be used for attributes in HTML: empty, unquoted,
single-quoted and double-quoted. All four syntaxes may be used in the HTML syntax, depending on what
is needed for each specific attribute. However, in the XHTML syntax, attribute values must always
be quoted using either single or double quotes.

3.2.3.1 Empty Attribute Syntax

An empty attribute is one where the value has been omitted. This is a syntactic shorthand for specifying
the attribute with an empty value, and is commonly used for boolean attributes. This syntax may be used
in the HTML syntax, but not in the XHTML syntax.

Note: In previous editions of HTML, which were formally based on SGML, it was technically an attribute's
name that could be omitted where the values was a unique enumerated value specified in the DTD. However,
due to legacy constraints, this has been changed in HTML5 to reflect the way implementations really work.

HTML Example:
Empty attributes may have their value omitted in the HTML syntax.

<input disabled>...</div>

Example:
Specifying the value as an empty string is equivalent to the empty attribute syntax.
This is an XHTML-compatible syntax.

<input disabled="">...</div>

Note: The previous examples are semantically equivalent to specifying the attribute with the value
"disabled", but are not exactly the same.

This syntax is permitted only for boolean attributes.

3.2.3.2 Unquoted Attribute Value Syntax

An unquoted attribute value is one where the value is supplied, but is not surrounded by quotation marks.
This syntax may be used in the HTML syntax, but not in the XHTML syntax.

The attribute value must not contain any literal space characters, any of the characters: double quote ("),
apostrophe ('), equals sign (=), less-than sign (<), greater-than sign (>), or grave accent (`), and the
value must not be the empty string.

To represent those characters in an attribute value, they either need to be escaped using character references,
or you need to use either the single- or double-quoted attribute values.

HTML Example:

Some attribute values may be left unquoted in the HTML syntax.

<img src=example.png height=200 width=300/>

In the previous example, each attribute is separated from the last by a space. The slash at the end, which despite
not being separated from the last value by any space characters, is not considered part of teh attribute's value.

Instead, the slash indicates the use of the self-closing tag syntax.

There may be space characters between the attribute name and the equals sign (=), and between that and the
attribute value.

HTML Example:

Whitespace is permitted before and after the equal sign, separating the name and the value.

<img src = image.png>

3.2.3.3 Double-Quoted Attribute Value Syntax

An double-quoted attribute value is one where the supplied value is surrounded by double quotation marks (").
This syntax may be used in both HTML and XHTML.

The attribute value must delimieted by double-quote chars (") before and after the value, and must not contain any
double-quote characters or an ambigious ampersands in between. All other text and character references are permitted.

The advantage of quoting attributes, the value may contain the additional characters that cannot be used in unquoted
attribute values. To include a double-quote character within the value, either use a character reference (&quot;),
or use a single-quoted attribute value instead.

Example:
Attribute values may be quoted with double quote marks.

<img src="example.jpg" title="An example photograph">

There may be space chars between the attribute name and the equals sign (=), and between that and the
attribute value.

HTML Example:

Whitespace is permitted before and after the equals sign, separating the name and the value.

<img src = "example.png">

3.2.3.4 Single-Quoted Attribute Value Syntax

An single-quoted attribute value is one where the supplied value is surrounded by single quotation marks (').
This syntax may be used in both HTML and XHTML.

The attribute value must be delimited by single-quote chars (') before and after the value, and must not contain
any single-quote chars or an ambigious ampersands in between. All other text and char references are permitted.

The advantage of quoting attributes, the value may contain the additional chars that can not be used in unquoted attribute
values. To include a single quote or apostrophe char within the value, either use a char reference (&apos;), or
use a double-quoted attribute value instead.

Example:

Attribute values may be quoted with single quote marks.

<img src='example.jpg' title='An example photograph'>

There may be space chars between the attribute name and the equals sign (=), and between that and the attribute
value.

HTML Example:

Whitespace is permitted, before and after the equal sign, separating the name and the value.

<img src = 'example.png'>

3.2.3.5 HTML and XHTML Comparison

Comparison of the attribute syntax requirements between HTML and XHTML

										HTML 								XHTML
Attribute Names  						Case-insensitive 					Case-sensitive

Namespace Prefixes for Attribute Names	Limited, specified prefixes only 	Allowed

Empty attributes 						Allowed 							Forbidden

Unquoted Attributes 					Allowed 							Forbidden

Double quoted attributes 				Allowed 							Allowed

Single quoted attributes 				Allowed 							Allowed

Line feeds in attribute values 			Allowed 							Normalised to spaces

3.2.4 Comments

?

3.2.5 Text

?

3.2.6 CDATA Sections

?

3.2.7 Character References

Discuss numeric and named char reference syntax. May link to the list of entity references in a seperate
document, rather than trying to list them all in here.

3.3 Understanding MIME Types

Discuss text/html, application/xhtml+xml, etc.

3.4 Character Encoding

Overview of Unicode, character repetoires, encodings, etc. Declaring the encoding with the Content-Type
header, BOM, meta, etc.

3.5 Choosing HTML or XHTML

The choice of HTML or XHTML syntax is largely dependent upon a number of factors the, including needs of a given project,
the skill set of the devs involved, level of support in browsers used by the site's target audience, or it may simply be
a matter of personal preference.

The important thing thing to understand is that there are valid reasons to choose both, and that authors are encouraged
to make an informed decision.

Need to develop guidelines ot help authors make this choice.

3.6 Polyglot Documents

A polyglot HTML document is a document that conforms to both the HTML and XHTML syntactic reqs, and which can be processed
as either by browsers, depending on the MIME type used. This works by using a common subset of the syntax that is shared by
both HTML and XHTML.

Polyglot documents are useful to create for situations where a document is intended to be served as either HTML or XHTML,
depending on the support in particular browsers, or when it is known at the time of creation, which MIME type the document
will ultimately be served as.

In order to successfully create and maintain polyglot docs, authors need to be familiar with both the similarities and 
differences between the two syntaxes. This includes not only syntactic differences, but also differences in the way stylesheets,
and scripts are handled, and the way in which char encodings are detected.

This section will provide the details about each of these similarities and differences, and provide guidelines on the
creation of polyglot documents.

Base this on the HTML vs. XHTML article.

4. The HTML Vocabulary and APIs

4.1 Categories

Each element in HTML falls into zero or more categories that group elements with similar characteristics together.
The following categories are used in this guide:

Metadata content
Flow content
Sectioning root
Sectioning content
Heading content
Phrasing content
Embedded content
Interactive content
Transparent

Some elements have unique requirements and do not fit into any particular category.

These Categories are as follows:

Flow
	>Embedded
		>Phrasing
			>MetaData
			>Interactive
	>Heading
	>Sectioning

[Create and link to some sort of index of elements that lists each element in each category.]

4.1.1 Metadata Content

Metadata content includes elements for marking up document metadata; marking up or linking to resources
that describe the behaviour or presentation of the document; or indicate relationships with other documents.

Metadata elements appear within the head of a document. Some common examples of metadata elements include:
title, meta, link, script and style.

4.1.2 Flow content

Most elements that are used in the body of documents and applications are categorised as flow content.
Most of the elements used to mark up the main content in the body of a page are considered to be flow
content. In general, this includes elements that are presented visually as either block level or inline
level.

Some common flow content includes elements like div, p, em and strong.

Elements categorised as heading content, phrasing content or embedded content are also considered
to be flow content.

4.1.3 Sectioning root

[This desc needs improvement]

These elements can have their own outlines, but the sections and headers inside these elements
do not contribute to the outlines of their ancestors.

Some common sectioning root elements include, among others, body, blockquote and figure.

4.1.4 Sectioning content

Sectioning content is used for structuring a document into sections, each of which generally has
its own heading. These elements provide a scope within which associated headers, footers and
contact information apply.

Some common sectioning elements include, amongst others, section, article and nav.

Most sectioning elements, with the exception of the body element, are also classified as flow content.

4.1.5 Heading content

Heading content includes the elements for marking up headers. Headings, in conjunction with the sectioning
elements, are used to describe the structure of the document.

Heading content includes the header element and the h1 to h6 elements.

Elements categorised as heading content are considered to be flow content.

4.1.6 Phrasing content

Phrasing content includes text and text-level markup. This is similar to the concept of inline
level elements in HTML 4.01. Most elements that are categorised as phrasing content can only
contain other phrasing content.

Some common examples of phrasing content elements include abbr, em, strong and span.

Elements categorised as phrasing content are considered to be flow content.

4.1.7 Embedded Content

Embedded content includes elements that load external reosurces into the document. Such external
resources includes, for example, images, videos and Flash-based content. Some embedded content 
elements include: img, object, embed and video. 

Elements categorised as embedded content are considered ot be phrasing content, and thus also
considered to be flow content.

4.1.8 Interactive Content

Interactive elements are those that allow the user to interact with or activate in some way. Depending
on the user's browser and device, this could be performed using any kind of input device, such as,
for example, a mouse, a keyboard, touch screen or voice input.

SOme common examples of interactive elements include a, audio, and video when used with the controls
attribute, and most form controls using input.

4.1.9 Transparent Content Models

Some elements have transparent content models, meaning that their allowed content depends upon the
parent element. They may contain nay content that their parent element may contain, in addition
to any other allowances or exceptions descriebd for the element.

When the element has no parent, then the content model defaults to flow content.

4.2 Global Attributes

To be Completed

4.3 The Elements

Expect major changes to this section. Each of tehse needs longer desc. and the elements should be divided
into categories. The IDL for the DOM Interface is likely to be replaced by something a lot more reader-friendly
in the future, consider it a placeholder for now. Attributes will likely be accompanied by brief desc. with
the summary box, in addition to fuller desc. and examples afterwards.

4.3.1 The Root Element 			Start tag: Optional End Tag: Optional

4.3.1.1 The html element

The html element represents the root of an HTML document

Categories: 		None.

Contained By: 		As the root element of a document.
					Whenver a subdocument fragment is allowed in a compound document.

Content Model: 		A head element followed by a body element.

Attributes 							Dom interface

Global attributes manifest 			Uses HTMLElement

The html element is the root element of a document. Every document must begin with this element,
and it must contain both the head and body elements.

It is considered good practice to specify the primary language of the document on this element
using the lang attribute.

HTML Example:

<!DOCTYPE html>
<html lang="en">
	<head>
		...
	</head>
	<body>
		...
	</body>
</html>

In the HTML syntax only, both the start and end tags are optional, and so for convenience either may be
omitted, unless you wish to specify attributes on this element, which case, at least the start tag needs
to be included.

HTML Example

<!DOCTYPE html>
<head>
	...
</head>
<body>
	...
</body>

In the XHTML syntax, the xmlns attribute needs to be specified on this element to declare that it is in the
HTML namespace. You may use either the lang or xml:lang attribute to specify the language:

XHTML Example

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
	<head>
		...
	</head>
	<body>
		...
	</body>
</html>

manifest: The manifest attribute gives the address of the document's application cache manifest, if there is one.
IF the attribute is present, the attribute's value must be a valid URL.

Need to describe application cache manifests.

4.3.2 Document Metadata

4.3.2.1 The Head element 	Start tag: optional 	End tag: optional

The head element collects the document's metadata.

Categories: 		None.

Contained By: 		As the first element in an html element.

Content Model: 		One or more elements of metadata content, of which exactly one is a title element.

Attributes 			DOM interface

Global attributes 	Uses HTMLElement

The head element is the container for the document's metadata. Metadata is information about teh document itself,
such as its title, author. Scripts and stylesheets may also be included within the head element. Every document
must have a head element.

The following examples illustrate the typical usage of the head element in HTML and XHTML:

HTML Example:

<!DOCTYPE html>
<html>
<head>
	<title>Example</title>
</head>
<body>
	<h1>Document</h1>
</body>
</html>

XHTML Example:

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Example</title>
</head>
<body>
	<h1>Document</h1>
</body>
<html>

4.3.2.2 The title Element 			Start tag: required End tag: required

The title element represents the document's title or name, and should be meaningful even when
read out of context.

Categories: 			Metadata content

Contained By: 			In a head element containing no other title elements

Content Model: 			Text.

Attributes 				DOM INTERFACE

Global attributes 		Uses HTMLElement

4.3.2.3 The base element 			Start tag: required End tag: empty

The base element is for specifying a base URL against which relative links will be resolved, and the name of
the default target for opening links and form submissions.

Categories: 	Metadata content

Contained By: 	In a head element containing no other base elements

Content Model: 	Empty.

Attributes 							DOM INTERFACE

Global Attributes 					interface.HTMLBaseElement : HTMLElement {
href											attribute DOMString href;
target											attribute DOMString target;
									};

4.3.2.4 The link Element 				Start tag: required End tag: Empty

The link is for linking to other resources, such as stylesheets, favicons and syndication
feeeds.

Categories: 			Metadata content

Contained By: 			Where metadata content is expected
						In a nonscript element that is a child of a head element

Content Model: 			Empty

Attributes 											DOM Interface

Global Attributes 									interface HTMLLinkElement : HTMLElement {
																attribute boolean disabled;
																attribute DOMString href;
																attribute DOMString rel;
													readonly 	attribute DOMTokenList relList;
																attribute DOMString media;
																attribute DOMString hreflang;
																attribute DOMString type;
																attribute DOMString sizes;
													};

													The LinkStyle interface must also be implemented by this element,
													the styling processing model defines how. [CSSOM]
href 									

rel

media

hreflang

type

sizes

Also, the title attribute has special semantics on thsi element

4.3.2.5 The meta element 			Start tag: required End tag: empty

The meta element is providing various types of metadata, such as the application-name or specifying
the documents char encoding.

Categories: 		Metadata content

Contained By: 		If the charset attribute is present, or if the element is in the Encoding declaration state: in a head element.
					If the http-equiv attribute is present, and the element is not in the Encoding declaration state: in a head element
					If the http-equiv attribute is present, and the element is not in the Encoding declaration state: in a nonscript element that is
					a child of a head element.
					If the name attribute is present: where metadata content is expected.

Content Model: 		Empty

Attributes 								DOM INterface

Global Attributes 						interface HTMLMetaElement : HTMLElement {
											attribute DOMString content;
											attribute DOMString name;
											attribute DOMString httpEquiv;
										};
name

http-equiv

content

charset

4.3.2.6 The style element 						Start tag: required End tag: required

The style element allows authors to embed stylesheets, typically CSS, within their documents

Categories: 			Metadata content
						IF the scoped attribute is present: flow content.

Contained By: 			If the scoped attribute is absent: where metadata content is expected.
						If the scoped attribute is absent: in a nonscript element that is a child of a head element.
						If the scoped attribute is present: where flow content is expected, but before any other flow content
						other than other style elements and inter-element whitespace.

Content MOdel: 			Depends on the value of the type attribute.

Attributes 					DOM INTERFACE

Global attributes 			interface HTMLStyleElement : HTMLElement {
								attribute boolean disabled;
								attribute DOMString media;
								attribute DOMString type;
								attribute boolean scoped;
								};

							The LinkStyle interface must also be implemented by this element,
							the styling processing model defines how. [CSSOM]
media

type

scoped

Also, the title attribute has special semantics on this element.

4.3.3 Scripting

4.3.3.1 The script element 					Start tag: required End tag: required

The script element allows authors to include scripts, typically JS and data blocks in their documents.

Categories: 				Metadata content
							Flow content
							Phrasing content

Contained By: 				Where metadata content is expected.
							Where phrasing content is expected.

Content Model: 				If there is no src attribute, depends on the value of the type attribute.
							If there is a src attribute, the element must be either empty or contain only script documentation.

Attributes 														DOM Interface

Globval attrs:

src 															interface HTMLScriptElement : HTMLElement {
																	attribute DOMString src;
																	attribute boolean async;
																	attribute boolean defer;
																	attribute DOMString type;
																	attribute DOMString charset;
																	attribute DOMString text;
																};

async

defer

type

charset

4.3.3.2 The noscript element 										Start tag: required End tag: required

The noscript element is used to provide alternative content for users using browsers that do not support
scripting or have it disabled.

Categories: 			Metadata content
						Flow content
						Phrasing content

Contained by: 			In a head element of an HTML document, if there are no ancestor noscript elements.
						Where phrasing content is expected in HTML documents, if there are no ancestor noscript elements.

Content Model: 			When scripting is disabled, in a head element, in any order, zero or more link elements, zero or more
						style elements, and zero or more meta elements.
						When scriping is disabled, not in a head element: transparent, but there must be no noscript
						element descendants
						Otherwise: text that conforms to the requirements given in the prose.

Attributes 				DOM INTERFACE

Global attributes 		Uses HTMLElement

4.3.4 Sections

4.3.4.1 The body element 				Start tag: optional End tag: optional

The body element represents the main content of the document.

Categories: 		Sectioning root

Contained by: 		As the second element in an html element

Content Model: 		Flow content

Attributes 										DOM INTERFACE

Global attrs

onbeforeunload

onerror

onhashchange

onload

onmessage

onoffline

ononline

onpopstate

onresize

onstorage

onunload

DOM INTERFACE:

interface HTMLBodyElement : HTMLElement {
	attribute Function onbeforeunload;
	attribute Function onerror;
	attribute Function onhashchange;
	attribute Function onload;
	attribute Function onmessage;
	attribute Function onoffline;

	attribute Function ononline;
	attribute Function onpopstate;
	attribute Function onresize;
	attribute Function onstorage;
	attribute Function onunload;
}

4.3.4.2 The section element 				Start tag: Required End tag: Required

The section element represents a generic document or application section. A section, in this context, is a thematic
grouping of content, typically with a header and possibly a footer.

Categories: 		Flow content
					Sectioning Content

Contained By: 		Where flow content is expected

Content Model: 		Flow content

Attribs 				DOM INTERFACE

Global attributes 		Uses HTMLElement

4.3.4.3 The nav element 	Start tag: Required, End Tag: required

The nav element represents a section of a page containing primary navigation links to other
pages or to parts within the page.

Categories: 					Flow content
								Sectioning Content

Contained By: 					Where flow content is expected.

Content model: 					Flow content

Attributes 						DOM INTERFACE

Global attributes 				Uses HTMLElement

4.3.4.4 The article element 								Start tag: Required End tag: required

The article element represents an independent section of a document, page, or site. This could be a forum post,
a magazine or newspaper article, a blog entry, a user-submitted comment, or any other independent item of
content.

Categories: 					Flow content
								Sectioning Content

Contained By: 					Where flow content is expected

Content Model: 					Flow content

Attribs 						DOM INTERFACE

Global attribs 					Uses HTMLElement

4.3.4.5 The aside element 						Start tag: Required End tag: required

The aside element represents a section of a page that consists of content that is tangentially related to the content
around the aside element, and which should be considered separate from that content.

Such sections are often represented as sidebars in printed typography.

Categories: 			Flow content
						Sectioning Content

Contained By: 			Where flow content is expected

Content Model: 			Flow content

Attribs 						DOM INTERFACE

Global attribs 					Uses HTMLElement

4.3.4.6 The h1, h2, h3, h4, h5 and h6 elements 			Start tag: Required End tag: required

These elements define headers for their sections.

Categories: 			Flow content
						Heading Content

Contained By: 			Where flow content is expected

Content Model: 			Phrasing content

Attributes 				DOM INTERFACE

Global attributes 		Uses HTMLElement

4.3.4.7 The header element 				Start tag: required End tag: required

The header element represents the header of a section, containing headings and subheadings, and other
metadata about the section.

Categories: 			Flow content
						Heading content

Contained By: 			Where flow content is expected

Content Model: 			Flow content, including at least one descendant that is heading content, but no 
						sectioning content descendants, no header element descendants and no footer
						element descendants.

Attribs 					DOM INTERFACE

Global attribs 				Uses HTMLElement

4.3.4.8 The footer element 					Start tag: required End tag: required

The footer element represents a footer of a section, typically containing information such as
who wrote it, links to related documents and copyright notices.

Categories: 			Flow content

Contained By: 			Where flow content is expected

Content Model: 			Flow content, but with no heading content descendants, no sectioning content descendants,
						and no footer element descendants.

ATTRIBUTES 				DOM INTERFACE

Global attributes 		Uses HTMLElement

4.3.4.9 The address element 		Start tag: required End tag: Required

The address element represents the contact information for the section it applies to. If it applies to the body
element, then it instead applies to the document as a whole.

Categories: 		Flow content

Contained By: 		Where flow content is expected

Content Model: 		Flow content, but with no heading content descendants, no sectioning content descendants, no footer
					element descendants, and no address element descendants.

Attributes 				DOM INTERFACE

Global Attributes 		Uses HTMLElement

4.3.4.10 Headings and Sections

A typical document is often structured into different sections and subsections, with each potentionally
having its own heading and possibly a subheading. These heading and section elements provide a way for this
structure to be conveyed to the reader.

Consider a simple page like a blog, which is structured into a few main sections.

4.3.5 Grouping Content 				

4.3.5.1 The p element 			Start tag: required End tag: optional

The p element represents a paragraph

Categories: 			Flow content

Contained By: 			Where flow content is expected

Content Model: 			Phrasing content

ATTRIBUTES 				DOM INTERFACE

Global attributes 		Uses HTMLElement

4.3.5.2 The hr element 			Start tag: required End tag: empty

The hr element represents a paragraph-level thematic break, e.g. a scene change in a story, or a transition
to another topic within a section of a reference book.

Categories: 			Flow content

Contained By: 			Where flow content is expected

Content Model: 			Empty

ATTRIBUTES 				DOM INTERFACE

Global attributes 		Uses HTMLElement

4.3.5.3 The br element 			Start tag: required End tag: empty

The br element represents a line break

Categories: 			Flow content
						Phrasing content

Contained By: 			Where phrasing content is expected

Content Model: 			Empty

ATTRIBUTES 				DOM INTERFACE

Global attributes 		Uses HTMLElement

4.3.5.4 The pre element 		Start tag: required End tag: required

The pre element represents a block of preformatted text, in which structure is represented by typographic
conventions rather than by elements.

Categories: 			Flow content

Contained By: 			Where flow content is expected.

Content Model: 			Phrasing content.

ATTRIBUTES 				DOM INTERFACE

Global attributes 		Uses HTMLElement

4.3.5.5 The dialog element 		Start tag: required End tag: required

The dialog element represents a conversation.

Categories: 			Flow content.

Contained By: 			Where flow content is expected.

Content Model: 			Zero or more pairs of one dt element followed by one dd element.

ATTRIBUTES 				DOM INTERFACE

Global attributes 		Uses HTMLElement

4.3.5.6 The blockquote element 		Start tag: required End tag: required

The blockquote element represents a section that is quoted from another source.

Categories: 			Flow content
						Sectioning root

Contained By: 			Where flow content is expected.

Content Model: 			Flow content

ATTRIBUTES 				DOM INTERFACE

Global Attributes
cite

interface HTMLQuoteElement : HTMLElement {
	attribute DOMString cite;
};

The HTMLQuoteElement interface is also used by the q element

4.3.5.7 The ol element 		Start tag: required End tag: required

The ol element represents an ordered list.

Categories: 				Flow content.

Contained By: 				Where flow content is expected.

Content Model: 				Zero or more li elements.

ATTRIBUTES 					DOM INTERFACE

Global attributes

reversed

start

DOM INTERFACE

interface HTMLOListElement : HTMLElement {
	attribute boolean reversed;
	attribute long start;
};

4.3.5.8 The ul element 		Start tag: required End tag: required

The ul element represents an unordered list.

Categories: 		Flow content

Contained By: 		Where flow context is expected.

Content Model: 		Zero or more li elements.

ATTRIBUTES 

Global attributes

DOM INTERFACE

Uses HTMLElement

4.3.5.9 The li element 			Start tag: required End tag: optional

The li element represents a list item

Categories: 			None.

Contained By: 			Inside ol elements.
						Inside ul elements.
						Inside menu elements.

Content Model: 			Flow content

ATTRIBUTES

Global attributes

If the element is a child of an ol element: value

DOM INTERFACE

interface HTMLLIElement : HTMLElement {
	attribute long value;
};

4.3.5.10 The dl element 	Start tag: required End tag: required

The dl element introduces an association list containing groups of terms and associated
descriptions (a description list)

Categories: 		Flow content

Contained By: 		Where flow content is expected

Content Model: 		Zero or more groups each consisting of one or more dt elements followed by one
					or more dd elements.

ATTRIBUTES

Global attributes

DOM INTERFACE

Uses HTMLElement

4.3.5.11 The dt element 			Start tag: required End tag: optional

The dt element represents the term, or name, part of a term-description group in a description list
(dl element), and the talker, or speaker, part of a talker-discourse pair in a conversation (dialog element)

Categories: 		None.

Contained By: 		Before dd or dt elements inside dl elements.
					Beore a dd element inside a dialog element.

Content Model: 		Phrasing content

ATTRIBUTES

Global Attributes

DOM INTERFACE

Uses HTMLElement

4.3.5.12 The dd element 			Start tag: required End tag: optional

The dd element represents the description, definition, or value, part of a term-description group in a description
list (dl element), and the discourse, or quote, part in a conversation (dialog element).

Categories: 		None.

Contained By: 		After dt or dd elements inside dl elements.
					After a dt element inside a dialog element.

Content Model: 		Flow content

ATTRIBUTES

Global attributes

DOM INTERFACE 

Uses HTMLElement

4.3.6 Text-Level Semantics

4.3.6.1 The a element 	Start tag: required End tag: required

If the a element has an href attribute, then it represents a hyperlink.

Categories: 	Interactive content
				Flow content
				When the element only contains phrasing content: phrasing content.

Contained By: 	Where phrasing content is expected

Content Model: 	Transparent, but there must be no interactive content descendant.

ATTRIBUTES

Global Attributes

href

target

ping

rel

media

hreflang

type

DOM INTERFACE

[Stringifies=href] interface HTMLAnchorElement : HTMLElement {
	attribute DOMString href;
	attribute DOMString target;
	attribute DOMString ping;
	attribute DOMString rel;
	readonly attribute DOMTokenList relList;
	attribute DOMString media;
	attribute DOMString hreflang;
	attribute DOMString type;
};

The Command interface must also be implemented by this element

4.3.6.2 The q element 			Start tag: required End tag: required

The q element represents a phrase quoted from another source.

Categories: 			Flow content
						Phrasing content

Contained By: 			Where phrasing content is expected

Content Model: 			Phrasing content

ATTRIBUTES

Global Attributes

cite

DOM INTERFACE

The q element uses the HTMLQuoteElement interface.

4.3.6.3 The cite element 					Start tag: required End tag: required

The cite element represents the titel of a work, such as an article, a book, a poem, a song, a film
or any other creative work.

Categories: 			Flow content
						Phrasing content

Contained By: 			Where phrasing content is expected

Content Model: 			Phrasing content

ATTRIBUTES

Global Attributes

DOM INTERFACE

Uses HTMLElement

4.3.6.4 The em element 					Start tag: required End tag: required

The em element represents stress emphasis of its contents

Categories: 		Flow content
					Phrasing content

Contained By: 		Where phrasing content is expected

Content Model: 		Phrasing content

ATTRIBUTES

Global attributes

DOM INTERFACE

Uses HTMLElement

4.3.6.5 The strong element 			Start tag: required End tag: required

The strong element represents strong importance for its contents

Categories: 		Flow content
					Phrasing content

Contained By: 		Where phrasing content is expected

Content Model: 		Phrasing content

ATTRIBUTES

Global attributes

DOM INTERFACE

Uses HTMLElement

4.3.6.6 The small element 		Start tag: required End tag: required

The small element represents small print (part of a document often describing legal restrictions, such as copyrights
or other disadvantages), or other side comments.

Categories: 		Flow content
					Phrasing content

Contained By: 		Where phrasing content is expected

Content Model: 		Phrasing content

ATTRIBUTES

Global attributes

DOM INTERFACE

Uses HTMLElement

4.3.6.7 The mark element 			Start tag: required End tag: required

The mark element represents a run of text in one document marked or highlighted for reference purposes,
due to its relevance in another context.

Categories: 		Flow content
					Phrasing content

Contained By: 		Where phrasing content is expected

Content Model: 		Phrasing content

ATTRIBUTES

Global attributes

DOM INTERFACE

Uses HTMLElement

4.3.6.8 The dfn element 		Start tag: required End tag: required

The dfn element represents the defining instance of a term, where its definition
is provided nearby.

Categories: 	Flow content
				Phrasing content

Contained By: 	Where phrasing content is expected.

Content Model: 	Phrasing content, but there must be no descendant dfn elements.

ATTRIBUTES

Global attributes
Also, the title attribute has special semantics on this element

DOM INTERFACE

Uses HTMLElement

4.3.6.9 The abbr element 				Start tag: required End tag: required

The abbr element represents an abbrevation or acronym, optionally with its expansion.

Categories: 			Flow content
						Phrasing content

Contained By: 			Where phrasing content is expected.

Content Model: 			Phrasing content

ATTRIBUTES

Global attributes
Also, the title attribute has special semantics on this element.

DOM INTERFACE

Uses HTMLElement

4.3.6.10 The time element 			Start tag: required End tag: required

The time element represents a date and/or a time.

Categories: 		Flow content
					Phrasing content

Contained By: 		Where phrasing content is expected

Content Model: 		Phrasing content

ATTRIBUTES

Global attributes
datetime

DOM INTERFACE

interface HTMLTimeElement : HTMLElement {
	attribute DOMString dateTime;
	readonly attribute Date date;
	readonly attribute Date time;
	readonly attribute Date timezone;

};

4.3.6.11 The progress element 			Start tag: required 	End tag: required

The progress element represents the completion progress of a task.

Categories: 			Flow content
						Phrasing content

Contained By: 			Where phrasing content is expected

Content Model: 			Phrasing content

ATTRIBUTES

Global attributes
value

max

DOM INTERFACE

interface HTMLProgressElement : HTMLElement {
	attribute float value;
	attribute float max;
	readonly attribute float position;
};

4.3.6.12 The meter element 				Start tag: required 	End tag: required

The meter element represents a scalar measurement within a known range, or a fractional value.

Categories: 			Flow content
						Phrasing content

Contained By: 			Where phrasing content is expected.

Content Model: 			Phrasing Content

ATTRIBUTES

Global attributes

value

min

low

high

max

optimum

DOM INTERFACE

interface HTMLMeterElement : HTMLElement {
	attribute float value;
	attribute float min;
	attribute float max;
	attribute float low;
	attribute float high;
	attribute float optium;
};

4.3.6.13 The code element 			Start tag: required End tag: Required

The code element represents a fragment of computer code

Categories: 		Flow content
					Phrasing content

Contained By: 		Where phrasing content is expected

Content Model: 		Phrasing content

ATTRIBUTES

Global attributes

DOM INTERFACE

Uses HTMLElement

4.3.6.14 The var element 			Start tag: required End tag: required

The var element represents a variable, such as in a mathematical expression or programming context,
or it could just be a term used as a placeholder in prose.

Categories: 			Flow content
						Phrasing content

Contained By: 			Where phrasing content is expected

Content Model: 			Phrasing content

ATTRIBUTES

Global attributes

DOM INTERFACE

Uses HTMLElement

4.3.6.15 The samp element 			Start tag: required End tag: required

The samp element represents (sample) output from a program or computing system.

Categories: 		Flow content
					Phrasing content

Contained By: 		Where phrasing content is expected

Content Model: 		Phrasing content

ATTRIBUTES

Global attributes

DOM INTERFACE

Uses HTMLElement

4.3.6.16 The kbd element 			Start Tag: required End tag: required

The kbd element represents user input (typically keyboard input, although it may also be used to represent
other input, such as voice commands).

Categories: 		Flow content
					Phrasing content

Contained By: 		Where phrasing content is expected

Content Model: 		Phrasing content

ATTRIBUTES

Global attributes

DOM INTERFACE

Uses HTMLElement

4.3.6.17 The sub and sup elements 		Start tag: required End tag: required

The sup element represents a superscript and the sub element represents a subscript

Categories: 		Flow content
					Phrasing content

Contained by: 		Where phrasing content is expected

Content Model: 		Phrasing content

ATTRIBUTES

Global Attributes

DOM INTERFACE

Uses HTMLElement

4.3.6.18 The span element 			Start tag: required 	End tag: required

The span element does not mean anything on its own, but can be useful when used together
with other attributes, e.g. class, lang or dir.

Categories: Flow content
			Phrasing content

Contained By: 	Where phrasing content is expected

Content Model: 	Phrasing content

ATTRIBUTES

Global attributes

DOM INTERFACE

Uses HTMLElement

4.3.6.19 The i element 				Start tag: required End tag: required

The i element represents a span of text in an alternative voice or mood, or otherwise offset from the normal
prose, such as taxonomic desgination, a technical term, an idiomatic phrase from another language, a thought,
a ship name or some other prose whose typical typographic presentation is italicized.

Categories: 			Flow content
						Phrasing content

Contained By: 			Where phrasing content is expected

Content Model: 			Phrasing Content

ATTRIBUTES

Global attributes 

DOM INTERFACE

Uses HTMLElement

4.3.6.20 The b element 			Start tag: required End Tag: required

The b element represents a span of text to be stylistically offset from the normal prose without conveying any
extra importance, such as key words in a document abstract, product names in a review, or other spans of text
whose typical typographic presentation is boldened.

Categories: 		Flow content
					Phrasing content

Contained By: 		Where phrasing content is expected

Content Model: 		Phrasing content

ATTRIBUTES

Global attributes

DOM INTERFACE

Uses HTMLElement

4.3.6.21 The bdo element 			Start tag: required End tag: required

The bdo element allows authors to override the unicode bidi algorithm by explicitly specifying
a direction override. [BIDI]

Categories: 		Flow content
					Phrasing content

Contained By: 		Where phrasing content is expected

Content Model: 		Phrasing Content

ATTRIBUTES

Global Attributes

Also, the dir global attribute has special semantics on this element

DOM INTERFACE

Uses HTMLElement

4.3.6.22 The ruby element 				Start tag: required End tag: required

The ruby element allows one or more spans of phrasing content to be marked with ruby annotations.
Ruby annotations are short runs of text presented alongside base text, primarily used in East Asian
typography as a guide for pronounciation or to include other annotations. In Japanese, this form
of typography is also known as furigana.

Categories: 			Flow content
						Phrasing content

Contained By: 			Where phrasing content is expected

Content Model: 			One or more groups of: phrasing content followed either by a single rt element,
						or an rp element, an rt element and another rt element.

ATTRIBUTES

Global attributes

DOM INTERFACE

Uses HTMLElement

4.3.6.23 The rt element 			Start tag: Required 	End tag: required

The rt element marks teh ruby text component of a ruby annotation

Categories: 			None.

Contained By: 			As a child of a ruby element.

Content Model: 			Phrasing content

ATTRIBUTES

Global Attributes

DOM INTERFACE

Uses HTMLElement

4.3.6.24 The rp element 			Start tag: required End tag: required

The rp element can be used to provide paranthesis aroudn a ruby text component of a ruby
annotation, to be shown by user agents that do not support ruby annotations.

Categories: 		None.

Contained By: 		As a child of a ruby element, either immediately before or immediately after an rt element.

Content Model: 		If the rp element is immediately after an rt element that is immediately preceded by another
					rp element: a single character from Unicode character class Pe.
					Otherwise, a single character from Unicode character class Ps.

ATTRIBUTES

Glboal Attributes

DOM INTERFACE

Uses HTMLElement

4.3.7 Edits

4.3.7.1 The ins element 				Start tag: required End tag: required

The ins element represents an addition to the document.

Categories: 			Flow content
						When the element only contains phrasing content: phrasing content

Contained By: 			Where phrasing content is expected

Content Model: 			Transparent

ATTRIBUTES

Global attributes

cite

datetime

DOM INTERFACE

Uses the HTMLModElement interface

4.3.7.2 The del element 			Start tag: required End tag: required

The del element represents a removal from the document.

Categories: 		Flow content
					When the element only contains phrasing content: phrasing content.

Contained By: 		Where phrasing content is expected

Content Model: 		Transparent

ATTRIBUTES

Global Attrbibutes

cite

datetime

DOM INTERFACE

Uses the HTMLModElement interface.

4.3.8 Embedded Content

4.3.8.1 The figure element 			Start tag: required End tag: required

The figure element represents some flow content, optionally with a caption, which can be moved from
the main flow of the document without affecting the document's meaning.

Categories: 			Flow content
						Sectioning root

Contained By: 			Where flow content is expected

Content Model: 			Either: one legend element followed by flow content.
						Or: Flow content followed by one legend element.
						Or: Flow content.

ATTRIBUTES

Global Attributes

DOM INTERFACE

Uses HTMLElement

4.3.8.2 The img element 				Start tag: required End tag: empty

An img element represents an image.

Categories: 		Flow content.
					Phrasing content.
					Embedded content.

					if the element has an usemap attribute: Interactive content.

Contained By: 		Where embedded content is expected.

Content Model: 		Empty.

ATTRIBUTES

Global attributes

alt

src

usemap

ismap

width

height

DOM INTERFACE

[NamedConstructor=Image(),
NamedConstructor=Image(in unsigned long width),
NamedConstructor=Image(in unsigned long width, in unsigned long height)]
interface HTMLImageElement : HTMLElement {
	attribute DOMString alt;
	attribute DOMString src;
	attribute DOMString useMap;
	attribute boolean isMap;
	attribute unsigned long width;
	attribute unsigned long height;
readonly attribute boolean complete;
};

4.3.8.3 The iframe element 				Start tag: required 		End tag: required

The iframe element introduces a new nested browsing context

Categories: 		Flow content
					Phrasing content
					Embedded content

Contained By: 		Where embedded content is expected.

Content Model: 		Text that conforms to the requirements given in the prose.

ATTRIBUTES

Global Attributes

src

name

sandbox

seamless

width

height

DOM INTERFACE

interface HTMLIFrameElement : HTMLElement {
	attribute DOMString src;
	attribute DOMString name;
	attribute DOMString sandbox;
	attribute boolean seamless;
	attribute DOMString width;
	attribute DOMString height;
};

Objects implementing the HTMLIFrameElement interface must also implement the EmbeddingElement
interface defined in the Window Object specification. [WINDOW]

4.3.8.4 The embed element 			Start tag: required End tag: empty

The embed element represents an integration point for an external (typically non-HTML)
application or interactive content.

Categories: 		Flow content
					Phrasing content
					Embedded content

Contained By:	 	Where embedded content is expected

Content Model: 		Empty.

ATTRIBUTES

Global attributes

src

type

width

height

Any other attribute that has no namespace (see prose).

DOM INTERFACE

interface HTMLEmbedElement : HTMLElement {
	attribute DOMString src;
	attribute DOMString type;
	attribute DOMString width;
	attribute DOMString height;
};

Depending on the type of content instansiated by the embed element, the node may also support
other interfaces.

4.3.8.5 THe object element 		Start tag: required 	End tag: 	required

The object element can represent an external resource, which, depending on the type of the resource,
will either be treated as an image, as a nested browsing context, or as an external resource to be
processed by a plugin.

Categories: 		Flow content
					Phrasing content
					Embedded content
					Listed, submittable, form-associated element

Contained By: 		Where embedded content is expected.

Content Model: 		Zero or more param elements, then, transparent.

ATTRIBUTES

Global attributes

data

type

name

usemap

form

width

height

DOM INTERFACE

interface HTMLObjectElement : HTMLElement {
	attribute DOMString data;
	attribute DOMString type;
	attribute DOMString name;
	attribute DOMString useMap;
	readonly attribute HTMLFormElement form;
	attribute DOMString width;
	attribute DOMString height;

};

Objects implementing the HTMLObjectElement interface must also implement the EmbeddingElement interface
defined in the Window Object specification. [WINDOW]

Depending on the type of content instansiated by the object element, the node may also support other
interfaces.

4.3.8.6 The param element 				Start tag: required 		End tag: 	empty

The param element defines parameters for plugins invoked by object elements.

Categories: 		None.

Contained By: 		As a child of an object element, before any flow content.

Content Model: 		Empty.

ATTRIBUTES

Global attributes

name

value

DOM INTERFACE

interface HTMLParamElement : HTMLElement {
	attribute DOMString name;
	attribute DOMString value;
};

4.3.8.7 The video element 					Start tag: required 	End tag: required

A video element represents a video or movie

Categories: 	Flow content
				Phrasing content
				Embedded content
				If the element has a controls attribute: Interactive content

Contained By: 	Where embedded content is expected.

Content Model: 	If the element has a src attribute: transparent
				If the element does not have a src attribute: one or more source elements, then, transparent

ATTRIBUTES

Global attributes

src

poster

autobuffer

autoplay

loop

controls

width

height

DOM INTERFACE

interface HTMLVideoElement : HTMLMediaElement {
	attribute DOMString width;
	attribute DOMString height;
	readonly attribute unsigned long videoWidth;
	readonly attribute unsigned long videoHeight;
	attribute DOMString poster;
};

4.3.8.8 The audio element 				Start tag: required 	End tag: required

An audio element represents a sound or audio stream.

Categories: 		Flow content
					Phrasing content
					Embedded content
					If the element has a controls attribute: Interactive content.

Contained By: 		Where embedded content is expected.

Content Model: 		If the element has a src attribute: transparent
					If the element does not have a src attribute: one or more source elements, then, transparent

ATTRIBUTES

Global attributes

src

autobuffer

autoplay

loop

controls

DOM INTERFACE

[NamedConstructor=Audio(),
 NamedConstructor=Audio(in DOMString src)]
 interface HTMLAudioElement : HTMLMediaElement {
 	//no members
 };

4.3.8.9 The source element 				Start tag: required 	End tag: empty

The source element allows authors to specify multiple media resources for media elements.

Categories: 		None.

Contained By: 		As a child of a media element, before any flow content.

Content Model: 		Empty

ATTRIBUTES

Global attributes

src

type

media

DOM INTERFACE

interface HTMLSourceElement : HTMLElement {
	attribute DOMString src;
	attribute DOMString type;
	attribute DOMString media;
};

4.3.8.10 The canvas element 			Start tag: required 		End tag: required

The canvas element represents a resolution-dependant bitmap canvas, which can be used for rendering
graphs, game graphics or other visual images on the fly.

Categories: 			Flow content
						Phrasing content
						Embedded content

Contained By: 			Where embedded content is expected

Content Model: 			Transparent

ATTRIBUTES

Global attributes

width

height

DOM INTERFACE

interface HTMLCanvasElement : HTTMLElement {
	attribute unsigned long width;
	attribute unsigned long height;

	DOMString toDataURL([Optional] in DOMString type, [Variadic] in any args);

	Object getContext(in DOMString contextId);
};

4.3.8.11 The map element 					Start tag: required 		End tag: required

The map element, in conjunction with any area element descendants, defines an image map.

Categories: 			Flow content.

Contained By: 			Where flow content is expected.

Content Model: 			Flow content.

ATTRIBUTES

Global attributes

name

DOM INTERFACE

interface HTMLMapElement : HTMLElement {
	attribute DOMString name;
	readonly attribute HTMLCollection areas;
	readonly attribute HTMLCollection images;
};

4.3.8.12 The area element 				Start tag: required End tag: required

The area element represents either a hyperlink with some text and a corresponding area on an image map,
or a dead area on an image map.

Categories: 			Flow content
						Phrasing content

Contained By: 			Where phrasing content is expected, but only if there is a map element ancestor

Content Model: 			Empty

ATTRIBUTES

Global attributes

alt

coords

shape

href

target

ping

rel

media

hreflang

type

DOM INTERFACE

interface HTMLAreaElement : HTMLElement {
	attribute DOMString alt;
	attribute DOMString coords;
	attribute DOMString shape;
	attribute DOMString href;
	attribute DOMString target;
	attribute DOMString ping;
	attribute DOMString rel;
	readonly attribute DOMTokenList relList;
	attribute DOMString media;
	attribute DOMString hreflang;
	attribute DOMString type;
}

4.3.9 Tabular Data

4.3.9.1 The table element 			Start tag: required End tag: required

The table element represents data with more than one dimension (a table).

Categories: 	Flow content.

Contained By: 	Where flow content is expected

Content Model: 	In this order: optionally a caption element, followed by either zero or more colgroup elements,
				followed optionally by a thread element, followed optionally by a tfoot element, followed by
				either zero or more tbody elements or one or more tr elements, optionally by a tfoot element
				(but there can only be one tfoot element child in total)

ATTRIBUTES
Global Attributes

DOM INTERFACE

interface HTMLTableElement : HTMLElement {
	attribute HTMLTableCaptionElement caption;
	HTMLElement createCaption();
	void deleteCaption();
			attribute HTMLTableSectionElement tHead;
	HTMLElement createTHead();
	void deleteTHead();
			attribute HTMLTableSectionElement tFoot;

	HTMLElement createTFoot();
	void deleteTFoot();
	readonly attribute HTMLCollection tBodies;
	HTMLElement createTBody();
	readonly attribute HTMLCollection rows;
	HTMLElement insertRow([Optional] in long index);
	void deleteRow(in long index);
};

4.3.9.2 The caption element 		Start tag: required End tag: required

The caption element represents the title of the table that is its parent, if it has a 
parent and that is a table element.

Categories: 		None.

Contained By: 		As the first element child of a table element.

Content Model: 		Phrasing content.

ATTRIBUTES

Global attributes

DOM INTERFACE

Uses HTMLElement

4.3.9.3 The colgroup element 			Start tag: optional End tag: optional

The colgroup element represents a group of one or more columns in the table that is its parent,
if it has a parent and that is a table element.

Categories: 		None.

Contained By: 		As a child of a table element, after any caption elements and before any thead, tbody, tfoot and
tr elements.

Content Model: 		Zero or more col elements.

ATTRIBUTES

Global Attributes

span

DOM INTERFACE

interface HTMLTableColElement : HTMLElement {
	attribute unsigned long span;
};

4.3.9.4 The col element 			Start tag: required End tag: empty

If a col element has a parent and that is a colgroup element that itself has a parent that is a table
element, then the col represents one or more columns in the column group represented by that colgroup.

Categories: 		None.

Contained By: 		As a child of a colgroup element that does not have a span attribute.

Content Model: 		Empty.

ATTRIBUTES

Global attribs

span

DOM INTERFACE

HTMLTableColElement, same as for colgroup elements. This interface defines one member, span.

4.3.9.5 The tbody element 					Start tag: optional End tag: optional

The tbody element represents a block of rows that consists of a body of data for the parent table
element, if the tbody element has a parent and it is a table.

Categories: 		None.

Contained By: 		As a child of a table element, after any caption, colgroup, and thead elements, but only if there
are no tr elements that are children of the table element.

ATTRIBUTES

Global attributes

DOM INTERFACE

interface HTMLTableSectionElement : HTMLElement {
	readonly attribute HTMLCollection rows;
	HTMLElement insertRow([Optional] in long index);
	void deleteRow(in long index); 
};

The HTMLTableSectionElement interface is also used for thead and tfoot elements.

4.3.9.6 The thead element 				Start tag: optional 	End tag: optional

The thead element represents the block of rows that consist of the column labels (headers) for the
parent table element, if the thead element has a parent and it is a table.

Categories: 			None.

Contained By: 			As a child of a table element, after any caption, and colgroup elements and before any tbody, tfoot
and tr elements, but only if there are no other thead elements that are children of the table element.

Content Model: 			Zero or more tr elements

ATTRIBUTES

Global attributes

DOM INTERFACE

HTMLTableSectionElement, as defined for tbody elements.

4.3.9.7 The tfoot element 			Start tag: optional 	End tag: optional

The tfoot element represents the block of rows that consists of the column summaries (footers) for the parent
table element, if the tfoot element has a parent and it is a table.

Categories: 		None.

Contained By: 		As a child of a table element, after any caption, colgroup and thead elements and before any
tbody and tr elements, but only if there are no other tfoot elements that are children of the table element.

As a child of a table element, after any caption, colgroup, thead, tbody and tr elements, but only if there are
no other tfoot elements that are children of the table element.

Content Model: 	Zero or more tr elements.

ATTRIBUTES

Global attributes

DOM INTERFACE

HTMLTableSectionElement, as defined for tbody elements.

4.3.9.8 The tr element 				start tag: required 		end tag: optional

The tr element represents a row of cells in a table.

Categories: 		None.

Contained By: 		As a child of a thead element.
					As a child of a tbody element.
					As a child of a tfoot element.
					As a child of a table element, after any caption, colgroup, and thead elements, but only if 
					there are no tbody elements that are children of the table element.

Content Model: 		Zero or more td or th elements.

ATTRIBUTES

Global attributes

DOM INTERFACE

interface HTMLTableRowElement : HTMLElement {
	readonly attribute long rowIndex;
	readonly attribute long sectionRowIndex;
	readonly attribute HTMLCollection cells;
	HTMLElement insertCell([Optional] in long index);
	void deleteCell(in long index);
};

4.3.9.9 The td element 				Start tag: required End tag: optional

The td element represents a data cell in a table.

Categories: 		Sectioning root.

Contained By: 		As a child of a tr element.

Content Model: 		Flow content

Attributes

Global attributes

colspan

rowspan

headers

DOM INTERFACE

interface HTMLTableDataCellElement : HTMLTableCellElement {};

4.3.9.10 The th element 			Start tag: required End tag: optional

The th element represents a header cell in a table

Categories: 		None.

Contained By: 		As a child of a tr element.

Content Model: 		Phrasing content

ATTRIBUTES

Global attributes

colspan

rowspan

headers

scope

DOM INTERFACE

interface HTMLTableHeaderCellElement : HTMLTableCellElement {
	attribute DOMString scope;
};

4.3.10 Forms

4.3.10.1 	The form element 				Start tag: required 		End tag: 	required

The form element represents a collection of form-associated elements, some of which can represent
editable values that can be submitted to a server for processing.

Categories: 		Flow content

Contained By: 		Where flow content is expected.

Content MOdel: 		Flow content, but with no form element descendants.

ATTRIBUTES

Global attributes

accept-charset

action

autocomplete

enctype

method

name

novalidate

target

DOM INTERFACE

[Callable=namedItem]
interface HTMLFormElement : HTMLElement {
	attribute DOMString acceptCharset;
	attribute DOMString action;
	attribute boolean autocomplete;
	attribute DOMString enctype;
	attribute DOMString method;
	attribute DOMString name;
	attribute boolean novalidate;
	attribute DOMString target;

	readonly attribute HTMLFormControlsCollection elements;
	readonly attribute long length;
	[IndexGetter] any item(in DOMString name);
	[NameGetter=OverrideBuiltins] any namedItem(in DOMString name);

	void submit();
	void reset();
	boolean checkValidity();

	void dispatchFormInput();
	void dispatchFormChange();
};

4.3.10.2 The fieldset element 				Start tag: required 		End tag: required

The fieldset element represents a set of form controls grouped under a common name.

Categories: 			Flow content
						Listed form-associated element.

Contained By: 			Where flow content is expected.

Content Model: 			One legend element followed by flow content.

ATTRIBUTES

Global attributes

disabled

form

name

DOM INTERFACE

interface HTMLFieldSetElement : HTMLElement {
	attribute boolean disabled;
	readonly attribute HTMLFormElement form;
	attribute DOMString name;

	readonly attribute DOMString type;

	readonly attribute HTMLFormControlsCollection elements;

	readonly attribute boolean willValidate;
	readonly attribute ValidityState validity;
	readonly attribute DOMString validationMessage;

	boolean checkValidity();
	void setCustomValidity(in DOMString error);
};

4.3.10.3 The label element 					start tag: required 		end tag: required

The label represents a caption in a user interface. The caption can be associated with a specific form
control, known as the label element's labeled control.

Categories: 		Flow content
					Phrasing content
					Interactive content
					Form-associated element.

Contained By: 		Where phrasing content is expected.

Content Model: 		Phrasing content, but with no descendant labelable form-associated elements unless it is 
					the element's labeled control, and no descendant label elements.

ATTRIBUTES

Global attributes

form

for

DOM INTERFACE

interface HTMLLabelElement : HTMLElement {
	readonly attribute HTMLFormElement form;
	attribute DOMString htmlFor;
	readonly attribute HTMLElement control;
};

4.3.10.4 The input element 						Start tag: required 		End tag: empty

The input element represents a typed data field, usually with a form control to allow the user
to edit the data.

Categories: 			Flow content
						Phrasing content
						If the type attribute is not in the Hidden state: Interactive Content
						Listed, labeable, submittable, and resettable form-associated element.

Contained By: 			Where phrasing content is expected.

Content Model: 			Empty.

ATTRIBUTES

Global attributes

accept

action

alt

autocomplete

autofocus

checked

disabled

enctype

form

height

list

max

maxlength

method

min

multiple

name

novalidate

pattern

placeholder

readonly

required

size

src

step

target

type

value

width

DOM INTERFACE

interface HTMLInputElement : HTMLElement {
	attribute DOMString accept;
	attribute DOMString action;
	attribute DOMString alt;
	attribute boolean autocomplete;
	attribute boolean autofocus;
	attribute boolean defaultChecked;
	attribute boolean checked;
	attribute boolean disabled;

	attribute DOMString enctype;
	readonly attribute HTMLFormElement form;
	attribute DOMString height;

	attribute boolean indeterminate;
	readonly attribute HTMLElement list;
	attribute DOMString max;
	attribute long maxLength;
	attribute DOMString method;

	attribute DOMString min;
	attribute boolean multiple;
	attribute DOMString name;
	attribute boolean noValidate;

	attribute DOMString pattern;
	attribute DOMString placeholder;
	attribute boolean readOnly;

	attribute boolean required;
	attribute unsigned long size;
	attribute DOMString src;
	attribute DOMString step;

	attribute DOMString target;
	attribute DOMString type;
	attribute DOMString defaultValue;
	attribute DOMString value;

	attribute Date valueAsDate;
	attribute float valueAsNumber;
	readonly attribute HTMLOptionElement selectedOption;
	attribute DOMString width;

void setpUp(in long n);
void stepDown(in long n);

readonly attribute boolean willValidate;
readonly attribute ValidityState validity;
readonly attribute DOMString validationMessage;
boolean checkValidity();
void setCustomValidity(in DOMString error);

readonly attribute NodeList labels;

void select();
		attribute unsigned long selectionStart;
		attribute unsigned long selectionEnd;
		void setSelectionRange(in unsigned long start, in unsigned long end);
};

4.3.10.5 The button element 				Start tag: required 		End tag: required

The button element represents a button. If the element is not disabled, then the user agent should
allow the user to activate the button.

Categories: 		Flow content
					Phrasing content
					Interactive content
					Listed, labelable, and submittable form-associated element.

Contained By: 		Where phrasing content is expected.

Content Model: 		Phrasing content, but there must be no interactive content descendant.

Attributes

Global attributes

action

autofocus

disabled

enctype

form

method

name

novalidate

target

type

value

DOM INTERFACE

interface HTMLButtonElement : HTMLElement {
	attribute DOMString action;
	attribute boolean autofocus;
	attribute boolean disabled;
	attribute DOMString enctype;
	readonly attribute HTMLFormElement form;
	attribute DOMString method;

	attribute DOMString name;
	attribute DOMString noValidate;
	attribute DOMString target;
	attribute DOMString type;
	attribute DOMString value;

readonly attribute boolean willValidate;
readonly attribute ValidityState validity;
readonly attribute DOMString validationMessage;
boolean checkValidity();
void setCustomValidity(in DOMString error);

readonly attribute NodeList labels;
};

4.3.10.6 The select element 				Start tag: required 		End tag: required

The select element represents a control for selecting amongt a set of options.

Categories: 			Flow content
						Phrasing content
						Interactive content
						Listed, labelable, submittable, and resettable form-associated element.

Contained By: 			Where phrasing content is expected.

Content Model: 			Zero or more option or optgorup elements.

ATTRIBUTES

Global attributes

autofocus

disabled

form

multiple

name

size

DOM INTERFACE

[Callable=namedItem]
interface HTMLSelectElement : HTMLElement {
	attribute boolean autofocus;
	attribute boolean disabled;
	readonly attribute HTMLFormElement form;
	attribute boolean multiple;
	attribute DOMString name;
	attribute boolean size;

readonly attribute DOMString type;

readonly attribute HTMLOptionsCollection options;
		 attribute unsigned long length;
[IndexGetter] any item(in DOMString name);
[NameGetter] any namedItem(in DOMString name);

void add(in HTMLElement element, in HTMLElement before);
void add(in HTMLElement element, in long before);
void remove(in long index);

readonly attribute HTMLCollection selectedOptions;
		 attribute long selectedIndex;
		 attribute DOMString value;

readonly attribute boolean willValidate;
readonly attribute ValidityState validity;
readonly attribute DOMString validationMessage;
boolean checkValidity();

void setCustomValidity(in DOMString error);

readonly attribute NodeList labels;
};


4.3.10.7 The datalist element 							Start tag: required 		End tag: required

The datalist element represents a set of option elements that represent predefined options for other controls.
The contents of the element represents fallback content for legacy user agents, intermixed with option elements
that represent the predefined options. In teh rendering, the datalist elemetn represents nothing and it, along with
its children, should be hidden.

Categories: 			Flow content
						Phrasing content

Contained By: 			Where phrasing content is expected

Content Model: 			Either: phrasing content
						Or: Zero or more option elements.

ATTRIBUTES

Global attributes

DOM INTERFACE

interface HTMLDataListElement : HTMLElement {
	readonly attribute HTMLCollection options;
};

4.3.10.8 The optgroup element 					Start tag: required 		End tag: 	optional

The optgroup element represents a group of option elements with a common label.

Categories: 		None.

Contained By: 		As a child of a select element.

Content Model: 		Zero or more option elements.

ATTRIBUTES

Global attributes

disabled

label

DOM INTERFACE

interface HTMLOptGroupElement : HTMLElement {
	attribute boolean disabled;
	attribute DOMString label;
};

4.3.10.9 The option element 					Start tag: required 		End tag: 	optional

The option element represents an option in a select element or as part of a list of suggestions in a datalist
element.

Categories: 			None.

Contained By: 			As a child of a select element.
						As a child of a datalist element.
						As a child of an optgroup element.

Content Model: 			Text

ATTRIBUTES

Global attributes

disabled

label

selected

value

DOM INTERFACE

[NamedConstructor=Option(),
NamedConstructor=Option(in DOMString text),
NamedConstructor=Option(in DOMString text, in DOMString value),
NamedConstructor=Option(in DOMString text, in DOMString value, in boolean defaultSelected),
NamedConstructor=Option(in DOMString text, in DOMString value, in boolean defaultSelected, in boolean selected)]
interface HTMLOptionElement : HTMLElement {
	attribute boolean disabled;
	readonly attribute HTMLFormElement form;
	attribute DOMString label;
	attribute boolean defaultSelected;
	attribute boolean selected;
	attribute DOMString value;

readonly attribute DOMString text;
readonly attribute long index;

};

4.3.10.10 The textarea element 								Start tag: required 		End tag: 	required

The textarea element represents a multiline plain text edit control for the element's raw value. The contents of
the control represents the control's default value.

Categories: 		Flow content
					Phrasing content
					Interactive content
					Listed, labelable, submittable, and resettable form-associated element.

Contained By: 		Where phrasing content is expected.

Content Model: 		Text.

ATTRIBUTES

Global attributes

autofocus

cols

disabled

form

maxlength

name

readonly

required

rows

wrap

DOM INTERFACE

interface HTMLTextAreaElement : HTMLElement {
	attribute boolean autofocus;
	attribute unsigned long cols;
	attribute boolean disabled;
	readonly attribute HTMLFormElement form;
	attribute long maxLength;
	attribute DOMString name;
	attribute boolean readOnly;
	attribute boolean required;
	attribute unsigned long rows;
	attribute DOMString wrap;

	readonly attribute DOMString type;
	attribute DOMString defaultValue;
	attribute DOMString value;

readonly attribute boolean willValidate;
readonly attribute ValidityState validity;
readonly attribute DOMString validationMessage;
boolean checkValidity();
void setCustomValidity(in DOMString error);

readonly attribute NodeList labels;

void select();
		attribute unsigned long selectionStart;
		attribute unsigned long selectionEnd;
void setSelectionRange(in unsigned long start, in unsigned long end);
};

4.3.10.11 The output element 							Start tag: required End tag: required

The output element represents the result of a calculation.

Categories: 			Flow content
						Phrasing content
						Listed and resettable form-associated element.

Contained By: 			Where phrasing content is expected.

Content Model: 			Phrasing content

ATTRIBUTES

Global attributes

for

form

name

DOM INTERFACE

interface HTMLOutputElement : HTMLElement {
	attribute DOMString htmlFor;
	readonly attribute HTMLFormElement form;
	attribute DOMSTring name;

	readonly attribute DOMString type;
	attribute DOMString defaultValue;
	attribute DOMString value;

readonly attribute boolean willValidate;
readonly attribute ValidityState validity;
readonly attribute DOMString validationMessage;
boolean checkValidity();
void setCustomValidity(in DOMString error);
};

4.3.11 Interactive Elements

4.3.11.1 The details element 					Start tag: required 		End tag: 	required

The details element represents additional information or controls which the user can obtain on demand.

Categories: 		Flow content
					Interactive content

Contained By: 		Where flow content is expected

Content Model: 		One legend element followed by flow content.

ATTRIBUTES

Global attributes
open

DOM INTERFACE

interface HTMLDetailsElement : HTMLElement {
	attribute boolean open;
};

4.3.11.2 The command element 			Start tag: required End tag: empty

The command element represents a command that hte user can invoke

Categories: 		Metadata content
					Flow content
					Phrasing content

Contained By: 		Where metadata content is expected
					Where phrasing context is expected

Content Model: 		Empty.

ATTRIBUTES 		

Global attributes

type

label

icon

disabled

checked

radiogroup

default

Also, the title attribute has special semantics on this element.

DOM INTERFACE

interface HTMLCommandElement : HTMLElement {
	attribute DOMString type;
	attribute DOMString label;
	attribute DOMString icon;
	attribute boolean disabled;
	attribute boolean checked;
	attribute DOMString radiogroup;
	attribute boolean default;
void click(); // shadows HTMLElement.click()
};

The command interface must also be implemented by this element.

4.3.11.3 The bb element 					Start tag: required 	End tag: 	required

The bb element represents a user agent command that the user can invoke.

Categories: 		Flow content
					Phrasing content
					Interactive content

Contained By: 		Where phrasing content is expected.

Content Model: 		Phrasing content, but there must be no interactive content descendant.

ATTRIBUTES

Global attributes

type

DOM INTERFACE

interface HTMLBrowserButtonElement : HTMLElement {
	attribute DOMString type;
	readonly attribute boolean supported;
	readonly attribute boolean disabled;
};

The command interace must also be implemented by this element

4.3.11.4 The menu element 								Start tag: required End tag: required

The menu element represents a list of commands.

Categories: 		Flow content
					If the elementy's type attribute is in the tool bar state: Interactive content.

Contained By: 		Where flow content is expected

Content Model: 		Either: Zero or more li elements.
					Or: Flow content.

ATTRIBUTES

Global attributes

type

label

DOM INTERFACE

interface HTMLMenuElement : HTMLElement {
	attribute DOMString type;
	attribute DOMString label;
};

4.3.12 miscellaneous Elements

4.3.12.1 The legend element 				Start tag: required End tag: required

The legend element represents a title or explanatory caption for hte rest of the contents of
the legend element's parent element.

Categories: 		None.

Contained By: 		AS the first child of a fieldset element.
					AS the first child of a details element.
					As a child of a figure element, if there are no other legend element children 
					of that element.

Content Model: 		Phrasing content

ATTRIBUTES

Global attributes

DOM INTERFACE

interface HTMLLegendElement : HTMLElement {
	readonly attribute HTMLFormElement form;
};

4.3.12.2 The div element 				Start tag: required End tag: required

The div element represents nothing at all. It can be used with the class, lang/xml:lang, and title
attributes to mark up semantics common to a group of consecutive elements.

Categories: 		Flow content

Contained By: 		Where flow content is expected

Content Model: 		Flow content

ATTRIBUTES

Global attributes

DOM INTERFACE

Uses HTMLElement.

4.4 Microdata

...

5 Index of Elements

5.1 Conforming Elements

Element 		Start Tag 			End Tag 			Short Desc 				Notes

a 				required 			required 			Hyperlink

abbr 			required 			required 			Abbreviation

address 		required 			required 			Contact information

area 			required 			empty 				Image map region

article 		required 			required 			Independent section

aside 			required 			required 			Auxiliary Section

audio 			required 			required 			Audio stream

b 				required 			required 		 	Bold text

base 			required 			empty 				Document base URI

bb 				required 			required 			browser button

bdo 			required 			required 			Bi-directional text override

blockquote 		required 			required 			Long quotation

body 			optional 			optional 			Main content

br 				required 			empty 				Line break

button 			required 			required 			Push button control

canvas 			required 			required 			Bitmap canvas

caption 		required 			required 			Table caption

cite 			required 			required 			Citation

code 			required 			required 			Code fragment

col 			required 			empty 				Table column

colgroup 		required 			optional 			Table column group

command 		required 			empty 				Command that a user can invoke

datagrid 		required 			required 			interactive tree, list or tabular data

datalist 		required 			required 			Predefined control values

dd 				required 			optional 			Description description

del 			required 			required 			Deletion

details 		required 			required 			Additional information

dfn 			required 			required 			Defining instance of a term

dialog 			required 			required 			Conversation

div 			required 			required 			Generic division

dl 				required 			required 			Description list

dt 				required 			optional 			Description item

em 				required 			required 			Stress emphasis

embed 			required 			empty 				Embedded application

fieldset 		required 			required 			Form control group

figure 			required 			required 			A figure with a caption

footer 			required 			required 			Section footer

form 			required 			required 			Form

h1 				required 			required 			Heading level 1 						The heading level is also affected by sectioning elements

h2 				required 			required 			Heading level 2

h3 				required 			required 			Heading level 3

h4 				required 			required 			Heading level 4

h5 				required 			required 			Heading level 5

h6 				required 			required 			Heading level 6

head 			optional 			optional 			Document head

header 			required 			required 			Section header

hr 				required 			empty 				Separator

html 			optional 			optional 			Document root

i 				required 			required 			Italic text

iframe 			required 			required 			Inline frame

img 			required 			empty 				Image

input 			required 			empty 				Form control

ins 			required 			required 			Insertion

kbd 			required 			required 			User input

label 			required 			required 			Form control label

legend 			required 			required 			Explanatory, title or caption

li 				required 			optional 			List item

link 			required 			empty 				Link to resources

map 			required 			required 			Client-side image map

mark 			required 			required 			Marked or highlighted text

menu 			required 			required 			Command menu

meta 			required 			empty 				Metadata

meter 			required 			required 			Scalar measurement

nav 			required 			required 			Navigation

noscript 		required 			required 			Alternative content for no script support

object 			required 			required 			Generic embedded resource

ol 				required 			required 			Ordered List

optgroup 		required 			optional 			Option group

option 			required 			optional 			Selection choice

output 			required 			required 			Output control

p 				required 			optional 			Paragraph

param 			required 			empty 				Plugin param

pre 			required 			required 			Preformatted text

progress 		required 			required 			Progress of a task

q 				required 			required 			Inline quotation

rp 				required 			required 			Ruby paranthesis

rt 				required 			required 			Ruby text

ruby 			required 			required 			Ruby annotation

samp 			required 			required 			Sample output

script 			required 			required 			Linked or embedded script

section 		required 			required 			Document section

select 			required 			required 			Selection control

small 			required 			required 			Small print

source 			required 			empty 				Media resource

span 			required 			required 			Generic inline container

strong 			required 			required 			Strong importance

style 			required 			required 			embedded stylesheet

sub 			required 			required 			Subscript

sup 			required 			required 			Superscript

table 			required 			required 			Table

tbody 			optional 			optional 			Table body

td 				required 			optional 			Table cell

textarea 		required 			required 			Multi-line text control

tfoot 			optional 			optional 			Table footer

th 				required 			optional 			Table header cell

thead 			optional 			optional 			Table head

time 			required 			required 			Date and/or time

title 			required 			required 			Document title

tr 				required 			optional 			Table row

ul 				required 			required 			Unordered list

var 			required 			required 			Variable

video 			required 			required 			Video or move

5.2 Obsolete Elements

these elements are obsolete and should not be used by authors. However, they are documented here because they are supported
by browsers, along with notes about conforming alternatives that may be used instead.

THis list may be incomplete. Please report any missing elements.

Element 		Start tag 		End tag 			Short Desc 								Notes

acronym 		required 		required 			Acronym 				use the abbr element

applet 			required 		required 			Java applet 			use the object element

basefont 		required 		empty 				Base font style 		This has limited support in browsers. Use CSS instead

bgsound 		required 		empty 										use the audio element

big 			required 		required 									Use a semantically appropiate element with CSS for style.

blink 			required 		required 									CSS provides an alternative with limited browser support
																			but note that blinking text is annoying.

center 			required 		required 									use a semantically appropiate element with CSS for style.

dir 			required 		required 									Use the ul element

font 			required 		required 			Font style 				Use a semantically appropiate element with CSS for style.

frame 			required 		required 									Consider using CSS layouts or the iframe element.

frameset 		required 		required 									Consider using CSS layouts or the iframe element.

isindex 		required 		required 									Use a form with text input and submit button.

listing 		required 		required 			Preformatted text 		Use the pre element

marquee 		required 		required 									Scripting or CSS animations can be used to simulate scrolling text.

nobr 			required 		required 									Use a semantically appropiate element with CSS for style.

noembed 		required 		required 		

noframes 		required 		required

plaintext 		required 		required 			Preformatted text 		Use the pre element

s 				required 		required 									Consider using the del element, if appropiate, or another semantically
																			appropiate element with CSS for style.

spacer 			required 		required 									Use CSS layout techniques

strike 			required 		required 									Consider using the del element, if appropiate, or another semantically
																			appropiate element with CSS for style.

tt 				required 		required 			Teletype 				Consider using the code element, if appropiate, or another semantically
																			appropiate element with CSS for style.

u 				required 		required 									Use a semantically appropiate element with CSS for style.

wbr 			required 		empty 

xmp 			required 		required 			Preformatted text 		Use the pre element

5.3 Comparison of HTML 4.01 and HTML5 Elements

Element 		HTML 4.01/XHTML 1.0 	HTML5 	Short Desc

a 				strict 					yes 	Hyperlink

abbr 			strict 					yes 	Abbreviation

acronym 		strict 					- 		Acronym

address 		strict 					yes 	Contact information

applet 			transitional 			- 		Java applet

area 			strict 					yes 	image map region

article 		- 						yes 	independent section

aside 			- 						yes 	Auxilliary section

audio 			- 						yes 	Audio stream

b 				strict 					yes 	Bold text

base 			strict 					yes 	Document base URI

basefont 		transitional 			- 	 	Base font style

bb 				- 						yes 	browser button

bdo 			strict 					yes 	Bi-directional text override

bgsound 		- 						- 

big 			strict 					-

blink 			- 						-

blockquote 		strict 					yes 	Long quotation

body 			strict 					yes 	Main content

br 				strict 					yes 	Line break

button 			strict 					yes 	Push button control

canvas 			- 						yes 	Bitmap canvas

caption 		strict 					yes 	Table caption

center 			transitional 			- 	

cite 			strict 					yes 	Citation

code 			strict 					yes 	Code fragment

col 			strict 					yes 	Table column

colgroup 		strict 					yes 	Table column group

command 		- 						yes 	Command that a user can invoke

datagrid 		- 						yes 	Interactive tree, list or tabular data

datalist 		- 						yes 	Predefined control values

dd 				strict 					yes 	Description description

del 			strict 					yes 	Deletion

details 		- 						yes 	Additional information

dfn 			strict 					yes 	Definining instance of a term

dialog 			- 						yes 	Conversation

dir 			transitional 			- 

div 			strict 					yes 	Generic division

dl 				strict 					yes 	Description list

dt 				strict 					yes 	Description term

em 				strict 					yes 	Stress emphasis

embed 			- 						yes 	Embedded application

fieldset 		strict 					yes 	Form control group

figure 			- 						yes 	A figure with a caption

font 			transitional 			- 		Font style

footer 			- 						yes 	Section footer

form 			strict 					yes 	Form

frame 			framset 				-

frameset 		framset 				-

h1 				strict 					yes 	Heading level 1

h2 				strict 					yes 	heading level 2

h3 				strict 					yes 	heading level 3

h4 				strict 					yes 	heading level 4

h5 				strict 					yes 	heading level 5

h6 				strict 					yes 	Heading level 6

head 			strict 					yes 	Document head

header 			- 						yes 	Section header

hr 				strict 					yes 	Separator

html 			strict 					yes 	Document root

i 				strict 					yes 	Italic text

iframe 			transitional 			yes 	Inline frame

img 			strict 					yes 	Image

input 			strict 					yes 	Form control

ins 			strict 					yes 	Insertion

isindex 		transitional 			-

kbd 			strict 					yes 	User input

label 			strict 					yes 	Form control label

legend 			strict 					yes 	Explanatory title or caption

li 				strict 					yes 	List item

link 			strict 					yes 	Link to resources

listing 		- 						- 		Preformatted text

map 			strict 					yes 	Client-side image map

mark 			- 						yes 	Marked or highlighted text

marquee 		- 						-

menu 			transitional 			yes 	Command menu

meta 			strict 					yes 	Metadata

meter 			- 						yes 	Scalar measurement

nav 			- 						yes 	Navigation

nobr 			- 						-

noembed 		- 						-

noframes 		frameset 				-

noscript 		strict 					yes 	Alternative content for no script support

object 			strict 					yes 	Generic embedded resource

ol 				strict 					yes 	Ordered list

optgroup 		strict 					yes 	Option group

option 			strict 					yes 	Selection choice

output 			- 						yes 	Output control

p 				strict 					yes 	Paragraph

param 			strict 					yes 	PLugin parameter

plaintext 		- 						- 		Preformatted text

pre 			strict 					yes 	Preformatted text

progress 		- 						yes 	Progress of a task

q 				strict 					yes 	Inline quotation

rp 				- 						yes 	Ruby paranthesis

rt 				- 						yes 	Ruby text

ruby 			- 						yes 	Ruby annotation

s 				transitional 			-

samp 			strict 					yes 	Sample output

script 			strict 					yes 	Linked or embedded script

section 		- 						yes 	Document section

select 			strict 					yes 	Selection control

small 			strict 					yes 	Small print

source 			- 						yes 	media resource

spacer 			- 						-

span 			strict 					yes 	Generic inline container

strike 			transitional 			-

strong 			strict 					yes 	Strong importance

style 			strict 					yes 	Embedded stylesheet

sub 			strict 					yes 	Subscript

sup 			strict 					yes 	Superscript

table 			strict 					yes 	Table

tbody 			strict 					yes 	Table body

td 				strict 					yes 	Table cell

textarea 		strict 					yes 	Multi-line text control

tfoot 			strict 					yes 	Table footer

th 				strict 					yes 	Table header cell

thead 			strict 					yes 	Table head

time 			- 						yes 	Date and/or time

title 			strict 					yes 	Document title

tr 				strict 					yes 	Table row

u 				transitional 			-

ul 				strict 					yes 	Unordered list

var 			strict 					yes 	Variable

video 			- 						yes 	Video or movie

wbr 			- 						-

xmp 			- 						- 		preformatted text

6. How to read this guide:

This section needs major revision and may be dropped.

6.1 Conventions 

To ease readability and improve understanding, this document uses a number of conventions.

6.1.1 Notes, Tips and Warnings

Notes are used throughout this document to provide additional information. Tips are used to provide useful hints
and suggestions. Warnigns are used to point out common authoring errors and highlight important issues oteb aware
of.

6.1.2 Example Markup

Example markup is provided for both HTML and XHTML. In some cases, the markup is the same and thus only ony example is needed,
but in others there may be differences synctatic differences. Where HTML and XHTML differ, separate examples are given
with each one clearly labelled.

HTML Example

<!DOCTYPE html>
<html lang="en">
<head>
	<title>HTML Example</title>
</head>
<body>
	<p>This is a sample HTML document.
</body>
</html>

XHTML example

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>XHTML example</title>
</head>
<body>
	<p>This is a sample XHTML document.</p>
</body>
</html>

Sometimes, errornous examples are included. THis is usually done to illustrate common authoring errors,
bad practices and other issues ot be cautious of.

Erorrneous example

<p>This markup contains a <em><strong>mistake</em></strong></p>

6.1.2.1 Attributes

Unless explicitly stated otherwise for a specific purpose, all attribute values in examples are quoted using 
double quotes. In HTML examples, boolean attributes are written in their minimised form and in XHTML examples,
they are written in expanded form.

HTML Example

<input type="checkbox" checked>

XHTML Example

<input type="checkbox" checked="checked"/>

6.1.2.2 Void Elements

In XHTML examples, due to the XML Well-Formedness requirements, void elements are always marked up
using the trailing slash.

XHTML example

<img src="image.png" alt="example"/>

In HTML however, the trailing slash is optional and unless explicitly stated otherwise, is always omitted.

HTML example

<img src="images.png" alt="example"/>

6.1.2.3 Namespaces

Some XHTML examples makes use of XML namespaces. In such cases, the following prefixes are assumed to be defined
even if there is no xmlns attirbutes in the fragment of the code.

xml
	http://www.w3.org/XML/1998/namespace
html
	http://www.w3.org/1999/xhmtl
math
	http://www.w3.org/1998/Math/MathML
svg
	http://www.w3.org/2000/svg

XHTML Example
	<html xml:lang="en">
	...
	</html>

XHTML Example

<div>
<svg:svg><svg:circle r="50" cx="50" cy="50" fill="green"/></svg:svg>
</div>

//First part was sweeped away, moving on to http://w3c.github.io/html/introduction.html#introduction

HTML 5.2 

Editor's Draft, 28 September 2017

1. Introduction

1.1 Background

This section is non-normative.

HTML is the WWW's core markup language. Originally, HTML, was primarly designed as a language
for semantically describing scientific documents. Its general design, however, has enabled
it to be adapted, over the subsequent years, to describe a number of other types of documents
and even applications.

1.2 Audience

THis section is non-normative

This specification is intended for authors of documents and scrips that use the features defined 
in this specification, implementors of tools that operate on pages that use the features defined
in this specification, and individuals wishing to establish the correctness of documents or implementations
with respect to the requirements of this specification.

This document is probably not suited to readers who do not already have at least passing familiart with
Web techs, as in places it sacrifices calrity for precision and brevity for completeness.
More approachable tutotirals and authoring guides can provide a gentler intro to the topic.

In particular, familiarity with the basics of DOM is nececsary for a complete understanding of
some of the mroe technical parts of this specification. An understanding of Web IDL, HTTP, XML, Unicode
, Char encodings, JS and CSS will also be helpful in parts but not essential.

1.3 Scope

This seciton is non-normative

This specification is limited to providing a semantic-level markup language and associated semantic-level
scripting APIs for authoring accessible pages on the Web ranging from static documents to dynamic apps.

The scope of this specification does not include providing mechanisms for media-specific customization
of presentation (although default rendering rules for Web browsers are included at the end of this 
specification and several mechanisms for hooking into CSS are provided as part of the language).

The scope of this specification is not to describe an entire OS. In particular, hardware config
software, image manipulation tools, and applications that users would be expected to use with 
high-end workstations on a daily basis are out of scope. In terms of apps, this specification
is targeted specifically at applications that would be expected to be used by users on occasional
basis, or regularly but from disparate locations, with low CPU requirements.

Examples of such applications include online online purchasing systems, searching systems, games (Especially
multiplayer online games), public telephone books or address books, communications software (e-amil
clients, instant messaging clients, discussion software), document editing software, etc.

1.4 History

This section is non-normative.

For its first five years (1990-1995), HTML went through a number of revisions and experienced a number of
extensions, primarily hosted first at CERN and then at the IETF.

With the creation of W3C, HTML's development changed venue again. A first abortive attempt at extending
HTML in 1995 known as HTML 3.0 then made way to a more pragmatic approach known as HTML 3.2, which
was completed in 1997. HTML 4.01 quickly followed later that same year.

The following year, the W3C membership decided to stop evolving HTML and instead begin work on an
XML-based equivalent, called XHTML. This effort started with a reformulation of HTML 4.01 in XMl,
known as XHTML  1.0, which added no new features except the new serialization, and which was completed
in 2000.

After XHTML 1.0, the W3C's focus turned to making it easier for other working groups to extend XHTML,
under the banner of XHTML Modularization. In parallel with this, the W3C also worked on a new language
that was not compatible with the earlier HTML and XHTML languages, calling it XHTML 2.0.

Around the time that HTML's evolution was stopped in 1998, parts of the API for HTML developed by
browser vendors were specified and published under the name DOM level 1 (in 1998) and DOM level 2
Core and DOM Level 2 HTML (Starting in 2000 and culminating in 2003). These efforts then petered out,
with some DOM Level 3 specifications published in 2004 but the working group being closed before 
all teh Level 3 drafts were completed.

In 2003, the publication of XForms, a technology which was positioned as the next generation of Web
forms, sparked a renewed interest in evolving HTML itself, rather than finding replacements for it.
This interest was borne from the realization that XML's deployment as a Web technology was limited
to entirely new techs (like RSS and later Atom), rather than as a replacement for existing deployed
techs (like HTML).

A proof of concept to show that it was possible to extend HTML 4.01 's form to provide many of the
features that XForms 1.0 introduced, without requiring browsers to implement rendering engines that 
were incomaptible with existing HTML Web pages, was the first result of this renewed interest.

At this early stage, while the draft was already publicly available, and input was already being solicited
from all sources, the specification was only under Opera Software's copyright.

The idea that HTML's evolution should be reopened was tested at a W3C workshop in 2004, where some of
the principles that underlie the HTML work (described below), as well as teh aformentioned early
draft proposal convering just forms-related features, were presented to the W3C jointly by Mozilla
and Opera.

The proposal was rejected on the gorunds that the proposal conflicted with the previously chosen
direction for the Web's evolution; the W3C staff and membership voted to continue developing XML-based
replacements instead.

Shortly thereafter, Apple, Mozilla and Opera jointly announced their intent to continue working on
the effort under the umbrella of a new venue called WHATWG. A public mailing list was created and
the draft was moved to the WHATWG site. The copyright was subsequently amended to be jointly owned
by all three vendors, and to allow reuse of this specification.

The WHATWG was based on several core principles, in particular that tech needs to be backwards 
compatible, that specification and implementations need to match even if this means changing
the specification rather than the implementations, and that specificaitons need ot be detailed
enough that implemetnations can achieve complete interoperability without reverse-engineering
each other.

The latter requirement in particular required that the scope of the HTML specification include
what had previously been specified in three separate documents. HTML 4.01, XHTML 1.1, and
DOM Level 2 HTML. It is also meant including significantly more detail than had previously
been considered the norm.

In 2006, the W3C indicated an interest to participate in the development of HTML 5.0 after all,
and in 2007 formed a working group charted to work with the WHATWG on the development of the HTML
specification.

Apple, Mozilla, and Opera allowed the W3C to publish the specification under the W3C copyright,
while keeping a version with the less restrictive license on the WHATWG site.

For a number of years, both groups then worked together under the same editor: Ian Hickson. In
2011, the groups came to the conclusion that they had different goals: the W3C wanted to draw
a line in the sand for features for a HTML 5.0 Recommendaton, while the WHATWG wanted to continue
working on a Living Standard for HTML, continously maintining the specification and adding new
features.


In mid 2012, a new editing team was introduced at the W3C to take care of creating a HTML 5.0
Recommendation and prepare a Working Draft for the next HTML version.

Since then, the W3C Web Platform WG has been cherry picking patches from the WHATWG that
resolved bugs registered on the W3C HTML specification or more accurately represented 
implemented reality in user agents. At time of publication of this document, patches from
the WHATWG HTML specification have been merged until January 12, 2016.

The W3C HTML editors have also added patches that resulted from discussions and decisions
made by the W3C Web Platform WG as well a bug fixes from bugs not shared by the WHATWG.

A separate document is published to document the differences between the HTML specified
in this document and the language described in the HTML 4.01 specification. HTML5-DIFF

1.5 Design Notes

it must be admitted that many aspects of HTML appear at first glance to be nonsensical
and inconsistent.

HTML, its supporting DOM APIs, as well as many of its supporting techs, have been developed
over a period of several decades by a wide array of people with different priorities who,
in many cases, did not know of each others existence.

Features have thus arisen from many sources, and have not always been designed in especially
consistent ways. Furthermore, because of the unique characteristics of the Web, implementation
bugs have often become de-facto, and now de-jure, standards, as content is often unintentionally
written in ways that rely on them before they can be fixed.

Despite all this, efforts have been made to adhere to certain design goals. These are described
in the next few subsections.

1.5.1 Serializability of script execution

To avoid exposing Web authors to the complexities of multithreading, the HTML and DOM APIs
are designed such that no script can ever detect the simultaneous execution of other scripts.
Even with workers, the intent is that the behavior of implementations can be thought of as 
completely serializing the execution of all scripts in all browsing contexts.

1.5.2 Compliance with other specifications

This specification interacts with and relies on a wide variety of other specifications.
In certain circumstances, unfortunately, conflicting needs have led to this specification
violating the requirements of htese other specifications.

Whenever this has occurred, the transgressions have each been noted as "willful violation",
and the reason for the violation has been noted.

1.5.3 Extensibility

HTML has a wide array of extensibility mechanisms that can be used for adding semantics
in a safe manner:

AUthors can use the class attribute ot extend elements, effectively creating their own
elements, while using the most applicable existing "real" HTML element, so that browsers
and other tools that do not know of the extension can still support it somewhat well.

This is the tack used by microformats, for example.

Authors can include data for inline client-side scripts or server-side site-wide scripts
to process using the data-*="" atributes. These are guaranteed to never be touched by browsers,
and allows scripts to include data on HTML elements that scripts can then look for and process.

Authors can use the <meta name="" content=""> mechanism to include page-wide metadata by registering
extensions to the predefiend set of metadata names.

Authors can use the rel="" mechanism to annotate links with specific meanings by registering
extensions to the predefined set of link types. This is also used by microformats.

Authors can embed raw data using the <script type=""> mechanism with a custom type, for further
handling by inline or server-side scripts.

Authors can extend APIs using the JS prototyping mechanism. This is widely used by script libs,
for instnace.

1.6 HTML vs XML Syntax

This specification defines an abstract language for describing documents and applications, and some
APIs for interacting with in-memory representations of resources that use this language.

The in-memory representation is known as "DOM HTML", or "the DOM" for short.

There are various concrete syntaxes taht can be used to transmit resources that use this abstract
language, two of which are defined in this specification.

The first such concrete syntax is the HTML syntax. This is the format suggested for most authors.
it is compatible with most legacy Web browsers. If a document is transmitted with the text/html
MIME type, it will be processed as an HTML document by Web Browsers. This specification defines
the latest version of the HTML syntax, known simply as HTML.

The second concrete syntax is the XHTML syntax, which is an application of XML. When a document
is transmitted with an XML MIME type, such as application/xhtml+xml, then it is treated as an
XML document by Web browsers, to be parsed by an XML processor.

Authors are reminded that hte processing for XML and HTML differs; in particular, even minor syntax
errors will prevent a document labeled as XML from beign rendered fully, whereas they would be
ignored in the HTML syntax.

This specification defines the latest version of the XHTML syntax, known simply as XHTML.

the DOM, the HTML syntax, and the XHTML syntax cannot all represnet the same content. For example,
namespaces cannot be represented using the HTML syntax, but they are supported in teh DOM and in the
XHTML syntax.

Similarly, documents that use the <noscript> feature can be represented using the HTML syntax,
but cannot be represented with the DOM or in teh XHTML syntax. COmments that contain the string "-->"
can only be represented in the DOM, not in the HTML and XHTML syntaxes.

1.7 Structure of this specification

This specification is divided into the following major sections:

1. Introduction
	Non-normative materials providing a context for the HTML specification

2. Common infrastructure
	The conformance classes, algorithms, definitions, and the common underpinnings 
	of the rest of the specification.

3 Semantics, structure, and APIs of HTML documents
	Documents are built from elements. These elements form a tree using the DOM. This
	section defines the features of this DOM, as well as introducing the features common
	to all elements, and the concepts used in definining elements.

4 The elements of HTML
	Each element has a predefined meaning, which is explained in this section. Rules for
	authors on how to use the element, among with user agent requirements for how to
	handle each element, are also given. This includes large signature features of HTML
	such as video playback and subtitles, form controls and form submission, and a
	2D Graphics API known as the HTML canvas.

5 User Interaction
	HTML documents can provide a number of mechanisms for users to interact with and modify
	content, which are described in this section, such as how focus works, and drag-and-drop.

6 Loading Web Pages
	HTML documents do not exist in a vacuum - This section defines many of the features that
	affect environments that deal with multiple pages, such as Web browsers and offline caching
	of Web applications.

7 Web application APIs
	This section introduces basic features for scripting of applications in HTML.

8 The HTML SYntax

9 The XML Syntax
	ALl of these features would be for naught if htey could not be represented in a serialized
	form and sent to other people, and so these sections define the syntaxes of HTML and XHTML,
	along with rules for how to parse content using those syntaxes.

10 Rendering
	This section defines the default rendering rules for Web browsers.

There are also some appendices, listing 11 Obsoloete features and 12 IANA considerations, and several
in-dices.

1.7.1 How to read this specification

This specification should be read like all other specifications. First, it should be read cover-to-cover,
multiple times. THen it should be read backwards at least once. (This is BS)

As described in the conformance requirements section below, this specification describes conformance criteria
for a variety of conformance classes. In particular , there are conformance requirements that apply to producers,
for example authors and the documents they create, and there are conformance requirements that apply to 
consumers, for example Web browsers. They can be distinguished by what they are requiring: a requirement
on a producer states what is allowed, while a requirement on a consumer states how software is to act.

EXAMPLE 1

For example, "the foo attribute's value must be a valid integer" is a requirement on producers, as it lays
out the allowed values; in contrast, the requirement "the foo attribute's value must be parsed using the
rules for parsing integers" is a requirement on consumers, as it describes how to process the content.

Requirements on producers have no bearing whatsoever on consumers.

Example 2

Continuing the above example, a requirement stating that a particular attirbute's value is constrained to 
being a valid integer emphatically does not imply anything about the reuqirements on consumers. It might
be that the consumers are in fact reuqired to treat the attribute as an opaque string, completely unaffected
by whether the value conforms to the requirements or not. It might be (as in the previous example) that the
consumers are required to parse the value using specific rules that define how invalid (non-numeric in this case)
values are to be processed.

1.7.2 Typographic conventions

THis is a definition, reuqirement, r explanation.

NOTE:
This is  an ote.

Example 3
THis is an example

This is an open issue //Red square

Warning! This is a warning //Warnign box

interface Example {
	//This is an IDL definition
};

NOTE: Idl stands for interactive data langauge

variable = object.method([optionalArugment])
	This is an ote to authors describing the usage of an interface

/* This is a CSS fragment */

The defining instance of a temr is markedu p like this. Uses of that term are marked up as underliend notes.

The defining instance of an element, attribute, or API is marked up like orange. References ot hat element,
attribute, or API are marked up like <orange>

other code fragments are marked up like orange

Byte sequnces with bytes in the range 0x00 to 0x7F, inclusive, are marked up as orange

Variables are marked up with white bg

In an algo, steps in synch sections are marked with an hourglass.

In some cases, requirements are given in teh form of lists with conditions and corresponding requirements.
In such cases, the reuqirements that apply to a ocndition are always the first set of requirements that
follow the condition, even in the case of there being multiple sets of conditions for those requirements.

Such cases are presented as follows:

>This is a condition
> this is anotehr condition
	Thi sis the reuqirement that applies to teh conditions above
> this is a third condition
	This is the requirement that applies to the third condition

1.8 Privacy Concerns

SOme features of HTML trade user convenience for a measure of user privacy.

In general, deu to the internet's architechture, a user can be distinguished from another by
the user's IP address. IP addresses do not perfectly match to a user; as a user moves from device
to device, or from network to network, their IP address will change.

Similarly, NAT routing, proxy servers and shared computers enable packets that appear to all come
from a single IP address to actually map to multiple users. Techs such as onion routing can be 
used to further anonymize requests so taht requests from a single user at one node on teh Internet
appear to come from many disparate parts of the network.

However, the IP address used for a user's requests is not only mechanism by which a user's requests
could be related to each other. Cookies, for example, are designed specifically to enale this,
and are the basis of most of the Web's session features that enables you to log into a site with
which you have na acc.

There are other mechanisms that are more subtle. Certain characteristics of a user's system can be
used to distinguish groups of users from each other; by collecting enough such information,
an individual user's browsers "digital fingerprint" can be computed, which can be as good,
if not better, as an IP address in ascerting which requests are from the same user.

Grouping reuqests in this manner, especially across multiple sites, can be used for both benign
(and even arguably positive) purposes, as well as for malevolent purposes. An example of a 
reasonably benign purpose would be determining whether a particular person seems to prefer
sites with dog illustrations as opposed to sites with cat illustrations (based on how
often they visit the site in question), and then automatically using the preffered illustrations
on subsequent visists to participating sites.

Malevolent purposes, however, could include goverments combining information such as the peron's
home address (determined from the addresses they use when getting driving directions on one site)
with their apparent political affiliations (determined by examining the forum sites that they
participate in) to determine whether the person should be prevented from voting in an election.

Since the malevolent purposes can be remarkably evil, user agent implementations are encouraged
to consider how to provide their users with tools to minimize leaking information that could be
used to fingerprint a user.

Unfortuantely, as the first paragraph in this section implies, sometimes, there is a great benefit
to be derived from exposing the very info that can also be used for fingerprinting purposes, so
it is not easy as simply blocking all possible leaks.

For instance, the ability to log int oa site to post under a specific identity requires that 
the user's requests be identifiable as all being from the same user. More subtly, though,
information such as how wide text is, which is ncessary for many effects that involve drawing
text onto a canvas (e.g any effect that involves drawing a border around the text) also leaks
info taht can be used to group a user's requests.

In this case, by potentionally exposing, via a brute force search, which fonts a user has
installed, information which can vary considerably from user to user.

Features in this specification which can be used to fingerprint the user are marked as 
this in this paragraph. (fingerprint)

Other features in the platform can be used for the same purpose, though, including,
though not limited to:

The exact list of which features a user agents supports.

The maximum allowed stack depth for recursion in a script.

Features that describes teh user's environment, like Media Queries and the SCreen object.
[MEDIAQ] [CCSOM-VIEW]

The user's time zone.

1.9 A quick introduction to HTML

A basic HTML document looks like this:

<!DOCTYPE html>
<html>
	<head>
		<title>Sample page</title>
	</head>
	<body>
		<h1>Sample page</h1>
		<p>This is a <a href="demo.html">simple</a> sample.</p>
		<!-- This is a comment -->
	</body>
</html>

HTML documents consists of a tree of elements and text. Each element is denoted in the source
by a start tag, such as "<body>" and an end tag, such as "</body>". (Certain start tags and end
tags can in certain cases be omitted and are implied by other tags).

Tags have to be nested such that elements are all completely within each other, without overlapping:

<p>This is <em>very <strong>wrong</em>!</strong></p>

<p>This <em> is <strong>correct</strong>.</em></p>

This specification defines a set of elemetns that can be used in HTML, along with rules about the
ways in which the elements can be nested.

Elements can ahve attributes, which control how the elements work. In the example above, there is a 
hyperlink, formed using the <a> element and its href attribute:

<a href="demo.html">simple</a>

Attributes are placed inside hte start tag, and consists of a name and a value, separated by an "="
character. The attribute value can remained unquoted if it does not contain space chars, or any of 
"'`=> or >. Otherwise, it has to be quoted using the single or double quotes.

THe value, along with the "=" char, can be omitted altogether if the value is the empty string.

<!-- empty attributes -->
<input name=address disabled>
<input name=address disabled="">

<!-- Attributes with a value -->
<input name=address maxlength=200>
<input name=address maxlength='200'>
<input name=address maxlength="200">

HTML usger agents (e.g, Web browsers) then parse this markup, turning it into a DOM (DOcuemtn Object MOdel)
tree. A DOM tree is a in-memory representation of a document.

DOM trees contain several kinds of nodes, in particular a DocumentType node, Element nodes, Text nodes,
Comment nodes, and in some cases ProcessingInstruction nodes.

THe markup snippet at the top of this section would be turned into the following DOM tree:

DOCTYPE:html
><html>
	V><head>
	V	V>#text 
	V	><title>
	V	V	V>#text Sample page
	V	V>#text
	V>#text
	V><body>
		V
		V>#text
		V><h1>
		V	V>#text: Sample page
		V>#text
		V
		v><p>
		V	V>#text: This is a
		V	V
		V	V><a>href="demo.html"
		V	V	V>#text: simple
		V	V>#text: sample.
		V>#text
		V>#comment: this is a comment
		V>#text

The document element of this tree is the <html> element, which is the element always found in that position
in HTML documents. It contains two elements, <head> and <body>, as well as a Text node between them.

There are many more Text nodes in teh DOM tree than one would initially expect, because the source contains
a number of spaces (represented here "_") and line breaks ("<") that all end up as Text nodes in the DOM.
However, for historical reasons not all of hte spaces and line breaks in the original markup appear in the DOM.

IN particular, all the white space before <head> start tag ends up being dropped silently, and all teh white 
space after the <body> end tag ends up placed at the end of the <body>.

The <head> element contains a <title> element, which itself contains a Text node with the text "Sample page".
Similarly, the <body> element contains an <h1> element, a <p> element and a comment.

This dom tree can be manipulated from scripts in the page. Scripts (typically in JS) are small programs
that can be embedded using the <script> element or using event handler content attributes. For exmaple,
here is a form with a script that sets the value of the form's <output> element to say "Hello world!":

<form name="main">
	Result: <output name="result"></output>
	<script>
		document.forms.main.elements.result.value = 'Hello world';
	</script>
</form>

Each element in the DOM tree is represented by an object, and these objects have APIs so that they can be 
manipulated. For instance, a link (e.g the <a> element in the tree above) can have its "href" attribute
changed in several ways.

var a  = document.links[0]; //Obtain the first link in teh document
a.href = 'sample.html'; //change the destination URL of the link
a.protocol = 'https'; //Change just the scheme part of the URL
a.setAttribute('href', 'http://example.com/'); //change the content attribute directly

Since DOM trees are used as the way to represent HTML documents when they are processed
and presented by implementations (especially interactive implementations like Web browsers),
this specification is mostly phrased in terms of DOM trees, instead of the markup described above.

HTML documents represent a media-independent description of interactive content. HTML documents 
might be rendered to a screen, or through a speech synthesizer, or on a braille display.

to influecne exactly how such rendering takes place, authors can use a styling langauge such as
CSS.

IN the followign example, the pageh as been made yellow-on-blue using CSS.

<!DOCTYPE html>
<html>
	<head>
		<title>Sample styled page</title>
		<style>
			body { background: navy; color: yellow; }
		</style>
	</head>
	<body>
		<h1>Sample styled page</h1>
		<p>This page is just a demo</p>
	</body>
</html>

FOr more details on how to use HTML, autheors are encouraged to consult tutorials and guides.
SOme of the examples included in this specification might also be of use, but teh novice author
is cautioned that htis specification by necessity, defines the language with a level of detail
that might be difficult to understand.

1.9.1 Writing secure applicatiosn with HTML

When HTML is used to create interactive sites, care needs to be taken to avoid introducing 
vulnerabilities through which attackers can compromise the integrity of the site itself or
of the site's users.

A comprehensive study of this matter is beyond teh scope of this document, and authors are
strongly encouraged to study the matter in more detail. However, this section attempts to
provide a quick introduction to some common pitfalls in HTML application development.

The security model of the WEb is based on the concept of "origins", and corresponding 
many of the potentional attacks on the Web invvole cross-origin actions. [ORIGIN]

Not validating user input

Cross-site scripting (XSS)

SQL injection
	When accepting untrusted input, e.g user-generated content such as text comments,
	values in URL parameters, messages from third-party sites, etc., it is imperative
	that the data be validated before use, and properly escaped when displayed.

	Failing to do this can allow a hostile user to perform a variety of attacks,
	ranging from the potentionally benign, such as providing bogus user informaiton
	like a negative age, to the serious, such as running scripts every time a user
	looks at a page that includes the info, potentionally propogating the attack
	in the process, to the catastrophic, such as deleting all teh DATA inteh server.

	When writing filters to validate user input, it is imperative that filters always
	be safelist-based, allowing known-safe constructs and disallowing all other input.
	Blocklist-based filters that disallow known-bad inputs and allow everything
	else are not secure, as not everything that is bad is yet known (for example,
	because it might be invented in the future).

Example 4

FOr example, suppose a page looked at its URL's query string to determine what to display,
and the site then redirected the user to that page to display a message, as in:

<ul>
	<li><a href="message.cgi?say=Hello">Say hello</a>
	<li><a href="message.cgi?say=Welcome">Say WElcome</a>
	<li><a href="message.cgi?say=Kittens">Say Kittens</a>
</ul>

If the message was just displayed to the user without escaping, a hostile attacker could
then craft a URL that contained a script element.

http://example.com/message.cgi?say=%3Cscript%3Ealert%28%27Oh%20no%21%27%29%3C/script%3E

If the attacker then convinced a victim user to visit this page, a script of the attacker
choosing would run on the page. Such a script could do any number of hostile actions,
limited only by what the site offers.

If the site is an e-commerce shop, for instance, such a script could cause the user
to unknowingly make arbitrarily many unwanted purchases.

This is called a cross-site scripting attack.

There are many constructs taht can be used to try to trick a site into executing code.
Here are some that authors are encouraged to consider when writing safelist filters:

When allowing harmless-seeming elements like <img>, it is important to safelist any provided
attributes as well. If one allowed all attributes then an attacker could, for instance, use
the onload attribute to run arbitrary script.

When allowing URLs to be provided (e.g, for links), the scheme of each URL also needs to be
explicitly safelisted, as there are many schemes that can be abused. The most prominent
example is "javascript:", but user agents can implement (and indeed, have historically
implemented others).

ALlowing a <base> element to be inserted means any <script> elements in the page with
 relative links can be hijacked, and similarly that any form submissions can get redirected
 to a hostile site.

Cross-site request forgery (CSRF)

If a site allows a user to make form submissions with user-specific side-effects, for example
posting messages on a forum under the user's name, making purchases, or applying for a passport,
it is important to verify that the request was made by the user intentionally, rather than by another
site tricking the user into making the request unknowingly.

THis problem exists because HTML forms can be submitted to other origins.

Sites can prevent such attacks by populating forms with user-specific hidden tokens, or by
checking Origin headers on all requests.

Clickjacking

A page that provides users with an interface to perform actions that the user might not wish
to perform needs to be designed so as to avoid the possibility that users can be tricked 
into activating the interface.

One way that a user could be so tricked is if a hostile site places the victim site
in a small <iframe> and then convinces the user to click, for instance by having the
user player a reaction game.

Once the user is playing the game, the hostile site can quickly position the <iframe>
under the mouse cursor just as the user is about to click, thus tricking the user into
clicking the victim site's interface.

To avoid this, sites that do not expect to be used in frames are encouraged to only
enable their interface if they detect that they are not in a frame (e.g, by comparing
the window object to the value of the top attribute).

1.9.2 Common pitfalls to avoid when using the scripting APIs

Scripts in HTML have "run-to-completion" semantics, meaning that the browser will
generally run the script uninteruppted before doing anything else, such as firing
fruther events or continuing to parase the document.

On theo ther hand, parsing of HTML files happens incrementally, meaning that hte 
parser can pause at any point to let scripts run. This is generally a good thing,
but it does mean that authors need to be careful to avoid hooking event handlers
after the events could have possibly fired.

There are two techniques for doing thsi reliably: use event handler content attributes,
or create the element and add the event handlers in the same script. The latter is safe,
because as mentioned earlier, scripts are run to completion before further events
can fire.

Example 5

One way this could manifest itself is with <img> elements and the load event. The event
could fire as soon as the element has been parsed, especially if the image has already
been cached (which is common).

Here, the author uses the onload handler on an <img> element to catch the load event:

<img src="games.png" alt="Games" onload="gamesLogoHasLoaded(event)">

If the element is being added by script, then so long as the event handlers are added
in the same script, the event will still not be missed:

<script>
var img = new Image();
img src = 'games.png';
img.alt = 'Games';
img.onload = gamesLogoHasLoaded;
// img.addEventListener('load', gamesLogoHasLoaded, false); // would work also
</script>

However, if the author first created the <img> element and then in a separate script
added the event listeners, there is a chanse that the load event would be fired in between,
leading to it being missed.

<!-- Do not use this style, ith as a race condition! -->
<img id="games" src="games.png" alt="Games">
<!-- the 'load' event might fire here while the parser is takign a break, in which case you will not see it -->
<script>
var img = document.getElementById('games');
img.onload = gamesLogoHasLoaded; //might never fire!
</script>

1.9.3 HOw to catch mistakes when writing HTML: validators and conformance checkers

Authors are encouraged to make use of conformance checkers (also known as validators) to catch
common mistakes. The W3C provides a number of online validation services, including the Nu Markup
Validation Service.

1.10 Conformance requirements for authors

Unlike previous versions of the HTML specification, this specification defines in some detail
the required processing for invalid documents as well as valid documents.

However, even though the processing of invalid content is in most cases well-defined, conformance
requirements for documents are still important: in practice, interoperability (the situation in which all implementation
process particular content in a reliable and identical or equivalent way) is not the only goal 
of document conformance requirements.

This section details some of the more common reasons for still distinguishing between a conforming
document and one with errors.

1.10.1 Presentational markup

The majority of presentational features from previous versions of HTML are no longer allowed.
Presentational markup in general has been found to have a number of problems:

The use of presentaitonal elements leads to poorer accessibility
	While it is possible to use presentationl markup in a way that provides users of assistive
	technologies (ATs) with an acceptable experience (e.g, using ARIA), doing so is significantly
	more difficult than doing so when using semantically-appropiate markup.

	Furthermore, even using such techniques does not help make pages accessible for non-AT,
	non-graphical users, such as users of text-mode browsers.

	Using media-independent markup, on the other hand, provides an easy way for documents
	to be authored in such a way that they are "accessible" for more users (e.g, users
	of text browsers)

Higher cost of maintenance

	It is significantly easier to maintain a site written in such a way that the markup
	is style-independent. For example, changing the color of a site that uses <font color="">
	throughout requires changes across the entire site, whereas a similar change to a site
	based on CSS can be done by changing a single file.

Larger document sizes

	Presentational markup tends to be much more redundant, and thus results in larger document
	sizes.

For those reasons, presentational markup has been removed from HTML in this version. This change
should not come as a surprise; HTML 4.0 deprecated presentatonal markup many years ago and provided
a mode (HTML Transitional) to help authors move away from presentational markup; later, XHTML 1.1
went further and obsoleted these features altogether.

THe only remaining presentational markup features in HTML are the style attribute and the <style>
element. Use of the style attribute is somewhat discouraged in production environments, but it can
be useful for rapid prototyping (Where its rules can be directly moved into a separate style sheet
later) and for providing specific styles in unusual cases where a separate style sheet would be 
inconvinient.

Similarly, the <style> element can be useful in syndication or for page-specific styles, but in
general an external style sheet is likely to be more convenient when the styles apply to
multiple pages.

It is also worth noting that some elements that were previously presentational have been redefined
in this specification to be media-independent: <b>, <i>, <hr>,<s>, <small> and <u>.

1.10.2 Syntax errors

The syntax of HTML is constrained to avoid a wide variety of problems.

Unintuitive error-handling behavior
	Certain invalid syntax constructs, when parsed, result in DOM trees that are highly
	unintuitive.

	EXAMPLE 6

	For example, the following markup fragments results in a DOM with an <hr> element that
	is an earlier sibling of the corresponding <table> element:

	<table><hr>...

//5, then you get some DOTA.

Errors with optional error recovery
	To allow user agents to be used in controlled environments without having to implement the
	more bizarre and convoluted error handling rules, user agents are permitted to fail
	whenever encountering a parse error.

Errors where the error-handling behavior is not compatible with streaming user agents
	Some error-handling behavior, such as the behavior for the <table><hr>... example
	mentioned above, are incompatible with streaming user agents (user agents that process
	HTML files in one pass, without storing state).

	To avoid interoperability problems with such user agents, any syntax resulting in such
	behavior is considered invalid.

Errors that can result in infoset coercion
	
	When a user agent based on XML is connected to an HTML parser, it is possible that
	certain invariants that XML enforces, such as element or attribute names never 
	contain multiple colons, will be violated by an HTML File.

	Handling this can require that the parser coerce teh HTML DOM into an XML-compatible
	infoset. Most syntax constructs that require such handling are considered invalid.
	(Comments containing two consecutive hypens, or ending with a hyphen, are exceptions
	that are allowed in teh HTML syntax.)

Errors that result in disproportionately poor performance
	
	Certain syntax consturcts can reuslt in disproportionately poor performance.
	To discourage the use of such constructs, they are typically made non-conforming.

	Example 7

	For example, the following markups result in poor performance, since all the unclosed
	<i> elements have to be reconstructed in each paragraph, resulting in progressively
	more elements in each paragraph.

	<p><i>He dreamt.
	<p><i>He dreamt that he ateb reakfast.
	<p><i>Then lunch.
	<p><i>And finally dinner.

	The resulting DOM for this fragment would be:

	V><p>
	V	V><i>
	V		V>#text: He dreamt.
	V><p>
	V	V><i>
	V		V><i>
	V			V>#text: He dreamt that he ate breakfast.
	V><p>
	V	V<i>
	V		V<i>
	V			V<i>
	V				V#text: Then lunch.
	V><p>
		V<i>
			V<i>
				V<i>
					V<i>
						V#text: And finally dinner.

Errors involving fragile syntax constructs
	
	There are syntax constructs that, for historical reasons, are relativly fragile. To help
	reduce the number of users who accidentaly run into such problems, they are made non-conforming.

	Example 8

	For example, the parsing of certain named character references in attributes happens even with
	the closing semicolons being omitted. It is safe to include an ampersand followed by letters
	that do not form a name char reference, but if the letters are changed to a string that does
	form a named char reference, they will be interpreted as that char instead.

	In this fragment, the attributes value is "?bill&ted".

	<a href="?bill&ted">Bill and Ted</a>

	In the following fragment, however, the attribute value is actually "?art(copy symbol)", not the intended
	"?art&copy", because even without teh final semicolon, "&copy" is handled the same as "&copy;" and thus
	gets interperted as "(copy symbol)".

	<a href="?art&copy">Art and Copy</a>

	To avoid this problem, all named char references are required to end with a semicolon, and uses
	of named character references without a semicolon are flagged as errors.

	Thus, the correct way to express the above cases is as follows:

	<a href="?bill&ted">Bill and Ted</a> <!-- &ted is ok, since it is not a named character reference -->

	<a href="?art&amp;copy">Art and Copy</a> <!-- the & has to be escaped, since &copy is a named character
	reference -->

Errors involing known interoperability problems in legacy user agents

	Certain syntax constructs are known to cause especially subtle or serious problems in legacy
	user agents, and are therefore marked as non-conforming to help authors avoid them.

	Example 9

	For example, this is why the U+0060 GRAVE ACCENT character (`) is not allowed in unquoted
	attributes. In certain legacy user agents, it is sometimes treated as a quote character.

	EXAMPLE 10
	Another example of this is the DOCTYPE, which is required to trigger no-quriks mode, because the
	behavior of legacy user agents in quirks mode is often largely undocumented.

Errors that risk exposing authors to security attacks
	
	Certain restrictions exist purely to avoid known security problems.

	Example 11
	For example, the restriction on using UTF-7 exists purely to avoid authors falling prey
	to a known cross-site-scripting attack, using UTF-7. [RFC2152]

Cases where the author's intent is unclear
	
	Markup where the authors intent is very unclear is often made non-conforming. Correcting
	these errors early makes later maintenance easier.

	EXAMPLE 12
	For example, it is unclear whether hte author intended the following to be an <h1> heading
	or an <h2> heading:

	<h2>Contact details</h1>

Cases that are likely to be typos

	When a user makes a simple typo, it is helpful if the error can be caught early, as this can
	save the author a lot of debugging time. This specification therefore usually considers it an
	error to use element names, attribute names and so forth, that do not match the names defined
	in this specification.

	EXAMPLE 13

	For example, if the author typed <capton> instead of <caption>, this would be flagged as an error
	and the author could correct the typo immediately.

Errors that could interfere with new syntax in teh future
	
	In order to allow the language syntax to be extended in the future, certain otherwise harmless
	features are disallowed.

	EXAMPLE 14

	For example, attributes in end tags are ignored currently, but they are invalid, in case a future
	change to the language makes use of that syntax feature without conflicting with already-deployed
	(and valid!) content.

Some authors find it helpful to be in the practice of always quoting all attributes and always including
all optional tags, preferring the consistency derived from such custom over the minor benefits of terseness
afforded by making use of the flexibility of the HTML syntax.

To aid such authors, conformance checkers can provide modes of operation wherein such conventions are enforced.

1.10.3 Restrictions on content models and on attribute values

Beyond the syntax of the language, this specification also places restrictions on how elements and attributes
can be specified. These restrictions are present for similar reasons:

Errors involving content with dubious semantics
	
	To avoid misuse of elements with defined meanings, content models are defined that restrict how elements
	can be nested when such nestings would be of dubious value.

	Example 15

	For example, this specification disallows nesting a <section> element inside a <kbd> element,
	since it is highly unlikely for an author to indicate that an entire section should be keyed in.

Errors that involve a conflict in expressed semantics
	
	Similarly, to draw the author's attention to mistakes in the use of elements, clear contradictions
	in teh semantics expressed are also considered conformance errors.

	EXAMPLE 16

	IN the fragments below, for example, the semantics are nonsensical: a separator cannot simultaneously
	be a cell, nor can a radio button be a progress bar.

	<hr role="cell">

	<input type=radio type=progressbar>

	EXAMPLE 17

	Another example is the restrictions on teh content models of the <ul> element, which only
	allows <li> element children. Lists by definition consists just of zero or more list items,
	so if a <ul> element contains something other than an <li> element, it is not clear what
	was meant.

Cases where the default styles are likely to lead confusion
	
	Certain elements have default styles or behaviors that make certain combinations likely
	to lead to confusion. Where these have euqivalent alternatives without this problem,
	the confusing combinations are disallowed.

	EXAMPLE 18

	For example, <div> elements are rendered as block boxes, and <span> elements as inline boxes.
	Putting a block box in an inline box is unnessecarily confusing; since either nesting just
	<div> elements, or nesting just <span> elements, or nesting <span> elements inside <div>
	elements all serve the same purpose as nesting a <div> element in a <span> element, but only
	the latter involves a block box in an inline box, the latter combination is disallowed.

	EXAMPLE 19

	Another example would be the way interactive content cannot be nested. For example, a <button>
	element cannot contain a <textarea> element. This is because the defualt behavior of such
	nesting interactive elements would be highly confusing to users. Instead of nesting these
	elements, they can be placed side by side.

Errors that indicate a likely misunderstanding of the specification
	
	Sometimes, something is disallowed because allowing it would likely cause author
	confusion.

	EXAMPLE 20

	For example, setting the disabled attribute to the value "false" is disallowed, because
	despite the appearance of meaning that hte element is enabled, it in fact means that
	the element is disabled (what matters for implementations is the presence of the attribute, 
	not its value)

Errors involving limits that have been imposed merely to simplify the language
	
	Some conformance errors simplify the language that authors need to learn.

	EXAMPLE 21

	For example, the <area> element's shape attribute, despite accepting both "circ" and
	"circle" values in practice as synonyms, disallows the use of the "circ" value, so as 
	to simplify tutorials and other learning aids. There would be no benefit to allowing both,
	but it would cause extra confusion when teaching the language.

Errors that involve peculiarities of the parser
	
	Certain elements are parsed in somewhat eccentric ways (typically for historical reasons),
	and their content model restrictions are intended to avoid exposing the author to these
	issues.

	EXAMPLE 22

	For example, a <form> element is not allowed inside phrasing content, because when parsed
	as HTML, a <form> element's start tag will imply a <p> element's end tag. Thus, the following
	markup results in two paragraphs, not one:

	<p>Welcome. <form><label>Name:</label> <input></form>

	It is parsed exactly like the following:

	<p>Welcome. </p><form><label>Name:</label> <input></form>

Errors that would likely result in scripts failing in hard-to-debug ways
	
	Some errors are intended to help prevent script problems that would be hard to debug.

	EXAMPLE 23

	This is why, for instance, it is non-conforming to have two id attributes with the same value.
	Duplicate ID to the wrong element being selected, with sometimes disasterous effects whose
	cause is hard to determine.

Errors that waste authoring time
	
	Some constructs are disallowed because historically they have been the cause of a lot of wasted
	authoring time, and by encouraging authors to avoid making them, authors can save time in future efforts.

	EXAMPLE 24

	For example, a <script> element's src attribute causes the element's contents to be ignored.
	HOwever, this is not obvious, especially if the element's content appear to be executable
	script - which can lead to authors spending a lot of time trying to debug the inline script
	without realizing that it is not executing.

	To reduce this problem, this specification makes it non-conforming to have executable script
	in a <script> element where the src attribute is present. This means that authors who are validating
	their documents are less likely to waste their time with this kind of mistake.

Errors that involve areas that affect authors migrating to and from XHTML

	Some authors like to write files that can be interpreted as both XML and HTML with similar results.
	Though this practice is discouraged in general due to the myriad of subtle complications involved
	(especially when involving scripting, styling or any kind of automated serialization), this specification
	has a few restrictions intended to at least somewhat mitigate the difficulties.

	THis makes it easier for authors to use this as a transitionary step when migrating between
	HTML and XHTML.

	EXAMPLE 25

	For example, there are somewhat ocmplicated rules surrounding the lang and xml:lang attributes
	intended to keep the two synchronized.

	EXAMPLE 26

	Another example would be the restrictions on the values of xmlns attributes in teh HTML serialization,
	which are intended to ensure that elements in conforming documents end up in the same namespaces
	whether processed as HTML or XML.

Errors that involve areas reserved for future expansion
	
	As with the restrictions on the syntax intended to allow for new syntax in the future revisions of the
	language, some restrictions on the content models of elements and values of attributes are intended to
	allow for future expansion of the HTML vocabulary.

	EXAMPLE 27

	For example, limiting the values of the target attribute taht start with an U+005F LOW LINE character
	(_) to only specific predefined values allows new predefiend values to be introduced at a future time
	without conflicting with author-defined values.

Errors that indicate a mis-use of other specifications
	
	Certain restrictions are intended to support the restrictions made by other specifications.

	Example 28

	For example, requiring that attributes that take media query lists use only valid media
	query lists reinforces the the importance of following the conformance rules of that
	specification.

1.11 Suggested reading

the following documents might be of interest to readers of this specification.

Character Model for the World Wide Web 1.0: Fundamentals [CHARMOD]
	This Architechtural Specification provides authors of specifications, software devs, and content
	devs with a common reference for interoperable text manipulation on WWW, building on the Universal
	Character Set, defined jointly by the UNicode specification and ISO/IEC 10646. Topics addressed
	includes use of the terms "character", "encoding" and "string", a reference processing model,
	choice and identification of character encodings, character escaping and string indexing.

Unicode Security Considerations [UNICODE-SECURITY]
	Because Unicode contains such a large number of chars and incoprorates the varied systems of the
	world, incorrect usage can expose programs or systems to possible security attacks. This is 
	especially important as more and more products are internationalized. This document describes
	some of the security considerations that programmers, system analysts, standards devs, and users
	should take into account and provides specific recommendations to reduce the risk of problems.

Web Content Accessibility Guidelines (WCAG) 2.0 [WCAG20]
	Web Content Accessibility Guidelines (WCAG) 2.0 covers a wide range of recommendations for making
	Web content more accessible. Following these guidelines will make content accessible to a wider range
	of people with disabilities, including blindness and low vision, deafness and hearing loss, learning
	disabilities, cognitive limitations, limited movement, speech disabilities, photosensitivity and combinations
	of these. Following these guidelines will also often make your Web content more usable to users in general.

Authoring Tool Accessibility Guidelines (ATAG) 2.0 [ATAG20]
	This specification provides guidelines for designing Web content authoring tools that are more accessible
	for people with disabilities. An authoring tool that conforms to these guidelines will promote accessibility
	by providing an accessible user interface to authors with disabilities as well as by enabling, supporting,
	and promoting the production of accessible Web content by all authors.

User Agent Accessibility Guidelines (UAAG) 2.0 [UAAG20]
	This document provides guidelines for designing user agents that lower barriers to Web accesibility
	for people with disabilities. User agents include browsers and other types of software that retrieve
	and render Web content. A user agent taht conforms to these guidelines will promote accessibility
	through its own user interface and through other internal facilities, including its ability to
	communicate with other techs (especially assistive techs). Furthermore, all users, not just users
	with disabilities, should find conforming user agents to be more usable.

HTML Accessibility APIs Mappings 1.0 [html-aam-1.0]
	Defines how user agents map HTML 5.1 elements and attributes to platform accessibility APIs.
	Documenting these mappings promotes interoperable exposures of roles, states, properties and
	events implemented by accessibility APIs and helps to ensure that this information appears in a
	manner consistent with author intent.

2 Common infrastructure

2.1 Terminology
	
	This specification refers to both HTML and XML attributes and IDL attributes, often in the same
	context. When it is not clear which is being referred to, they are referred to as content attributes
	for HTML and XML attributes, and IDL attributes for those defined on IDL interfaces.

	Similarly, the term "properties" is used for both JavaScript object properties and CSS props.
	When these are ambigious they are qualified as object props and CSS props respectively.

	Generally, when the specification states that a feature applies to the HTML syntax or the
	XHTML syntax, it also includes the other. When a feature specifically only applies to one
	of the two languages, it is called out by explicitly stating that it does not apply to
	the other format, as in "for HTML, ... (this does not apply to XHTML)"

	This specification uses the term document to refer to any use of HTML, ranging from short static
	documents to long essays or reports with rich multimedia, as well as to fully-fledged interactive
	applications. The term is used to refer both to Document objects and their descendant DOM trees,
	and to serialize byte streams using the HTML syntax or XHTML syntax, depending on context.

	In the context of the DOM structures, the terms HTML document and XML document are used as defined
	in the DOM specification, and refer specifically to two different modes that Document objects can
	find themselves in. [DOM] (Such uses are always hyperlinekd to their def)

	In the context of byte streams, the term HTML document refers to resources labeled as text/html,
	and the term XML document refers to resources labeled with an XML MIME type.

	The term XHTML document is used to refer to both Documents in the XML document mode that contains
	element nodes in the HTML namespace, and byte streams labeled with an XML MIME type that contain
	elements from the HTML namespace, depending on the context.

	For simplicitly, terms such as shown, displayed and visible might sometimes be used when referring
	to the way a document is rendered to the user. These terms are not meant to imply a visual medium;
	they must be considered to apply to other media in equivalent ways.

	When an algorithm B says to return to another algo A, it implies that A called B. Upon returning
	to A, the implementation must continue from where it left off in calling B. Some algorithms run
	in parallel; this means that the algorithm's subsequent steps are to be run, one after another,
	at the same time as other logic in the specification (e.g at teh same time as the event loop).

	This specification does not define the precise mechanism by which this is achieved, be it time-sharing
	cooperative multitasking, fibers, threads, processes, uses different hyperthreads, cores, CPUs, machines,
	etc. By contrast, an operation that is to run immediately MUST interuppt the currently running task
	, run itself and then resume the previously running task.

	The term "transparent black" refers to the color with red, green, blue and alpha channels set to zero.

2.1.1 Resources
	
	The specification uses the term supported when referring to whether a user agent has an implementation
	capable of decoding the semantics of an external resource. A format or type is said to be supported if
	the implementation can process an external resource of that format or type without critical aspects
	of the resource being ignored.

	Whether a specific resource is supported can depend on what features of the resource's format are in
	use.

	EXAMPLE 1

	For example, a PNG image would be considered to be in a supported format if its pixel data could be
	decoded and rendered, even if, unbeknownst to the implementation, the image also contained animation
	data.

	Example 2

	An MPEG-4 video file would not be considered to be in a supported format if the compression format
	used was not supported, even if the implementation could determine the dimensions of the movie from
	the file's metadata.

	What some specifications, in particular the HTTP specification, refer to as a representation is
	referred to in this specification as a resource. [HTTP]

	The term MIME type is used to refer to what is sometimes called an Internet media type in protocol
	literature. The term media type in this specification is used to refer to the type of media intended
	for presentation, as used by the CSS specifications. [RFC2046][MEDIAQ]

	A string is a valid MIME type if it matches the media-type rule. In particular, a valid MIME-type 
	may include MIME type parameters. [HTTP]

	A string is a valid MIME type if it matches the media-type rule. In particular, a valid MIME type
	may include MIME type parameters. [HTTP]

	A string is a valid MIME type with no parameters, if it matches the media-type rule, but does not
	contain any U+003B SEMICOLON characters (;). In other words, if it consists only of a type 
	and subtype with no MIME type parameters. [HTTP]

	The term HTML MIME type is used to refer to the MIME type text/html.

	A resource's critical subresources are those that the resource needs to have available to be
	correctly processed. Which resources are considered critical or not is defined by the specification
	that defines the resource's format.

	2.1.2 XML compability

	To ease migration from HTML to XHTML, user agents conforming to this specification will place elements
	in HTML in the http://www.w3.org/1999/xhtml namespace, at least for the purposes of the DOM and CSS.
	The term "HTML elements", when used in this specification, refers to any element in that namespace,
	and thus refers to both HTML and XHTML elements.

	Except where otherwise stated, all elements defined or mentioned in this specification are in the
	HTML namespace ("http://www.w3.org/1999/xhtml"), and all attributes defined or mentioned in this
	specification have no namespace.

	The term element type is used to refer to the set of elements that have a given local name and
	namespace. For example <button> elements are elements with the element type <button>, meaning
	they have the local name "<button>" and (implicitly as defined above) the HTML namespace.

	Attribute names are said to be XML-compatible if they match the Name production defined in XML
	and they contain no U+003A COLON characters(:). [XML]

	The term XML MIME type is used to refer to the MIME types text/xml, application/xml, and any
	MIME type whose subtype ends with the four characters "+xml". [RFC7303]

	2.1.3 DOM trees

	When it is stated that some element or attribute is ignored, or treated as some otehr value,
	or handled as if it was something else, this refers only to the processing of the node after
	it is in the DOM. A user agent must not mutate the DOM in such situations.

	A content attribute is said to change value only if its new value is different than its previous
	value; setting an attribute to a value it already has does not change it.

	The term empty, when used for an attribute value, Text node, or string means that the length
	of the text is zero (i.e, not even containing spaces or control characters).

	An element's child text content is the concatenation of the data of all the Text nodes that are
	children of the element (ignoring any other nodes such as comments or elements), in tree order.

	A node A is inserted into a node B when the insertion steps are invoked with A as the argument
	and A's new parent is B. Similarly, a node A is removed from a node B when the removing steps
	are invoked with A as the removeNode argument and B as the oldParent argument.

	A node is inserted into a document when the insertion steps are invoked with it as the argument
	and it is now in a document tree. Analogously, a node is removed from a document when the removing
	steps are invoked with it as the argument and it is now no longer in a document tree.

	2.1.4 Scripting

	The construction "a Foo object", where Foo is actually an interface, is sometimes used instead of
	the more accurate "an object implementing the interface Foo".

	An IDL attribute is said to be getting when its value is being retrieved (e.g, by author script),
	and is said ot be setting when a new value is assigned to it.

	If a DOM object is said to be live, then the attributes and methods on that object must operate on
	the actual underlying data, not a snapshot of the data.

	In teh contexts of events, the terms fire and dispatch are used as defined in the DOM specification:
	firing an event means to create and dispatch it, and dispatching an event means to follow the steps
	that propogate the event through the tree. The term trusted event is used to refer to events whose
	isTrusted attribute is initialized to true. [DOM]

	2.1.5 Plugins

	The term plugin refers to a user-agent defined set of content handlers that can be used by the
	user agent. The content handlers can take part in the user agent's rendering of a Document object,
	but that neither act as child browsing contexts of the Document nor introduce any Node objects
	of teh Document's DOM.

	Typically such content handlers are provided by third parties, though a user agent can also designate
	built-in content handlers as plugins.

	A user agent must not consider the types text/plain and application/octet-stream as having a registered
	plugin.

	EXAMPLE 3
	One example of a plugin would be a PDF viewer that is instansiated in a browsing context when the
	user navigates to a PDF file. This would count as a plugin regardless of whether the party that
	implemented the PDF viewer component was the same as taht which implemented the user agent itself.
	However, a PDF viewer application taht launches separate from the user agent (as opposed to using 
	the same interface) is not a plugin by this definition.

	NOTE:
	This specification does not define a mechanism for interacting with plugins, as it is expected
	to be user-agent and platform-specific. Some user agents might opt to support a plugin mechanism
	such as the Netscape Plugin API; others might use remote content converters or have built-in
	support for certain types. Indeed, this specification does not require user agents to support
	plugins at all. [NPAPI]

	A plugin can be secured if it honors the semantics of the sandbox attribute.

	EXAMPLE 4

	For example, a secured plugin would prevent its contents from creating pop-up windows when the
	plugin is instansiated inside a sandboxed <iframe>.

	WARNING! Browsers should take extreme care when interacting with external content intended for
	plugins. When third-party software is run with the same privileges as the user agent itself,
	vulnerabilities in the third-party software become as dangerous as if they were vurnerabilities
	of the user agent itself.

	Since different users having different sets of plugins provides a fingerprinting vector that increases
	the chanses of users being uniquely identified, user agents are encouraged to support the exact
	same set of plugins for each user.

2.1.6 Character encodings
	
	A character encoding, or just encoding where that is not ambigious, is a defined way to convert between
	byte streams and Unicode strings, as defined in teh WHATWG Encoding specification. An encoding has
	an encoding name and one or more encoding labels, referred to as the encoding's name and labels
	in the Encoding specification. [ENCODING]

	A UTF-16 encoding is UTF-16BE or UTF-16LE. [ENCODING]

	An ASCII-compatible encoding is any encoding that is not a UTF-16 encoding [ENCODING]

	NOTE:
	Since support for encodings that are not defined in the WHATWG Encoding specification is prohibited,
	UTF-16 encodings are the only encodings that this specification needs to treat as not being
	ASCII-compatible encodings.

	The term code unit is used as defined in the Web IDL specification: a 16 bit unsigned integer,
	the smallest atomic component of a DOMString. (This is narrower definition than the one used in
	Unicode, and is not the same as a code point). [WEBIDL]

	The term Unicode code point means a Unicode scalar value where possible, and an isolated surrogate
	code point when not. When a conformance requirement is defined in terms of characters or Unicode
	code points, a pair of code units consisting of a high surrogate followed by a low surrogate must
	be treated as the single code point represented by the surrogate pair, but isolated surrogates must
	each be treated as the single code point with the value of the surrogate. [UNICODE]

	In this specification, the term character, when not qualified as Unicode character, is synonymous
	with the term Unicode code point.

	The term UNicode character is used to mean a Unicode scalar value (i.e any Unicode code point that
	is not a surrogate code point). [UNICODE]

	The code-unit length of a string is the number of code units in that string.

	NOTE: 
	This complexity results from the historical decision to define the DOM APIs in terms of 16bit(UTF-16)
	code units, rather than in terms of UNicode characters.

	2.2 Conformance requirements

	All diagrams, examples and notes in this specification are non-normative, as are all sections explicitly
	marked non-normative. Everything else in this specification is normative.

	The key words: "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT",
	"RECOMMENDED", "NOT RECOMMENDED", "MAY" and "OPTIONAL" in the normative parts of this document
	are to be interpreted as described in RFC2119. The key word "OPTIONALLY" in the normative parts of
	this document is to be interpreted as described in RFC2119.

	The key word "OPTIONALLY" in the normative parts of this document is to be interpreted with the same
	normative meaning as "MAY" and "OPTIONAL". For readability, tehse words do not appear in all uppercase
	letters in this specification. [RFC 2119]

	Requirements phrased in the imperative as part of algorithms (such as "strip any leading space chars"
	or "return false and abort these steps") are to be interpreted with the meaning of the key word ("must",
	"should", "may", etc) used in introducing the algorithm.

	EXAMPLE 5

	For example, were the spec to say:

		To eat an orange, the user must:
		1. Peel the orange.
		2. Separate each slice of the orange.
		3. Eat the orange slices.
	Would be the equivalent to:

		To eat an orange:
		1. The user must peel the orange.
		2. The user must separate each slice of the orange.
		3. The user must eat the orange slices.

Here the keyword is "must".

The former (imperative) style is generally preferred in this specification for stylistic reasons.

Conformance requirements phrased as algorithms or specific steps may be implemented in any manner, so long
as the end result is equivalent. (In particular, teh algorithms defined in this specification are intended to be
easy to follow, and not intended to be performant.)

2.2.1 Conformance classes
	
	This specification describes the conformance criteria for user agents (relevant to implementors) and documents
	(relevant to authors and authoring tool implementors).

	Conforming documents are those that comply with all the conformance criteria for documents. For readability,
	some of these conformance requirements are phrased as conformance requirements on authors; such requirements
	are implicitly requirements on documents: by definition, all documents are assumed to have an author.
	(In some cases, that author may itself be a user agent - such user agents are subject to additional rules,
	as explained below).

	EXAMPLE 6

	For example, if a requirement states that "authors must not use the foobar element", it would imply that
	documents are not allowed to contain elements named foobar.

	NOTE:
	There is no implied relationship between document conformance requirements and implementation conformance
	requirements. User agents are not free to handle non-conformant documents as they please; the processing
	model described in this specification applies to implementations regardless of the conformity of the input documents.

	User agents fall into several (overlapping) categories with different conformance requirements.

	Web browsers and other interactive user agents

		Web browsers that support the XHTML syntax must process elements and attributes from the
		HTML namespace found in XML documents as described in this specification, so that users
		can interact with them, unless the semantics of those elements have been overried by other
		specifications.

		EXAMPLE 7

		A conforming XHTML processor would, upon finding an XHTML <script> element in an XML document,
		execute the script contained in that element. However, if the element is bound within a 
		transformation expressed in XSLT (assuming the user agent also supports XSLT), then the processor
		would instead treat teh <script> element as an opaque element that forms part of the transform.

		Web browsers that support the HTML syntax must process documents labeled with an HTML MIME
		type as described in this specification, so that users can interact with them.

		User agents that support scripting must also be conforming implementations of the IDL
		fragments in this specification, as described in the Web IDL specification. [WEBIDL]

		NOTE:
		Unless explicitly stated, specifications that override the semantics of HTML elements
		do not override the requirements on DOM objects representing those elements. For example,
		the <script> element in the example above would still implement the HTMLScriptElement interface.

		Non-interactive presentation user agents

			User agents that process HTML and XHTML documents purely to render non-interactive
			versions of them must comply to the same conformance criteria as Web browsers, except
			that they are exempt from requirements user interaction.

			NOTE:
			Typical examples of non-interactive presentation user agents are printers (static
			user agents) and overhead displays (dynamic user agents). It is expected that most
			static non-interactive presentation user agents will also opt to lack scripting
			support.

		EXAMPLE 8

		A non-interactive but dynamic representation user agent would still execute scripts,
		allowing forms to be dynamically submitted, and so forth. However, since the concept of
		"focus" is irrelevant when the user cannot interact with the document, the user agent
		would not need to support any of the focus-related DOM APIs.

	Visual user agents that support the suggested default rendering

		User agents, whether interactive or not, may be designated (possibly as a user option)
		as supporting the suggested default rendering defined by this specification.

		This is not required. In particular, even user agents that do implement the suggested
		default rendering are encouraged to offer settings that override this default to
		improve the experience for the user, e.g, changing the color contrast, using different
		focus styles, or otherwise making the experience more accessible and usable to the user.

		User agents that are designated as supporting the suggested default rendering must,
		while so designated, implement the rules in ¤10 Rendering. That section defines the behavior
		that user agents are expected to implement.

	User agents with no scripting support

		Implementations that do not support scripting (or which have their scripting features disabled
		entirely) are exempt from supporting the events and DOM interfaces mentioned in this specification.
		For the parts of this specification that are defined in terms of an event model or in terms
		of the DOM, such user agents must still act as if events and teh DOM were supported.

		NOTE:
		Scripting can form an integral part of an application. Web browsers that do not support
		scripting, or that have scripting disabled, might be unable to fully convey the author's
		intent.

	Conformance checkers

		Conformance checkers must verify that a document conforms to the applicable conformance
		criteria described in this specification. Automated conformance checkers are exempt
		from detecting errors that require interpretation of the author's intent (for example,
		while a document is non-conforming if the content of a <blockquote> element is not a quote,
		conformance checkers running without the input of human judgement do not have to check that
		<blockquote> elements only contain quoted material).

		Conformance checkers must check that the input document conforms when parsed without a 
		browsing context (meaning that no scripts are run, and that hte parser's scripting flag
		is disabled), and should also check that the input document conforms when parsed with a browsing
		context in which scripts execute, and that the scripts never cause non-conforming states to 
		occur other than transiently during the script execution itself.

		This is only a "SHOULD" and not a "MUST" requirement, because it has been proven to be impossible.[COMPUTABLE]

		The term "HTML validator" can be used to refer to a conformance checker that itself conforms 
		to the applicable requirements of this specification.

		NOTE:
		XML DTDs cannot express all the conformance requirements of this specification. Therefore, a validating
		XML processor and a DTD cannot constitute a conformance checker. Also, since neither of the two
		authoring formats defiend in this specification are applications of SGML, a validating SGML system
		cannot constitute a conformance checker either.

		To put it another way, there are three types of conformance criteria:

			1. Criteria that can be expressed in a DTD.

			2. Criteria that cannot be expressed by a DTD, but can still be checked by a machine.

			3. Criteria that can only be checked by a human.

		A conformance checker must check for the first two. A simple DTD-based validator only
		checks for the first class of errors and is therefore not a conforming conformance checker
		according to this specification.

	Data mining tools

		Applications and tools that process HTML and XHTML documents for reasons other than to
		either render the documents or check them for conformance should act in accordance with
		the semantics of the documents that htey process.

		EXAMPLE 9

		A tool that generates document outlines but increases the nesting level for each
		paragraph and does not increase the nesting level for each section would not be conforming.

	Authoring tools and markup generators
		Authoring tools and markup generators must generate conforming documents. Conformance
		criteria that apply to authors also apply to authoring tools, where appropiate.

		Authoring tools are exempt from the strict requirements of using elements only for their
		specified purpose, but only to the extent that authoring tools are not yet able to determine
		author intent. However, authoring tools must not automatically misuse elements or encourage
		their users to do so.

		EXAMPLE 10

		For example, it is not conforming to use an <address> element for arbitrary contract information;
		that element can onl be used for marking up contact information for the author of the
		document or section. However, since an authoring tool is likely unable to determine the difference,
		an authoring tool is exempt from that requirement.

		This does not mean, though, that authoring tools can use <address> elements for any block
		of italics text (for instance); it just means that the authoring tool doesn't have to verify
		, if a user inserts contact information for a section or something else.

		NOTE:
		Ín terms of conformance checking, an editor has to output documents that conform to the same
		extent that a conformance checker will verify.

		When an authoring tool is used to edit a non-conforming document, it may preserve the conformance
		errors in sections of the document that were not edited during the editing session (i.e, an editing
		tool is allowed to round-trip errorneous content). However, an authoring tool must not claim that
		the output is conformant if errors have been so preserved.

		Authorings tools are expected to come in two broad varieties: tools that work from structure
		or semantic data, and tools that work on a What-You-See-Is-What-You-Get media-specific editing
		basis (WYSIWYG).

		The former is the preferred for tools that author HTML, since the structure in teh source information
		can be used to make informed choices regarding which HTML elements and attributes are most appropiate.

		However, WYSIWG tools are legitimate. WYSIWYG tools should use elements they know are appropiate,
		and should not use elements that they do not know to be appropiate. This might in certain extreme
		cases mean limiting the use of flow elements to just a few elements, like <div>,<b>,<i>, and <span>
		and making liberal use of the style atribute

		All authoring tools, whether WYSIWYG or not, should make a best effort attempt at enabling
		users to create well-structured, semantically rich, media-independent content.

	User agents may impose implementation-specific limits on otherwise unconstrained inputs, e.g,
	to prevent denial of service attacks, to guard against running out of memory, or to work around
	platform-specific limitations.

	For compability with existing content and prior specifications, this specification describes two
	authoring formats: one based on XML (referred to as the XHTML syntax) and one using a custom format
	inspired by SGML (referred to as teh HTML syntax).

	Implementations must support least one of these two formats, although supporting both is encouraged.

	Some conformance requirements are phrased as requirements on elements, attributes, methods or objects.
	Such requirements fall into two categories: those describing content model restrictions, and those 
	describing implementation behavior.

	Those in the former category are requirements on documents and authoring tools. Those in the second
	category are requirements on user agents. Similarly, some conformance requirements are phrased
	as requirements on authors; such requirements are to be interpreted as conformance requirements
	on the documents that authors produce. (In other words, this specification does not distingusih
	between conformance criteria on authors and conformance criteira on documents).

	2.2.2 Dependencies

		This specification relies on several other underlying specifications.

		Unicode and Encoding

		The Unicode character set is used to represent textual data, and the Encoding specification
		defines requirements around character encodings. [UNICODE]

		NOTE:
		This specification introduces terminology based on the terms defined in those specifications,
		as described earlier.

		The following terms are used as defined in the Encoding specification: [ENCODING]

		Getting an encoding
		
		Get an output encoding

		The generic decode algorithm which takes a byte stream and an encoding and returns a character
		stream

		The UTF-8 decode algorithm which takes a byte stream and returns a character stream, additionally
		stripping one leading UTF-8 byte Order Mark (BOM), if any

		The UTF-8 decode without BOM algorithm which is identical to UTF-8 decode except that it does not
		strip one leading UTF-8 byte Order Mark (BOM).

		The UTF-8 decode without BOM or fail algorithm which is identical to UTF-8 decode without BOM except
		that it returns failure upon encountering an error

		The encode algorithm which takes a character stream and an encoding and returns a byte stream

		The UTF-8 encode algorithm which takes a character stream and returns a byte stream.

	XML and related specifications

		Implementations that support the XHTML syntax must support some version of XML, as well as its
		corresponding namesapces definition, because that syntax uses an XML serialization with namespaces.
		[XML] [XML-NAMES]

		The attribute with the tag name xml:space in the XML namespace is defined by the XML specification. [XML]

		This specification also references the <?xml-stylesheet?> processing instruction, defined in the
		Associating Style Sheets with XML documents specification. [XML-STYLESHEET]

		This specification also non-normatively mentions the XSLTProcessor interface and its 
		transformToFragment() and transformToDocument() methods. [XSLTP]

	URLs
		The following terms are defined in the WHATWG URL specification. [URL]

		host
		domain
		URL
		Origin of URLs
		Absolute URL
		Relative URL
		Relative schemes
		The URL parser and basic URL parser as well as these parser states:
			scheme start state
			host state
			hostname state
			port state
			path start state
			query state
			fragmen state
		URL record, as well as tis individual components:
			scheme
			username
			password
			host
			port
			path
			query
			fragment
		A network scheme
		The URL serializer
		The host parser
		The host serializer
		Host equals
		serialize an integer
		Default encode set

		Percent encode
		set the username
		set the password
		The domain to Unicode algorithm
		non-relative flag
		Parse errors from the URL parser

	A number of schemes and protocols are referenced by this specification also:

		The about: scheme [RFC6694]

		The blob: scheme [FILEAPI]

		The data: scheme [RFC2397]

		The http: scheme [HTTP]

		The mailto: scheme [RFC6068]

		The sms: scheme [RFC5724]

		The urn: scheme [URN]

	media fragment syntax is defined in the Media Fragments URI specification [MEDIA-FRAGS]

	HTTP and related specifications

		The following terms are defiend in the HTTP specifications: [HTTP]

		Accept header

		Accept-language header

		Cache-Control header

		Content-Disposition header

		Content-Language header

		Content-Length header

		Last-Modified header

		Referer

	The following terms are defined in teh Cookie specification. [COOKIES]

		cookie-string

		receives a set cookie-string

		Cookie header

	The following term is defined in the Web Linking Specification [RFC5988]
		Link header

	Fetch
		The following terms are defined in the WHATWG Fetch specification. [FETCH]

		about:blank

		HTTPS state value

		referrer policy

		CORS protocol

		default User-Agent value

		extract a MIME type

		fetch

		ok status

		Origin header

		process response

		set

		terminate

		the RequestCredentials enumeration

		response and its associated

			type

			url

			url list

			status

			header list

			body

			internal response

			CSP list

			HTTPS state

		request and its associated

			url

			method

			header list

			body

			client

			target browsing context

			initiator

			type

			destination

			origin

			omit-Origin-header flag

			same-origin-data-URL flag

			referrer

			synchronous flag

			mode

			credentials mode

			use-URL-credentials flag

			unsafe-request flag

			cache mode

			redirect mode

			cryptographic nonce metadata

			referrer policy

			parser metadata
		The following terms are defined in Referrer Policy [REFERRERPOLICY]

		referrer policy

		The Referrer-Policy HTTP header

		The parse a referrer policy from a Refferer-Policy header algorithm

		The "no-referrer", "no-referrer-when-downgrade", and "unsafe-url" referrer policies

	Web IDL

		The IDL fragments in this specification must be interpreted as required for conforming
		IDL fragments, as described in teh Web IDL specification. [WEBIDL]

		The following terms are defined in the Web IDL specification:

			array index property name

			supported property indices

			Determine the value of an indexed property

			Support named properites

			Determine the value of a named property

			perform a security check

			Platform object

			Primary interface

			Global environment associated with a platform object

			Read only (when applied to arrays)

			Callback this value

			Converting between WebIDL types and JS types

			invoke the Web IDL callback function
		The Web IDL specification also defines the following types that are used in 
		Web IDL fragments in this specification:

			ArrayBufferView

			'boolean'

			'DOMString'

			'USVString'

			'double'

			'Error'

			Function

			'long'

			object

			'unrestricted double'

			'unsigned long'
		The term throw in this specification is used as defined in teh WebIDL specification. The following
		exception names are defined by WebIDL and used by this specification:

			IndexSizeError

			HierarchyRequestError

			WrongDocumentError

			InvalidCharacterError

			NoModificationAllowedError

			NotFoundError

			NotSupportedError

			InvalidStateError

			SyntaxError

			InvalidModificationError

			NamespaceError

			InvalidAccessError

			SecurityError

			NetworkError

			AbortError

			URLMismatchError

			QuotaxExceededError

			TimeoutError

			InvalidNodeTypeError

			DataCloneError
		When this specification requires a user agent to create a Date object representing a particular
		time (which could be the special value NaN), the milliseconds component of that itme, if any,
		must be truncated to an int, and the time value of the newly created Date object must represent
		the resulting truncated time.

		EXAMPLE 11

		For instance, given the time 23045 milliseconds of a second after 01:00 UTC on January 1st 2000,
		i.e, the time 2000-01-01T00:00:00.023045Z, then the Date object created representing that time
		would represent the same time as that created representing the time 2000-01-01T00:00:00.023Z,
		45 millionths earlier.

		If the given time is NaN, then the result is a Date object that represents a time value NaN
		(indicating that the object does not represent a specific instant of time).

	JavaScript

		Some parts of the langauge described by this specification only support Javascript as the underlying
		scripting language. [ECMA-262]

		NOTE:
		The Term "JavaScript" is used to refer to ECMA262, rather than the official term ECMAScript, since the
		term JavaScript is more widely known. Similarly, the MIME type header used to refer to JavaScript in
		this specification is text/javascript, since that is the msot commonly used type, despite it being
		an officialy obsoleted type according to RFC 4329. [RFC4329].

		The following terms are defined in the JavaScript specification and used in this specification. [ECMA-262]:

			automatic semicolon insertion

			early error

			Directive Prologue

			JavaScript execution context

			JavaScript execution context stack

			running JavaScript execution context

			JavaScript realm

			The current Realm Record

			Use Strict Directive

			Well-Known Symbols, including:

				@@hasInstance

				@@isConcatSpreadable

				@@toPrimitive

				@@toStringTag

			Well-Known Instrinsic Objects, including:

				%ArrayBuffer%

				%ArrayPrototype%

				%ObjProto_toString%

				%ObjProto_valueOf%

			The FunctionBody production

			The Module production

			The Pattern production

			The Script production

			The Type notation

			The List and Record specification types

			The Property Descriptor specification type

			The Source Text Module Record specification type and its
			ModuleEvaluation and ModuleDeclarationInstansiation methods

			The ArrayCreate abstract operation

			The Call abstract operation

			The Construct abstract operation

			The CopyDataBlockBytes abstract operation

			The CreateByteDataBlock abstract operation

			The CreateDataProperty abstract operation

			The DetachArrayBuffer abstract operation

			The EnqueueJob abstract operation

			The FunctionCreate abstract operation

			The Get abstract operation

			The GetActiveScriptOrModule abstract operation

			The GetFunctionRealm abstract operation

			The HasOwnProperty abstract operation

			The HostEnsureCanCompileStrings abstract operation

			The HostPromiseRejectionTracker abstract operation

			The HostResolveImportedModule abstract operation

			The InitializeHostDefinedRealm abstract operation

			The isAccessorDescriptor abstract operation

			The IsCallable abstract operation

			The IsConstructor abstract operation

			The IsDataDescriptor abstract operation

			The IsDetachedBuffer abstract operation

			The NewObjectEnvironment abstract operation

			The OrdinaryGetPrototypeOf abstract operation

			The OrdinarySetPrototypeOf abstract operation

			The OrdinaryIsExtensible abstract operation

			The OrdinaryPreventExtensions abstract operation

			The OrdinaryGetOwnProperty abstract operation

			The OrdinaryDefineOwnProperty abstract operation

			The OrdinaryGet abstract operation

			The OrdinarySet abstract operation

			The OrdinaryDelete abstract operation

			The OrdinaryOwnPropertyKeys abstract operation

			The ParseModule abstract operation

			The ParseScript abstract operation

			The RunJobs abstract operation

			The SameValue abstract operation

			The ScriptEvaluation abstract operation

			The ToBoolean abstract operation

			The ToString abstract operation

			The ToUint32 abstract operation

			The TypedArrayCreate abstract operation

			The Abstract Entity Comparison algorithm

			The Strict Equality Comparison algorithm

			The ArrayBuffer object

			The Date object

			The SyntaxError object

			The TypeError object

			The RangeError object

			The RegExp object

			The typeof operator

			The TypedArray Constructors table

		DOM
			The Document Object Model (DOM) is a representation - a model - of a document and its content.
			The DOM is not just an API; the conformance criteria of HTML implementations are defined, in this
			specification, in terms of operations on the DOM. [DOM]

			Implementations must support DOM and the events defined in UI events, ebcause this specification
			is defined in terms of the DOM, and some of hte features are defined as extensions to the DOM 
			interfaces.
			[DOM][UIEVENTS]

			In particular, the following features are defined in the DOM specification: [DOM]

				Attr interface

				Comment interface

				DOMImplementation interface

				Document interface

				XMLDocument interface

				DocumentFragment interface

				DocumentType interface

				DOMException interface

				ChildNode interface

				Element interface

				Node interface

				NodeList interface

				ProcessingInstruction interface

				Text interface

				HTMLCollection interface

				item() method

				The terms collections and represented by the collection

				DOMTokenList interface

				createDocument() method

				createHTMLDocument() method

				createElement() method

				createElementNS() method

				getElementById() method

				getElementsByClassName() method

				appendChild() method

				cloneNode() method

				importNode() method

				id attribute

				textContent attribute

				The tree concept

				The tree order concept

				The root concept

				The inclusive ancestor concept

				The document element concept

				The in a document concept

				The pre-insert, insert, append, remove, replace, and adopt algorithms for nodes

				The insertion steps, removing steps, and adopting steps hooks

				The attribute list concept

				The data of a text node.

				Event interface

				EventTarget interface

				EventInit dictionary type

				target attribute

				currentTarget attribute

				isTrusted attribute

				initEvent() method

				addEventListener() method

				The type of an event

				The concept of an event listener and the event listeners associated with an EventTarget

				The concept of a target override

				The encoding (herein the character encoding) and the content type of a Document

				The distinction between XML documents and HTML documents

				The terms quirks mode, limited-quirks mode, and no-quirks mode.

				The algorithm to clone, a Node, and the concept of cloning steps used by that algorithm.

				The concept of base URL change steps and the definition of what happens when an element is affected
				by a base URL change

				The concept of an element's unique identifier (ID)

				The term supported tokens

				The concept of a DOM range, and the terms start, end, and boundary point as applied to ranges.

				The create an element algorithm

				MutationObserver interface and mutation observers in general

			EXAMPLE 12

			For example, to throw a TimeoutError exception, a user agent would construct a DOMException object
			whose type was the string "TimeoutError" (and whose code was the number 23, for legacy reasons)
			and actually throw that object as an exception.

			The following features are defined in the UI Events specification: [UIEVENTS]

				MouseEvent interface and the following interface members:

					The relatedTarget attribute

					The button attribute

					The ctrlKey attribute

					The shiftKey attribute

					The altKey attribute

					The metaKey attribute

					The getModifierState() method

				MouseEventInit dictionary type

				The FocusEvent interface and its relatedTarget attribute

				The UIEvent interface's view and detail attributes

				click event

				dblclick event

				mousedown event

				mouseenter event

				mouseleave event

				mousemove event

				mouseout event

				mouseover event

				mouseup event

				wheel event

				keydown event

				keyup event

				keypress event

			The following features are defined in the Touch Events specification: [TOUCH-EVENTS]

				Touch interface

				Touch point concept

			This specification sometimes uses the term name to refer to the event's type, as in, "an event named
			click" or "if the event name is keypress". The terms "name" and "type" for events are synonymous.

			The following features are defined in teh DOM Parsing and Serialization specification: [DOM-PARSING]

				innerHTML

				outerHTML

			The Selection interface is defined in the Selection API specification [SELECTION-API]

			NOTE:
				User agents are also encouraged to implement the features described in the HTML Editing APIs
				and UndoManager and DOM Transaction specification [EDITING] [UNDO]

			The following parts of the Fullscreen specification are referenced from this specification, in part
			to define the rendering of <dialog> elements, and also to define how the Fullscreen API interacts
			with the sandboxing features in HTML: [FULLSCREEN]

				The top layer concept

				requestFullscreen()

				The fullscreen enabled flag

				The fully exit fullscreen algorithm

			The High Resolution Time specification provides the DOMHighResTimeStamp typedef and the Performance
			object's now() method. [HT-TIME-2]
		File API

			This specification uses the following features defined in the File API specification. [FILEAPI]

				Blob interface and its type attribute

				File interface and its name and lastModified attributes

				FileList interface

				The concept of a Blob's snapshot state

				the concept of read errors

				Blob URL Store

		Indexed Database API

			this specification uses cleanup Indexed Database transactions defined by the Indexed
			Database API specification. [INDEXEDDB].

		Media Source Extensions

			The following terms are defined in the Media Source Extensions specification: [MEDIA-SOURCE]

				MediaSource interface

				Detach from a media element

		Media Capture and Streams

			The following term is defined in the Media Capture and Streams specification.
			[MEDIACAPTURE-STREAMS]

			MediaStream interface

		XMLHttpRequest
			This specification references the XMLHttpRequest specification to describe how the two
			specifications interact and to use its ProgressEvent features. The following features
			and terms are defined in the XML HttpRequest specification. [XHR]

			XMLHttpRequest interface

			XMLHttpRequest.responseXML attribute

			ProgressEvent interface

			ProgressEvent.lengthComputable attribute

			ProgressEvent.loaded attribute

			ProgressEvent.total attribute

			Fire a progress event named e

		Server-Sent Events

			This specification references EventSource which is specified in the Server-Sent Events
			specification. [EVENTSOURCE] //Note, all of these [] notations are actually referneces
			//That is based on further docsi n the W3C, in case of time over, read thoose as well to better
			//undersatanding underlying architechture, albeit pattern seems to be the same, ish

		Media Queries
			Implementations must support the Media Queries language. [MEDIAQ]

			<media-condition>

		CSS modules
			While support for CSS as a whole is not required of implementations of this specification
			(though it is encouraged, at least for Web browsers), some featurs are defined in terms
			of specific CSS requirements.

			In particular, some features require that a string be parsed as a CSS <color> value. When
			parsing a CSS value, user agents are required by the CSS specifications to apply some error
			handling rules. These apply to this specification also. [CSS3COLOR] [CSS-2015]

			EXAMPLE 13

			For example, user agents are required to close all open constructs upon finding the end
			of a style sheet unexpected. Thus, when parsing the string "rgb(0,0,0" (with a missing
			close-paranthesis) for a color value, the close paranthesis is implied by this error 
			handling rule, and a value is obtained (the color 'black').

			However, a similar construct, the value of "rgb(0,0" (with both a missing parantehsis
			and a missing "blue" value), it cannot be parsed, as closing the open paranthesis does not
			result in a valid vlaue.

			The following terms and features are defined in the CSS specification: [CSS-2015]

				viewport

				replaced element

				intrinsic dimensions

			The term named color is defined in the CSS Color specification. [CSS3COLOR]

			The terms intrinsic width and intrinsic height refer to the width dimension
			and the height dimension, respectively, of intrinsic dimensions.

			The term paint source is used as defined in the CSS Image Values and Replaced Content
			specification to define the interaction of certain HTML elements with CSS 'element()'
			function. [CSS3-IMAGES]

			The term default object size is also defined in the CSS Image Values and Replaced Content
			specification [CSS3-IMAGES].

			Implementations that support scripting must support the CSS Object Model. The following
			features and terms are defined in the CSSOM specifications: [CSSOM] [CSSOM-VIEW]

				Screen

				LinkStyle

				CSSStyleDeclaration

				cssText attribute of CSSStyleDeclaration

				StyleSheet

				create a CSS style sheet

				remove a CSS style sheet

				associated CSS style sheet

				CSS style sheets and their properties: type, location, parent CSS style sheet, owner node,
				owner CSS rule, media, title, alternate flag, disabled flag, CSS rules, origin-clean flag.

				Alternative style sheet sets and the preffered style sheet set

				Serializing a CSS value

				run the resize steps

				run the scroll steps

				evaluate media queries and report changes

				Scroll an element into view

				Scroll to the beginning of the document

				The resize event

				The scroll event

				The features argument of window.open

			The following features and terms are defined in the CSS Syntax specifications: [CSS-SYNTAX-3]

				Parse a comma-separated list of component values

				component value

				environment encoding

				<whitespace-token>

			The following terms are defined in the Selectors specification: [SELECTORS4]

				type selector

				attribute selector

				pseudo-class

			The feature <length> is defined in the CSS Values and Units specifiation. [CSS-VALUES]

			the term style attribute is defined in the CSS Style Attributes specification. [CSS-STYLE-ATTR]

			The term used value is defined in the CSS Cascading and Inheritance specification. [CSS-CASCADE-3]

			The CanvasRenderingContext2D object's use of fonts depends on the features described in teh CSS
			Fonts and Font Loading specifications, including in particular FontFace objects and the font source
			concept.
			[CSS-FONTS-3][CSS-FONT-LOADING-3]

			The following interface is defined in the Geometry Interfaces Module specification. [GEOMETRY-1]

				DOMMatrix interface
		SVG

			The CanvasRenderingContext2D object's use of fonts depends on the features described in the CSS Fonts
			and Font Loading specifications, including in particular FontFace objects, and the font source concept.
			[CSS-FONTS-3][CSS-FONT-LOADING-3]

			The following interface is defined in the SVG specification: [SVG11]

				SVGMatrix

		WebGL
			The following interface is defined in the WebGL specification: [WEBGL]

			WebGLRenderingContext

		WebVTT
			Implementations may support WebVTT as a text track format for subtitles, captions, chapter titles,
			metadata, etc, for media resources. [WEBVTT]

			The following terms, used in this specification, are defined in the WebVTT specification.

				WebVTT file

				WebVTT file using cue text

				WebVTT file using chapter title text

				WebVTT file using only nested cues

				WEbVTT parser

				The rules for updating the display of WebVTT text tracks

				The rules for interpreting WebVTT cue text

				The WebVTT text track cue writing direction

		The WebSocket protocol

			The following terms are defined in teh WebSocket protocol specification. [RFC6455]

			establish a WebSocket connection

			The WebSocket connection is established

			validate the server's response

			extensions in use

			subprotocol in use

			headers to send appropaite cookies

			cookies set during the server's opening handshake

			a WebSocket message has been received

			send a WebSocket Message

			fail the WebSocket connection

			close the WebSocket connection

			Start the Websocket closign handshake

			the WebSocket closing handshake is started

			the WebSocket connection is closed (possibly cleanly)

			the WebSocket connection close code

			the WebSocket connection close reason

			Sec-WebSocket-Protocol field.

		ARIA
			The role attribute is defiend in the ARIA specification, as are the following roles:
			[war-aria-1.1]

			-> alert, alertdialog, application, article, banner, button, cell, columnheader, combobox,
			complementary, contentinfo, definition, dialog, directory, document, feed, figure, form, grid,
			gridcell, heading, img, link, list, listbox, listitem, log, main, marquee, math, menu,
			menubar, menuitem, menuitemcheckbox, menuitemradio, navigation, none, note, option,
			presentation, progressbar, radio, radiogroup, region, row, rowgroup, rowheader, scrollabr,
			search, searchbox, separator, slider, spinbutton, status, switch, tab, table, tablist,
			tabpanel, term, textbox, toolbar, tooltip, tree, treegrid, treeitem

			In addition, the following aria-* content attributes are defined in the ARIA specification: [wai-aria-1.1]
			-> aria-activedescendant, aria-atomic, aria-autocomplete, aria-busy, aria-checked, aria-colcount,
			aria-colindex, aria-colspan, aria-controls, aria-current, aria-describedby, aria-details, aria-dialog,
			aria-disabled, aria-dropeffect, aria-errormessage, aria-expanded, aria-flowto, aria-grabbed, aria-haspopup,
			aria-hidden, aria-invalid, aria-keyshortcuts, aria-label, aria-labelledby, aria-level, aria-live,
			aria-multitude, aria-multiselectable, aria-orientation

			aria-owns, aria-placeholder, aria-posinset, aria-pressed, aria-readonly, aria-relevant, aria-required,
			aria-roledescription, aria-rowcount, aria-rowindex, aria-rowspan, aria-selected, aria-setsize, aria-sort,
			aria-valuemax, aria-valuemin, aria-valuenow, aria-valuetext

	Content Security Policy

		The following terms are defined in Content Security Policy: [CSP3]

			Content Security Policy

			Content Security Policy Directive

			The Content Security Policy Syntax

			enforce the policy

			The parse a serialized Content Security Policy algorithm

			The initialize a global object's CSP list algorithm

			The initialize a Document's CSP list algorithm

			The Should element's inline behavior be blocked by Content Security Policy? Algorithm

			The report-uri, frame-ancestors, and sandbox directives

			The EnsureCSPDoesNotBlockStringCompilation abstract algorithm

			The Is base allowed for Document? algorithm

			The Should element be blocked a priori by Content Security Policy? algorithm

		The following terms are defined in Content Security Policy: Document Features

			The frame-ancestors directive

			The sandbox directive

	Service Workers

		The following terms are defined in Service Workers: [SERVICE-WORKERS]
			client message queue

			match service working registration

			ServiceWorkerContainer

	Secure Contexts

		The following term is defiend in Secure Contexts [SECURE-CONTEXTS]
			Is Environment settings object a secure context?

	Payment Request API

		The following term is defined in the Payment Request API specification: [PAYMENT-REQUEST]

			PaymentRequest interface
	MathML

		While support for MathML as a whole is not required by this specification (though it is encouraged,
		at least for Web Browsers), certain features depends upon small parts of MathML being implemented.
		[MATHML]

		The following features are defined in teh MATHML specification:

			MathML annotation-xml element

			MathML math element

			MathML merror element

			MathML mi element

			MathML mn element

			MathML mo element

			MathML ms element

			MathML mtext element

		SVG
			While suport for SVG as a whole is not required by this specification (though it is encouraged,
			at least for Web Browsers), certain features depend upon parts of SVG being implemented.

			Also, the SVG specifications do not reflect implementation reality. IMplementations implement subsets
			of SVG 1.1 and SVG Tiny 1.2. Although it is hoped that the in-progress SVG 2 specification is
			a more realistic target for implementations, until that specification is ready, user agents
			that implement SVG must do so with the following willful violations and additions.
			[SVG11][SVGTINY12][SVG2]


			User agents that implement SVG must not implement the following features from SVG 1.1

				The tref element

				The cursor element (use CSS's cursor property instead)

				The font-defining SVG elements: font, glyph, missing-glyph, hkern, vkern, font-face,
				font-face-src, font-face-uri, font-face-format, and format-face-name (use CSS's @font-face
				instead)

				The externalResourcesRequired attribute

				The enable-background property

				The contentScriptType and contentStyleType attributes (uses the type attribute on the
				SVG <script> and style elements instead)

			USer agents that implement SVG must implement the following features from SVG Tiny 1.2:

				The non-scaling-stroke value for the vector-effect property

				The class attribute is allowed on all SVG elements

				The tabindex attribute is allowed on visible SVG elements

				The ARIA accessibility attributes are allowed on all SVG elements

			The following features are defined in the SVG specifications

				SVGScriptElement interface

				SVG <dec> element

				SVG <foreignObject> element

				SVG <script> element

				SVG <svg> element

				SVG <title> element

			Filter Efffects

				The following feature is defiend in the Filter Effects specification:

					<filter-function-list>

		This specification does not require support of any particular network protocl, style sheet language,
		scripting langauge or any of the DOM specifications before those required in teh list above. however,
		the language described by this specification is biased towards CSS as the styling language, JS as
		the scripting language, and HTTP as the network protocol, and several features assume that those
		languages and protocols are in use.

		A user agent that implements the HTTP protocol must implement the Web Origin Concept specification
		and teh HTTP State Management Mechanism specification (Cookies) as well. [HTTP] [ORIGIN] [COOKIES]

		NOTE:
		This specification might have certain additional requirements on cahracter encodings, image formats,
		audio formats and video formats in the respective sections.

		2.2.3 Extensibility

		Vendor-specific proprietary user agent extensions ot this specification are strongly discouraged.
		//proprietary is ownership

		Documents must not use such extensions, as doing so reduces interoperability and fragments the user
		base, allowing only users of specific user agents to access the content in question.

		If such extensions are nonetheless needed, e.g, for experimental purposes, then vendors are strongly
		urged to use one of the following extension mechanisms:

			For markup-level features that can be limited to the XML serialization and need not be supported
			in the HTML serialization, vendors should use the namespace mechanism to define custom namespaces
			in which the non-standard elements and attribute are supported.

			For markup-level features that are intended for use with the HTML syntax, extensions should be limited
			to new attributes of the form "x- vendor - feature", where vendor is short string that identifies
			teh vendor responsible for the extension, and feature is the name of the feature.

			New element names should not be created. Using attirbutes for such extensions exclusively allows
			extenisons from multiple vendors to co-exist on the same element, which would not be possible
			with elements. Using the "x- vendor - feature" form allows extensions to be made without risk
			of conflicting with future additions to the specification.

			EXAMPLE 14

			For instance, a browser named "FerretBRowser" could use "ferret" as a vendor prefix, while a browser
			named "Melblom Browser" could use "mb". If both of these browsers invented extensions that turned
			elements into scratch and sniff areas, an author experimenting with these features could write:

			<p>This smells like lemons!
			<span x-ferret-smellovvision x-ferret-smellcode="LEM01"
			x-mb-outputsmell x-mb-smell="lemon juice"></span></p>

		Attribute names beginning with two characters "x-" are reserved for user agent use and are guaranteed
		to never be formally added to the HTML language. For flexibility, attributes names containing underscores
		(the U+005F LOW LINE character) are also reserved for experiemtnal purposes and are guaranteed to never
		be formally added to the HTML language.

		NOTE:
		Pages that use such attributes are by definition non-conforming.

		For DOM extensions, e.g, new methods and IDL attributes, the new members should be prefixed by vendor-specific
		strings to prevent the clashes with future versions of this specification.

		For events, experimental event types should be prefixed with vendor-specific things.

		EXAMPLE 15
		For example, if a user agent called "Pleasold" were to add an event to indicate when the user is going up
		in an elevator, it could use hte prefix "pleasold" and thus name the event "pleasoldgoingup", possibly
		with an event handler attribute named "onpleaseoldgoingup".

		All extensions must be defined so that hte use of extensions neither contradicts nor causes the non-conformance
		of functionality defined in the specification.

		Example 16

		For example, while strongly discouraged from doing so, an implementation "Foo Browser" could add a new
		IDL attribute "fooTypeTime" to a control's DOM interface that returned the time it took the user to select
		the current value of a control (say).

		On the other hand, defining a new control that appears in a form's elements array would be in violation of
		the above requirement, as it would violate the definition of elements given in this specification.

		When adding new reflecting IDL attributes corresponding to content attributes of the form "x-vendor - feature",
		the IDL attribute should be named "vendor Feature" (i.e, the "x" is dropped from the IDL attribute's name).

		When vendor-neutral extensions to this specification are needed, either this specification can be updated
		accordingly, or an extension specification can be written that overrides the requirements in this specification.
		When someone applying this specification to their activites decides that they will recognize the requirements 
		of such an extension specification, it becomes an applicable specification for purposes of conformance requirements
		in this specification.

		NOTE:
		Someone could write a specification that defines any arbitrary byte stream as conforming, and then claim that
		their random junk is conforming. However, that does not mean taht their random junk is actually conforming
		for everyone's purposes: if someone else decides that the specification does not apply to their wokr, then
		they can quite legitmately say that the afformentioned random junk is just that, junk, and not conforming at all.

		As fr as conformances goes, what matters in a particular community is what that community agrees is applicable.

		applicable specification

		The conformance technology for documents depends on the nature of the changes introduced by such applicable
		specifications, and on the content and intended interpretation of the document. Applicable specifications MAY
		define new document content (e.g, a foorbar element), MAY prohibit certain otherwise conforming content
		(e.g, prohibit useo f <table>s), or MAY change the semantics, DOM mappings, or other processing rules for
		content defined in this specification.

		Whether a document is not a conforming HTML document does not depend on the use of applicable specifications:
		if the syntax and semantics of a given conforming HTML document is unchanged by the use of applicable 
		specification(s), then that document remains a conforming HTML document.

		If the semantics or processing of a given (othewise conforming) document is changed by use of applicable
		specification(s), then it is not a conforming HTML document. For such cases, the applicable specifications
		SHOULD define conformance terminology.

		NOTE:
		As a suggested but not required convention, such specifications might define conformance technology such
		as "Conforming HTML+XXX document", where XXX is a short name for the applicable specification. (Example:
		"Conforming HTML+AutomotiveExtensions document").

		NOTE:
		a consequence of the rule given above is that certain syntactically correct HTML documents may not be
		conforming HTML documents in the presence of applicable specifications. (Example: the applicable
		specification defines <table> to be a piece of furniture - a document written to that specification
		and containing a <table> element is NOT a conforming HTML element, even if it happens ot be syntactically
		correct HTML).

		User agents msut treat elements and attributes that they do not understand as semantically neutral;
		leaving them in the DOM (for DOM processors), and styling them according to CSS (for CSS processors),
		but not infering any meaning from them.

		When support for a feature is disabled (e.g, as an emergency measure ot mitigate a security problem,
		or to aid in development, or for performance reasons), user agents must act as if they had no support
		for the feature whatsoever, and as if the feature was not mentioned in this specification.

		For example, if a particular feature is accessed via an attribute in a Web IDL interface, the attribute
		itself would be omitted from the objects that implement that interface - leaving the attribute on the
		object but making it return null or throw an exception is unsifficient.

		2.2.4 Interactions with XPath and XSLT

		Implementations of XPath 1.0 that operate on HTML documents parsed or created in the manners described
		in this specification (e.g, as part of the document.evaluate() API) must act as if the following
		edit was applied to the XPath 1.0 specification.

		First, remove this paragraph:

			A QName in the node test is expanded into an expanded-name using the namespace declarations from
			the expression context. This is the same way expansion is done for element type names in start
			and end-tags-except that hte default namespace declared with xmlns is not used: if the QName
			does not have a prefix, then the namespace URI is null (this is the same way attribute names
			are expanded). It is an error if the QName has a prefix for which there is no namespace 
			declaration in the expression context.

		Then, insert in its place the following:

			A QName in the node test is expanded into an expanded-name using the namespace declarations from
			the expression context. If the QName has a prefix, then there must be a namespace declaration for
			this prefix in teh expression context, and the corresponding namespace URI is the one that is
			associated with this prefix.

			It is an error if the QName has a prefix for which there is no namespace declaration in the
			expression context. If the QName has no prefix and the principal node type of the axis is element,
			then the default element namespace is a member of the context for teh XPath expression. The value
			of the default element namespace when executing an XPath expression through the DOM3 XPath API
			is determined in the following way:

			1. If the context node is from an HTML DOM, the default element namespace is "http://www.w3.org/1999/xhtml"

			2. Otherwise, the defualt element namespace URI is null.

		NOTE:
		This is equivalent to adding the default element namespace of XPath 2.0 to XPath 1.0 and using the
		HTML namespace as the default namespace for HTML documents. It is motivated by the desire to have
		implementations be compatible with legacy HTML content while still supporting the changes that this
		specification introduces to HTML regarding the namespace used for HTML elements, and by the desire
		to use XPath 1.0 rather than XPath 2.0

	NOTE:
	This change is a willful violation of the XPath 1.0 speficiation, motivated by the desire to have
	implementations be compatible with legacy content while still supporting the changes that this
	specification introduces to HTML, regarding which namespace is used for HTML elements. [XPATH]

	XSLT 1.0 processors outputting to a DOM where the output method is "html" (either explicitly or via the
	defaulting rule in XSLT 1.0) are affected as fllows:

	If the transformation program outputs an element in no namespace, the processor, must, prior to constructing
	the corresponding DOM element node, change the namespace of the element to the HTML namespace, ASCII-lowercase
	the element's local name, and ASCII-lowercase the names of any non-namespaced attributes on the element.

	NOTE:
	This requirement is a willful violation of the XSLT 1.0 specification, required because this specification
	changes the namespaces and case-sensitivity rules of HTML in a manner that would otherwise be incompatible
	with DOM-based XSLT transformation. (processors that serialize the output are unaffected) [XSLT]

	This specifcation does not specify precisely how XSLT processing interacts with the HTML parser infrastructure
	(for example, whether an XSLT processor acts as if it puts any elements into a stack of open elements).
	however, XSLT processors must stop parsing if they successfully complete, and must set the current document
	readiness first to "interactive" and then to "complete" if they are aborted.

	This specification does not specify how XSLT interacts with the navigation algorithm, how it first with the
	event loop, nor how error pages are to be handled (e.g, whether XSLT errors are to replace an incremental
	XSLT output or are rendered inline, etc.)

	NOTE:
	There are also additional non-normative comments regarding the interaction of XSLT and HTML in the 
	script element section, and of XSLT, XPath and HTML in the template element section.

	2.3 Case-sensitivity and string comparison

	Comparing two strings in a case-sensitive manner means comparing them exactly, code point to code point.

	Comparing two strings in an ASCII case-insensitive manner means comparing them exactly, code point for code point,
	except that the chars in the range U+0041 to U+005A (i.e LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z) and the
	corresponding chars in range U+0061 to U+007A (i.e, LATIN SMALL LETTER A to LATIN SMALL LETTER Z) are considered
	to also match.

	Comparing two strings in compability caseless manner means using the UNicode compability caseless
	match operation to compare the two strings, with no language-specific tailorings. [UNICODE]

	Except where otherwise stated, string comparisons must be performed in a case-sensitive manner.

	Converting a string to ASCII uppercase means replacing all cahracters in the range U+0061 to
	U+007A (i.e LATIN SMALL LETTER A to SMALL LATIN LETTER Z) with the corresponding chars in range
	U+0041 to U+005A (i.e, LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z).

	Convertiing a string to ASCII lowercase means replacing all chars in range U+0041 to U+005A
	(i.e LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z) with the corresponding chars in teh range
	U+0061 to U+007A(i.e, LATIN SMALL A to SMALL LATIN LETTER Z).

	A string pattern is a prefix match for a string when pattern is not longer than s and truncating
	s to patterns length leaves the two strings s matches of each other.

	2.4 Common microsyntaxes

	There are various places in HTML that accept particular data types, such as dates or numbers.
	This section describes what hte conformance for content in those formats is, and how to parse them.

	NOTE:
	Implementors are strongly urged to carefully examine any third-party libs they might consider using to
	implement the parsing of syntaxes described below. For example, date libs are likely to implement
	error handling behavior that differs from what is required in this specification, since error-handling
	behavior is often not defined in specifications that describe date syntaxes similar to those used
	in this specification, and thus implementations tend to vary greatly in how they handle errors.

	2.4.1 Common parser idioms

	The space characters, for hte purposes of this specification are U+0020 SPACE, U+0009 CHARACTER
	TABULATION (tab), U+000A LINE FEED (LF), U+000C FORM FEED (FF), and U+000D CARRIAGE RETURN (CR).

	The White_Space characters are those that have the Unicode property "White_Space" in teh Unicode
	PropList.txt data file. [UNICODE]

	NOTE:
	This should not be confused with the "White_Space" value (Abbreviated "WS") of the "Bidi_Class"
	property in the Unicode.txt data file.

	The control characters are those whose Unicode "General_Category" property has the value "Cc"
	in the Unicode UNicodeData.txt data file. [UNICODE]

	The uppercase ASCII letters are the characters in teh range U+0041 LATIN CAPITAL LETTER A 
	to U+005A LATIN CAPITAL LETTER Z.

	The lowercase ASCII letters are the characters in the range U+0061 LATIN SMALL LETTER A to
	U+007A LATIN SMALL LETTER Z.

	The ASCII letters are the characters that are either uppcase ASCII letters or lowercase ASCII
	letters.

	The ASCII digits are the chars in range U+0030 DIGIT ZERO (0) to U+0039 DIGIT NINE (9).

	The alphanumeric ASCII chars are those that are either uppercase ASCII letters, lowercase
	ASCII letters, or ASCII digits.

	The ASCII hex digits are the characters in the ranges U+0030 DIGIT ZERO (0) to U+0039 DIGIT NINE (9),
	U+0041 LATIN CAPITAL LETTER A to U+0046 LATIN CAPITAL LETTER F, and U+0061 LATIN SMALL LETTER
	A to U+0066 LATIN SMALL LETTER F.

	The uppercase ASCII hex digits are the chars in the range of U+0030 DIGIT ZERO (0) to U+0039 DIGIT
	 NINE (9) and U+0041 LATIN CAPITAL A to U+0046 LATIN CAPITAL LETTER F only.

	The lowercase ASCII hex digits are teh chars in range of U+0030 DIGIT ZERO (0) to U+0039
	DIGIT NINE (9) and U+0061 LATIN SMALL LETTER A to U+0066 LATIN SMALL LETTER F only.

	Some of the micro-parses described below follow the pattern of having an input variable
	that holds the string being parsed, and having a position variable pointing at the next
	character to parse in input.

	For parsers based on this pattern, a step that requires the user agent to collect a sequence
	of characters means that hte following algorithms must be run, with characters being the
	set of characters that can be collected:

	1. Let input and position be the same variables as those of the same name in teh algorithm
	that invoked these steps.

	2. Let result be the empty string.

	3. While position does not point past the end of input and the character at position is one
	of the characters, append that characters to the end of result and advance position to the
	next character in input.

	4. Return result.

	The step skip white space means that hte user agent must collect a sequence of characters
	that are space characters. The collected characters are not used.

	WHen a user agent is to strip line breaks from a string, the user agent must remove any
	U+000A LINE FEED (LF) and U+000D CARRIAGE RETURN (CR) characters from that string.

	When a user agent is to strip leading and trailing white space from a string, the user agent
	must remove all space characters that are at the start anmd end of the string.

	When a user agent is to strip and collapse white space in a string, it must replace
	any sequence of one or more consecutive space chars in that string with a single U+0020
	SPACE character, and then strip leading and trailing white space from that string.

	When a user agent has to strictly split a string on a particular delimieter character
	delimieter, it must use hte following algorithm:

		1. Let input be the string being parsed.

		2. Let position be a pointer into input, intiially pointing at the start of the string.

		3. Let tokens be a ordered list of tokens, initialle empty.

		4. While position is not past the end of input.

			1. Collect a sequence of chars that are not the delimiter char.

			2. Append the string collected in previous steps to tokens.

			3. Advance position to the next character in input.

		5. Return tokens.

	NOTE:
		For the special case of splitting a string on spaces and on commas, this algorithm
		does not apply (those algorithms also perform white space trimming)

	2.4.2 Boolean Attributes

		A number of attributes are boolean attributes. The presence of a boolean attribute on an element
		represents the true value, and absence of the attribute represents the false value.

		If the attribute is present, its value must either be the empty string or a value that is
		an ASCII case-insensitive match for the attribute's canonical name, with no leading or
		trailing white space.

		NOTE:
		A boolean attribute without a value assigned to it (e.g, checked) is implicitly equivalent to
		one that has the empty string assigned to it (i.e checked=""). As a consequence, it represents the true value.

		NOTE:
		The values "true" and "false" are not allowed on boolean attributes. To represent a false value,
		the attribute must be omitted altogether.

		Example 17:
		Here is an example of a checkbox that is checked and disabled. The checked and disabled attributes
		are the boolean attributes.

		<label><input tpye=checkbox checked name=cheese disabled> Cheese</label>

		This could be equivalently written as this:

		<label><input type=checkbox checked=checked name=cheese disabled=disabled> Cheese</label>

		You can also mix styles, the following is still equivalent

		<label><input type='checkbox' checked name=cheese disabled=""> Cheese</label>

	2.4.3 Keywords and enumerated attributes

	Some attributes are defined as taking one of a finite set of keywords. Such attributes are called
	enumerated attributes. The keywords are each defined to map to a particular state (several keywords
	might map to the same state, in which case some of the keywords are synonyms of each other, additionaly,
	some of the keywords can be said to be non-conforming, and are only in the specification for historical reasons.).

	In addition, two default states can be given. The first is the invald value default, the second is the missing value default.

	If an enumerated attribute is specified, teh attribute's value must be an ASCII case-insensitive match for one of
	the given keywords that are not said to be non-conforming, with no leading or trailing white space.

	When the attribute is specified, if its value is an ASCII case-insensitive match for one of the given keywords then
	that keyword'state is the state that the attribute represents. If the attirbute value matches none of the given
	key-words, but the attribute has an invalid value default, then the attribute represents that state.

	Otherwise, if the attirbute value matches none of the keywords but there is a missing value default 
	state defined, then that is hte state represented by the attribute. Otherwise, there is no default and 
	invalid values means that htere is no state represented.

	WHen the attribute is not specified, if there is a missing value default state defined, then that is the
	state represented by the (missing) attribute. Otherwise, the absence of the attribute means that there
	is no state presented.

	NOTE:
	The empty string can be a valid keyword.

	2.4.4 Numbers

	2.4.4.1 Signed integers

		A string is a valid integer if it consists of one or more ASCII digits, optionally prefixed with a 
		U+002D HYPHEN-MINUS character (-)

		A valid integer without a U+002D HYPHEN-MINUS(-) prefix represents the number that is represented
		in base ten by that string of digits. A valid integer with a U+002D HYPHEN-MINUS(-) prefix represents
		the number of represented in base ten by the string of digits that follows the U+002D HYPHEN-MINUS
		, subtracted from 0.

		The rules for parsing integers are as given in the following algorithm. When invoked, the steps
		must be followed in the order given, aborting at the first step that returns a value. This algorithm
		will return either an integer or an error.

			1. Let input be the string being parsed.

			2. Let position be a pointer into input, initially pointing at the start of teh string.

			3. Let sign have the value "positive".

			4. Skip white space.

			5. If position is past the end of input, return an error.

			6. If the character indicated by position (the first character) is a U+002D HYPHEN-MINUS character (-)

					1. Let sign be "negative"

					2. Advance position to the next character

					3. If position is past the end of input, return an error

					Otherwise, if the character indicated by position (the first character) is a U+002B PLUS SIGN
					char (+)

					1. Advance position to the enxt character. (The "+" is ignored but its not conforming)

					2. If position is past at the end of input, return an error.

			´7. If the character indicated by position is not an ASCII digit, then return an error.

			8. Collect a sequence of characters that are ASCII digits, and interpret the resulting sesquence
			as base-ten integer. Let value be that integer.

			9. If sign is "positive", return value. Otherwise, return the result of subtracting value from zero.

	2.4.4.2 Non-negative integers

		A string is a valid non-negative integer if it consists of one or more ASCII digits.

		A valid non-negative integer represents the number that is represneted in base ten by that string of digits.

		The rules for parsing non-negative integers are as given in teh following algorithm. When invoked, the steps
		must be followed in teh order given, aborting at the first step that returns a value. The algorithm will
		return either zero, a positive integer or an error.

		1. Let input be the string being parsed.

		2. Let value be result of parsing input using the rules for parsing integers.

		3. If the value is an error, return an error.

		4. If value is less than zero, return an error.

		5. Return value.

	2.4.4.3 Floating-point numbers

		A string is a valid floating-point number if it consits of:

			1. Optionally, a U+002D HYPHEN-MINUS character (-)

			2. One or both of the following, in the given order:

				1. A series of one or more ASCII digits.

				2. Both of the following, in the given order:

					1. A single U+002E FULL STOP characer (.)

					2. A series of one or more ASCII digits.
			3. Optionally:

				1. Either a U+0065 LATIN SMALL LETTER E character (e) or a U+0045 LATIN CAPITAL LETTER E character (E).

				2. Optionally, a U+002D HYPHEN-MINUS character (-) or U+002B PLUS SIGN character(+).

				3. A series of one or more ASCII digits.

		A valid floating-point number represents the number obtained by multiplying the significand by ten raised
		to the power of the exponent, where the significant is the first number, interpreted as base ten (including
		the decimal point and the number after the decimal point, if any, and interpreting the significand as a negative
		number if the whole strrings tarts with a U+002D HYPHEN-MINUS character (-) and the number is not 0), and where
		the exponent is the number first after the E, if any (interpreted as a negative number if there is a U+002D HYPHEN-MINUS
		character (-) between the E and the number and the number is not 0, or else ignoring a U+002B PLUS SIGN char (+)
		between the E and the number if there is one). If there is no E, then the exponent is treated as zero.

		NOTE:
		The Infinity and Not-a-Number (NaN) values aren ot valid floating-point numbers.

		The best representation of the number n as a floating-point number is the string obtained from running
		ToString( n ). The abstract operation ToString is not uniquely determined. When there are multiple
		possible strings that could be obtained from ToString for a particular value, the user agent must
		always return the same string for that value (though it may differ from the value used by other user agents).

		The rules for parsing floating-point number values are as given in the following algorithm. This algorithm
		must be aborted at the first step that returns something. This algorithm will return either a number or an
		error.

		1. Let input be the string being parsed.

		2. Let position be a pointer into input, initially pointing at the start of the string.

		3. Let value have the value 1.

		4. Let divisor have the value 1

		5. Let exponent have the value 1.

		6. SKip white space

		7. If position is past the end of input, return an error.

		8. If the character indicated by position is a U+002D HYPHEN-MINUS character(-)

			1. Change value and divisor to -1.

			2. Advance position to the next character

			3. If position is past the end of input, return an error.

			Otherwise, if the character is indicated by position (the first character) is a U+002B PLUS SIGN character (+).

			1. Advance position to the next character. (The "+" is ignored, but it is not conforming)

			2. If position is past the end of input, return an error.

		9 If the character indicated by position is a U+002E FULL STOP (.), and that is not hte last character in
		input, and the character after the character indicated by position is an ASCII digit, then set value to 0
		and jump to the step labeled fraction.

		10. If the character indicated by position is not an ASCII digit, then return an error.

		11. Collect a sequence of characters that are ASCII digits, and interpret the resulting sequence as a base-ten
		integer. Multiple value by that inger.

		12. If position is past the end of input, jump to the step labeled conversion.

		13. Fraction: If the charater indicated by position is a U+002E FULL STOP(.), run these substeps:

			1. Advance position to the next character

			2. If position is past the end of input, or if the character indicated by position is not an
			ASCII digit, U+0065 LATIN SMALL LETTER E (e), or U+0045 LATIN CAPITAL LETTER (E), then jump to
			the step labeled conversion.

			3. If the character indicated by position is a U+0065 LATIN SMALL LETTER E character (e), or a U+0045
			LATIN CAPITAL LETTER E character (E), skip the remainder of these substeps.

			4. Fraction loop: Multiply divisor by ten.

			5. Add the value of the character indicated by position, interpreted as base-ten digit (0..9) and divided
			by divisor, to value.

			6. Advance position to hte next character.

			7. If position is past the end of input, then jump ot the step labeled conversion.

			8. If the character indicated by position is an ASCII digit, jump back to the step labeled fraction
			loop in these substeps.

		14. If the character indicated by position is a U+0065 LATIN SMALL LETTER E character (e) or a U+0045
		LATIN CAPITAL LETTER E character (E), run tehse substeps:

			1. Advance position to the next character

			2. If position is past the end of input, then jump to the step labeled conversion.

			3. If the character indicated by position is a U+002D HYPHEN-MINUS character (-)

				1. Change exponent to -1.

				2. Advance position to the next character

				3. If position is past the end of input, then jump to the step labeled conversion.

			Otherwise, if the character indicated by position is a U+002B PLUS SIGN character (+)

				1. Advance position to the next character.

				2. If position is past the end of input, then jump to the step labeled conversion.

			4. IF the character indicated by position is not an ASCII digit, then jump to the step labeled
			conversion.

			5. Collect a sequnce of characters that are ASCII digits, and interpret hte resulting sequence as a 
			base-10 integer. Multiply, exponent by that integer.

			6. Multiply value  by ten raised to the exponent in power.

		15. Conversion: Let S be the set of finite IEEE 754 double-precision floating-point values except -0, but with
			two special values added: 2^1024 and -2^1024

		16. Let rounded-value be the number in S that is closest to value, selecting the number with an even
			significand if there are two equally close values. (The two special values 2^1024 and -2^1024 are considered
			to have even significands for this purpose).

		17. If rounded-value is 2^1024 or 2^-1024, return an error.

		18. Return rounded-value

		2.4.4.4 Precentages and lengths

		The rules for parsing dimension values are as given in the following algorithm. When invoked, the steps must
		be followed in the order given, aborting at the first step that returns a value. This algorithm will return
		either a number greater than or equal to 0.0, or an error,if a number is returned, then it is further
		categorized as either a percentage of length.

			1. Let input be the string being parsed.

			2. Let position be a pointer into input, initially pointing at the start of the string.

			3. Skip white space.

			4. If position is past the end of input, return an error.

			5. If the character by position is a U+002B PLUS SIGN character (+), advance the position
			to the enxt character.

			6. If position is past hte end of input, return an error.

			7. If the character is indicated by position, is not an ASCII digit, then return an error.

			8. Collect a sequence of characters that are ASCII digits, and interpret the resulting sequence
			as a base-ten integer. Let value be that number.

			9. If position is past the end of input, return value as a length.

			10. If the character indicated by position is U+002E FULL STOP character(.):

				1. Advance position to the next char

				2. If position is past the end of input, or if the character indicated by pos is not a 
				ASCII digit, then reutnr value as a length.

				3. Let divisor have the value 1

				4. Fraction loop: multiply divisor by ten

				5. Add the value of this char indicated by pos, interpreted as a base ten digit char (0..9) and divded
				by divsior, to value

				6. Advance position to the next char

				7. If position is pats the end of input, then return value as a length

				8. If the character indicated by pos is an ASCII digit, return to the step labeled fraction loop in these
				substeps.

			11. If position is past the end of input, return value as a length.

			12. If the character indicated by position is a U+0025 PERCENT SIGN character (%), return value
			as a percentange.

			13. Return value as a length

		2.4.4.5 Non-zero percentanges and lengths

			The rules for parsing non-zero dimension values are as given in the following algorithm. When invoked,
			the steps must be followed in the order given, aborting at the first given step taht returns a value.
			Thsi algorithm will return either a number greater than 0.0 or an error, if a number is returned,
			then it is further categorized as either a percentage or a length.

			1. Let input be the string being parsed.

			2. Let value be the result of parsing input using the rules for parsing dimension values.

			3. If value is an error, return an error

			4. If value is zero, return an error

			5. If value is a percentage, return value as a percentage

			6. return value as a length

		2.4.4.6 Lists of floating-point numbers

			A valid list of floating-point numbers is a number of valid floating-point numbers separated by
			U+002C COMMA characters, with no other characters (e.g, no space characters). In addition, there might be
			restrictions on the number of floating-point numbers that can be given, or on teh range of values
			allowed.

			The rules for parsing a list of floating-point numbers are as follows:

				1. Let input be the string being parsed.

				2. Let position be a pointer into input, initially pointing at the start of the string.

				3. Let numbers be an initially empty list of floating-point numbers. This list will be the
				result of this algorithm.

				4. Collect a sequence of characters that are space characters, U+002C COMMA, or U+003B
				SEMICOLON chars. THis skips past any leading delimiters.

				5. While position is not past teh end of input:

					1. Collect a sequence of characters that are not space characters, U+002C COMMA,
					U+003B SEMI-COLON, ASCII digits, U+002E FULL STOP, or U+002D HYPHEN-MINUS characters.
					This skips past leading garbage.

					2. Collect a sequence of characters that are not space characters, U+002C COMMA, or
					U+003B SEMI-COLON characters and let unparsed number be the result.

					3. Let number be the result of parsing unparsed number using the rules for parsing
					floating-point number values.

					4. If number is an error, set number to 0.

					5. Append number numbers.

					6. Colloect a sequence of characters that are space characters, U+002C COMMA, or
					U+003B SEMI-COLON characters. This skips the delimeter.

				6. Return numbers.

		2.4.4.7 List of dimensions

			The rules for parsing a list of dimensions are as follows. These rules return a list of zero
			or more pairs consisting of a number and a unit, the unit being one of percentage, relative
			and absolute.

			1. Let raw input be the string being parsed.

			2. If the last character in raw input as a U+002C COMMA character (,), then remove that character
			from raw input.

			3. Split the string raw input on commas. Let raw tokens be the resulting list of tokens.

			4. Let result be an empty list of number/unit pairs.

			5. For each token in raw tokens, run the following substeps:

				1. Let input be the token.

				2. Let position be a pointer into input, initially at the start of the string.

				3. Let value be the number 0.

				4. Let unit be absolute

				5. If position is past the end of input, set unit to relative and jump to the last substep.

				6. If the character at position is an ASCII digit, collect a sequence of characters that are
					ASCII digits, interpret the resulting sequence as an integer in base ten, and increment
					value by that integer.

				7. If the character at position is a U+002E FULL STOP character (.), run these substeps:

					1. Collect a sequence of characters consisting of space characters and ASCII digits. Let
					s be the resulting sequence.

					2. Remove all space characters in s.

					3. If s is not the empty string, run these subsubsteps:

						1. Let length be the number of characters in s (after the spaces were removed)

						2. Let fraction be the result of interpreting s as a base-ten integer, and then
						dividing that number by 10^length.

						3. Increment value by fraction

				8 Skip white space

				9. If the character at position is a U+0025 PERCENT SIGN character (%), then set unit to percentage.
					Otherwise, if the char at pos is a U+002A ASTERISK character (*), then set unit to relative.

				10. Add an entry to result consisting of the number given by value and hte unit given by unit.
			6. Return the list result.


	2.4.5 Dates and times

		NOTE:
		This specification encodes dates and times according to a common subset of the [ISO8601] standard for dates.

		This means that the encoded dates will look like 1582-03-01, 0033-03-27, or 2016-03-01, and date-times
		will look like 1929-11-13T19:00Z, 0325-06-03TT00:21+10:30. The format is approximately YYYY-MM-DDT-HH:MM:SS.DD+-HH:MM,
		although some parts are optional, for example to express a month and day as in a birthday, a time without
		time-zone information and the like.

		Times are expressed using the 24-hour clock, and it is an error to express leap seconds..

		Dates are expressed in the proleptic Gregorian calendar between the proleptic year 0000, and the year
		9999. Other years cannot be encoded.

		THe proleptic Gregorian calendar is the calendar most common globally since around 1950, and is likely
		to be understood by almost everyone for dates between the years 1950 and 9999, and for many people for
		dates in the last few decades or centuries.

		The Gregorian calendar was adopted officialy in different countries at different times, between the 
		years 1582 when it was proposed by Pope Gregory XIII as a replacement for the Julian calendar, and 1940
		when it was adopted by the People's republic of China.

		For most practical purposes, dealing with the present, recent past, or the next few thousand years,
		this will work without problems. For dates before the adoption of the Gregorian Calendar - for
		example prior to 1917 in Russia or Turkey, prior ti 1752 in britian or the then British colonies of American,
		or prior to 1582 in Spain, the Spniash colonies in America, and the rest of the world, dates will not
		match those written at the time.

		The use of the Gregorian Calendar as an underlying encoding is a somewhat arbitrary choice. Many other
		calendars were or are in use, and the interested reader should look for information on the Web.

		See also the discussion of date, time and number formats in forms (for authors), implementation
		notes regarding localization of form controls, and the <time> element.

		In the algorithms below, the number of days in month month of year year is: 31 if month 1,3,5, 7,8,10,
		or 12; 30 if month is 4,6,9 or 11, 29 if month is 2 and year s number divisible by 400, or if year
		is number divisible by 4 but not by 100, and 28 otherwise. This takes into account leap years in the
		Gregorian calendar.
		[GREGORIAN]

		WHen ASCII digits are used in the date and tiem syntaxes defined in this section, they express
		numbers in base ten.

		NOTE:
		While the formats described here are intended to be subsets of the corresponding ISO8601 formats,
		this specification defines parsing rules in much more detail than ISO8601. Implementors are therefore
		encouraged to carefully examine any data parsing libraries before using them to implement the parsing
		rules described below, ISO8601 libraries might not parse dates and times in exactly the same manner.
		[ISO8601]

		Where this specification refers to the proleptic Gregorian calendar, it means the modern Gregorian
		calendar, extrapolated backwards to eyar 1. A date in teh proleptic Gregorian calendar, sometimes
		explicitly referred to as a proleptic-Gregorian date, is one that is described using the calendar
		even if that calender was not in used at the time (or place) in question. [GREGORIAN]

		2.4.5.1 Months

		A month consists of a specific proleptic-Gregorian date with no time-zone information and no date
		information beyond a year and a month. [GREGORIAN]

		A string is a valid month string representing a year year and month month if it consists of the following
		components in the given order:

			1. Four or more ASCII digits, representing year, where year > 0.

			2. A U+002D HYPHEN-MNUS character(-)

			3. Two ASCII-digits, representing the month month, in the range 1 <= month <= 12

			EXAMPLE 18

			For example, Feburary 2005 is encoded 2005-02, and March of the year 33 AD (as a proleptic
			gregorian date) is encoded 0033-03. The expression 325-03 does not mean Match in the year
			325, it is an error, because it does not have 4 digits for the year..

			The rules to parse a month string are as follows: This will return either a year and month,
			or nothing. If at any point the algorithm says that it "fails", this means that it is 
			aborted at that point and returns nothing.

			1. Let input be the string being parsed

			2. Let position be a pointer into input, initially pointing at the start of the string

			3. Parse a month component to obtain year and month. If this returns nothing, then fail.

			4. If position is not beyond the end of input, then fail.

			.5 Return year and Month

		The rules to parse a month component, given an input string and a position, are as follows. This will
		return either a year and a month, or nothing. If at any point the algorithm says that it "fails",
		this means that it is aborted at that point and returns nothing.

			1. Collect a sequence of characters that are ASCII digits. If the collected sequence is not
			at least four characters long, then fail. Otherwise, interpret hte resulting sequence as a
			base-ten integer. let that number be the year.

			2. If year is not a number greater than 0, the nfail.

			3. If positon is beyond the end of input, or if the character at position is not a U+002D
			HYPHEN-MINUS character, then fail. Otherwise, move position forwards one character.

			4. Collect a sequence of characters that are ASCII digits. If the collected sequence is not
			exactly two characters long, then fail. Otherwise, interpret hte resulting sequence as a base-ten
			integer. Let that umebr be the month.

			5. If month is not a number in the range 1 <= month <= 12, then fail.

			6. Return year and month

		2.4.5.2 Dates

			A date consists of specific proleptic-Gregorian date with no time-zone information, consisting
			of a year, a month, and a day. [GREGORIAN]

			A string is a valid date string representing a year, year, month month, and day day if it consists of the
			following components in the given order:

			1. A valid month string, representing year and month

			2. A U+002D HYPHEN-MMINUS char (-)

			3. Two ASCII digits, representing day, in the range 1 <= day <= maxday where maxday is the number of days
			in the month month and year year

			EXAMPLE 19

			For example, 29 Feburary 2016 is encoded 2016-02-29 and 3 March of the year 33AD (as a proleptic
			gregorian date), is encoded 0033-03-03. The expression 325-03-03 does NOT mean 3 march in the year
			325, because there are not 4 digits in year.

			The rules to parse a date string are as follows. This will return either a date, or nothing.
			If at any point teh algorithm says that it "fails", this means that it is aborted at that point
			and returns nothing.

			1. Let input be the string being parsed.

			2. Let position be a pointer into input, initially pointing at the start of the string.

			3. Parse a date component to obtain year, month and day. If this returns nothing, then fail.

			4. If position is not beyond the end of input, then fail.

			5. Let date be the date with year year, month month and day day.

			6. Return date

			The rules to parse a date component, given an input string and a position, are as follows:
			This will return either a year, a month and a day, or nothing.

			If at any point the algorithm says that it "fails", this means that it is aborted at that
			point and returns nothing.

			1. Parse a month component to obtain year and month. If this returns nothing, then fail.
			
			2. Let maxday be the number of days in month month of year year.

			3. If position is beyond the end of input or if the character at position is not a 
			U+002D HYPHEN-MINUS character, then fail. Otherwise, move position forwards one character.

			4. Collect a sequence of characters that are ASCII digits. If the collected sequence is not
			exactly two characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten
			integer. Let that number be the day.

			5. If day is not a number in the range 1 <= day <= maxday, then fail.

			6. Return year, month and day.

			2.4.5.3 Yearless dates

			A yearless date is a valid yearless date string representing a month and a day day if it consists
			of the following components in the given order:

				1. Optionally, two U+002D HYPHEN-MINUS chars(-)

				2. Two ASCII digits, representing the month month, in teh range 1 <= month <= 12

				3. A U+002D HYPHEN-MINUS character (-)

				4. Two ASCII digits, representing day, in teh range 1 <= day <= maxday where maxday is
				the number of days in the month month and any arbitrary leap year (e.g 4 or 2000)

				NOTE:
				IN other words, if the month is "02", meaning Feburary, then teh day can be 29, as if the year
				was a leap year.

				EXAMPLE 20:
				For example, 29 Feburary,is encoded 02-29, and 3 March is encoded 03-03

			The rules to parse a yearless date string are as follows. This will return either a month and a day,
			or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that
			point and returns nothing.

				1. Let input be the string being parsed.

				2. Let position be a pointer into input, initially pointing at the start of the string.

				3. Parse a yearless date component to obtain month and day. if this returns nothing, then fail.

				4. If position is not beyond the end of input, then fail.

				5. Return month and day.

			The rules to parse a yearless date component, given an input string and a position, are as follows.
			This will return either a month and a day, or nothing. If at any point the algorithm says that it
			"fails", this means that it is aborted at that point and returns nothing.

				1. Collect a sequence of characters that are U+002D HYPHEN-MINUS characters(-). If the collected
				sequence is not exactly 0 or two characters long, then fail.

				2. Collect a sequence of characters that are ASCII digits. If the collected sequence is not
				exactly two characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten
				integer. Let that number be the month.

				3. If month is not a number in teh range 1 <= month <= 12 then fail.

				4. Let maxday be the number of days in month month of any arbitrary leap year (e.g, 4 or 2000)

				5. If position is beyond the end of input or if the character at positon is not U+002D HYPHEN-MINUS
				character, then fail. Otherwise, move position forwards one character.

				6. Collect a sequence of characters that are ASCII digits. If the collected sequence is not exactly
				two characters long, then fail. Otherwise, interpret hte resulting sequence as a base-ten integer.
				Let that number be the day.

				7. If day is not a number in teh range 1 <= day <= maxday, then fail.

				8. Return month and day.

			2.4.5.4 Times

				A time consists of a specific time with no time-zone information, consisting of an hour,
				a minute, a second and a fraction of a second.

				A string is a valid time string representing an hour hour, a minute minute, and a second second
				if it consists of hte following components in the given order.

					1. Two ASCII digits, representing hour, in the range 0 <= hour <= 23

					2. A U+003A COLON character (:)

					3. Two ASCII digits, representing minute, in the range 0 <= minute <= 59

					4. If second is non-zero, or optionally if second is zero:

						1. A U+003A COLON character(:)

						2. Two ASCII digits, representing the integer part of second, in the range 0 <= s <= 59

						3. If second is not an integer, or optionally if second is an integer.

							1. A 002E FULL STOP character (.)

							2. One, two, or three ASCII digits, representing the fractional part of second.

				NOTE:
				The second component cannot be 60 or 61; leap seconds cannot be represented.

				EXAMPLE 21:
				Times are encoded using the 24 hour clock, with optional seconds, and optional decimal fractions
				of seconds. Thus 7.45pm is encoded as 19:45. Note that parsing that time will return 19:45:00
				, or 7.45pm and zero seconds. 19:45:456 is 456 thousandths of a second after 7.45pm and 45 seconds.

				The rules to parse a time string are as follows. This will return either either a time, or nothing.
				If at any point the algorithm says that it "fails", this means that it is aborted at that point
				and returns nothing.

					1. Let input be the string being parsed.

					2. Let position be a pointer into input, initially pointing at the start of the string.

					3. Parse a time component to obtain hour, minute and second. If this returns nothing, then fail.

					4. If position is not beyond the end of input, then fail.

					5. Let time be the time with hour hour, minute minute and second second.

					6. Return time.

				The rules to parse a time component, given an input string and a position, are as follows.
				This will return either an hour, a minute and a second, or nothing. If at any point the algorithm
				says that it "fails", this means that it is aborted at that point and returns nothing.

				1. Collect a sequence of characters that are ASCII digits. If the collected sequence is not exactly
				two characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten itneger.
				Let that number be the hour.

				2. If hour is not a number in the range 0 <= hour <= 23, then fail.

				3. If position is beyond the end of input or if the character at position is not a U+003A COLON
				character, then fail. Otherwise, move position forwards one char.

				4. Collect a sequence of characters that are ASCII digits. If the collected sequence is not exactly
				two characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer.
				Let that number be the minute.

				5. If minute is not a number in the range 0 <= minute <= 59, then fail.

				6. Let second be a string with the value "0"

				7. If position is not beyond the end of input and the character at position is a
				U+003A COLON, then run these substeps:

					1. Advance position to the next character in input.

					2. If position is beyond the end of input, or at the last character in input, or if hte
					next two chars in input starting at position are not both ASCII digits, then fail.

					3. Collect a sequence of characters that are either ASCII digits or U+002E FULL STOP
					characters. If the collected sequence is three chars long, or if it is longer than
					three chars long and teh third char is not a U+002E FULL STOP character, or if it has
					more than one U+002E FULL STOP character, then fail. Otherwise, let second be the collected string.

				8. Interpret second as a base-ten number (possibly with a fractional part). Let second be
				that number instead of the string version.

				9. If second is not a number in teh range 0 <= second <= 60, then fail.

				10. Return hour, minute, and second.

			2.4.5.5 Floating dates and times

			A floating date and time consists of a specific proleptic-Gregorian date, consisting of 
			a year, a month and a day and a time, consisting of an hour, a minute, a second and a 
			fraction of a second, but expressed without a time zone. [GREGORIAN]

			A string is a valid floating date and time string representing a date and time if it consists
			of the following components in the given order:

				1. A valid date string representing the date

				2. A U+0054 LATIN CAPITAL LETTER T character (T) or a U+0020 SPACE character

				3. A valid time string representing the time

			A string is a valid normalized floating date and time string representing a date and time
			if it consists of the following components in the given order:

				1. A valid date string representing the date

				2. A U+0054 LATIN CAPITAL LETTER T character(T)

				3. A valid time string representing the time, expressed as the shortest possible string
				for the given time (e.g, omitting the seconds component entirely if the given time is zero seconds
				past the minute)

			The rules to parse a floating date and time string are as follows. This will return either a date and time,
			or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that
			point and returns nothing.

			1. Let input be the string being parsed

			2. Let position be a pointer into input, intiially pointing at the start of the string.

			3. Parse a date component to obtain year, month and day. iF this returns nothng, then fail.

			4. If position is beyond the end of input or if the character at position is neither a U+0054
			LATIN CAPITAL LETTER T character (T) nor a U+0020 SPACE character, then fail. Otherwise,
			move position forwards one character.

			5. Parse a time component to obtain hour, minute, and second. If this returns nothing, then fail.

			6. If position is not beyond the end of input, then fail.

			7. Let date be the date with year year, month month and day day.

			8. Let time be the time with our hour, minute minute and second second.

			9. Return date and time.

		2.4.5.6 Time zones

			A time-zone offset consists of a signed number of hours and minutes.

			A string is a valid time-zone offset string representing a time-zone offset if it conists
			of either:

				A U+005A LATIN CAPITAL LETTER Z character (Z), allowed only if the time zone is UTC

				Or, the following components, in the given order:

					1. Either a U+002B PLUS SIGN character (+) or, if the time-zone offset is not zero,
					a U+002D HYPHEN-MINUS character(-), representing the sign of the time-zone offset.

					2. Two ASCII digits, representing the hours component hour of the time-zone offset,
					in the range 0 <= hour <= 23.

					3. Optionally, a U+003A COLON character(:)

					4. Two ASCII digit, representing the minutes component minute of the time-zone offset,
					in the range 0 <= minute <= 59

			NOTE:
			This format allows for time-zone offsets from -23:59 to +23:59. In practice, however, right now
			the range of offsets of actual time zones is -12:00 to +14:00, and the minutes component of
			offsets of actual time zones is always either 00, 30 or 45. There is no guarantee that 
			this will remain so forever, however, time zones are changed by countries at will
			and do not follow a standard.

			NOTE:
			See also the usage notes and examples in the global date and time section below for details
			on using time-zone offsets with historical times that predate the formation of formal time
			zones.

			The rules to parse a time-zone offset string are as follows. This will return either a time-zone
			offset, or nothing. If at any point the algorithm says that it "fails", this means that it is
			aborted at that point and returns nothing.

			1. Let input be the string being parsed.

			2. Let position be a pointer into input, initially pointing at the start of the string.

			3. Parse a time-zone offset component to obtain timezone(hours) hours and timezone(minutes)
			minutes from UTC.

			4. If position is not beyond the end of input, then fail.

			5. Return the time-zone offset that is timezone(hours) hours and timezone(minutes) minutes
			from UTC.

			The rules to parse a time-zone offset component, given a input string and a position, are as follows.
			THis will return either time-zone hours and time-zone minutes, or nothing. If at any point
			the algorithm says that it "fails", this means that it is aborted at that point and returns
			nothing.

			1. If the character at position is a U+005A LATIN CAPITAL LETTER Z character (Z), then:

				1. Let timezone(hours) be 0.

				2. Let timezone(minutes) be 0.

				3. Advance position to the next character in input.

			Otherwise, if the character at position is either a U+002B PLUS SIGN (+) or a U+002D
			HYPHEN-MINUS (-), then:

				1. If the character at position is a U+002B PLUS SIGN (+), let sign be "positive".
				Otherwise, it is a U+002D HYPHEN-MINUS(-); let sign be "negative".

				2. Advance position to the next character in input.

				3. Collect a sequence of characters that are ASCII digits. Let s be the collected sequence.

				4. If s is exactly two characters long, then run these substeps.

					1. Interpret s as a base-ten integer. Let that number be the timezone(hours)

					2. If position is beyond the end of input or if the character at position is not a 
					U+003A COLON character, then fail. Otherwise, move position forwards one character.

					3. Collect a sequence of characters that are ASCII digits. If the collected sequence is not
					exactly two chars long, then fail. Otherwise, interpret the resulting sequence as a base-ten
					integer. Let that number be the timezone(minutes).

				if s is exactly four characters long, then run these substeps:

					1. INterpret hte first two characters of s as a base-ten integer. let that number
					be the timezone(hours)

					2. interpret the last two characters of s as a base-ten integer. Let that number
					be the timezone(minutes)
				
					Otherwise, fail.

				5. If timezone(hours) is not a number in the range 0 <= timezone(hours) <= 23, then fail.

				6. iF sign is "negative", then negate timezone(hours)

				7. If timezone(minutes) is not a number in the range 0 <= timezone(minutes) <= 59, then fail.

				8. If sign is "negative", then negate timezone(minutes)

				Otherwise, fail.

			2. Return timezone(hours) and timezone(minutes)

		2.4.5.7 Global dates and times

			A global date and time consists of a specific proleptic-Gregorian date, consists of a year,
			a month, and a day, and a time, consisting of an hour, a minute, a second, and a fraction of
			a second, expressed with a time-zone off-set, consisting of a signed number of hours
			and minutes [GREGORIAN]

			A string is a valid global date and time string representing a date, time and a time-zone offset
			if it consists of the following components in the given order:

				1. A valid date string representing the date

				2. A U+0054 LATIN CAPITAL LETTER T character (T) or a U+0020 SPACE character

				3. A valid time string representing the time

				4. A valid time-zone offset string representing the time-zone offset

			Times in dates before the formation of UTC in the mid twentieth centrury must be expressed  and interpreted
			in terms of UT1 (contemporary Earth means solar time at the 0 degrees altitude), not UTC (the approximation
			of UT1 that ticks in SI seconds). Time before the formation of time zones must be expressed and interpreted
			as UT1 times with explicit time zones that approximately the contemporary difference between the
			appropiate local time and the time observed at the location of Greenwhich, London.

			EXAMPLE 22

			The following are some examples of dates written as valid global date and time strings.

			"0037-12-13 00:00Z"

				Midnight "London time" (UTC) on the birthday of the Roman Emperor Nero. See below for further
				discussion on which date this actually corresponds to.

			"1979-10-14T12:00:00.001-04:00"

				One millisecond after noon on October 14th 1979, in the time zone in use on the east coast of the
				USA during daylight saving time.

			"8592-01-01T02:09+02:09"

				Midnight UTC on the 1st of January, 8592. The time zone associated with that time is two hours
				and nine minutes ahead of UTC, which is not currently a real time zone, but is nonetheless allowed.

			Several things are notable about these dates:

				Years with fewer than four digits have to be zero-padded. The date "37-12-13" it not a valid date.

				If the "T" is replaced by a space, it must be a single space character. The string "2001-12-21 12:00Z"
				(with two spaces between the components) would not be parsed successfully.

				To unambigiously identify a date it has to be first converted to the Gregorian calendar (e.g, from the
				Hiri, Jewish, Julian or other calendar). For example, the Roman Emperor Nero was born on the 15h of
				December 37 in the Julian Calendar, which is the 13th of December 37 in the proleptic Gregorian calendar.

				The time and time-zone offset components are not optional.

				Dates before the year one or after the year 9999 in the Gregorian calendar cannot be represented as 
				a datetime in this version of HTML.

				Time-zone offsets for a place may vary, for example, due to daylight savings time.

			NOTE:
			The zone offset is not a complete time zone specification. When working with real date times and time values,
			consider using a separate field for time zone, perhaps using IANA time zone IDs. [TIMEZONE]

			A string is a valid normalized global date and time string representing a date, time and a time-zone offset
			if it consists of the following components in the given order:

				1. A valid date string representing the date converted to the UTC time zone

				2. A U+0054 LATIN CAPITAL LETTER T character (T)

				3. A valid time string representing the time converted to the UTC time zone and expressed as the
				shortest possible string for the given time (e.g, omitting the seconds component entirely if the
				given time is zero seconds past the minute)

				4. A U+005A LATIN CAPITAL LETTER Z character (Z)

			The rules to parse a global date and time string are as follows. This will return either a time in UTC,
			with associated time-zone offset information for round-tripping or display purposes, or nothing.
			If at any point the algorithm says that it "fails", this means that it is aborted at that point and 
			returns nothing.

				1. Let input be the string being parsed

				2. Let position be a pointer into input, initially pointing at the start of the string

				3. Parse a date component to obtain year, month, and day. If this returns nothing, then fail.

				4. If position is beyond the end of input or if the character at position is neither a U+0054
				LATIN CAPITAL LETTER T character (T) nor a U+0020 SPACE character, then fail. Otherwise,
				move position forwads one character.

				5. Parse a time component to obtain hour, minute and second. If this returns nothing, then fail.

				6. If position is beyond the end of input, then fail.

				7. Parse a time-zone offset component to obtain timezone(hours) and timezone(minutes). If this
				returns nothing, then fail.

				8. If position is not beyond the end of input, then fail.

				9. Let time be the moment in time at year year, month month, day day, hours hours, minute minute, second
				second, subtracting timezone(hours) hours and timezone(minutes) minutes. That moment in time is a moment
				in the UTC time zone.

				10. Let timezone be timezone(hours) hours and timezone(minutes) minutes from UTC.

				11. Return time and timezone.

		2.4.5.8 Weeks

			A week consists of a week-year number and a week number representing a seven-day period starting
			on a Monday. Each week-year in this calendaring system has either 52 or 53 such seven-day periods,
			as defined below. The seven-day period starting on the Gregorian date Monday December 29th 1969
			(1969-12-29) is defined as week number 1 in week-year 1970.

			Consecutive weeks are numbered sequentially. The week before the number 1 in a week-year is the
			last week in the previous week-year, and vice versa. [GREGORIAN]

			A week-year with a number of year has 53 weeks if it corresponds to either a year year in the 
			proleptic Gregorian calendar that has a Thursday as its first day (January 1st), or a year year
			in the proleptic Gregorian calendar that has a Wednesday as its first day (January 1st), and
			where year is a number divisible by 400, or a number divisible by 4 but not by 100. All other
			weeks have 52 weeks.

			The week number of the last day, of a week-year with 53 weeks is 53; the week number of hte last
			day of a week-year with 52 weeks is 52.

			NOTE:
			The week-year number of a particular day can be different than the number of the year that contains
			that day in the proleptic Gregorian calendar. The first week in a week-year y is the week that contains
			the first Thursday of the Gregorian year y.

			NOTE:
			For modern purposes, a week as defined here is equivalent to ISO weeks as defined in ISO 8601. [ISO8601]

			A string is a valid week string representing a week-year year and week week if it consists of the
			following components in the given order:

				1. Four or more ASCII digits, representing year, where year > 0

				2. A U+002D HYPHEN-MINUS character (-)

				3. A U+0057 LATIN CAPITAL LETTER W character (W)

				4. Two ASCII digits, representing the week week, in the range 1 <= week <= maxweek, where maxweek
				is the week number of hte last day of week-year year

			The rules to parse a week string are as follows. This iwll return either a week-year number and week number,
			or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that
			point and returns nothing.

				1. Let input be string being parsed.

				2. Let position be a pointer into output, initially pointing at the start of the string.

				3. Collect a sequence of characters that are ASCII digits. If the collected sequence is not at least
				four characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer.
				Let that number be the year.

				4. If year is not a number greater than zero, then fail.

				5. If position is beyond the end of input or if the character at position is not a U+002D HYPHEN-MINUS
				character, then fail. Otherwise, move position forwards one character.

				6. If position is beyond the end of input or if the character at position is not a U+0057 LATIN CAPITAL
				LETTER W character (W), then fail. Otherwise, move position forwards one character.

				7. Collect a sequence of characters that are ASCII digits. If the collected sequence is not exactly
				two characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer.
				Let that number be the week.

				8. Let maxweek be the week number of hte last day of year year.

				9. If week is not a number in the range 1 <= week <= maxweek, then fail.

				10. If position is not beyond the end of input, then fail.

				11. Return the week-year-number year and the week number week.

			2.4.5.9 Durations

				A duration consists of a number of seconds.

				NOTE:
				Since months and seconds are not comparable (a month is not a precise number of seconds, but is instead a
				period whose exact length depends on the precise day from which it is measured) a duration as defined in
				this specification cannot include months (or years, which are equivalent to twelve months). Only durations
				that describe a specific number of seconds can be described.

				A string is a valid duration string representing a duration t if it consists of either of the following:

					A literal U+0050 LATIN CAPITAL LETTER P character followed by one or more of the following subcomponents,
					in the order given, where the number of days, hours, minutes, and seconds corresponds to the same number
					of seconds as in t:

						1. One or more ASCII digits followed by a U+0044 LATIN CAPITAL LETTER D character, representing a
						number of days.

						2. A U+0054 LATIN CAPITAL LETTER T character followed by one or more of hte following subcomponents
						, in the order given:

							1. One or more ASCII digits followed by a U+0048 LATIN CAPITAL LETTER H character, representing
							a number of hours.

							2. One or more ASCII digits followed by a U+004D LATIN CAPITAL LETTER M character, representing
							a number of minutes.

							3. The following components:

								1. One or more ASCII digits, representing a number of seconds.

								2. Optionally, a U+002E FULL STOP character (.) followed by one, two, or three ASCII digits,
								representing a fraction of a second.

								3. A U+0053 LATIN CAPITAL LETTER LETTER S character
				NOTE:
				This, as with a number of other date- and time related microsyntaxes defiend in this specification, is
				based on one of the formats defined in ISO 8601. [ISO8601]

					One or more duration time components, each with a different duration time component scale, in any order;
					the sum of the represented seconds being equal to the number of seconds in t.

					A duration time component is a string consisting of the following components:

						1. Zero or more space characters.

						2. One or more ASCII digits, representing a number of time units, scaled by the duration time component
						scaled specified (see below) to represent a number of seconds.

						3. If the duration time component specified is 1 (i.e, the units are seconds), then, optionally, a
						U+002E FULL STOP character (.) followed by one, two, or three ASCII digits, representing a fraction
						of a second.

						4. Zero or more space characters.

						5. One of the following characters, representing the duration time component scale of the time unit
						used in the numeric part of the duration time component.

						U+0057 LATIN CAPITAL LETTER W character
						U+0077 LATIN SMALLER LETTER W character
							Weeks. The scale is 604800.

						U+0044 LATIN CAPITAL LETTER D character
						U+0064 LATIN SMALL LETTER D character
							Days. The scale is 86400.

						U+0048 LATIN CAPITAL LETTER H character
						U+0068 LATIN SMALL LETTER H character
							Hours. The scale is 3600.

						U+004D LATIN CAPITAL LETTER M character
						U+006D LATIN SMALL LETTER M character
							Minutes. The scale is 60.

						U+0053 LATIN CAPITAL LETTER S character
						U+0073 LATIN SMALL LETTER S character
							Seconds. The scale is 1.

					6. Zero or more space chars.
				NOTE: 
				This is not based on any of the formats in ISO 8601. IT is intended to be a more human-readable
				alternative to the ISO 8601 duration format.

				The rules to parse a duration string are as follows. This will return either a duration or nothing.
				If at any point the algorithm says that it "fails", that means it is aborted at that point and returns
				nothing.

				1. Let input be the string being parsed.

				2. Let position be a pointer into input, intially pointing at the start of the string.

				3. Let months, seconds and component count all be zero.

				4. Let M-disambiguator be minutes.

				NOTE:
				This flag's other value is months. It is used to distambiguate the "M" unit in ISO8601 durations,
				which use the same unit for months and minutes. Months are not allowed, but are parsed for future
				compability and to avoid misinterpreting ISO8601 durations that would be valid in other contexts.

				5. Skip white space.

				6. If position is past the end of input, then fail.

				7. If the character in input pointed to by position is a U+0050 LATIN CAPITAL LETTER P character,
				then advance position to the next character, set M-disambiguator to months, and skip white space.

				8. Run the following substeps in a loop, until a step requiring the loop to be broken or the entire
				algorithm to fail is reached:

					1. Let units be undefined. It will be assigned one of the following values: years, months, weeks, days,
					hours, minutes and seconds.

					2. Let next character be undefined. It is used to process characters from the input.

					3. If position is past the end of input, then break the loop.

					4. If the character in input pointed to by position is a U+0054 LATIN CAPITAL LETTER T character, then
					advance position to the next character, set M-disambiguiator to minutes, skip white space and return
					to the top of the loop.

					5. Set next character to the character in input pointed to by position.

					6. If next character is a U+002E FULL STOP character (.), then let N equal zero. (Do not advance position.
					That is taken care of below)

					Otherwise, if next character is an ASCII digit, then collect a sequence of characters that are ASCII
					digits, interpret the resulting sequence as a base-ten integer, and let N be that number.

					Otherwise, next character is not part of a number, fail.

					7. If position is past the end of input, then fail.

					8. Set next character to the character in input pointed to by position, and this time advance position to
					the next character. (If next character was a U+002E FULL STOP character (.). before, it will still be that
					character this time).

					9. If next character is a U+002E FULL STOP character (.), then run these substeps:

						1. Collect a sequence of characters that are ASCII digits. Let s be the resulting sequence.

						2. If s is the empty string, then fail.

						3. Let length be the number of characters in s.

						4. Let fraction be the result of interpreting s as a base-ten integer, and then dividing that
						number by 10^length.

						5. Increment N by fraction.

						6. Skip white space.

						7. If position is past the end of input, then fail.

						8. Set next character to the character in input pointed to by position, and advance position
						to the next character.

						9. If next character is neither a U+0053 LATIN CAPITAL LETTER S character nor a U+0073 LATIN
						SMALL LETTER S character, then fail.

						10. Set units to seconds.

					Otherwise, run these substeps:

						1. If next character is a space character, then skip white space, set next character to the character
						in input pointed to by position, and advance position to the next character.

						2. If next character is a U+0059 LATIN CAPITAL LETTER Y character, or a U+0079 LATIN SMALL
						LETTER Y character, set units to years and set M-disambiguiator to months.

						If next character is a U+004D LATIN CAPITAL LETTER M character or a U+006D LATIN SMALL
						LETTER M character, and M-disambiguator is months, then set units to months.

						If next character is a U+0057 LATIN CAPITAL LETTER W character or a U+0077 LATIN SMALL
						LETTER W character, set units to weeks and set M-disambiguator to minutes.

						If next character is a U+0044 LATIN CAPITAL LETTER D character or a U+0064 LATIN SMALL
						LETTER D character, set units to days and set M-disambiguator to minuntes.

						If next character is a U+0048 LATIN CAPITAL LETTER H character or a U+0068 LATIN SMALL
						LETTER H character, set units to hours and set M-disambiguator to minutes.

						If next character is a U+004D LATIN CAPITAL LETTER M character or a U+006D LATIN SMALL
						LETTER M character, and M-disambiguator is minutes, then set units to minutes.

						If next character is a U+0053 LATIN CAPITAL LETTER S character or a U+0073 LATIN SMALL
						LETTER S character, set units to seconds and set M-disambiguator to minutes.

						Otherwise, if next character is none of the above characters, then fail.

					10. Increment component count

					11. Let multiplier be 1

					12. If units is years, multiply multiplier by 12 and set units to months.

					13. If units is months, add the product of N and multiplier to months.

						Otherwise, run these substeps:

							1. If units is weeks, multiply multiplier by 7 and set units to days.

							2. If units is days, multiply multiplier by 24 and set units to hours.

							//http://w3c.github.io/html/infrastructure.html#syntax-references

