Magento is a Stack of Opensource integrations of technology, as follows:

PHP //Programming Language for Server Side

Coding standards //PSR-o (Autoloading standard), PSR-1 (basic coding standard), PSR-2(Coding style guide), PSR-3 and PSR-4

Composer //A dependancy manager package for PhP to pull in Vendor lib requirements

HTML5 //lol

CSS3 //uses LESS CSS preprocessor

jQuery //crossplatform JS lib to simplify DOM Manipulation

RequireJS //JS file and module loader

Third party libs //Zend Framework and Symfony, used Internally in Magento

Apache or Nginx //HTTP servers, Magento uses Apache 2.2/2.4 and Nginx 1.7

MySQL

MTF //Magento Testing Framework, a fully integrated testing suite, covers performance, function, and unit testing.

Magento can be broken down into 4 layers - presentation, service, domain and presistence.

The presentation layer, is the one that supports presentation and contains a bit of interaction with controllers. It uses jQuery, CSS, RequireJS and LESS.

Generally, three types of users interact with this layer: web users, System admins, and thoose making Web API calls. Web API calls can be used with HTTP calls akin
to how a user uses the browser.

This also means that the Web Admin can interact with the CMS (Content Manager System) to handle pages, blocks and products.

When the components of the Presentation layer is interacted with, it makes calls to the Service layer.

The Service layer, is a bridge between the presentation and domain layer. It contains service contracts, which define the implementation behavior.

A service contract, is basically a PHP interface. In this layer, we can find the REST/SOAP APIs. Most user interaction on the store front is routed
through the service layer.

Similarly, external Apps that make the REST/SOAP API calls also interact with this layer.

When components of the service layer is interacted with, they make calls to the underlying Domain layer.

The Domain layer, is where we have business Logic. It is here, that we have references to a resource model that is used to retrieve and persist data to a MySQL DB.

A domain layer code from one module can interact with a domain module code from another module via the use of event observers, plugins and the di.xml defs.

The interaction of the di.xml and plugins, should occur through service contracts.

When components of the Domain layer are interacted with, they usually interact with the underlying persistence layer.

The persistence layer, is what the name implies - The layer to handle persistence of data, meaning it handles all the CRUD management (Create, Read, Update, Delete)

Magento uses a active record pattern stratergy for the persistence layer.

The Model object contains a resource model that can map to one or several DB rows.

There are two different types of models, in this field:

simple resource model

and

EAV resource models //Entity-Attribute-Value resource models

A simple resource model goes to one table, a EAV goes to several.

For example, Customer and Catalog, uses EAV resource models, whilst Subscriber resource model uses a simple resource model.

The root dir structure of Magento, looks something akin to the following:

.htaccess

.htaccess.sample

.php_cs

.travis.yml

CHANGELOG.md

CONTRIBUTING.md

CONTRIBUTOR_LICENSE_AGREEMENT.html

COPYING.txt

Gruntfile.js

LICENSE.txt

LICENSE_AFL.txt

app

bin

composer.json

composer.lock

dev

index.php

lib

nginx.conf.sample

package.json

php.ini.sample

phpserver

pub

setup

update

var

vendor

The app/etc/di.xml is one of the most important files during Development, given that it contains various class mappings or preferences for individual interfaces.

The var/magento/language-* dirs is where the registered languages reside. Though each module can declare it's own translations under app/code/{VendorName}/{ModuleName}/i18n/,
Magento will fall back to it's own i18n in case translations are not found in the custom module or within the theme dir

The bin dir, is where we can find the Magento file. The magento file, is a script taht is intended to be run from a console. Once triggered through the 
php bin/magento command on cmd line, it will run the Magento\Framework\Console\Cli app, presenting us with a number of Console options. We can use the magento script
to enable/disable cache, enable/disable modules, run an indexer and many other things.

In the dev dir, is where we will find the Magento test scripts. The Lib dir, consists of two major underdirs, one for Server-side PHP lib code and fonts under lib/internal
and the client-side JS libs found in lib/web

The pub dir, is where the public exposed files are located. This is the dir that we should set as root when setting up Apache or Nginx. The pub/index.php file is what gets triggered
when the storefront is opened in a browser.

The var dir, is where dynamically generated group type of files such as cache, log and a few others are created in. We should be able to delete it at any time, to have
magento recreate it.

inside of the vendor dir, is where we will find most of our code. Here, we can find third-party vendor codes, Magento modules, themes and language packs. Inside of vendor dir, the following structure follows:

.htaccess

autoload.php

bin

braintree

composer

doctrine

fabpot

justinrainbow

league

lusitanian

magento

monolog

oyejorge

pdepend

pelago

phpmd

phpseclib

phpunit

psr

sebastian

seld

sjparkinson

squizlabs

symfony

tedivm

tubalmartin

zendframework

Within the vendor, we find various vendors, such as phpunit, phpseclib, monolog, symfony etc.

Magento, itself, can be found there, and contains these amongst others:

composer

framework

language-en_us

magento-composer-installer

magento2-base

module-authorization

module-backend

module-catalog

module-customer

module-theme

module-translation

module-ui

module-url-rewrite

module-user

module-version

module-webapi

module-widget

theme-adminhtml-backend

theme-frontend-blank

theme-frontend-luma

Logically, each dir has a structure to their name, such akin to that module dirs contains modules, language dirs contains languages and theme contains themes.

The general structure of Magento, is that it is highly modular. Meaning, it has specific dir for modules. What follows, is an example of a structure of a module, 
the vendor/magento/module-contact to be specific:

Block

composer.json

Controller

etc
	acl.xml

	adminhtml

		system.xml

	config.xml

	email_templates.xml

	frontend

		di.xml

		page_types.xml

		routes.xml

	module.xml

Helper

i18n

LICENSE_AFL.txt

LICENSE.txt

Model

README.md

registration.php

Test
	
	Unit

		Block

		Controller

		Helper

		Model
view
	
	adminhtml

	frontend

		layout

		contact_index_index.xml

		default.xml

	templates

		form.phtml

The Block dir, is where the view-related block PHP classes are located.

The Controller dir, is where we find the Controller-related PHP classes. This is the code that responds to the storefront POST and GET HTTP actions.

In the etc dir, we find module config files, they are as follows:

module.xml, di.xml, acl.xml, system.xml, config.xml, email_templates.xml, page_types.xml, routes.xml etc.

The module.xml is an actual module declaration file. 

The Helper dir, is where we can find various helper classes. These classes are usually used to abstract various store config values into the getter methods.

The i18n dir is where the module translation package CSV files are stored.

The Module dir is where the entities, resource entities, collections and various other business classes can be found.

The Test Dir stores module unit tests.

The view dir, contains all module admin and storefront template files (.phtml and .html) and static files (.js and .css)

Finally, the registration.php is a module registration file.

Next up, is how we setup our Magento stuff.

This book will cover the minimum of doing it, meaning we won't go into auto-scaling, caching servers, content delivery networks and similar.

What we will go through, is as follows:

Setting up a dev env

	VirtualBox

	Vagrant

	Vagrant Project

		Provisioning PHP

		Provisioning MySQL

		Provisioning Apache

		Provisioning Magento installation

Setting up a production environment
	
	Introduction to Amazon Web Services (AWS)

	Setting up access for S3 usage

		Creating IAM users

		Creating IAM groups

		Setting up S3 for DB and Media files backup

		Bash script for automated EC2 setup

			Setting up EC2

			Setting up Elastic IP and DNS

VirtualBox, is a VM machine, that will allow us to run a server with Magento, which means involving MySQL, Apache, and a few other things.

Vagrant, is a high-level software wrapper used for virtualization software management. We can use it to create and configure dev envs.
Vagrant supports several types of virtulization software, such as VirtualBox, VMware, Kernel-based VM (KVM), Linux Containers (LXC), and others.
It also supports server envs like Amazon EC2

We start by creating a empty dir in our host OS, let's say /Users/brank/www/B05032-Magento-Box/

This is the dir where we will put our Magento code. We wish for the magento code to be external to Vagrant box, so we can use it in a IDE.

We then create a Vagrant Project dir, let's say /Users/branko/www/magento-box/

Within the magento-box dir above, we run the vagrant init console command.

This will put a VagrantFile in that dir. Now, a VagrantFile is just a Ruby source file, to which if we strip comments, we get the following:

# -*- mode: ruby -*-
# vi: set ft=ruby :

Vagrant.configure(2) do |config|
	config.vm.box = "base"
end

if we were to run vagrant up within the magento-box dir, we would get a headless (No GUI) mode and run the base OS.

We wish to create a more robust file that allows for running Magento, Apache, MySQL, PHP, PHPUnit, composer and full Magento install with performance
fixture data.

To help support this, we will make a config file for Vagrantfile, which will host the MySQL pw/username and some other stuff.

Thus, we create the Vagrantfile.config.yml file, along with the Vagrantfile in the same dir, the content to which is as follows:

ip: 192.168.10.10
s3:
	access_key: "AKIAIPRNHSWEQNHWLCDQ"
	secret_key: "5Z9Lj+kI8wpDjSvwWU8q0btJ4QGLrNStnxAB2Zc"
	bucket: "foggy-project-dhj6"
synced_folder:
	host_path: "/Users/branko/www/B05032-Magento-Box/"
	guest_path: "/vagrant-B05032-Magento-Box/"
mysql:
	host: "127.0.0.1"
	username: root
	password: user123
http_basic:
	repo_magento_com:
		username: <numbers/letters>
		password: <same>
github_oauth:
	github_com: <some string>
magento:
	db_name: "magento"
	admin_firstname: "John"
	admin_lastname: "Doe"
	admin_password: "admin123"
	admin_user: "admin"
	admin_email: "email@change.me"
	backend_frontname: "admin"
	language: "en_US"
	currency: "USD"
	timezone: "Europe/London"
	base_url: "http://magento.box"
	fixture: "small"

This is not restrictive to a Vagrant imposed structure. This is legit for any YAML file. Values are PH's

If we wish, we can generate a user token to authenticate against the Git repo. You do so, by logging into Magento Connect with a username and PW, then going
to My Account| Developers | Secure Keys. The public key and private key then become our username and PW for accessing Magento GitHub repo.

Having a seperate config yml file, allows us to have version control on Vagrantfile to our project, while leaving teh config file out of it.

We then go to modify the Vagrantfile by replacing it's contents with the following:

# -*- mode: ruby -*-
# vi: set ft=ruby :

require 'yaml' //require to include the yaml

vagrantConfig = YAML.load_file //read the contents of the Yaml config file
'Vagrantfile.config.yml'

Vagrant.configure(2) do |config| //a box with the config settings

	config.vm.box = "ubuntu/vivid64" //config the vm box to use ubuntu and run vivid64, which gives us PHP 5.6.x and MySQL 5.6.x

	config.vm.network "private_network", ip: vagrantConfig['ip'] /run a private network with a fixed ip

	#Mount local "~/www/B05032-Magento-Box/" path into Box's "/vagrant-B05032-Magento-Box/" path 

	config.vm.synced_folder

vagrantConfig['synced_folder']['host_path'], //configure shared folders to be synced
vagrantConfig['synced_folder']['guest_path'],
owner: "vagrant", group: "www-data", mount_options: ["dmode=775, fmode=664"] //declare a group with owner being vagrant, the group being named www-data, mount options are the masking of user permissions

	#Virtualbox specific settings
	config.vm.provider "virtualbox" do |vb| //Set some simple options for the VB
		vb.gui = false
		vb.memory = "2048"
		vb.cpus = 2
	end

	# <provisioner here>
end

We then go to set the fixed ip in our hosts file of our host OS:

192.168.10.10 magento.box

The reason we are assining the fixed IP, is that we can directly open a URL like http://magento.box within our host OS, then access the Apache served page 
within our Guest OS.

Now, the next part, is where we put in our provisioners, to which we replace the <provisioner here>, with the following:

config.vm.provision "file", source: "~/.gitconfig", //pass the git config from the host to the guest OS, inheriting the Host OS git setup
destination: ".gitconfig"
config.vm.provision "shell", inline: "sudo apt-get update" //force a update on the OS

Further adding to the Vagrantfile, we run several provisioners that will install PHP, require PHP modules and PHPUnit, as follows:

config.vm.provision "shell", inline: "sudo apt-get -y 
install php5 php5-dev php5-curl php5-imagekick php5-gd
php5-mcrypt php5-mhash php5-mysql php5-xdebug php5-intl
php5-xsl" //Install php 5, dev version of php5, curl API, imagekick, gd, encryption, hashing, mysql, debug, intl and XSL

config.vm.provision "shell", inline: "echo
\"xdebug.max_nesting_level=200\" >> /etc/php5/apache2 //Run the output of the shell of config.vm.provision into the etc/php5/apache2.php.ini, allowing for a max of 200 nesting 
/php.ini" 											//functions. Since normally it will complain at about 100 nested functions

config.vm.provision "shell", inline: "sudo apt-get -y install phpunit"

Next up, we provision the MySQL in the Vagrantfile, to install the MySQL server:

config.vm.provision "shell", inline: "sudo debconf-set-selections <<< 'mysql-server mysql-server/root_password password" //store the parameters for input
#{vagrantConfig['mysql']['password']}'" //React the first time to the prompt with PW
config.vm.provision "shell", inline: "sudo debconf-set-selections <<< 'mysql-server mysql-server/root_password_again password //store a second time
#{vagrantConfig['mysql']['password']}'"//React a second time to the PW prompt
config.vm.provision "shell", inline: "sudo apt-get -y install mysql-server" //install the mysql-server
config.vm.provision "shell", inline: "sudo service mysql start" //start the mysql server
config.vm.provision "shell", inline: "sudo update-rc.d mysql defaults" //Add the mysql to the default boot cycle, meaning it will be there when we reboot the VM

Further adding to the Vargantfile, we run the Apache provisioners with the following:

config.vm.provision "shell", inline: "sudo apt-get -y install apache2" //install Apache
config.vm.provision "shell", inline: "sudo update-rc.d apache2 defaults" //add it to the default boot cycle
config.vm.provision "shell", inline: "sudo service apache2 start" //Start apache
config.vm.provision "shell", inline: "sudo a2enmod rewrite" //turn on the rewrite module
config.vm.provision "shell", inline: "sudo awk '/<Directory \\/>/, /AllowOverride None/{sub(\"None\",
\"All\", $0)}{print}' /etc/apache2/apache2.conf > /tmp/tmp.apache2.conf" //Run substitution on the AllowOverride from None to be All, otherwise Magento won't work
config.vm.provision "shell", inline: "sudo mv /tmp/tmp.apache2.conf /etc/apache2/apache2.conf" //move the config files
config.vm.provision "shell", inline: "sudo awk '/<Directory \\/var\\/www\\/>/, /AllowOverride //run the second substituion of AllowOverride
None/{sub(\"None\", \"All\", $0)}{print}' /etc/apache2/apache2.conf > /tmp/tmp.apache2.conf"
config.vm.provision "shell", inline: "sudo mv /tmp/tmp.apache2.conf /etc/apache2/apache2.conf" //Move them
config.vm.provision "shell", inline: "sudo service apache2 stop" //stop the Apache server 

The next part, is to provision the actual Magento installation. To this, we do several steps of provisioning to the Vargantfile.
First, we link our host folder, /vagrant-B05032-Magento-Box/, with the guest /var/www/html, using the Synced folder feature of Vagrant:

config.vm.provision "shell", inline: "sudo rm -Rf /var/www/html" //Remove the dir with all teh files of var/www/html
config.vm.provision "shell", inline: "sudo ln -s //create a symbolic link between synced_folder and guest_path in relativity to /var/www/html
#{vagrantConfig['synced_folder']['guest_path']}
/var/www/html"

We then go to use the composer create-project command to pull the Magento 2 files from the official repo.magento.com source into /var/www/html dir:

config.vm.provision "shell", inline: "curl -sS https://getcomposer.org/installer | php" //Run a curl request to get the installer piped from php
config.vm.provision "shell", inline: "mv composer.phar /usr/local/bin/composer" //move the composer.phar into relevant dir
config.vm.provision "shell", inline: "composer clearcache" //clear the cache
config.vm.provision "shell", inline: 'echo ' {\"http-basic\": {\"repo.magento.com\": {\"username\":\"#{vagrantConfig ['http_basic']['repo_magento_com']
['username']}\",\"password\": 
\"#{vagrantConfig['http_basic']['repo_magento_com']
['password']} \"}}, \"github-oauth\":
{\"github.com\": \"#{vagrantConfig['github_oauth']
['github_com']}\"}}' >> /root/.composer/auth.json" //Take all the info and throw it into the auth.json file 
config.vm.provision "shell", inline: "composer
create-project -- repository-
url=https://repo.magento.com/ magento/project-
community-edition /var/www/html/" //create a project with the relevant stuff

We then create a DB to which Magento will be installed into, later on:

config.vm.provision "shell", inline: "sudo mysql --user=#{vagrantConfig['mysql']['username']} -- //Run mysql, log in, create a DB 
password=#{vagrantConfig['mysql']['password']} -e \"CREATE DATABASE #{vagrantConfig['magento']['db_name']};\""

We then run the Magento install from the commandline:

config.vm.provision "shell", inline: "sudo php
/var/www/html/bin/magento setup:install --base-url=\"#{vagrantConfig['magento']['base_url']}\" --db- //install things and declare all relevant options
host="#{vagrantConfig['mysql']['host']}\" --db- user\"#{vagrantConfig['mysql']['username']}\" --db-
password=\"#{vagrantConfig['mysql']['password']}\" --db- name=\"#{vagrantConfig['magento']['db_name']}\"
--admin- firstname=\"#{vagrantConfig['magento']['admin_firstname']}\" -- admin-lastname=\"#
{vagrantConfig['magento']['admin_lastname']}\"
--admin-email=\"#{vagrantConfig['magento']['admin_email']}\" -- admin-user=\"#{vagrantConfig['magento']['admin_user']}\" -- admin-
password=\"#{vagrantConfig['magento']['admin_password']}\" --backend- frontname=\"#
{vagrantConfig['magento']['backend_frontname']}\" --language=\"#{vagrantConfig['magento']['language']}\"
-- currency=\"#{vagrantConfig['magento']['currency']}\" -- timezone=\"#{vagrantConfig['magento']['timezone']}\"" //Config all of the relevant things
config.vm.provision "shell", inline: "sudo php /var/www/html/bin/magento deploy:mode:set developer" // -||-
config.vm.provision "shell", inline: "sudo php /var/www/html/bin/magento cache:disable" // -||-
config.vm.provision "shell", inline: "sudo php /var/www/html/bin/magento cache:flush" //provide options regarding magentos settings
config.vm.provision "shell", inline: "sudo php /var/www/html/bin/magento setup:performance/generate-fixtures /var/www/html/setup/performance-toolkit/profiles/ce/small.xml"

NOTE: We have to be careful in terms of setting up our Vagrantfile.config.yml, we need to make sure we provide valid data, otherwise we will get an error similar to the following:

SQLSTATE[28000] [1045] Access denied for user 'root'@'localhost' (using password: NO)
User Name is a required field.
First Name is a required field.
Last name is a required field.
'magento.box' is not a valid hostname for email adress 'john.doe@magento.box'
'magento.box' appears to be a DNS hostname but cannot match TLD against known list
'magento.box' appears to be a local networkname but local network names are not allowed
Password is a required field
Your password must be at least 7 characters.
Your password must include both numeric and alphabetical characters.

If we were to run the vagrant up command now, it would run all the commands above. The total time would clock in on about 1 hour or so.

Once the vagrant up is complete, we can connect to the box with ssh:

vagrant ssh

At the same time, if we open the http://magento.box in our browser, we should see the Magento storefront loading.

The preceeding Vargantfile simply pulls from the official Git and allows for basic setup. We can further tailor this to our needs and engineer it to such that
we can spin up more developers quickly by just deploying the script unto each relevant person.

A production environment is the client-facing env that focuses on good performance and availability. Setting up production envs is not really
what a dev normally does, especially if there are heavy requirements on scaling, load balancing, high availability and similar. Sometimes, however,
we need to set up a simple production environment. There are various cloud providers that offer quick and simple solutions to this.

We will turn to Amazong Web services for our needs.

AWS, is a collection of remote computing services refered to as WEb services. AWS provides on-demand computing resources and services in the cloud,
with pay-as-you-go. 

The reason we would like to use this, is for the fact of spinning DBs, Web app servers and complex infrastructures in a matter of minutes.
We can run these services for a arbitrary amount of time and then shut em down, to which we only pay for the amount of time we use them.

We can also do costs savings in terms of using their auto-scaling of resources, that otherwise costs a lot in terms of on-premises infrastructure.

Beyond this, they offer certifications.

To access the interface of dealing with stuff, we can get to it by : https://aws.amazon.com/console.

It then divides the stuff into several major groups, such as follows:

Compute

Developer Tools

Mobile Services

Storage & Content Delivery

Management Tools

Application Services

Database

Security & Identity

Networking

Analytics

Enterprise Applications

We will be taking a look at the EC2 under Compute and S3 under Storage & Content Delivery.

The Amazon EC2,is a web service that provides a re-sizable compute capacity in the cloud. We can think of it as a virtual
computer machine in the cloud that we can turn on and off, at any time, within minutes.  Beyond this, we can comission as many as we wish,
simultaneously. This allows for re-sizable compute capacity.

S3, is web storage : Secure, durable and scalable.

However, to setup S3, we have to take a look at AWS Identity and Access Management (IAM for short)

IAM is a Web service that allows secure control access to AWS resources for our users. We can use the IAM to control authentication (Who can use AWS resources) and
authorization (What resources they can use and in what ways). More specifically, as we will soon see, we are interested in Users and Groups.

We begin by making a IAM user, which is the user that will interact with the AWS.

Go to Security Credentials -> Users And create a user.

We get then the credentials we need, and can download the thing in a CSV format, or we can copy paste the credentials manually.

Next up, we have to create groups for our IAM users.

go to Security Credentials -> Groups -> Create new group

Next we choose a policy, we go with AmazonS3FullAccess -> Next

Then we mark the group and add users to our group.

We will use this info (The Access Key Id, Secret Access Key and the Policy), to back-up DBs to the S3.

Now, to setup S3 for Media and DB backup, we have to create a Bucket (a dir, kind of), to which we will set permissions.

We log into the AWS management console, go to Storage & Content Delivery group, click on S3.

We click create bucket.

We provide a unique name for it and create our bucket.

We then create our folders, database and media

When we are in the root bucket dir, we click properties and fill in the permissions respectively.

When we have set this up correctly, having applied permissions for Authenticated Users, we can then later on use the s3cmd console tool, to handle our bucket.

Now, next up, we wish to write a Bash script file that allows for automated EC2 setup, which can be written as follows:

#!/bin/bash
apt-get update
apt-get -y install s3cmd //A free commandline tool for uploading, retrieving and managing Data in Amazon S3.

We can use it later on for DB and Media file backups and restores.

Next up, we install a mail server, called postfix. However, this will prompt a graphical UI prompt, so to bypass this, we use debconf-set-selections:

sudo debconf-set-selections <<< "postfix postfix/mailname string magentize.me" //bypass these two, because they will prompt a GUI request
sudo debconf-set-selections <<< "postfix postfix/main_mailer_type string 'Internet Site'"
sudo apt-get install -y postfix
sudo /etc/init.d/postfix reload

Using the Ec2 box is fine for smaller productions, but on higher traffic and load, they might throttle our acitvity on port 25. Thus, we need to monitor for that,
and if we run into it, we ask them to alleviate it or move on to more robust services like Amazon Simple Email Service.

Next up, is the installation of the PHP stuff. To which, we turn off the xdebug, albeit we can use it for debugging the live site if needed be by remote debugging in terms of 
shutting down the site nad then accessing it with the remote debugging of xdebug

apt-get -y install php5 php5-dev php5-curl php5-imagick php5-gd php5- mcrypt php5-mhash php5-mysql
php5-xdebug php5-intl php5-xsl 
php5enmod mcrypt //Enable mcryption
php5dismod xdebug //disable debug
service php5-fpm restart //restart the service 
apt-get -y install phpunit
echo "Starting Composer Stuff" >> /var/tmp/box-progress.txt
curl -sS https://getcomposer.org/installer | php 
mv composer.phar /usr/local/bin/composer

Next up we automate the mySQL process and add it to the boot cycle:

debconf-set-selections <<< 'mysql-server mysql-server/root_password password <text>' //Automate console input of values to bypass prompts
debconf-set-selections <<< 'mysql-server mysql-server/root-password_again password <text>'
apt-get -y install mysql-server //isntall the mysql
service mysql start //start the mysql
update-rc.d mysql defaults //Add to boot cycle 

Next up is the Apache, where we have to account for the replacement of AllowOverride to be All instead of None, for the magento dir:

apt-get -y install apache2 //install apache
update-rc.d apache2 defaults //include Apache in the boot cycle
service apache2 start //start the apache service
a2enmod rewrite //activate the rewrite mod
awk '/<Directory \/>,/AllowOverride None/{sub("None", "All", $0)}{print}' /etc/apache2/apache2.conf > /tmp/tmp.apache2.conf //override AllowOverride from none to All
mv /tmp/tmp.apache2.conf /etc/apache2/apache2.conf //move the conf file from temp to the apache2 conf for our Magento
service apache2 restart //restart the apache

Next up, we will pull from the official Magento public git repo:

sudo rm -Rf /var/www/html/* //Clear out
git clone https://github.com/magento/magento2.git
/var/www/html/. //Clone the git repo
sudo composer config --global github-oauth.github.com <string/numbers> //access the oauth of github with said PW
sudo composer install --working-dir="/var/www/html/" //install into working dir, the git
mysql -uroot -pRrkSBi6VDg6C -e "CREATE DATABASE magento;" //create a dataase called magento with root user, using root users PW
PUBLIC_HOSTNAME="'wget -q -O - http://instance-data/latest/meta- data/public-hostname'" //save the name of the public host EC2 meta data instance, to pass it on later

To clone from private repos, we can use the following syntax:

<OAuthToken>@github.com/<user>/<repo>.git

We also get to use the PUBLIC_HOSTNAME variable for the Magento installation, passing it as --base-url param:

php /var/www/html/bin/magento setup:install --base-url="http://$PUBLIC_HOSTNAME" --db-host="127.0.0.1"
--db- user="root" --db-password="RrkSBi6VDg6C"
--db-name="magento" -- admin-firstname="John"
--admin-lastname="Doe" --admin-
email="john.doe@change.me" --admin-user="admin"
--admin- password="pass123" --backend- frontname="admin"
-- language="en_US" --currency="USD" --timezone="Europe/London"

The above stuff takes a lot of per project specs, so we gotta make sure that we have the correct values

Next we make sure that the Magento cache is turned on and flushed:

php /var/www/html/bin/magento deploy:mode:set production
php /var/www/html/bin/magento cache:enable
php /var/www/html/bin/magento cache:flush

Then we reset the permissions on the /var/www/html dir in order for our Magento to function properly:

chown -R ubuntu:www-data /var/www/html
find /var/www/html -type f -print0 | xargs -r0 chmod 640 //Find the file, if it exists, print it, otherwise, chmod it to 640
find /var/www/html -type d -print0 | xargs -r0 chmod 750 //Find the dir, if it exists, print it, otherwise chmod it it to 750
chmod -R g+w /var/www/html/pub
chmod -R g+w /var/www/html/var
chmod -R g+w /var/www/html/app
chmod -R g+w /var/www/html/vendor

However, we need to take precaution with the preceeding code.

The idea is to show that we could automatically set Git pull from a public or private repo. The magento installation is a nice bonus for this
specific case, not something we would actually do on our production machine. The whole purpose of this script would be to serve as a blueprint for
powering up new AMI images. So ideally what we would usually do once the code is pulled, is to restore the DB from some private storage like S3
and then attach it to our installation. Thus making for a complete restore, with DB, media and files, once it is done.

Next up, we set a daily DB routine of backing up our DB:

CRON_CMD="mysql --user=root --password=RrkSBi6VDg6C //Connect to the mysql magento, pipe it to gzip in a gz, which we run 2:30 am
magento | gzip -9 > ~/database.sql.gz"CRON_JOB="30 2 * * * $CRON_CMD" ( crontab -l | grep -v "$CRON_CMD" ; echo "$CRON_JOB") | crontab -

CRON_CMD="s3cmd --access_key="AKIAINLIM7M6WGJKMMCQ" -- secret_key="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" put ~/database.sql.gz s3://foggy-project-ghj7/database
/database_'date + "%Y-%m-%d_%H-%M"'.sql.gz" //we then access the S3 storage at 3 30 and run the command to push back the items up to Storage again
CRON_JOB="30 3 * * * $CRON_CMD"
( crontab -l | grep -v "$CRON_CMD" ; echo "$CRON_JOB") | crontab -

Similar to the DB backup, we can add the Media backup instructions to our script:

CRON_CMD="tar -cvvzf ~/media.tar.gz /var/www/html/pub/media/" //make a copy of the file
CRON_JOB="30 2 * * * $CRON_CMD" //run it at 2:30 AM
( crontab -l | grep -v "$CRON_CMD" ; echo "$CRON_JOB" ) | crontab - 

CRON_CMD="s3cmd --access_key="AKIAINLIM7M6WGJKMMCQ" -- secret_key="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" put ~/media.tar.gz s3://foggy-project-ghj7/media/media_'date + "%Y-%m- %d_%H-%M"'.tar.gz" CRON_JOB="30 3 * * * $CRON_CMD" //run s3cmd tool with access key and secret key, put a copie of the media with dating/timing, run it at 3 30
( crontab -l | grep -v "$CRON_CMD" ; echo "$CRON_JOB" ) | crontab -

For simplicities sake, we will not be talking about dynamically allocating access tokens etc. If we wish to find out more about that ,we can go to
AWS Security Best Practices guide, found at the official AWS website

Next up, is that we setup the EC2.

Log in to the AWS console, under Compute click EC2.

Click launch instance.

Go to COmmunity AMIs, type in Ubuntu Vivid. //By default supports mytSQL and PhP at versions 5.6.x and 5.6.x, making it a good candidate for Magento installation.

We then choose a instance type and go to Next: Configure instance details. For smaller projects, it suffices to use default options, but in otehr cases,
we might consider other things.

Assert that shutdown is set to Stop.

We then scroll down to the bottom of Advanced Details, expand it.

In the User Data input field, we put in the Bash script, which we defined earlier, which was the #!/bin/bash script with adding to boot cycle etc.

We then move over to the next data storage button.

We choose a partionining part to assign to, preferably a SSD (faster), move on to Next: Tag instance

In tag instance, we can assign tags to stuff. Next, we move on to Configure Security Group.

The configure Security group allows us to manage what connections are allowed in terms of our Group, which in our case is:

HTTP

SSH

HTTPS

SMTP

We then go to Review and Launch, to which we can review the launch options and modify them, if we wish. The next stage, the Launch button,
gives us a Popup.

We get to choose a key-pair, either existing or create a new one, to which they are provided in a PEM format if new.
However, we have one, so we run with the magento-box pair

We then launch instance, and it should run.

Next up, we have two options for running into connecting: //Run either of following command from console

ssh -i /path/to/magento-box.pem
ubuntu@ec2-52-29-35-49.eu-central-1.compute.amazonaws.com

ssh -i /path/to/magento-box.pem ubuntu@52.29.35.49

It will take some time to process all of the commands, tho, thus, we can cover the progress with the following command from console as well:

sudo -tail -f /var/tmp/box-progress.txt //Write to file the output of our progress in a tmp file

With the EC2 box in place, we go to create a Elastic IP and DNS. Now, an Elastic IP is for dynamic Cloud computing, used by the AWS, which is bound
to said account on AWS, not any actual instance.

To do this, we go to AWS console, and log in.

Go to Compute, EC2 -> EC2 Dashboard, Elastic IPs -> Allocate new Address

We click yes, allocate.

We right click on the instance, and choose Associate Address.

We select the instance we wish to assign the elastic IP address to, and then associate it.

At this point, our EC2 box has a static (elastic IP) address assigned. We can now log into our Registrar and point the A-record of our
DNS to the Elastic IP we just created.

until we wait for the DNS change to kick in, we need to SSH ourselves into our box and update the Magento URL, to which we could have
done already by passing the right --base-url var, but now we do it like this:

mysql -uroot -<pw> -e "USE magento; UPDATE core_config_data SET value = 'http://our-domain.something/' WHERE path LIKE "%web/unsecure/base_url%";"
php /var/www/html/bin/magento cache:flush

All of the things we have done so far, are not final, they are merely a "Basic setup", a base skeleton, so to speak.

Next up, are some of the programming concepts and conventions used in Magento:

Composer

Service Contracts

Code generation

The var dir

Coding standards

The composer, is a tool that handles depedency management in PHP, it is not a Package manager like Yum or Apt on Linux systems.
It deals with Libs(packages) on a per-project basis. It does not run anything Globally. Composer is a multiplatform tool. Thus, it runs on
anything, really.

To install Composer, we just need to run the following command in the project dir:

curl -sS https://getcomposer.org/installer | php

Composer is used to fetch Magento and third-party components that it uses. an example of such a composer argument on CMD line, is as follows:

composer create-project --repository-url=https://repo.magento.com/ magento/project-enterprise-edition <installation directory name>

Once Magento is downloaded, we get tons of JSON files, which can be found in the respective Dir. However, if we were to run a search on it,
we'd get a result of having over a 100 things, as some of these showcases:

/vendor/magento/module-catalog/composer.json
/vendor/magento/module-cms/composer.json
/vendor/magento/module-contact/composer.json
/vendor/magento/module-customer/composer.json
/vendor/magento/module-sales/composer.json
/...
/vendor/magento/theme-adminhtml-backend/composer.json
/vendor/magento/theme-frontend-blank/composer.json
/vendor/magento/theme-frontend-luma/composer.json
/vendor/magento/language-de_de/composer.json
/vendor/magento/language-en_us/composer.json
/...
/composer.json
/dev/tests/...
/vendor/magento/framework/composer.json

The most relevant one, is probably the composer.json in the root dir, which looks to contain something like this:

{
	"name": "magento/project-community-edition",
	"description": "eCommerce Platform for Growth (Community Edition)",
	"type": "project",
	"version": "2.0.0",
	"license": [
		"OSL-3.0",
		"AFL-3.0"
	],
	"repositories": [
		{
			"type": "composer",
			"url": "https://repo.magento.com/"
		}
	],
	"require": {
		"magento/product-community-edition": "2.0.0",
		"composer/composer": "@alpha",
		"magento/module-bundle-sample-data": "100.0.*",
		"magento/module-widget-sample-data": "100.0.*",
		"magento/module-theme-sample-data": "100.0.*",
		"magento/module-catalog-sample-data": "100.0.*",
		"magento/module-customer-sample-data": "100.0.*",
		"magento/module-cms-sample-data": "100.0.*",
		"magento/module-catalog-rule-sample-data": "100.0.*",
		"magento/module-sales-rule-sample-data": "100.0.*",
		"magento/module-review-sample-data": "100.0.*",
		//This list carries on with the same pattern for some time
	},
	"require-dev": {
		"phpunit/phpunit": "4.1.0",
		"squizlabs/php_codesniffer": "1.5.3",
		"phpmd/phpmd": "@stable",
		"pdepend/pdepend": "2.0.6",
		"sjparkinson/static-review": "~4.1",
		"fabpot/php-cs-fixer": "~1.2",
		"lustanian/oauth": "~0.3 <=0.7.0"
	},
	"config": {
		"use-include-path": true
	},
	"autoload": {
		"psr-4": {
			"Magento\\Framework\\": "lib/internal/Magento/Framework/",
			"Magento\\Setup\\": "setup/src/Magento/Setup/",
			"Magento\\": "app/code/Magento"
		},
		"psr-0": {
			"": "app/code/"
		},
		"files": [
			"app/etc/NonComposerComponentRegistration.php"
		]
	},
	"autoload-dev": {
		"psr-4": {
			"Magento\\Sniffs\\": "dev/tests/static/framework/Magento/Sniffs/",
			"Magento\\Tools\\": "dev/tools/Magento/Tools/",
			"Magento\\Tools\\Sanity\\": "dev/build/publication/sanity/ Magento/Tools/Sanity/",
			"Magento\\TestFramework\\Inspection\\": "dev/tests/static/framework/Magento/TestFramework/Utility/"
		}
	},

	"minimum-stability": "alpha",
	"prefer-stable": true,
	"extra": {
		"magento-force": "override"
	}
	
}

The Schema defines the pattern of which all things must conform to. Meaning it cannot derive from this, thus, it means that we must
adhere to ensure validity of the composer file. It lists all the relevant keys.

Next up, we go to look at the individual module's composer.json file, one of the simpler modules with the least amount of dependencies, the
Contact module in vendor/magento/module-contact/composer.json file, to which looks like as follows:

{
	"name": "magento/module-contact",
	"description": "N/A",
	"require": {
		"php": "~5.5.0|~5.6.0|~7.0.0",
		"magento/module-config": "100.0.*",
		"magento/module-store": "100.0.*",
		"magento/module-backend": "100.0.*",
		"magento/module-customer": "100.0.*",
		"magento/module-cms": "100.0.*",
		"magento/framework": "100.0.*"
	},
	"type": "magento2-module",
	"version": "100.0.2",
	"license": [
		"OSL-3.0",
		"AFL-3.0"
	],
	"autoload": { //WE will use psr-4 for autoloading and we manually load registration.php
		"files": [
			"registration.php"
		],
		"psr-4": {
			"Magento\\Contact\\": ""
		}
	}
}

Next up, is the contents of vendor/magento/language-en_us/composer.json from the en_us language module:

{
	"name": "magento/language-en_us",
	"description": "English (United States) language",
		"version": "100.0.2",
		"license": [
			"OSL-3.0",
			"AFL-3.0"
		],
		"require": {
			"magento/framework": "100.0.*"
		},
		"type": "magento2-language",
		"autoload": {
			"files": [
				"registration.php"
			]
		}
}

Next, we look at the contents of vendor/magento/theme-frontend-luma/composer.json from the luma theme:

{
	"name": "magento/theme-frontend-luma",
	"description": "N/A",
	"require": {
		"php": "~5.5.0|~5.6.0|~7.0.0",
		"magento/theme-frontend-blank": "100.0.*",
		"magento/framework": "100.0.*"
	},
	"type": "magento2-theme",
	"version": "100.0.2",
	"license": [
		"OSL-3.0",
		"AFL-3.0"
	],
	"autoload": {
		"files": [
			"registration.php"
		]
	}
}

Generally, they follow the same theme, of implying attributes, what is required to use them, what should be autoloaded and what not.

A Serive contract is a set of PHP interfaces that is defined by a module. This contract comprises data interfaces and service interfaces.

The role of the data interface is to preserve data integrity, while the role of the service interface is to hide the business logic details from
service consumers.

The data interfaces, defines various functions, such as validation, entity information, search related functions, and so on. They are defined
within the Api/Data dir of an individual Module. To better understand the actual meaning of it, let's take a look at the data interfaces for the
Magento_Cms module. 

In the vendor/magento/module-cms/Api/Data dir, there are four interfaces defined, as follows:

BlockInterface.php
BlockSearchResultsInterface.php
PageInterface.php
PageSeachResultsInterface.php

The CMS module actually deals with two entities, one being Block and the other being Page. Looking at the interfaces defined in the given code,
we can see that we have seperate data interface for the entity itself and seperate data interface for search results.

Let's take a closer look at the (stripped) contents of the BlockInterface.php file, which is defined as follows:

namespace Magento\Cms\Api\Data;

interface BlockInterface
{
	const BLOCK_ID 			= 'block_id';
	const IDENTIFIER 		= 'identifier';
	const TITLE 			= 'title';
	const CONTENT 			= 'content';
	const CREATION_TIME 	= 'creation_time';
	const UPDATE_TIME 		= 'update_time';
	const IS_ACTIVE 		= 'is_active';

	public function getId();
	public function getIdentifier();
	public function getTitle();
	public function getContent();
	public function getCreationTime();
	public function getUpdateTime();
	public function isActive();
	public function setId($id);
	public function setIdentifier($identifier);
	public function setTitle($title);
	public function setContent($content);
	public function setCreationTime($creationTime);
	public function setUpdateTime($updateTime);
	public function setIsActive($isActive);
}

The BlockInterface simply defines the constants and the functions of which we are to use, with getters and setters. They do not define interactive function calls, such as delete.

An example of where this is in place, is in for example vendor/magento/module-cms/Model/Block.php :

public function getTitle()
{
	return $this->getData(self::TITLE); //getter for title
}

public function setTitle($title)
{
	return $this->setData(self::TITLE, $title); //Setter for title
}

Service interfaces are the ones that include management, repository and metadata interfaces. These interfaces are defined directly within the
module's Api directory. Looking back at the Magento Cms module, it's vendor/magento/module-cms/Api/ dir has two service interfaces, which are as follows:

BlockRepositoryInterface.php
PageRepositoryInterface.php

Looking at the BlockRepositoryInterface.php it reveals the following (partial) conent:

namespace Magento\Cms/Api;

use Magento\Framework\Api\SearchCriteriaInterface;

interface BlockRepositoryInterface
{
	public function save(Data\BlockInterface $block);
	public function getById($blockId);
	public function getList(SearchCriteriaInterface $searchCriteria);
	public function delete(Data\BlockInterface $block);
	public function deleteById($blockId);
}

We see the methods for saving, fetch, search and delete, related to said entity. It is later on integrated through the Web API definitions, as we will see later.

The result is well-formed API's that other modules and third-party integrators can consume.

Something that Magento uses as well, or supports, rather, is Code Generation. Meaning it can generate non-existant classes, which end up in var/generation dir.

The dir structure within var/generation is akin to the core of vendor/magento/module-* and app/code dirs. To be more precise, it follows the modules structure.
The code is generated for something that is called Factory, Proxy and Interceptor classes.

The Factory class creates an instance of a type. For example, a var/generation/Magento/Catalog/Model/ProductFactory.php file with a Magento\Catalog\Model\ProductFactory
class has been created because somewhere within the vendor/magento dir and it's code, there's been a call to the Magento\Catalog\Model\ProductFactory class,which originally
does not exist in Magento. During runtime, when {someClassName}Factory is called in the code, Magento creates a Factory class under the var/generation dir if it does not exist.

The following, is an partial example of ProductFactory class:

namespace Magento\Catalog\Model;

/**
* Factory class for @see \Magento\Catalog\Model
\Product
*/

class ProductFactory
{
	//...

	/**
	* Create class instance with specified parameters
	*
	* @param array $data
	* @return \Magento\Catalog\Model\Product
	*/

	public function create(array $data = array())
	{
		return $this->_objectManager->create($this->_instanceName, $data); //create an array of the data fed in, and then pass it to a objectManager and create it
		//with the instancename and the relevant data
	}
}

The create method returns the Product type instance. It also is type safe, by virtue of the @return annotation for IDE's to support the autocomplete functionality

Factories are used to isolate an object manager from the business code. Factories can be dependent on the object manager, unlike business objects.

The Proxy class is a wrapper for some base class. Proxy classes provide better performance than the base classes because they can be instansiated without instansiating
a base class. A base class is only instansiated when one of its methods are called. This is highly convenient for cases where the base class is used as a dependency,
but takes a lot of time to instansiate, and its methods are used only during some paths of execution.

Like Factory, the Proxy classes are also generated under the var/generation dir.

If we were to take a look at the var/generation/Magento/Catalog/Model/Session/Proxy.php file that contains the Magento\Catalog\Model\Session\Proxy class,
we would see that it actually extends \Magento\Catalog\Model\Session. The wrapping Proxy class implements several magical methods along the way,
such as __sleep, __wakeup, __clone and __call

Interception is yet another class type that gets autogenerated by Magento. It is related to the plugins feature, which will be discussed in detail later in Chapter 6, Plugins.

In order to trigger the code regeneration, we can use the code compiler that is available on the console. There are two versions.
the single-tenant compiler or the multi-tenant compiler. The single-tenant, implies one independant Magento app, the multi-tenant compiler implies several independant
Magento apps.

What follows, is the single-tenant followed by the multi one:

magento setup:di:compile

magento setup:di:compile-multi-tenant

Code compilation generates factories, proxies, interceptors, and several other classes. As listed in the setup/src/Magento/Setup/Module/Di/App/Task/Operation/ dir.

In Magento, we do a lot of caching and autogeneration of certain class types. These caches and generated classes are located in Magento's root var dir. The usual
contents of this dir, is usually as follows:

cache
composer_home
generation
log
di
view_preprocessed
page_cache

During development, we will most likely need to periodically clear these so that our changes can kick in. (i.e, clear cookies and stuff from the caches)

To clear individual dirs, we can use the following command on the cmd line:

rm -rf {Magento root dir}/var/generation/*

Or, we can use the bin/magento console tool, to trigger commands that will delete the proper dirs for us, as follows:

bin/magento setup:upgrade //updates the Magento DB schema and data. While doing this, it truncates the var/di and var/generation dirs

bin/magento setup:di:compile //this clears the var/generation dir. After doing this, it compiles the code in it again.

bin/magento deploy:mode:set {mode} //This changes the mode from the dev mode to the production mode and vice versa. While doing this,
it truncates the var/di, var/generation, and var/view_preprocessed dirs.

bin/magento cache:clean {type} //This cleans the var/cache and var/page_cache dirs

We must keep in mind the var dir, unless the code might encounter exceptions and function improperly.

Coding Standards are the de factor ways of praxis in Coding, meaning they are the pattern we should abide by, to make for easier code,
easier lineup of deployment. They, in Magento, are as follows:

The code demarcation standard

The PHP coding standard

The JS Coding standard

The jQuery widget coding standard

The DoBlock standard

JS DocBlock standard

The LESS coding standard

The code demarcation standard, seeks to decouple HTML, CSS and JS from PHP classes. By doing so, the two stand to be seperated and we do not nessecarily
end up in breaking the front end just because we changed the backend.

The PHP coding standard, refers to the PSR-1:Basic Coding Standard and PSR-2:Coding Style Guide. 

PSR-1, is as follows:

Files must only use <?php and <?= tags

Files must only use UTF-8 without BOM for PHP code.

Files SHOULD either declare symbols (classes, functions, constants etc) or cause side-effects(e.g. generate output, change .ini settings etc.) but SHOULD not do both.

An example of a side-effect mutating file:

<?php

//Side effect, changes ini settings
ini_set('error_reporting', E_ALL);

//Side effect, loads a file
include "file.php";

//side effect: generates output
echo "<html>\n";

//declaration
function foo()
{
	//function body
}

What follows, is an example of a no side-effects file:

<?php

//declaration
function foo()
{
	//function body
}

//conditional declarations is not a side effect
if (! function_exists('bar')){
	function bar(){
		//function body
	}
}


Namespaces and classes MUST follow an "autoloading" PSR:

They must also adhere to the fact of explicitly declaring namespaces , when it comes to PHP 5.3 and later:

<?php

//PHP 5.3 and later
namespace Vendor\Model;

class Foo
{
	
}

The < 5.3, uses psuedo ways:

<?php
// PHP 5.2.x and earlier
class Vendor_Model_Foo
{
	
}

Class names MUST be declared in StudlyCaps.

Class constants MUST be declared in all uppercase with underscore seperators

Method names MUST be declared in camelCase.

The PSR-2 adheres to the following:

Code must adhere to PSR-1

Code MUST use 4 spaces for indenting, not Tabs

There MUST NOT be a hard limit on line length; the soft limit MUST be 120 chars; lines SHOULD be 80 chars or less

There MUST be one blank line after the namespace declaration, and there MUST be one blank line after the block of use declarations.

Opening braces for classes MUST go on the next line, and closing bracers MUST go on the next line after the body.

Opening braces for methods MUST go on the next line, and closing bracers MUST go on the next line after the body.

Visibility MUST be declared on all properties and methods; abstract and final MUST be declared before the visibility; static MUST be declared after visibility

Control structure keywords MUST have one space after them; method and function calls MUST NOT.

Opening bracers for control structures MUST go on the same line, and closing bracers MUST go on the next line after the body.

Opening parantheses for control structures MUST NOT have a space after them, and closing parantheses for control structures MUST NOT have a space before

An example that puts all the rules to use, follows:

<?php
namespace Vendor\Package;

use FooInterface;
use BarClass as Bar;
use OtherVendor\OtherPackage\BazClass;

class Foo extends Bar implements FooInterface
{
	public function sampleMethod($a, $b = null)
	{
		if($a === $b){
			bar();
		} else {
			BazClass::bar($arg2, $arg3);
		}
	}

	final public static function bar()
	{
		//method body
	}
}

Note: There is no closing ?>, and MUST Be omitted ifi ton ly contains PhP. All PHP files end with a blank line.

There MUST NOT be a hard limit on line length, The soft limit being at 120, automated style chckers should warn, but not throw errors at the limit

Lines should not be longer than 80, if they are, split them up.

There MUST NOT be trailing whitespace at the end of non-blank lines.

Blank lines MAY be added to improve readability and to indicate related blocks of code.

There must NOT be more than one statement per line.

Keywords MUST be in lowercase (true, false, null)

there MUST be one line blank after namespace declaration

all use declarations MUST go after the namespace declaration

There MUST be one use keyword per declaration

There MUST Be one blank line, after each use block:

<?php
namespace Vendor\Package;

use FooClass;

use BarClass as Bar;

use OtherVendor\OtherPackage\BazClass;

//rest of the php code

Some rules regarding implemtnds and extends, follows:

<?php
namespace Vendor\Package;

use FooClass;
use BarClass as Bar;
use OtherVendor\OtherPackage\BazClass;


Implementations CAN be split across multiple lines:

class ClassName extends ParentClass implements 
	\ArrayAccess,
	\Countable,
	\Serializable
{
	//stuff
}

or just put on the same line:

class ClassName extends ParentClass implements \ArrayAccess, \Countable, \Serializable
{
	//stuff
}

Visibility MUST be declared on all properties and the var keyword, MUST NOT be used to declare a property.

There MUST NOT be more than one property declared per statement.

Property names SHOULD NOT be prefixed with a single underscore to indicate protected or private visibility.

An example of how to declare:

<?php
namespace Vendor\Package;

class ClassName
{
	public $foo = null;
}

Visibility MUST be declared on all methods.

Method names, SHOUULD NOT be pre-fixed with _ to indicate protected or private visibility.

An example of how Methods must be declared:

<?php
namespace Vendor\Package;

class ClassName
{
	public function fooBarBaz($arg1, &arg2, $arg3 = [])
	{
		//method body
	}
}

NOTE: method args with default values, MUST come last in ordering.

They can look as follows, as well:

<?php
namespace Vendor\Package;

class ClassName
{
	public function aVeryLongMethodName(
		ClassTypeHint $arg1,
		&$arg2,
		array $arg3 = []
	) {
		//method body
	}
}

Abstract, final and static, follows the following rules:

<?php
namespace Vendor\Package;

abstract class ClassName
{
	protected static $foo;

	abstract protected function zim();

	final public static function bar()
	{
		//method body
	}
}

Examples of Methods and function calls:

<?php
bar();
$foo->bar($arg1);
Foo::bar($arg2, $arg3);

OR

<?php
$foo->bar(
	$longArgument,
	$longerArgument,
	$muchLongerArgument
);

Foreach loops a bit different as well:

<?php
foreach ($iterable as $key => $value) {
	//foreach body
}

Try and catches:

<?php
try{
	//Try body
} catch (FirstExceptionType $e) {
	//catch body
} catch (OtherExceptionType $e) {
	//catch body
}

Function calls with args and vars:

<?php
$closureWithArgs = function ($arg1, $arg2){
	//body
};

$closureWithArgsAndVars = function ($arg1, $arg2) use ($var1, $var2) {
	//body
};

Further examples:

<?php
$longArgs_noVars = function (
	$longArgument,
	$longerArgument,
	$muchLongerArgument
) {
	//body
};

$noArgs_longVars = function () use (
	$longVar1,
	$longerVar2,
	$muchLongerVar3
) {
	//body
};

$longArgs_longVars = function (
	$longArgument,
	$longerArgument,
	$muchLongerArgument
) use (
	$longVar1,
	$longerVar2,
	$muchLongerVar3
) {
	//body
};

$longArgs_shortVars = function (
	$longArgument,
	$longerArgument,
	$muchLongerArgument
) use ($var1) {
	//body
};

$shortArgs_longVars = function ($arg) use (
	$longVar1,
	$longerVar2,
	$muchLongerVar3
) {
	//body
};

It also applies when the closure is used directly in a function or method call as an arg:

<?php
$foo->bar(
	$arg1,
	function ($arg2) use ($var1) {
		//body
	},
	$arg3
);

In the next chapter, we are going to look at, is dependency injections in Magento.

Akin to how most modern frameworks and platforms work these days, Magento uses a ORM approach to Sql Queries (Object Relational Mapping) rather than raw SQL queries.
It allows for isolated PHP code to run handling of DB objects parted away from vendor-specific SQL differences.

The tree types of classes that handles entity data management, is Model, Resource and collection, doing everything from loading, deleting, saving and listing entities.

The majority of the data access, will be done through the PHP Magento models. The models themselves, do not contain any code for communicating with the DB.

The DB communication part is decoupled into it's own PHP class called resource class. Each model is then assigned a resource class.
Calling load, save, or delete methods on models gets delegated to resource classes, as they are the ones to actually read, write and delete data from the DB.

Theoretically, with enough knowledge, you could write new resource classes for various DB vendors.

Next to the model and resource classes, we have the collection classes. We can think of a collection as an array of individual model instances. 
On a base level, collections extend from the \Magento\Framework\Data\Collection class, which implements \IteratorAggregate and \Countable from Standard PHP Library (SPL),
and a few other Magento specific classes.

More often than not, we look at model and resource as a single unified thing, thus simply calling it a model. Magento deals with two types of
models, which we might categorize as simple and EAV models.

We are going to look at the following things:

Creating a miniature module

Creating a simple model

The EAV model

Understanding the flow of schema and data scripts

Creating an install schema script(InstallSchema.php)

Creating an upgrade schema script(UpgradeSchema.php)

Creating an install data script(InstallData.php)

Creating an upgrade data script(UpgradeData.php)

Entity CRUD actions

Managing collections

For the purpose of this chapter, we will create a miniature module called Foggyline_Office.

The module, will have two entities, as follows:

	Department: a simple model with the following fields:
		entity_id: primary key

		name: name of department, string value

	Employee: an EAV model with the following fields and attributes:
		Fields:
			entity_id: primary key

			department_id: foreign key, pointing to Department.entity_id

			email: unique e-mail of an employee, string value

			first_name: first name of an employee, string value

			last_name: last name of an employee, string value

		Attributes:
			service_years: employee's years of service, integer value

			dob: Employee's date of birth, date-time value

			salary: monhtly salary, decimal value

			vat_number: VAT number, (short) string value

			note: possible note on employee, (long) string value

Every module starts with the registration.php and module.xml files. For the purpose of our chapter module, let's create the app/code/Foggyline/Office/registration.php with the following content:

<?php
\Magento\Framework\Component
\ComponentRegistrar::register( //run the registrar on the register of the ComponentRegistrar Dir with Module, Foggyline/Office, creating the dir there
	\Magento\Framework\Component
\ComponentRegistrar::MODULE,
	'Foggyline_Office',
	__DIR__
);

The registration.php file is sort of an entry point to our module.

Now, let's create the app/code/Foggyline/Office/etc/module.xml with the following content: 

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:noNamespaceSchemaLocation="urn:magento:framework:
Module/ etc/module.xsd">
	<module name="Foggyline_Office" setup_version="1.0.0">
		<sequence>
			<module name="Magento_Eav"/>
		</sequence>
	</module>
</config>

We will et back to the structure of the XML and the reasoning behind it, later on.

the only relevant parts so far, is the setup_version and module inside of the sequence.

The value of the setup_version is important, cause we might use it within our schema install script(InstallSchema.php) files,
effectively turning the install script into an update script, as we will show soon.

The sequence element is Magento's way of setting dependencies for our module. Given that our module will make use of EAV entities, we list
Magento_Eav as a dependancy.

The department entity, as per requirements, is modded as a simple model. We previously mentioned that whenever we talk about models, we implicitly think
of model class, resource class, and collection class forming one unit.

Let's start by first creating a model class, (partially) defined under the app/code/Foggyline/Office/Model/Department.php file as follows:

namespace Foggyline\Office\Model;

class Department extends \Magento\Framework\Model\AbstractModel
{
	protected function _construct()
	{
		$this -> _init('Foggyline\Office\Model\ResourceModel\Department');//trigger the init and pass it to our Resource class
	}
}

The above code actually derives from the Object superclass, leading to the matter of fact that we automatically aquire the get, set, unset and check for existence of values.

An example would be as follows, if we assume that our entity has employee_average_salary:

$department->getData('employee_average_salary');
$department->getEmployeeAverageSalary();

$department->setData('employee_average_salary', 'theValue');
$department->setEmployeeAverageSalary('theValue');

$department->unsetData('employee_average_salary');
$department->unsEmployeeAverageSalary();

$department->hasData('employee_average_salary');
$department->hasEmployeeAverageSalary();

The reason we can call getData, unsetData, setData etc. and the other ones, is because the Object superclass implements the __call method, which allows for
running calls like hasEmployeeAverageSalary() etc. even if thoose do not exist inheritly to the Model (Think of __call to be the delegation of a method call if one
is missing.)

This does not stop us from defining them to our Model, it's just that we inheritly don't need to.

Once the model class is in place, we create a model resource class, under app/code/Foggyline/Office/Model/ResourceModel/Department.php, with the following:

namespace Foggyline\Office\Model\ResourceModel;

class Department extends \Magento\Framework\Model\ResourceModel\Db\AbstractDb
{
	protected function _construct()
	{
		$this->_init('foggyline_office_department', 'entity_id'); //Assign the constructor to be initialization of the DB with the table name and primary column name "entity_id"
	}
}

The AbstractDB further more extends the Magento\Framework\Model\ResourceModel\AbstractResource.

The resource class is the key to communicating to the DB, all it takes is for us to name the table and it's primary key and our models can save, delete and update entities.

Finally, we create our collections class under app/code/Foggyline/Office/Model/ResourceModel/Department/Collection.php:

namespace Foggyline\Office\Model\ResourceModel\Department;

class Collection extends \Magento\Framework\Model\ResourceModel\Db\Collection\AbstractCollection
{
	protected function _construct()
	{
		$this->init( //we initialize our collection with the Model class name, and the resource model class name.
			'Foggyline\Office\Model\Department',
			'Foggyline\Office\Model\ResourceModel\Department'
		);
	}
}

AbstractCollection implements Magento\Framework\App\ResourceConnection\SourceProviderInterface and extends \Magento\Framework\Data\Collection\AbstractDb.

AbstractDb, then in turn, extends \Magento\Framework\Data\Collection.

It is worth to take time to study the innards of these collection classes, as this is our go-to place for whenever we need to deal with fetching
a list of entities that match certain search criteria.

The Employee entity, as per requirements, is modeled as an EAV model.

Let's start by first creating an EAV model class, under the app/code/Foggyline/Office/Model/Employee.php:

namespace Foggyline\Office\Model;

class Employee extends \Magento\Framework\Model\AbstractModel
{
	const ENTITY = 'foggyline_office_employee';

	public function _construct()
	{
		$this-> _init('Foggyline\Office\Model\ResourceModel\Employee');
	}
}

Next, we create a EAV model resource class, defined under the app/code/Foggyline/Office/Model/ResourceModel/Employee.php:

namespace Foggyline\Office\Model\ResourceModel;

class Employee extends \Magento\Eav\Model\Entity\AbstractEntity
{
	protected function _construct()
	{
		$this->_read =
'foggyline_office_employee_read';
		$this->_write =
'foggyline_office_employee_write';
	}

	public function getEntityType()
	{
		if (empty($this_type)) {
			$this->setType(\Foggyline\Office\Model\Employee::ENTITY); //sets the _type value to \Foggyline\Office\Model\Employee::ENTITY , which is the
			//string foggyline_office_employee

			//This same value is what is stored in the eav_entity_type table. Currently, there is no such entry in that table. But our
			//install schema script will create one, as we will showcase soon.
		}
		return parent::getEntityType();
	}
}

Lastly, we create our collection class: //NOTE: all of the classes have so far been defined partially
We define this in the app/code/Foggyline/Office/Model/ResourceModel/Employee/Collection.php:

namespace Foggyline\Office\Model\ResourceModel\Employee;

class Collection extends \Magento\Eav\Model\Entity\Collection\AbstractCollection
{
	protected function _construct()
	{
		$this->_init('Foggyline\Office\Model
\Employee', 'Foggyline\Office\Model\ResourceModel\Employee');
	}
}

The collection class extends from \Magento\Eav\Model\Entity\Collection\AbstractCollection.

The AbstractCollection has the same parent tree as the simple model collection class, but on it's own, implements
a lot of EAV collection-specific methods like addAttributeToFilter, addAttributeToSelect, addAttributeToSort etc.

The EAV models look a lot like simple models, the difference being in that resource class and collection class implementations and their first level parent classes.
However, we need to keep in mind that the example given here is the simplest one possible. If we look at eav_entity_type table in the DB, we
can see that the other entities types makes use of attribute_model, entity_attribute_collection, increment_model and so on.

These are all advanced props we can define along with our EAV model, making it closer to the implementation of the catalog_product entity type, which is probably the most
robust one in Magento. This type of advanced EAV is out of the scope for this book, as the subject is too big.

Now that we have simple and EAV models in place, it is time to look into installing the necessary DB schema and possibly pre-fill it with some data.
We do this through schemas and Data scripts.

To put it simple, the role of the Schema scripts is to create a DB structure supporting your module logic. For example,
create a table where our entities would persist their data. The role of the data scripts is to manage the data within existing tables, usually
in the form of adding some sample data during module installation.

if we look a few steps back, we can see how schema_version and data_version from the DB match the setup_version number from our module.xml file.

If we now, were to change the setup_version in our module.xml, and then run php bin/magento setup:upgrade, our schema_version and data_version would 
update to reflect the new number.

it is done by the virtue of install and upgrade scripts. If we take a quick look at the setup/src/Magento/Setup/Model/Installer.php file, we can see a function
getSchemaDataHandler with content as follows:

NOTE: The :: is a operator refereing self or Parent parameters or static params in Classes outside of the class, and the . operator is just string concatenation

private function getSchemaDataHandler($moduleName, $type)
{
	$className = str_replace('_', '\\', $moduleName) . '\Setup'; //Run a regex to replace _ with \ for folder structure in $moduleName
	switch ($type) { //Run a switch based on what is being called
		case 'schema-install': //case we want to install schemas
			$className .= '\InstallSchema'; //append installschema to the class name
			$interface = self::SCHEMA_INSTALL; //assign interface to be the calling of schema_install in self
			break;
		case 'schema-upgrade':
			$className .= '\UpgradeSchema';
			$interface = self::SCHEMA_UPGRADE;
			break;
		case 'schema-recurring':
			$className .= '\Recurring';
			$interface = self::SCHEMA_INSTALL;
			break;
		case 'data-install':
			$className .= '\InstallData';
			$interface = self::DATA_INSTALL;
			break;
		case 'data-upgrade':
			$className .= '\UpgradeData';
			$interface = self::DATA_UPGRADE;
			break;
		default:
			throw new \Magento\Setup\Exception("$className does not exist");
	}

	return $this->createSchemaDataHandler($className, $interface); //return whatever the case is against
}

For the first time that we run the php bin/magento setup:upgrade against our module, while it still has no entries under the setup_module table,
it would execute the files within the module Setup folder in the following order:

InstallSchema.php

UpgradeSchema.php

InstallData.php

UpgradeData.php

This is the same order as the case matching in the getSchemaDataHandler

Every call there after, would instead run against upgrade cases:

php bin/magento setup:upgrade

UpgradeSchema.php

UpgradeData.php 

In addition, Magento would record the upped version number under the setup_module DB. Magento will only trigger install or upgrade scripts when the
version number in the DB is less than the version number in the module.xml file

We are actually not required to always provide these installs or upgrade scripts, if ever. They are only needed when we need to add or edit existing tables
or entries in a DB.

If we look carefully, at the implementation of the install and update methods within the appropiate scripts, we can see they both accept ModuleContextInterface $context
as a second parameter. Since upgrade scripts are the ones triggering on every upped version number, we can use $context->getVersion() to target changes specific
to the module version.

Next up, we create an install schema script (InstallSchema.php)

To assemble the actual callings to InstallSchema etc., we begin by defining the content in the app/code/Foggyline/Office/Setup/InstallSchema.php as follows: (PARTIAL CONTENT)

namespace Foggyline\Office\Setup;

use Magento\Framework\Setup\InstallSchemaInterface;
use Magento\Framework\Setup\ModuleContextInterface;
use Magento\Framework\Setup\SchemaSetupInterface;

class InstallSchema implements InstallSchemaInterface
{
	public function install(SchemaSetupInterface $setup, ModuleContextInterface $context)
	{
		$setup->startSetup();
		/* #snippet1 */
		$setup->endSetup();
	}
}

If we were to look through the code base, we can see that Magento\Setup\Module\Setup is the one extending \Magento\Framework\Module\Setup
and implementing the SchemaSetupInterface.

This is the base skeleton, all we gotta do now, is add tables and rows that we need. WE will replace the snippet1, with the table creation parts, as follows:

$table = $setup->getConnection()

 ->newTable($setup->getTable('foggyline_office_department')) //make a table, get it, add columns, add  vvalues for respective table as per SQL
 	->addColumn(
 		'entity_id',
 		\Magento\Framework\DB\Ddl\Table::TYPE_INTEGER,
 		null,
 		['identity' => true, 'unsigned' => true, 'nullable' => false, 'primary' => true], 
 		'Entity ID'
 	)
 	->addColumn(
 		'name',
 		\Magento\Framework\DB\Ddl\Table::TYPE_TEXT,
 		64,
 		[],
 		'Name'
 	)
 	->setComment('Foggyline Office Department Table');
 	$setup->getConnection()->createTable($table);
 	/* #snippet2 */

The accepted values in the addColumn is as per expected:

boolean, smallint, integer, bigint, float, numeric, decimal, date, timestamp, datetime, text, blob, varbinary

The additional options array, may contain the following:

unsigned, precision, scale, unsigned, default, nullable, primary, identity, auto_increment

Next up, is creating the table for Employee entity as well, to which we replace snippet2:

$employeeEntity = \Foggyline\Office\Model\Employee::ENTITY;
$table = $setup->getConnection()
	->newTable($setup->getTable($employeeEntity . '_entity'))
	->addColumn(
		'entity_id',
		\Magento\Framework\DB\Ddl\Table::TYPE_INTEGER,
		null,
		['identity' => true, 'unsigned' => true, 'nullable' => false, 'primary' => true],
		'Entity ID'
	)
	->addColumn(
		'department_id',
		\Magento\Framework\DB\Ddl\Table::TYPE_INTEGER,
		null,
		['unsigned' => true, 'nullable' => false],
		'Department Id'
	)
	->addColumn(
		'email',
		\Magento\Framework\DB\Ddl\Table::TYPE_TEXT,
		64,
		[],
		'Email'
	)
	->addColumn(
		'first_name',
		\Magento\Framework\DB\Ddl\Table::TYPE_TEXT,
		64,
		[],
		'First Name'
	)
	->addColumn(
		'last_name',
		\Magento\Framework\DB\Ddl\Table::TYPE_TEXT,
		64,
		[],
		'Last Name'
	)
	->setComment('Foggyline Office Employee Table');
$setup->getConnection()->createTable($table);
/* #snippet3 */

We might notice that if every employee can be assigned a single department, perhaps we should add a foreign key to this table's department_id column.
For the moment, we will knowingly skip this - as we want to demonstrate this through the update schema script later on.

EAV models scatter their data across several tables, three at a minimum. The table foggyline_office_employee_entity that we just created, is one of them.

The other one, is the core Magento eav_attribute table.

The third one, is not a single table, but rather a list of multiple tables: one for each EAV type. The tables are a result of our install script.

Information stored within the core Magento eav_attribute table is not the value of an attribute or anything like it; information stored there
is an attribute's metadata. So how does Magento know about our employees attributes, such as service_years, dob, salary, vat_number etc.?

It does not. Not yet. We need to add these attributes into that table ourselves. which we will do, later, in the InstallData.

Depending on the EAV attribute data type, we need to create the following tables:

foggyline_office_employee_entity_datetime

foggyline_office_employee_entity_decimal

foggyline_office_employee_entity_int

foggyline_office_employee_entity_text

foggyline_office_employee_entity_varchar

The general formula to use, is thus: {name of the entity table} + {_} + {eav_attribute.backend_type value}. For example, if we need a decimal:

foggyline_office_employee_entity_decimal

Now, we go to replace the snippet3 with adding the relevant values:

$table = $setup->getConnection()
	->newTable($setup->getTable($employeeEntity . '_entity_decimal')) //Just get the name of the table by accessing the entity of the employeee and concatenate it to create the table
	->addColumn(
		'value_id',
		\Magento\Framework\DB\Ddl\Table::TYPE_INTEGER,
		null,
		['identity' => true, 'nullable' => false, 'primary' => true],
		'Value ID'
	)
	->addColumn(
		'attribute_id',
		\Magento\Framework\DB\Ddl\Table::TYPE_SMALLINT,
		null,
		['unsigned' => true, 'nullable' => false, 'default' => '0'],
		'Attribute ID'
	)
	->addColumn(
		'store_id',
		\Magento\Framework\DB\Ddl\Table::TYPE_SMALLINT,
		null,
		['unsigned' => true, 'nullable' => false, 'default' => '0'],
		'Store ID'
	)
	->addColumn(
		'entity_id',
		\Magento\Framework\DB\Ddl\Table::TYPE_INTEGER,
		null,
		['unsigned' => true, 'nullabe' => false, 'default' => 0],
		'Entity ID'
	)
	->addColumn(
		'value',
		\Magento\Framework\DB\Ddl\Table::TYPE_DECIMAL,
		'12,4',
		[],
		'Value'
	)
	//->addIndex
	//->addForeignKey
	->setComment('Employee Decimal Attribute Backend Table');
$setup->getConnection()->createTable($table);

We then go to implement the addIndex part:

->addIndex(
	$setup->getIdxName(
		$employeeEntity . '_entity_decimal',
		['entity_id', 'attribute_id', 'store_id'],
		\Magento\Framework\DB\Adapter
\AdapterInterface::INDEX_TYPE_UNIQUE
	),
	['entity_id', 'attribute_id', 'store_id'],
	['type' => \Magento\Framework\DB\Adapter
\AdapterInterface::INDEX_TYPE_UNIQUE]
)
->addIndex(
	$setup->getIdxName($employeeEntity .
'_entity_decimal', ['store_id']),
 	['store_id']
)
->addIndex(
	$setup->getIdxName($employeeEntity . 
'_entity_decimal', ['store_id']),
	['store_id']
)
->addIndex(
	$setup->getIdxName($employeeEntity .
'_entity_decimal', ['attribute_id']),
	['attribute_id']
)

The preceeding code adds three indexes on the foggyline_office_employee_entity_decimal table, resulting in a SQL as follows:

UNIQUE KEY
'FOGGYLINE_OFFICE_EMPLOYEE_ENTT_DEC_ENTT_ID_ATTR_ID_STORE_ID'
('entity_id', 'attribute_id', 'store_id')

KEY
'FOGGYLINE_OFFICE_EMPLOYEE_ENTITY_DECIMAL_STORE_ID' 
('store_id')

KEY
'FOGGYLINE_OFFICE_EMPLOYEE_ENTITY_DECIMAL_ATTRIBUTE_ID'
('attribute_id')

Simlarly, we will replace the ->addForeignKey part from the preceeding code:

->addForeignKey(
	$setup->getFkName(
		$employeeEntity . '_entity_decimal',
		'attribute_id',
		'eav_attribute',
		'attribute_id'
	),
	'attribute_id',
	$setup->getTable('eav_attribute'),
	'attribute_id',
	\Magento\Framework\DB\Ddl\Table::ACTION_CASCADE
)
->addForeignKey(
	$setup->getFkName(
		$employeeEntity . '_entity_decimal',
		'entity_id',
		$employeeEntity . '_entity',
		'entity_id'
	),
	'entity_id',
	$setup->getTable($employeeEntity . '_entity'),
	'entity_id',
	\Magento\Framework\DB\Ddl\Table::ACTION_CASCADE
)
->addForeignKey(
	$setup->getFkName($employeeEntity .
'_entity_decimal', 'store_id', 'store', 'store_id'),
	'store_id',
	$setup->getTable('store'),
	'store_id',
	\Magento\Framework\DB\Ddl\Table::ACTION_CASCADE
)

The preceeding code adds foreign keys to the foggyline_office_employee_entity_decimal table, resulting in the following SQL:

CONSTRAINT 'FK_D<tons of numbers>'
FOREIGN KEY ('entity_id') REFERENCES
'foggyline_office_employee_entity' ('entity_id')
ON DELETE CASCADE,

CONSTRAINT
'FOGGYLINE_OFFICE_EMPLOYEE_ENTITY_DECIMAL_STORE_I
D_STORE_STORE_ID' FOREIGN KEY ('store_id')
REFERENCES 'store' ('store_id') ON DELETE
CASCADE,

CONSTRAINT
'FOGGYLINE_OFFICE_EMPLOYEE_ENTT_DEC_ATTR_ID_EAV_A
TTR_ATTR_ID' FOREIGN KEY ('attribute_id')
REFERENCES 'eav_attribute' ('attribute_id') ON
DELETE CASCADE

Notice how we added the store_id column to our EAV attribute value
tables. Though our examples won't find use of it, it is a good practice to
use store_id with your EAV entities to scope the data for a possible
multi-store setup. To clarify further, imagine we had a multi-store
setup, and with EAV attribute tables set up as we have here, we can have
different values unique to each respective table - due to the entry being a combination of
entity_id, attribute_id and store_id columns

For performance and data integrity reasons, it is important to define indexes and foreign keys as per good database design practice.
We can do so within InstallSchema when defining new tables.

The next step, is to create the UpgradeSchema.php, which gets run immedeatly after an install Schema. We define upgrade schema
within the app/code/Foggyline/Office/Setup/UpgradeSchema.php :

namespace Foggyline\Office\Setup;

use Magento\Framework\Setup\UpgradeSchemaInterface;
use Magento\Framework\Setup\ModuleContextInterface;
use Magento\Framework\Setup\SchemaSetupInterface;

class UpgradeSchema implements UpgradeSchemaInterface
{
	public function ugpgrade(SchemaSetupInterface $setup, ModuleContextInterface $context)
	{
		$setup->startSetup();
			/* #snippet1 */
		$setup->endSetup();
	}
}

Since UpgradeSchema implements the UpgradeSchemaInterface, we must adhere to adding the upgrade function that accepts two parameters, namedly SchemaSetupinterface and
ModuleContextInterface.

This is very similar to InstallSchemaInterface, except for the method name.

The update method is run when this schema gets triggered. There, we would add any relevant code we might want to execute.

Next, we implement the FK:

$employeeEntityTable = \Foggyline\Office\Model\Employee::ENTITY. '_entity';
$departmentEntityTable = 'foggyline_office_department';

$setup->getConnection()
	->addForeignKey(
		$setup->getFkName($employeeEntityTable, 
'department_id', $departmentEntityTable,
'entity_id'),
		$setup->getTable($employeeEntityTable),
		'department_id',
		$setup->getTable($departmentEntityTable),
		'entity_id',
		\Magento\Framework\DB\Ddl
\Table::ACTION_CASCADE
	);

We instruct Magento to put the foriegn key on the foggyline_office_employee_entity table, more precisely on it's
department_id column, pointing to the foggyline_office_department table and it's entity_id column.

The next script we have to define, is the install data script, which is run instantly after the upgrade schema.

We define install data schema within the app/code/Foggyline/Office/Setup/InstallData.php:

namespace Foggyline\Office\Setup;

use Magento\Framework\Setup\InstallDataInterface;
use Magento\Framework\Setup\ModuleContextInterface;
use Magento\Framework\Setup\ModuleDataSetupInterface;

class InstallData implements InstallDataInterface
{
	private $employeeSetupFactory;

	public function __construct(
		\Foggyline\Office\Setup\EmployeeSetupFactory
$employeeSetupFactory
	)
	{
		$this->employeeSetupFactory = $employeeSetupFactory; //assign the SetupFactory to the respective Employee entity
	}

	public function install(ModuleDataSetupInterface $setup, ModuleContextInterface $context)
	{
		$setup->startSetup();
		/* #snippet1 */
		$setup->endSetup();
	}
}

The install mmethod gets triggered when this script is run, this is where we add our code. By now, the setup should be familiar, passing in params from the INterfaces refering to
setup and context.

We replace snippet1 with the following:

$employeeEntity = \Foggyline\Office\Model\Employee::ENTITY;

$employeeSetup = 
$this->employeeSetupFactory->create(['setup' => $setup]);

$employeeSetup->installEntities();

$employeeSetup->addAttribute(
	$employeeEntity, 'service_years', ['type' => 'int']
);

$employeeSetup->addAttribute(
	$employeeEntity, 'dob', ['type' => 'datetime']
);

$employeeSetup->addAttribute(
	$employeeEntity, 'salary', ['type' => 'decimal']
);

$employeeSetup->addAttribute(
	$employeeEntity, 'vat_number', ['type' => 'varchar']
);

$employeeSetup->addAttribute(
	$employeeEntity, 'note', ['type' => 'text']
);

So what we did, is that we simply run setup for the employee and addAttributes as nessecary upon running the factory for each relevant thing.

We will soon get to the innards of the employeeSetupFactory, but right now, notice the call to the addAttribute method. Within this method,
there is a call to the $this->attributeMapper->map($attr, $entityTypeId) method. the attributeMapper conforms to Magento\Eav\Model\Entity\Setup\PropertyMapperInterface,
which looking at vendor/magento/module-eav/etc/di.xml has a preference for the Magento\Eav\Model\Entity\Setup\PropertyMapper\Composite class,
which in turn, initializes the following things:

Magento\Eav\Model\Entity\Setup\PropertyMapper

Magento\Customer\Model\ResourceModel\Setup\PropertyMapper

Magento\Catalog\Model\ResourceModel\Setup\PropertyMapper

Magento\ConfigurableProduct\Model\ResourceModel\Setup\PropertyMapper

Since we are defining our own entity types, the mapper class we are interested in is in Magento\Eav\Model\Entity\Setup\PropertyMapper.

A look inside, reveals the following:

[
	'backend_model' => 'backend',
	'backend_type' => 'type',
	'backend_table' => 'table',
	'frontend_model' => 'frontend',
	'frontend_input' => 'input',
	'frontend_label' => 'label',
	'frontend_class' => 'frontend_class',
	'source_model' => 'source',
	'is_required' => 'required',
	'is_user_defined' => 'user_defined',
	'default_value' => 'default',
	'is_unique' => 'unique',
	'note' => 'note'
	'is_global' => 'global'
]

Looking at the preceeding array keys and value strings gives us a clue to as what is happening. The key strings match the column
names in the eav_attribute table, while the value strings match the keys of our array passed to the addAttribute method within InstallData.php

Next up, we take a look at the EmployeeSetupFactory class within the app/code/Foggyline/Office/Setup/EmployeeSetup.php file:

namespace Foggyline\Office\Setup;
use Magento\Eav\Setup\EavSetup;

class EmployeeSetup extends EavSetup
{
	public function getDefaultEntities()
	{
		/* #snippet1 */
	}
}

As per normal, the structure is what we expect.

We are extending from the Magento\Eav\Setup\EavSetup class, thus effectively telling Magento we are about to create our own entity. We do so by
overriding getDefaultEntities, replacing the /* #snippet1 */ with content as follows:

$employeeEntity = \Foggyline\Office\Model\Employee::ENTITY;
$entities = [
	$employeeEntity => [
		'entity_model' => 'Foggyline\Office\Model\ResourceModel\Employee',
		'table' => $employeeEntity . '_entity',
		'attributes' => [
			'department_id' => [
				'type' => 'static',
			],
			'email' => [
				'type' => 'static',
			],

			'first_name' => [
				'type' => 'static',
			],
			'last_name' => [
				'type' => 'static',
			],
		],
	],
];
return $entities;

The entire thing we just wrote, comes to become the getDefaultEntities(), which returns an array of entities we
want to register with Magento. Within our $entities array, the key $employeeEntity becomes an entry in the eav_entity_type table.
Given that our $employeeEntity has a value of foggyline_office_employee, running the following SQL query should yield a result:

SELECT * FROM eav_entity_type WHERE entity_type_code = "foggyline_office_employee";

Only a handful of metadata values are required to make our new entity type functional. The entity_model value should point to our EAV
model resource class, not the model class. The table value should equal the name of our EAV entity table in the DB. Finally, the attributes
array should list any attribute we want created on this entity.

Attributes and their metadata get created in the eav_attribute table.

If we look back at all thoose foggyline_office_employee_entity_* attribute value tables we created, they are not the ones that actually 
create attributes or register a new entity type in Magento. What creates attributes and a new entity type is the array we just
defined under the getDefaultEntities method. Once Magento creates the attributes and registers a new entity type, it simply
routes the entity save process to proper attribute value tables depending on the type of attirbute.

Next up, of course, in our line and quest to complete these bloody populating scripts, comes the UpgradeData.php.

This is the last one to execute, and we will use it to demonstrate the example of creating the sample entries for our
Department and Employee entities.

We start by creating the app/code/Foggyline/Office/Setup/UpgradeData.php file with the partial content to begin with as follows:

namespace Foggyline\Office\Setup;

use Magento\Framework\Setup\UpgradeDataInterface;
use Magento\Framework\Setup\ModuleContextInterface;
use Magento\Framework\Setup\ModuleDataSetupInterface;

class UpgradeData implements UpgradeDataInterface
{
	protected $departmentFactory;
	protected $employeeFactory;

	public function __construct(
		\Foggyline\Office\Model\DepartmentFactory
$departmentFactory,
		\Foggyline\Office\Model\EmployeeFactory
$employeeFactory
		)
		{
			$this->departmentFactory = 
$departmentFactory;
			$this->employeeFactory = $employeeFactory;
		}

		public function upgrade(ModuleDataSetupInterface $setup, ModuleContextInterface $context)
		{
			$setup->startSetup();
			/* snippet1 */
			$setup->endSetup();
		}
}

Since it implements the interface of UpgradeDataInterface, we of course put in the methods that co-respond.

We also use the construct to pass in the values of departmentFactory and employeeFactory to account for when we are handling updating these values.

The next part, is to account for that we implement the upgrade method, as follows:

$salesDepartment =
$this->departmentFactory->create();
$salesDepartment->setName('Sales');
$salesDepartment->save();

$employee = $this->employeeFactory->create();
$employee->setDepartmentId($salesDepartment->getId());
$employee->setEmail('john@sales.loc');
$employee->setFirstName('John');
$employee->setLastName('Doe');
$employee->setServiceYears(3);
$employee->setDob('1983-03-28');
$employee->setSalary(3800.00);
$employee->setVatNumber('GB123456789');
$employee->setNote('Just some notes about John, lol');
$employee->save();

The preceeding code creates an isntance of the department entity and then saves it. An instance of employee is also created and saved, passing it
the new the newly created Department ID and other attrs.

A more convinient and professional-looking approach for saving an entity could be given as follows:

$employee->setDob('1983-03-28')
	->setSalary(3800.00)
	->setVatNumber('GB123456789')
	->save();

Here, we utilize a trick, which is that each setter returns the entity instance, thus we can chain the calls given that we get the value returned each time so we jsut update the values as they come along and then save it.

So far, we have learned to as of how to create a simple model, an EAV model, and install and upgrade types of schema and data script. Now,
let us see how we can create, read, update and delete our entities, operations that are commonly refered to as being the CRUD. (Create, Read, update, delete)

Though this book chapter is about models, collections and related things, for the purpose of demonstration, let's make a tiny detour into routes
and controllers. The idea is to create a simple Test controller with the Crud action we can trigger in the browser via a URL. Within this CRUD aciton, we will
then dump our CRUD-related code.

To make Magento respond to the URL we punch into the browser, we need to define the route. We do so by creating the app/code/Foggyline/Office/etc/frontend/routes.xml file
with the following content:

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:noNamespaceSchemaLocation="urn:magento:framework:App/etc/routes.xsd">
	<router id="standard">
		<route id="foggyline_office" frontName="foggyline_office">
			<module name="Foggyline_Office"/>
		</route>
	</router>
</config>

Route definition requires an unique ID and frontName attribute values, which in our case both equal foggyline_office. The frontName
attribute value becomes part of our URL structure. Simply put, the URL formula for hitting the Crud action goes like {magento-base-url}/index.php/{route frontName}/{controller name}/{action name}.

For example, if our URL was named like http://shop.loc/, the full URL would be http://shop.loc/index.php/foggyline_office/test/crud/.

If we had URL rewrite turned on, we would omit the index.php part.

Once the route has been defined, we can go ahead and create the Test controller, defined in the app/code/Foggyline/Office/Controller/Test.php file: (partial code)

namespace Foggyline\Office\Controller;

abstract class Test extends \Magento\Framework\App\Action\Action
{
	
}



This is a empty controller that is the simplest form of a controller we could do. It needs to be defined as abstract and extends the \Magento\Framework\App\Action\Action
class. Controller actions live outside of the controller itself and can be found under the subdir on the same level and named as controller.

Since our controller is called Test, we place our Crud action under the app/code/Foggyline/Office/Controller/Test/Crud.php file with content as follows:

namespace Foggyline\Office\Controller\Test;

class Crud extends \Foggyline\Office\Controller\Test
{
	protected $employeeFactory;
	protected $departmentFactory;

	public function __construct(
		\Magento\Framework\App\Action\Context $context,
		\Foggyline\Office\Model\EmployeeFactory $employeeFactory,
		\Foggyline\Office\Model\DepartmentFactory $departmentFactory
	)

	{
		$this->employeeFactory = $employeeFactory;
		$this->departmentFactory = $departmentFactory;
		return parent::__construct($context);
	}

	public function execute()
	{
		/* CRUD GOES HERE ; DUNK IT! */
	}
}

The Controller action class is basically just an extension of the controller defining the execute method. Code within the execute
method is what gets run when we hit the URL in the browser. (duh)

Additionaly, we have a __construct method to which we are passing the EmployeeFactory and DepartmentFactory classes, which we will 
soon use for our CRUD examples. Note that EmployeeFactory and DepartmentFactory are not classes created by us. Magento will autogenerate
them under the DepartmentFactory.php and EmployeeFactory.php files within the var/generation/Foggyline/Office/Model folder.

These are factory classes for our Employee and Department model classes, generated when requested.

With this, we finish our little detour and focuys back on entitites.

There are three different flavors, if we might call them that. by which we can set property (field and attribute) values on our entity.

They all lead to the same result. The following few code snippets can be copied and pasted in our Crud class execute method for testing,
simply by replacing /* CRUD CODE HERE */ with one of the following code snippets:

//Simple model, creating new entities, flavour #1
$department1 = $this->departmentFactory->create();
$department1->setName('Finance');
$department1->save();

//SImple model, creating new entitties, flavour #2
$department2 = $this->departmentFactory->create();
$department2->setData('name', 'Research');
$department2->save();

//Simple model, creating new entities, falvour #3
$department3 = $this->departmentFactory->create();
$department3->setData(['name' => 'Support']);
$department3.save();

The flavour#1 above, is probably to be preffered to be use, as it allows us to refer to the older model we had with inherited gettersa nd setters from the Obejct supertype.

Both flavour#2 and flavour#3 use the setData method, just in a slightly different manner. All three examples should yield the same result once the save method is
called on an object instance.

The difference being that in falvour 2, we use the setData to access the stuff to the Object, where as of flavour3 we map the values in the object by passing am apping into
setData

Now that we know our simple model, let's take a quick look at doing the same with the EAV model. The following are analogous code snippets:

//EAV model, creating new entities, flavour #1 //jsut create a factory instance, then just run all the setters on that entity and then save it
$employee1 = $this->employeeFactory->create();
$employee1->setDepartment_id($department1->getId());
$employee1->setEmail('goran@mail.loc');
$employee1->setFirstName('Goran');
$employee1->setLastName('Gorvat');
$employee1->setServiceYears(3);
$employee1->setDob('1984-04-18');
$employee1->setSalary(3800.00);
$employee1->setVatNumber('GB123451234');
$employee1->setNote('Note #1');
$emmploye1->save();

//EAV model, creating new entities, flavour #2
$employee2 = $this->employeeFactory->create();
$employee2->setData('department_id', 
$department2->getId());
$employee2->setData('email', 'marko@mail.loc');
$employee2->setData('first_name', 'Marko');
$employee2->setData('last_name', 'TurkonovoIshc?');
$employee2->setData('service_years', 3);
$employee2->setData('dob', '1984-04-18');
$employee2->setData('salary', 3800.00);
$employee2->setData('vat_number', 'GB12345Gb1234');
$employee2->setData('note', 'Note #2');
$employee2->save();

//EAV model, creating new entities, flavour #3
$employee3 = $this->employeeFactory->create();
$employee3->setData([
	'department_id' => $department3->getId(),
	'email' => 'ivan@mail.loc',
	'first_name' => 'Ivan',
	'last_name' => 'Telebar',
	'service_year' => 2,
	'dob' => '1986-08-22',
	'salary' => 2400.00,
	'vat_number' => 'GB123454321',
	'note' => 'Note #3'
]);
$employee3->save();

As we can see, the EAV code for persisting the Data is identical to the simple model. There is one thing here worth noting. The Employee
entity has a relation defined toward department. Forgetting to specify department_id on a new emplyoee entity save would result in
an error akin to the following:

SQLSTATE[23000]: Integrity constraint violation: 1452
Cannot add or update a child row: a foreign key constraint fails
('magento'.'foggyline_office_employee_entity',
CONSTRAINT 'FK_<numbers lol>'
FOREIGN KEY ('deparment_id') REFERENCES
'foggyline_office_department' ('entity_id') ON),
query was: INSERT INTO
'foggyline_office_employee_entity' ('email',
'first_name', 'last_name', 'entity_id') VALUES (?, ?, ?, ?)

We can find the failure of foreign key dependance error in the same dir as where all the SQL errors go in Magento:

in the var/report dir

Reading an entity based on a provided entity ID value comes down to instansiating the entity and using load method to which we pass 
the entity ID as shown next:

//Simple model, reading existing entities
$department = $this->departmentFactory->create();
$department->load(28);

/*
	\Zend_Debug.:dump($department->toArray());

	array(10) {
		["entity_id"] => string(2) "25"
		["department_id"] => string(2) "28"
		["email"] => string(14) "marko@mail.loc"
		["first_name"] => string(5) "Marko"
		["last_name"] => string(9) "Tunukovic"
		["dov"] => string(19) "1984-04-18 00:00:00"
		["note"] => string(7) "Note #2"
		["salary"] => string(9) "3800.0000"
		["service_years"] => string(1) "3"
		["vat_number"] => string(11) "GB123451234"
	}
*/

Notice how the EAV entity loads all of its field and attribute values,
which is not always the case when we obtain the entity through EAV collection,
as we will show later on.

To update existing entities, we simply run load method, reset the value of a variable and save it. An example follows:

$department = $this->departmentFactory->create();
$department->load(28);
$department->setName('Finance #2');
$department->save();

Regardless if the target is a simple model or a EAV model, the code looks the same.

To delete existing entries, we simply load and delete:

$employee = $this->employeeFactory->create();
$employee->load(25);
$employee->delete();

Again, there is no differential between simple model entities and EAV models entities.

However, if we try to delete or loading stuff that does not exist etc., it will crash, due to exceptions, thus, we should run try and catch
to compensate for the fact of handling said error.

Next up, we are going to work with EAV model collections. They can be instansiated by the Factory class or use a object manager for it.
We begin with the factory example:

$collection = $this->employeeFactory->create()->getCollection();

And then, the object manager:

$collection = $this->_objectManager->create('Foggyline\Office\Model\ResourceModel\Employee\Collection's); //Create a dir for the collections with a obj manager

There is a third way, that would require defining APIs, that we would prefer, but we won't show that atm.

We then instansiate the collection object and perform dumps on it:

foreach ($collection as $employee) {
	\Zend_Debug::dump($employee->toArray(), '$employee');
}

Thsi would give the result as follows:

$employee array(5) {
	["entity_id"] => string(2) "24"
	["department_id"] => string(2) "27"
	["email"] => string(14) "goran@mail.loc"
	["first_name"] => string(5) "Goran"
	["last_name"] => string(6) "Gorvat"
}

We can then observe that the employee in question only has fields, not the attributes themselves. 

If we wanted to give the attributes as well, we map them to the collection:

$collection->addAttributeToSelect('salary')
		   ->addAttributeToSelect('vat_number');

The preceeding code would give the result:

$emplyoee array(7){
	["entity_id"] => string(2) "24"
	["department_id"] => string(2) "27"
	["email"] => string(14) "goram@mail.loc"
	["first_name"] => string(5) "Goran"
	["last_name"] => string(6) "Gorvat"
	["salary"] => string(9) "3800.0000"
	["vat_number"] => string(11) "GB123451234"
}

However, this is flawed, if we wish to add many attributes at once - we have to use the * notation, to import and assign all attributes:

$collection->addAttributeToSelect('*');

$employee array(10) {
	["entity_id"] => string(2) "24"
	["department_id"] => string(2) "27"
	["email"] => string(14) "goran@mail.loc"
	["first_name"] => string(5) "Goran"
	["last_name"] => string(6) "Gorvat"
	["dob"] => string(19) "1984-04-18 00:00:00"
	["note"] => string(7) "Note #1"
	["salary"] => string(9) "3800.0000"
	["service_years"] => string(1) "3"
	["vat_number"] => string(11) "GB123451234" 
}

Whilst it looks deceptively easy, the underlying SQL is actually complex. We will look at the three last queries, even if several are made before that:

SELECT COUNT(*) FROM 'foggyline_office_employee_entity' AS 'e'

SELECT 'e'.* FROM 'foggyline_office_employee_entity' AS 'e'

SELECT 'foggyline_office_employee_entity_datetime'.'entity_id', 'foggyline_office_employee_entity_datetime'.'attribute_id',
		'foggyline_office_employee_entity_datetime'.'value'
		FROM 'foggyline_office_employee_entity_datetime' WHERE (entity_id IN (24, 25, 26)) AND (attribute_id IN ('349')) UNION ALL SELECT

 'foggyline_office_employee_entity_text'.'entity_id','foggyline_office_employee_entity_text'.'attribute_id',
 'foggyline_office_employee_entity_text'.'value' FROM 'foggyline_office_employee_entity_text' WHERE (entity_id IN (24, 25, 26)) AND (attribute_id IN ('352')) UNION
 SELECT ALL

This carries on for some time, with slight differations of values. What is important, is not the pinpoint code, as what we need to learn from this is the Queries logic in a abstract manner so that we can apply this on ah igh level later on. The reaosn we cannot just copy paste it, is because we have to actually account for the fact that it will differ from installation to installation.

Further more, it is to explain what occurs on the SQL layer level of collections, when we handle the Magento level of collections and interact there of.

To account for resource intensity of loading from DBs, we have to account for possible bottleneckes in terms of loading Data. Thus we will use pagination to account for how many pages we are loading in:

$collection->addAttributeToSelect('*')
		   ->setPageSize(25)
		   ->setCurPage(5);

This would lead to the count statement being the same, but the other query would be changed, as follows:

SELECT 'e'.* FROM 'foggyline_office_employee_entity' AS 'e' LIMIT 25 OFFSET 4

The next step, is to further filter down the Queries so that we don't run PHP loops over the same items, mutliple times. What follows, is a clean
setup of starting the filtering of collections:

$collection = $this->_objectManager->create('Foggyline\Office\Model\ResourceModel\Employee\Collection');

$collection->addAttributeToSelect('*')
		   ->setPageSize(25)
		   -setCurPage(1);

$collection->addAttributeToFilter('email',
array('like'=> '%mail.loc%'))
		   ->addAttributeToFilter('vat_number',
array('like'=> 'GB%'))
		   ->addAttributeToFilter('salary',
array('gt'=>2400))
		   ->addAttributeToFilter('service_years',
array('lt'=>10));

What addAttriubteToFilter will do, is cause transformations of the SQL queries to become akin to Joins instead:

SELECT COUNT(*)
FROM 'foggyline_office_employee_entity' AS 'e' 
	INNER JOIN
'foggyline_office_employee_entity_varchar' AS
'at_vat_number'
	ON ('at_vat_number'.'entity_id' =
'e'.'entity_id') AND ('at_vat_number'.'attribute_id'
= '351')
	INNER JOIN
'foggyline_office_employee_entity_decimal' AS 
'at_salary'
	ON ('at_salary'.'entity_id' = 'e'.'entity_id')
AND ('at_salary'.'attribute_id' = '350')
	INNER JOIN 'foggyline_office_employee_entity_int'
AS 'at_service_years'
	ON ('at_service_years'.'entity_id' = 
'e'.'entity_id') AND
('at_service_years'.'attribute_id' = '348')
WHERE ('e'.'email' LIKE '%mail.loc%') AND
(at_vat_number.value LIKE 'GB%') AND (at_salary.value
> 2400) AND
		(at_service_years.value < 10)

So, this is a lot more complicated than the count query.

However, we have 4 addAttributeToFilter method calls, but only three INNER JOIN. This is because
one of thoose four calls is for e-mail, which is not an attribute but a field within the foggyline_office_employee_entity table,
meanign we don't need to inner join, because it's already there.

The second query also becomes more robust, as shown below:

SELECT 'e'.*,
	'at_vat_number'.'value' 	AS 'vat_number',
	'at_salary'.'value' 		AS 'salary',
	'at_service_years'.'value' 	AS 'service_years'
FROM 'foggyline_office_employee_entity' AS 'e'
	INNER JOIN
'foggyline_office_employee_entity_varchar' AS 
'at_vat_number'
	ON ('at_vat_number'.'entity_id' =
'e'.'entity_id') AND ('at_vat_number'.'attribute_id'
= '351')
	INNER JOIN
'foggyline_office_employee_entity_decimal' AS
'at_salary'
	ON ('at_salary'.'entity_id' = 'e'.'entity_id')
AND ('at_salary'.'attribute_id' = '350')
	INNER JOIN 'foggyline_office_employee_entity_int'
AS 'at_service_years'
	ON ('at_service_years'.'entity_id' = 
'e'.'entity_id') AND
('at_service_years'.'attribute_id' = '348')
WHERE ('e'.'email' LIKE '%mail.loc%') AND
 (at_vat_number.value LIKE 'GB%') AND (at_salary.value
 > 2400) AND
 		(at_service_years.value < 10)
LIMIT 25

Again, the same pattern with the joins.

The rest is just flattened piece of rows where the attributes vat_number, salary and service_years are present.

We can imagine the performancei mpact if we did not use setPageSize to acheive pagination.

As for the third and last query, it gets affected as follows:

SELECT 
	'foggyline_office_employee_entity_datetime'.'entity_id',
	'foggyline_office_employee_entity_datetime'.'attribute_id',
	'foggyline_office_employee_entity_datetime'.'value' 
	FROM 'foggyline_office_employee_entity_datetime'
	WHERE (entity_id IN (24, 25) AND (attribute_id IN 
	('349'))
	UNION ALL SELECT

	'foggyline_office_employee_entity_text'.'entity_id',
				'foggyline_office_employee_entity_text'.'
attribute_id',

	'foggyline_office_employee_entity_text'.'value'
			FROM
'foggyline_office_employee_entity_text'
			WHERE (entity_id IN (24, 25)) AND
(attribute_id IN ('352'))

Since 3 out of 5 attributs have been pulled, all that we have left is 2 attributes to get, which means we can run a union on 2 out of 5.

Whilst this might seem like a great solution, we might wish to add SQL loggers to see logs of performances so that we can identify bottlenecks and errors in the performance of the code.

The preceeding code we had, had a AND setup. What if we wish to have a OR setup? Then we could do as follows:

$collection->addAttributeToFilter([
	['attribute'=>'salary', 'gt'=>2400],
	['attribute'=>'vat_number', 'like'=>'GB%']
]);

Without going into details of actual SQL queries, it suffices to say that they are near identical to the previous example with the AND condition use of
addAttributeToFilter

Using collection methods like addExpressionAttributeToSelect, groupByAttribute and addAttributeToSort, collections offer further gradient
filtering and even shift some calculations away from the PHP application to the SQL layer.

Getting the ins and outs of thoose, is out of scope for this book, and is a big subject.

Looking back at preceeding addAttributeToFilter method call examples, questions pop out as to where can we see the list of all 
available collection filters. If we take a quick look inside the vendor/magento/framework/DB/Adapter/Pdo/Mysql.php file,
we can see the method called prepareSqlCondition defined:

public function prepareSqlCondition($fieldName, $condition)
{
	$conditionKeyMap = [
		'eq' 			=> "{{fieldName}} = ?",
		'neq' 			=> "{{fieldName}} != ?",
		'like' 			=> "{{fieldName}} LIKE ?",
		'nlike' 		=> "{{fieldName}} NOT LIKE ?",

		'in' 			=> "{{fieldName}} IN(?)",
		'nin' 			=> "{{fieldName}} NOT IN(?)",
		'is' 			=> "{{fieldName}} IS ?",
		'notnull' 		=> "{{fieldName}} IS NOT NULL"

		'null' 			=> "{{fieldName}} IS NULL",
		'gt' 			=> "{{fieldName}} > ?",
		'lt' 			=> "{{fieldName}} < ?",
		'gteq' 			=> "{{fieldName}} >= ?",
		'lteq' 			=> "{{fieldName}} <= ?",
		'finset' 		=> "FIND_IN_SET(?, {{fieldName}})",
		'regexp' 		=> "{{fieldName}} REGEXP ?",
		'from' 			=> "{{fieldName}} >= ?",
		'to' 			=> "{{fieldName}} <= ?",
		'seq' 			=> null,
		'sneq' 			=> null,
		'ntoa' 			=> "INET_NTOA({{fieldName}}) LIKE ?",
	];

	$query = '';
	if (is_array($condition)) {
		$key = key(array_intersect_key($condition,
$conditionKeyMap));

	...
	}
}

This method is what is gets called during some point at SQL query construction. The $condition parameter
is expected to have one of the following forms: (partially listed)

array("from" => $fromValue, "to" => $toValue)
array("eq" => $equalValue)
array("neq" => $notEqualValue)
array("like" => $likeValue)
array("in" => array($inValues))
array("nin" => array($notInValues))

array("notnull" => $valueIsNotNull)
array("null" => $valueIsNull)
array("gt" => $greaterValue)
array("lt" => $lessValue)
array("gteq" => $greaterOrEqualValue)

array("lteq" => $lessOrEqualValue)
array("finset" => $valueInSet)
array("regexp" => $regularExpression)
array("seq" => $stringValue)
array("sneq" => $stringValue)

if $condition is passed as a int or string, then the exact value will be filtered ('eq' condition)

If none of the conditions is matched, then a sequential array is expected as a param and OR conditions will be built using
the preceeding structure

The preceeding examples covered EAV model collections, as they are slightly more complex. Though the approach to filtering more or less
applies to simple model collections as well, the most notable difference is that there are no addAttributeToFilter, addAttributeToSelect,
and addExpressionToSelect methods, amongst other subtle differences.

Dependecy injection, is a design pattern where one or more dependancies are injected or passed by reference into a object.
what this exactly means on a practical level is shown in the following examples:

public function getTotalCustomers()
{
	$database = new \PDO( ... );
	$statement = $database->query('SELECT ...');
	return $statement->fetchColumn();
}

The above is a simplified PHP example, where the $database object is created within the Method. This leads to tight
coupling which has several disadvantages: Not high resuability, tight dependancy on the Method, can cause wide system changes based on
small changes.

A solution is to avoid this practice, by virtue of injecting the object as a inpassing parameter instead:

public function getTotalCustomers($database)
{
	$statement = $database->query('SELECT ...');
	return $statement->fetchColumn();
}

This leads to loose coupling, meaning it's reuasble, not dependant, etc. This is the concept of Dependency injection. It's simple.

The concept is simple, but it may not be easy to implement in larger systems such as Magento.

Magento has it's own Object manager and dependency injection mechanism that we will look into in the following sections:

The object manager

Depdency injection

Configuring class preferences

Using virtual types

To follow and test the code examples given in the following sections, we can use the code available at <link>.
To install it, we simply need to download it and put it in the app/code/Foggyline/Di dir. then run the following set of commands on the console
within the Magento root dir:

php bin/magento module:enable Foggyline_Di
php bin/magento setup:upgrade
php bin/magento foggy:di

The last command can be used repeatedly when testing the snippets presented in the following section. When php bin/magento foggy:di is run, it will
run the code within the execute method in the DiTestCommand class. Therefor, we can use the __construct and execute methods from within
the DiTestCommand class and the di.xml file itself as a playground for DI.

The initalization of Objects in Magento, is done with something called the Object Manager. the Object Manager itself is an instance of the
Magento\Framework\ObjectManager\ObjectManager class that implements the Magento\Framework\ObjectManagerInterface class.

The ObjectManager class defines the following three methods:

create($type, array $arguments = []) //Create a new instance of a object

get($type) //retrieve a cached object instance

configure(array $configuration) //Configures the di instance

The object manager can instansiate a PHP class, which can be a model, helper or block object. Unless the class that we are working with has already
recieved an instance of the object manager, we can recieve it by passing ObjectManagerInterface into the class constructor, as ofllows:

public function __construct(
	\Magento\Framework\ObjectManagerInterface $objectManager)
{
	$this->_objectManager = $objectManager;
}

Usually, we don't take care of the constructor parameter's order in Magento. The following example will also enable us to fetch an
instance of the object manager:

public function __construct(
	$var1,
	\Magento\Framework\ObjectManagerInterface
$objectManager,
	$var2 = []
)
{
	$this->_objectManager = $objectManager;
}

Though we can still use plain old PHP to instansiate an object such as $object = new \Foggyline\Di\Model\Object(),
by using the object manager, we can take advantage of Magento's advanced object features such as automatic constructor depdendcy injection
and object proxying.

Here are a few examples of using object managers create method to create new objects:

$this->_objectManager->create('Magento\Sales\Model\Order')
$this->_objectManager->create('Magento\Catalog\Model\Product\Image')
$this->_objectManager->create('Magento\Framework\UrlInterface')
$this->_objectManager->create('SoapServer', ['wsdl' => $url, 'options' => $options])

The following, are a few examples of using Object manager's get method to create new Objects:

$this->_objectManager->get('Magento\Checkout\Model\Session')
$this->_objectManager->get('Psr\Log\LoggerInterface')->critical($e)
$this->_objectManager->get('Magento\Framework\Escaper')
$this->_objectManager->get('Magento\Sitemap\Helper\Data')

The object manager's create method always returns a new object instance, whilst the get returns a Singleton.

Note how some of the string parameters passed to create and get are actually interface names and not strictly class names. We will soon
see why this works with both class names and interface names. For now, it suffices to say that it's because of Magentos dependency injection implementation.

Until now, we have seen how the Object manager has control over the instansiation depdencies. However, by convention, the object manager is
not supposed to be used directly in Magento. Rather, it is to be used for system-level things that bootstrap Magento. We are encouraged
to use the module's etc/di.xml file to instansiate objects.

Let's dissect one of the existing di.xml entities, such as the one found under the vendor/magento/module-admin-notification/etc/adminhtml/di.xml file for
the Magento\Framework\Notification\MessageList type:

<type name="Magento\Framework\Notification\MessageList">
	<arguments>
		<argument name="messages" xsi:type="array">
			<item name="baseurl" xsi:type="string">
Magento\AdminNotification\Model\System\Message
\BaseUrl</item>
			<item name="security" xsi:type="string">
Magento\AdminNotification\Model\System\
Message\Security</item>
			<item name="cacheOutdated"
xsi:type="string"> Magento\AdminNotification\Model
\System\Message\CacheOutdated</item>
			<item name="media_synchronization_error"
xsi:type="string">Magento\AdminNotification\Model\
System\Message\Media\Synchronization\Error</item>
			<item
name="media_synchronization_success"
xsi:type="string">Magento\AdminNotification\Model\
System\Message\Media\Synchronization\Success</item>
		</argument>
	</arguments>
</type>

Basically, what that means, is that whenever an instance of Magento\Framework\Notification\MessageList is being
created, the messages parameter is passed on to the constructor. The messages parameter is being defined as an array,
which further consists of other string type items. In this case, values of these string type attributes are class names, as follows:

Magento\Framework\ObjectManager\ObjectManager
Magento\AdminNotification\Model\System\Message\Baseurl

Magento\AdminNotification\Model\System\Message\Security

Magento\AdminNotification\Model\System\Message\CacheOutdated

Magento\AdminNotification\Model\System\Message\Media\Synchronization\Error

Magento\AdminNotification\Model\System\Message\Media\Synchronization\Success

If you now take a look at the constructor of MessageList, you will see that it is defined in the following way:

public function __construct(
	\Magento\Framework\ObjectManagerInterface
$objectManager,
	$messages = []
)
{
	//body goes here
}

If we modify the MessageList constructor as follows, the code will work:

public function __construct(
	\Magento\Framework\ObjectManagerInterface
$objectManager,
	$someVarX = 'someDefaultValueX',
	$messages = []
)
{
	//body goes here
}

And after modification:

public function __construct(
	\Magento\Framework\ObjectManagerInterface
$objectManager,
	$someVarX = 'someDefaultValueX',
	$messages = [],
	$someVarY = 'someDefaultValueY'
)
{
	//Method body goes here
}

NOTE: The naming of the argumentsi n the constructor, MUST match the naming in the di.xml argument Listing. 

If we were to derivate, it will fail:

public function __construct(
	\Magento\Framework\ObjectManagerInterface
$objectManager,
	$Messages = [] //Writing anything but $messages = [] will give an error in this case, cause not matchign the di.xml naming
)
{
	//Will give an error, due to Messages deriving from actual listing in di.xml argument list
}

However, the ordering is kind of shit the same, as long as the names are identical in terms of Argument listing and the actual contents of the PHP.

Looking further in the MessageList constructor, if we execute func_get_args somewhere within it, the list of Items within the 
$messages parameter will match and exceed the one shown in vendor/magento/module-admin-notification/etc/adminhtml/di.xml

This is because the list is not final, as Magento converegs several parts of the DI defintions and merge them, from the entire platform.

Thus, if another Module is modifying the MessageList type, the modifications will be reflected.

If we perform a string search within all the di.xml files across the entire Magento code base for <type name="Magento\Framework\Notification\MessageList">,
this will yield some additional di.xml files that have their own additions to the MessageList type, as follows:

//vendor/magento/module-indexer/etc/adminhtml/di.xml
<type name="Magento\Framework\Notification
\MessageList">
	<arguments>
		<argument name="messages" xsi:type="array">
			<item name="indexer_invalid_message"
xsi:type="string">Magento\Indexer\Model\Message
\Invalid</item>
		</argument>
	</arguments>
</type>

//vendor/magento/module-tax/etc/adminhtml/di.xml
<type name="Magento\Framework\Notification
\MessageList">
	<arguments>
		<argument name="messages" xsi:type="array">
			<item name="tax"
xsi:type="string">Magento\Tax\Model\System\Message\Notifications</item>
		</argument>
	</arguments>
</type>

What this means, is that the Magento\Indexer\Model\Message\Invalid and Magento\Tax\Model\System\Message\Notifications string items are being added
to the messages argument and are being made available within the MessageList constructor.

In the preceeding Di example, we only had $messages parameter defined as one argument of the array type, and the rest were its array items.

let's take a look at a DI example for another type definition. This time, it's the one found under the vendor/magento/module-backend/etc/di.xml file,
and which is defined as follows:

<type name="Magento\Backend\Model\Url">
	<arguments>
		<argument name="scopeResolver"
xsi:type="obejct">Magento\Backend\Model
\Url\ScopeResolver</argument>
		<argument name="authSession"
xsi:type="object">Magento\Backend\Model\Auth\Session
\Proxy</argument>
		<argument name="formKey" xsi:type="object">
Magento\Framework\Data\Form\FormKey\Proxy</argument>
		<argument name="scopeType" xsi:type="const">
Magento\Store\Model\ScopeInterface::SCOPE_STORE
</argument>
		<argument name="backendHelper"
xsi:type="obejct">Magento\Backend\Helper
\Data\Proxy</argument>
	</arguments>
</type>

Here, we see a type with several different arguments passed to the constructor of the Magento\Backend\Model\Url class.
If you now take a look at the constructor of the URL class, you will see that it is defined the following way:

public function __construct(
	\Magento\Framework\App\Route\ConfigInterface\
$routeConfig,
	\Magento\Framework\App\RequestInterface $request,
	\Magento\Framework\Url\SecurityInfoInterface
$urlSecurityInfo,
	\Magento\Framework\Url\ScopeResolverInterface
$scopeResolver,
	\Magento\Framework\Session\Generic $session,
	\Magento\Framework\Session\SidResolverInterface
$sidResolver,
	\Magento\Framework\Url\RouteParamsResolverFactory
$routeParamsResolverFactory,
	\Magento\Framework
\Url\QueryParamsResolverInterface
$queryParamsResolver,
	\Magento\Framework\App\Config
\ScopeConfigInterface $scopeConfig,
	$scopeType,
	\Magento\Backend\Helper\Data $backendHelper,
	\Magento\Backend\Model\Menu\Config $menuConfig,
	\Magento\Framework\App\CacheInterface $cache,
	\Magento\Backend\Model\Auth\Session $authSession,
	\Magento\Framework\Encryption\EncryptionInterface
$encryptor,
	\Magento\Store\Model\StoreFactory $storeFactory,
	\Magento\Framework\Data\Form\FormKey $formKey,
	array $data = []
) {
	// Method body goes here lol
}

The __construct method here clearly has more params than the di.xml file. What htis means,
is that the type argument entires in di.xml do not necessariyl cover all the class 
__construct params. The arguments that are defined in the di.xml are the ones that relate to the
PHP class itself. This works, as long as the di.xml parms are of the same type or descendants of the same type.

Ideally, we would not pass the class type but the interface into the PHP constructor and then set the type in the di.xml.

This is where the type, preference and virtualType play a major role in the di.xml. We have seen the role of type.
Now let's go ahead and see what preference does.

A great number of Magento's core classes pass interfaces around constructors. The benefit of this is that the
object manager, with the help of di.xml cna decide what class to actually instansiate for a given interface.

Let's imagine the Foggyline\Di\Console\Command\DiTestCommand class with a constructor, as follows:

public function __construct(
	\Foggyline\Di\Model\TestInterface $myArg1,
	$myArg2,
	$name = null
)
{
	//Method body goes here
}

Note how the $myArg1 is type hinted to be of \Foggyline\Di\Model\TestInterface interface.

The object manager knows that it needs to look into the entire di.xml for possible preference defs.

We can define preference within the module's di.xml file as follows:

<preference
		for="Foggyline\Di\Model\TestInterface"
		type="Foggyline\Di\Model\Cart"/>
Here, we are basically saying, that when someone asks for Foggyline\Di\Model\TestInterface, they will get an object of the type Foggyline\Di\Model\Cart.

For this to work, the Cart class has to implement TestInterface itself. Once the preference definition is in place,
$myArg1 shown in the preceeding example becomes an object of the Cart class.

Additionally, the preference element is not reserved only to point out the preferred classes for some interfaces. We can use it to
set the preferred class for some other class.

Now, let's have a look at the Foggyline\Di\Console\Command\DiTestCommand class with a constructor:

public function __construct(
	\Foggyline\Di\Model\User $myArg1,
	$myArg2,
	$name = Null
)
{
	//Method body
}

As per before, we have a type hinting for myArg1 to check in the xml and find preference related to user.

To which we define in the di.xml:

<preference
	for="\Foggyline\Di\Model\User"
	type="Foggyline\Di\Model\Cart"/>

What this preference model is telling us, is that whenever a user is requested, we return a Cart type of Object.
This will only work, if Cart extends User, tho.

This is a convinient way of rewriting a class, where the class is being passed directly into another class constructor in place
of the interface.

Since the class __construct parameters can be type hinted as either classes or interfaces and further manipulated through the di.xml
preference definition, a question rises as to what is better. Is it better to use interfaces or specific classes?

While the answer might not be fully clear, it is always preferable to use interfaces to specify the dependancies we are inejcting into the system.

Along with the type and preference, there is another powerful feature of di.xml that we can use. The virtualType element enables us to
define virtual types. Creating a virtual type is like creating a subclass of an existing class except for the fact that it's done in the di.xml 
and not in code.

Virtual types, are way of injecting dependancies into some of the existing classes without affecting other classes. To explain this via
a practical example, let's take a look at the following virtual type defined in the app/etc/di.xml file:

<virtualType name="Magento\Framework\Message\Session
\Storage" type="Magento\Framework\Session\Storage">
	<arguments>
		<argument name="namespace" xsi:type="string">
message</argument>
	</arguments>
</virtualType>
<type name="Magento\Framework\Message\Session">
	<arguments>
		<argument name="storage" xsi:type="object">
Magento\Framework\Message\Session\Storage</argument>
	</arguments>
</type>

The virtualType definiton in the preceeding example is Magento\Framework\Message\Session\Storage,
which extends from Magento\Framework\Session\Storage and overwrites the namespace param to the message string value

in virtualType, the name attribute defines the globally unique name of the virtual type, while the type attribute,
matches the real PHP class that the virtual type is based on.

Now, if you look at the type definition, you will see that it's storage argument is set to the object of Magento\Framework\Message\Session\Storage.
The Session\Storage file is actually a virtual type. This allows Message\Session to be customized without affecting other classes that also declare
a dependency on Session\Storage.

Virtual types allow us to effectively change the behavior of a dependency when it is used in a specific class. Which means that we can just
treat classes as Virtual types, i.e cases where we apply imagined rules for a given context.

In this chapter, we will look at a feature of Magento called plugins. Before we start with plugins, we first need to understand the term
interception becauses the two terms are used somewhat interchangeably when dealing with Magento.

Interception, is a software design pattern that is used when we want to insert code dynamically without necessarily changing the original
class behavior. This works by dynamically inserting code between the calling code and target object.

The interception pattern in Magento is implemented via plugins. They provide the before, after, and around listeners, which helps us extend the
observed method behavior.

In this chapter, we will cover the following topics:

Creating a plugin

Using the before listener

Using the after listener

Using the around listener

The plugin sort order

Before we start creating a plugin, it is worth noting their limitations. Plugins cannot be created for just any class or method, as they do not 
work for the following:

Final classes

Final methods

The classes that are created without a dependency injection

Let's go ahead and create a plugin using a simple module called Foggyline_Plugged.

Start by creating the app/code/Foggyline/Plugged/registration.php file with partial content, as follows:

\Magento\Framework\Component
\ComponentRegistrar::register(
	\Magento\Framework\Component
\ComponentRegistrar::MODULE,
	'Foggyline_Plugged',
	__DIR__
);

Then, create the app/code/Foggyline/Plugged/etc/module.xml with the content as follows:

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-
instance"
xsi:noNamespaceSchemaLocation="urn:magento:framework:
Module/etc/module.xsd">
	<module name="Foggyline_Plugged"
setup_version="1.0.0">
		<sequence>
			<module name="Magento_Catalog"/>
		</sequence>
	</module>
</config>

The preceeding file is simply a new module declaration with the dependency set against the Magento_Catalog module, as we will be
observing it's class. We will not go into the details of module declaration right now, as that will be covered in the following chapters.

Now, create the app/code/Foggyline/Plugged/etc/di.xml file:

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-
instance"
xsi:noNameSpaceSchemaLocation="urn:magento:framework:
ObjectManager/etc/config.xsd">
	<type name="Magento\Catalog\Block\Product //Map the class to which we want to write the plugin based on.
\AbstractProduct">
		<plugin name="foggyPlugin1"
type="Foggyline\Plugged\Block\Catalog\Product\
AbstractProductPlugin1" disabled="false"
sortOrder="100"/>
		<plugin name="foggyPlugin2"
type="Foggyline\Plugged\Block\Catalog\Product\
AbstractProductPlugin2" disabled="false"
sortOrder="200"/>
		<plugin name="foggyPlugin3"
type="Foggyline\Plugged\Block\Catalog\Product\
AbstractProductPlugin3" disabled="false"
sortOrder="300"/>
	</type>
</config>

Plugins are defined with the module di.xml file. To define a plugin,
by using the type element and its name attribute,we first map the class
that we want to observe. In this case, we are observing the 
Magento\Catalog\Block\Product\AbstractProduct class.

Note that even though the file and class name imply an abstract type of
class, the AbstractProduct class is not abstract.

In the type element, we then define one or more plugins using the plugin element.

The plugin element has the following four attributes assigned to it:

name: Using this attribute, you can provide a unique and recognizable name value
that is specific to the plugin

sortOrder: This attribute determines the order of execution when multiple plugins are observing the same method

disabled: The default value of this attribute is set to false, but if it is set to True, it will disable the plugin

type: This attribute points to the class that we will be using to implement the before, after or around listener

After doing this, create the app/code/Foggyline/Plugged/Block/Catalog/Product/AbstractProductPlugin1.php:

namespace Foggyline\Plugged\Block\Catalog\Product;

class AbstractProductPlugin1
{
	public function beforeGetAddToCartUrl(
		$subject,
		$product, $additional = []
	)
	{
		var_dump('Plugin1 - beforeGetAddToCartUrl');
	}

	public function afterGetAddToCartUrl($subject)
	{
		var_dump('Plugin1 - afterGetAddToCartUrl');
	}

	public function aroundGetAddToCartUrl(
		$subject,
		\Closure $proceed,
		$product,
		$additional = []
	)
	{
		var_dump('Plugin1 - aroundGetAddToCartUrl');
		return $proceed($product, $additional);
	}
}

As per the type definition in the di.xml file, the plugin observes the Magento\Catalog\Block\Product\AbstractProduct class,
and this class has a method called getAddToCartUrl, which is defined as follows:

public function getAddToCartUrl($product, $additional = [])
{
	//Method body goes here
}

The AbstractProductPlugin1 class does not have to be extended from another class for the plugin to work.
We define the before, after and around listeners for the getAddToCartUrl method by using the naming convention, as follows:

<before> + <getAddToCartUrl> => beforeGetAddToCartUrl
<after> + <getAddToCartUrl> => afterGetAddToCartUrl
<around> + <getAddToCartUrl> => aroundGetAddToCartUrl

We will go into the details of each listener later. Right nowe need to
finish the module by creating the AbstractProductPlugin2.php and AbstractProductPlugin3.php files as copy of
AbstractProductPlugin1.php and along with that, simply changing all the number values within their code from 1 to 2 or 3.

It's a good practice to organize the listeners into folders matching the structure of the observed class location. For example,
if a module is called Foggyline_Plugged and we are observing the method in the Magento\Catalog\Block\Product\AbstractProduct class,
we should consider putting the plugin class into the Foggyline/Plugged/Block/Catalog/Product/AbstractProductPlugin.php file.

This is not a requirement, but simply good praxis.

Once the module is in place, we need to execute the following commands on the console:

php bin/magento module:enable Foggyline_Plugged
php bin/magento setup:upgrade

This will make the module visible to Magento

If we now open the storefront in a browser for a category page, we will set the results of all the var_dump function calls.

Let's go ahead and take a look at each and every listener method in detail.

The before listeners are used when we want to change the arguments of an original method or add some bavior before an original method
is called.

Looking back at the beforeGetAddToCartUrl listener method definiton, you will see that htere are three properties assigne in sequence
-$subject, $product, and $additional

With the before method listener, the first property is always the $subject property, which contains the instance of the object type
being observed. Properties following the $subject property match the properties of the observed getAddToCartUrl method in a sequential order.

This simple rule used for transformation is as follows:

getAddToCartUrl($product, $additional = [])
beforeGetAddToCartUrl($subject, $product, $additional = []) //Sequence is always first $subject to indicate whatever is being listend to, and then copy the args in order
//Note: $subject is not of the same type as <valueBeingListenedTo>, it is of ListProduct\Interceptor type, as it is a interceptor

The before listener does not have a return value. 

If we run get_class($subject) in the beforeGetAddToCartUrl listener method that we previously saw, we will have the following result:

\Magento\Catalog\Block\Product\ListProduct
\Interceptor
	extends \Magento\Catalog\Block\Product
\ListProduct
		extends \Magento\Catalog\Block\Product
\AbstractProduct

What this shows, is that even though we are observing the AbstractProduct class, the $subject property is not directly of that 
type. Rather, it is of the ListProduct\Interceptor type. This is something that you should keep in mind during developemtn.

The after listeners are used when we want to change the values returned by an original method or add some behavior after an original
method is called.

Looking back at the afterGetAddToCartUrl listener method definition, you will see that it has only one 
$subject property assigned.

With the after method listener, the first and only property is always the $subject property, which contains the instance of the object type
being observed, and not the return value of the observed method.

This simple rule used for transformation is as follows:

getAddToCartUrl($product, $additional = [])
afterGetAddToCartUrl($subject)

The after listener method does not rhave ar eturn value.

Like the before listenr method, the $subject prop in this case is not directly of the AbstractProduct type. it is still of the ListProduct\Interceptor type.
Since it's an interceptor.

The around listeners are used when we want to change both the arguments and the returned values of an original method or add some behavior before and
after an original method is called.

Looking back at the aroundGetAddToCartUrl listener method definition, you will see that it has four properties assigned in sequence
-$subject, $proceed, $product and $additional

With the after method listener, the first property is always the $subject property, which contains the instance of the object type
being observed and not the return value of the observed method.

Meaning that the $subject contains the observed type, but the actual $subject object is a ListProduct\Interceptor type.

The second property is always the $proceed property of \Closure. The properties following the $subject and $proceed match
the properties of the observed getAddToCartUrl method in the sequential order too.

This simple rule used for transformation is as follows:

getAddToCartUrl($product, $additional = [])
aroundGetAddToCartUrl(
	$subject,
	\Closure $proceed, //Generally, \<name> <arg> infers a method call there, accepting the following arg
	$product,
	$additional = []
)

The around listener methods must have a return value. The return value is formed in such a way that the parameters following the $closure
param in the around listener method def are passed to the $closure function call in a sequential order as follows:

return $proceed($product, $additional); //gets return to the $closure method

or

$result = $proceed($product, $additional); //unessecary memory allocation of variable
return $result;

Looking back, when we defined a plugin in the di.xml file, one of the attributes that we set for every plugin def was sortOrder.
It was set to 100, 200, 300 for foggyPlugin1, foggyPlugin2 and foggyPlugin3 respetive.

The flow of the execution of code for the preceeding plugins is as follows:

Plugin1 - beforeGetAddToCartUrl
Plugin1 - aroundGetAddToCartUrl
Plugin2 - beforeGetAddToCartUrl
plugin2 - aroundGetAddToCartUrl
Plugin3 - beforeGetAddToCartUrl
Plugin3 - aroundGetAddToCartUrl
Plugin3 - afterGetAddToCartUrl
Plugin2 - afterGetAddToCartUrl
Plugin1 - afterGetAddToCartUrl

In other words, if multiple plugins are listening to the same method, the following execution order is used:

The before plugin functions with the lowest sortOrder value
the around plugin functions with the lowest sortOrder value
the before plugin functions following the sortOrder value from lowest to highest
the around plugin functions following the sortOrder value from lowest to highest
the after plugin functions with the highest sortOrder value
the after plugin functions following the sortOrder value from the higehst to the lowest

NOTE: Keep wary of that a around listener must ALWAYS return a value. OMittal of this can cause errors in terms of execution of flow

This pattern causes a gaussian curve, that goes from low, to higher and then goes low again.

Next up, is Backend development. It is a term that usually implies actual server, application code and the DB. For example,
if we open a storefront of a web shop, add a few products to the cart and then check out, teh app will store the info provided.

This info is managed on a server with a server-side langauge, such as PHP, and then saved in a DB. In chapter 4, Models and
Collections, we took a look at the backbone of backend development. In this chapter, we will explore other backend-related aspects.

We will use the Foggyline_Office module that was define in one of the previous chapters, as we go through the following concepts:

Crow jobs

Notification Messages

Sessions and Cookies

Logging

The profiler

Events and observers

Caches

Widgets

Custom variables

i18n (internalization)

Indexers

These indiviudal isolated units of functionality are mostly used in everyday backend-related development.

Speaking of cron jobs, it is worth noting one important thing.A magento cron job is not the same as one run by a OS.

A OS cron job, is driven by a crontab (short for cron table) file. The crontab file, is a config file that specifies shell
commmands that need to be run periodically on a given schedule.

A Magento cron job, is driven by a periodic execution of PHP code that handles entires in the cron_schedule table.
The cron_schedule table is where Magento cron jobs are queued once they are picked up from the individual crontab.xml file.

The Magento cron jobs cannot be executed without the operating system cron job being set to execute the php bin/magento cron:run command.

ideally, an OS cron job should be set to trigger Magento's cron:run every minute. Magento will then internally execute it's cron jobs according
to the way an individual cron job is defined in the crontab.xml file.

To define a new cron job in Magento cron, we first need to define a crontab.xml file in the module. Let's create a app/code/Foggyline/Office/etc/crontab.xml with
the following content:

<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-
instance" xsi:noNamespaceSchemaLocation=
"urn:magento:module:Magento_Cron:etc/crontab.xsd">
	<group id="default">
		<job name="foggyline_office_logHello"
instance="Foggyline\Office\Model\Cron"
method="logHello">
			<schedule>*/2 * * * *</schedule>
		</job>
	</group>
</config>

note that the XSD schema location points to crontab.xsd from within the Magento_Cron module.

The id attribute of a group element is set to the default value. In it's modules, Magento defines
two different groups, namedly default and index. We used the default value, as this is the one that gets
executed when the standard php bin/magento cron:run command is triggered on the console.

Within the group element, we have individual jobs defined under the job element. The job element requires
us to specify the name, instance and method attributes. The name attribute has to be unique within the group element.

The value of the instance and method attributes should point to the class that will be instansiated and the method within
the class that needs to be executed.

The schedule element nested within the cron job specifies the desired time of job execution. It uses the same time expression
as that of the entries in an OS crontab file. The specific example that we look at defines an expression (*/2 * * * *) that is executed every 2 minutes.

Once we have defined the crontab.xml file, we need to define the Foggyline\Office\Model\Cron class file, as follows:

namespace Foggyline\Office\Model;

class Cron
{
	protected $logger;

	public function __construct(
		\Psr\Log\LoggerInterface $logger
	)
	{
		$this->logger = $logger;
	}

	public function logHello()
	{
		$this->logger->info('Hello from Cron Job!');
		return $this;
	}
}

The preceeding code simply defines a logHello() method used by the cron job. In said method, we use the logger method that is instansiated by the 
constructor. The logger method will make an entry into the var/log/system.log file once it is executed.

Once the command is executed, you will see teh Ran jobs by schedule message in the console. Additionally, the cron_schedule table should
get filled with all the Magento cron jobs that were defined.

At this point, we should trigger the php bin/magento cron:run commands in the console.

the cron_schedule table contains the following columns:

schedule_id: The auto-increment primary field.

job_code: The value of the job name attribute, as defined in crontab.xml file, which equals to 
foggyline_office_logHello table in our example.

status: Defaults to the pending value for the newly created entries in the table and allows for a pending, running, success,
missed or error value. It's value changes as the cron job traverses through it's life cycle

messages: Stores the possible exception error message if the exception has occured during a job's execution

created_at: The timestamp value that denotes when a job was created.

scheduled_at: The timestamp value that denotes when a job was scheduled for execution

executed_at: The timestamp value that denotes when a job's executions tarted

finished_at: The timestmap value that denotes when a job finished execution

Unless we have already set the OS cron to trigger the php bin/magento cron:run command, we need to trigger it
on our own a few times every two minutes in order to actually execute the job.

The first time a command is run, if the job does not exist in the cron_schedule table, Magento will merely queue it,
but it won't execute it.

The subsequent cron runs will execute the command. Once we are sure that the cron job entry in the cron_schedule table has
the finished_at column value filled, we will see an entry that looks like [2015-11-21 09:42:18] main.INFO: Hello from Cron job! [] [] in the var/log/system.log file.

NOTE: When developing and testing cron jobs in Magento, we might need to truncate the cron_schedule table, delete Magento's var/cache value and execute
the php bin/magento cron:run command repetetively until we get it tested and working.

Notification messages

Magento implements the notification message mechanism via the Messages module. The messages module conforms to \Magento\Framework\Message\ManagerInterface.
Though the interface itself does not impose any session relation, an implementation adds interface-defined types of messages to a session and
allows access to those messages later.

In the app/etc/di.xml file, there is a preference defined for \Magento\Framework\Message\ManagerInterface towards the Magento\Framework\Message\Manager class

Message\ManagerInterface specifies four types of messages, namely error, warning, notice and success.

The types of messages are followed by several key methods in the Message\Manager class, such as addSuccess, addNotice, addWarning, addError, and addException.

The addException method is basically a wrapper for addError that accepts an exception object as a parameter.

Let's try to run the following code in the execute method of app/code/Foggyline/Office/Controller/Test/Crud.php:

$resultPage =
$this->resultPageFactory->create();

$this->messageManager->addSuccess('Success-1');
$this->messageManager->addSuccess('Success-2');
$this->messageManager->addNotice('Notice-1');

$this->messageManager->addNotice('Notice-2');
$this->messageManager->addWarning('Warning-1');
$this->messageManager->addWarning('Warning-2');

$this->messageManager->addError('Error-1');
$this->messageManager->addError('Error-2');

return $resultPage;

Once this code is executed, the result as follows, will be shown in the page of the browser:

//basically coloured tabs with Denotions of what they are will appear stacked in a list

Notification messages appear both in frontend and admin area.

The frontend layout vendor/magento/module-theme/view/frontend/layout/default.xml file defines it as follows:

<page layout="3columns"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-
instance" xsi:noNamespaceSchemaLocation=
"../../../../../../../lib/internal/Magento/Framework/View/Layout
/etc/page_configuration.xsd">
	<update handle="default_head_blocks"/>
	<body>
		<!-- ... -->
		<referenceContainer
name="column.top">
			<container name="page.messages"
htmlTag="div" htmlClass="page messages">
				<block
class="Magento\Framework\View\Element
\Messages" name="messages" as="messages"
template="Magento_Theme::messages.phtml"/>
			</container>
		</referenceContainer>
		<!-- ... -->
	</body>
</page>

The template file that renders the messages is view/frontend/templates/messages.phtml in the Magento_Theme module. By looking at the
Magento\Framework\View\Element\Messages class, you will see that the _toHtml method branches into if-else statements, depending on wether 
template is set or not.

In case the template is not set, _toHtml interally calls the _renderMessagesByType method, which renders messages in the HTML format
that are grouped by type.

The view/adminhtml/layout/default.xml admin layout file in the Magento_AdminNotification module defines it as follows:

<page xmlns:xsi="http://www.w3.org
/2001/XMLSchema-instance"
xsi:noNamespaceSchemaLocation="urn:magento:
framework:View/Layout
/etc/page_configuration.xsd">
	<body>
		<referenceContainer
name="notifications">
			<block
class="Magento\AdminNotification\Block
\System\Messages" name="system_messages"
as="system_messages" before="-" template=
"Magento_AdminNotification::system/messages.p
html"/>
		</referenceContainer>
	</body>
</page>

The template file that renders the messages is
view/adminhtml/templates/system
/messages.phtml in the Magento_AdminNotification
module. When you look at the Magento\AdminNotification\Block\System\Messages class,
we will see that it's _toHtml is calling the \Magento\Framework\View\Element\Template class.

This means that the output is relying on the view/adminHtml/templates/system/messages.phtml file in the
Magento_AdminNotification module.

Sessions in Magento conform to Magento\Framework\Session\SessionManagerInterface. In the app/etc/di.xml file,
there is a definition preference for the SessionManagerInterface class which points to the Magento\Framework\Session\SessionManager
class, which in turn implements the SessionManagerInterface class.

There is one important object that gets instansiated in the SessionManager instance that conforms to \Magento\Framework\Session\Config\ConfigInterface.

On looking at app/etc/di.xml file, we can see a preference for ConfigInterface pointing to a Magento\Framework\Session\Config class type.

To fully understand the session behavior in Magento, we should study the inner workings of both the SessionManager and Session\Config classes.
Magento uses cookies to keep track of a session. These cookies have a default lifetime of 3,600 seconds. When a session
is established, a cookie with the name of PHPSESSID is created in the browser.

The value of the cookie equals the session name. By default, sessions are stored in files in the var/session dir of Magento's root Install.

If you have a look at these session files, you will see that session information is being stored in serialized strings that are divided into groupings
such as _session_validator_data, _session_hosts, default, customer_website_1, and checkout as follows:

_session_validator_data
	|a:4:{s:11:"remote_addr";s:9:"127.0.0.1";s:8:
_session_hosts
	|a:1:{s:12:"magento2.loc";b:1;}
default
	|a:3:{s:9:"_form_key";s:16:"u3sNaa26Ii21nveV"
customer_website_1
	|a:0:{}
checkout
	|a:0:{}

This is not the finite list of grouping. Modules that implement their own session handling bits can add their own groups.

We can store and retrieve information in a session by simply using expressions like the following ones:

$this->sessionManager->setFoggylineOfficeVar1
('Office1');
$this->sessionManager->getFoggylineOfficeVar1
();

The preceeding expressions will create and get an entry from the session under the default group.
We can get the entire content of the default session group simply by using the $this->sessionManager->getData() expression,
which will return an array of data that is similar to the following one:

array(3) {
	["_form_key"] => string(16)
"u3sNaa26Ii21neV"
	["visitor_data"] => array(14) {
		["last_visit_at"] => string(19)
"2015-08-19 07:40:03"
		["session_id"] => string(26)
"8p82je0dkqq1o00lanlr6bj6m2"
		["visitor_id"] => string(2) "35"
		["server_addr"] => int(213076433)
		["remote_addr"] => int(213076433)
		["http_secure"] => bool(false)
		["http_host"] => string(12)
"magento2.loc"
		["http_user_agent"] => string(121)
"Mozaill/5.0 ..."
		["http_accept_language"] => string(41)
"en-US, en;"
		["http_accept_charset"] => string(0) ""
		["first_visit_at"] => string(19)
"2015-08-19 07:40:03"
		["is_new_visitor"] => bool(false)
	}
	["foggyline_office_var_1"] => string(7)
"Office1"
}

As you can see, the foggyline_office_var_1 value is right there among other session values.
There are several useful methods of ConfigInterface that we can use to fetch session configuration information; a few
of these methods are as follows:

getCookieSecure

getCookieDomain

getCookieHttpOnly

getCookieLifetime

getName

getSavePath

getUseCookies

getOptions

Here's a result example of the getOptions method call on the Session\Config instance:

array(9) {
	["session.save_handler"] => string(5)
"files"
	["session.save_path"] => string(39) "/Users
/branko/www/magento2/var/session/"
	["session.cookie_lifetime"] => int(3600)
	["session.cookie_path"] => string(1) "/"
	["session.cookie_domain"] => string(12)
"magento2.loc"
	["session.cookie_httponly"] => bool(true)
	["session.cookie_secure"] => string(0) ""
	["session.name"] => string(9) "PHPSESSID"
	["session.use_cookies"] => bool(true)
}

Cookies often go hand in hand with sessions. Besides being used to link to a certain session, cookies are often
used to store some information on the client side, thus tracking or identifying the return users and customers.

Besides the pure PHP approach with the setcookie function, we can manage cookies in Magento through an instance
of Magento\Framework\Stdlib\CookieManagerInterface. When you look at app/etc/di.xml file, you will see
that the preference for CookieManagerInterface points to a class of the Magento\Framework\Stdlib\Cookie\PhpCookieManager type

The following restrictions are worth noting when it comes to Magento cookies:

We can set maximum of 50 cookies in the system. Otherwise, Magento will throw an Unable to send the cookie. Maximum number of cookies would be exceeded exception.
We can store a cookie with a maximum size of 4096 bytes. Otherwise, Magento will throw an Unable to send the cookie. Size of \'%name\' is %size bytes exception.

By imposing these restrictions, Magento ensures that we are compatible with most browsers.

The CookieManagerInterface class, among other things, specifies the setSensitiveCookie method requirement. This method sets a value
in a private cookie with the given $name $value pairing. Sensitive cookies have HttpOnly set to true and thus cannot be accessed by JS.

As we will soon demonstrate in the following examples, to set a public or private cookie, we can help ourselves by using instances of the following:

\Magento\Framework\Stdlib\Cookie\CookieMetadataFactory

\Magento\Framework\Stdlib\CookieManagerInterface

\Magento\Framework\Session\Config\ConfigInterface

We can set public cookies in the following way:

$cookieValue = 'Just some value';
$cookieMetadata =
$this->cookieMetadataFactory
	->createPublicCookieMetadata()
	->setDuration(3600)

->setPath($this->sessionConfig->getCookiePath())

->setDomain($this->sessionConfig->getCookieDomain())

->setSecure($this->sessionConfig->getCookieSecure())

->setHttpOnly($this->sessionConfig->getCookieHttpOnly());

$this->cookieManager
	->setPublicCookie('cookie_name_1', 
$cookieValue, $cookieMetadata);

The preceeding code will result in a cookie, that is HttpOnly.

We can also set private cookies, as follows:

$cookieValue = 'Just some value';

$cookieMetadata =
$this->cookieMetadataFactory
	->createSensitiveCookieMetadata()
	->setPath($this->sessionConfig->getCookiePath())

	->setDomain($this->sessionConfig->getCookieDomain());

$this->cookieManager
	->setSensitiveCookie('cookie_name_2',
$cookieValue, $cookieMetadata);

This will result in a private cookie. Interestingly, both the public and private cookies in the preceeding example show that HttpOnly is checked off
because by default, a Magento admin has Stores | Settings | Configuration | General | Web | Default Cookie Settings | Use HTTP Only set to yes.

Since we are using the setHttpOnly method in the public cookie example, we simply picked up the config value via $this->sessionConfig->getCookieHttpOnly() and 
passed it on. If we comment out that line, we will see that public cookie does not really set HttpOnly by default.

Magento supports the messages logging mechanism via its \Psr\Log\LoggerInterface class. The LoggerInterface class has a preference defined
within app/etc/di.xml file for the Magento\Framework\Logger\Monolog class type. The actual crux of implementation is actually in
the Monolog parent class named Monolog\Logger, which comes from the Monolog vendor.

The LoggerInterface class uses the following eight methods to write logs to the eight RFC 5424 levels:

debug

info

notice

warning

error

critical

alert

emergency

To use a logger, we need to pass the LoggerInterface class to a constructor of a class from within we want to use it
and then simply make one the following method calls:

$this->logger->log(\Monolog\Logger::DEBUG,
'debug msg');
$this->logger->log(\Monolog\Logger::INFO,
'info msg');
$this->logger->log(\Monolog\Logger::NOTICE,
'notice msg');
$this-logger->log(\Monolog\Logger::WARNING,
'warning msg');
$this->logger->log(\Monolog\Logger::ERROR,
'error msg');
$this-logger->log(\Monolog\Logger::CRITICAL,
'critical msg');
$this->logger->log(\Monolog\Logger::ALERT,
'alert msg');
$this->logger->log(\Monolog
\Logger::EMERGENCY, 'emergency msg');

Alternatively, the preferred shorter version through individual log level type methods is as follows:

$this->logger->debug('debug msg');
$this->logger->info('info msg');
$this->logger->notice('notice msg');
$this->logger->warning('warning msg');
$this->logger->error('error msg');
$this->logger->critical('critical msg');
$this->logger->alert('alert msg');
$this->logger->emergency('emergency msg');

Both approaches result in the same two log files being created in Magento, which are as follows:

var/log/debug.log

var/log/system.log

The debug.log file contains only the debug level type of the log,
while the rest are saved under system.log

Entries within these logs will then look as follows:

[2015-11-21 09:42:18] main.DEBUG: debug msg
{"is-exception":false} []
[2015-11-21 09:42:18] main.INFO: info msg [] []
[2015-11-21 09:42:18] main.NOTICE: notice msg [] []
[2015-11-21 09:42:18] main.WARNING: warning msg [] []
[2015-11-21 09:42:18] main.ERROR: error msg [] []
[2015-11-21 09:42:18] main.CRITICAL: critical msg [] []
[2015-11-21 09:42:18] main.ALERT: alert msg [] []
[2015-11-21 09:42:18] main.EMERGENCY: emergency msg [] []

Each of these logger methods can accept an entire array of arbitrary data called context, as follows:

$this->logger->info('User logged in.', ['user'=>'Branko', 'age'=>32]);

The preceeding expression will produce the following entry in system.log:

[2015-11-21 09:42:18] main.INFO: User logged in. {"user":"Branko", "age":32} []

We can manually delete the log files from var/log dir, and Magento will automatically create it again when needed.

Magento also has another logging mechanism in place, where it logs the following actions in log_* tables in a DB:

log_customer

log_quote

log_summary

log_summary_type

log_url

log_url_info

log_visitorz

log_visitor_info

log_visitor_online

It is worth noting that this DB logging is not related in anyway to the Psr logger taht was described previously. While Psr logger
serves developers within the code to group and log certain messages according to the Psr standard, the DB logging logs
the live data that is result of user/customer interaction in the browser.

By default, Magento keeps DB logs for around 180 days. This is a config option that can be controlled in the Magento admin
area under the Stores | Settings | Configuration | Advanced | System | Log Cleaning tab with other related log options.

There we can set frequency, duration of save, log cleaning, start times, error email recipients, error email senders, error email templates.

These config options, only bare meaning OS cron is triggering Magento cron. (i.e, they only take effect if the OS cron uses the Magento Cron)

We can execute two commands on terminal: php bin/magento log:status to get the current state information about log tables and php bin/magento log:clean
to force the cleaning of tables

Magento has a built-in profiler that can be used to identify performance problems on the server side. In a nutshell,
the profiler can tell us the execution time of certain chunks of code. There is nothing that great with its behavior.

We can only get the execution time of code blocks or individual expressions that have been wrapped by the profiler's start
and stop methods. On its own, Magento calls for the profiler extensively across its code. However,
we cant see it in effect as the profiler output is disabled by default.

Magento supports three profiler outputs, namely html, csvfile and firebug.

To enable the profiler, we can edit .htaccess and add one of the following expressions:

SetEnv MAGE_PROFILER "html"

SetEnv MAGE_PROFILER "csvfile"

SetEnv MAGE_PROFILER "firebug"

The HTML type of profiler will show its output into the footer area of a page that we open in the browser, as shown in the following illustration:

Timer id 					Time 		Avg 		Cnt 	Emalloc 	RealMem

cache_frontend_create 		0.046384	0.023192	2 		1,479,184 	1,572,864

cache_load 					0.014226 	0.004742 	3 		454.796 	524,288

magento 					0.168286 	0.168286  	1 		4,086,732 	3,670,016

. cache_load 				0.013186 	0.001884 	7 		430,260 	524,288

. store.resolve 			0.080572 	0.080572 	1 		2,132,144 	2,097,152

. . EVENT:model_load_before 0.002523 	0.002523 	1 		133,904 	0

. . . cache_load 			0.00193 	0.0000967 	2 		40,436 		0

The csv file type of profiler will output into var/log/profiler.csv as shown:

cache_frontend_create,0.056334,0.028267, 2, "1,479,196", "1,572,864"
etc.
magento->cache_load,0.010538, etc.
magento->store.resolve->EVENT:model_load_before etc.

The profiler outputs, are as follows:

Time profiler shows the time spent from Profiler::start to Profiler::stop

Avg profiler shows the average time spent from Profiler::start to Profiler::stop for cases
where Cnt is greater than one

Cnt profiler shows the integer value of how many times we have started the profiler with the same timer name.
For example, if we have caled \Magento\Framework\Profiler::start('foggyline:office'); twice, somewhere in the code,
cnt will have been set to 2.

Emalloc profiler stands for amount of memory allocated to PHP. It is a mix of the core PHP memory_get_usage function
without the true parameter passed to it and the timer values.

RealMem profiler also stands for the amount of memory allocated to PHP whose final value is also obtained
via the memory_get_usage function minus the timer values, but this time with the true parameter passed to it.

We can easily add our own Profiler::start calls anywhere in the code. Every Profiler::start should be followed by
some code expressions and then finalized with a Profiler::stop call, as follows:

\Magento\Framework\Profiler::start('foggyline:office');
sleep(2); /* Code block or single expression here */
\Magento\Framework\Profiler::stop('foggyline:office');

Depending on where we call the profiler in the code, the resulting output should be similar to the one shown in the following
formatting:

. . CONTROLLER_ACTION:foggyline_office_test_crud 	2.077258 2.077258  1  239,732 	262,144
. . . action_body 									- II -    - II -  -II- -II-       -II-
. . . . foggyline:office 							2.000966  2.000966 1  1,308 	 	0
. . . . postdispatch 								0.052955  0.52955  1  55,952        0

Magento implements the observer pattern through \Magento\Framework\Event\ManagerInterface.
In app/etc/di.xml, there is a preference for MagentoInterface that points to the Magento\Framework\Event\Manager\Proxy class type.

The Proxy class further extends the \Magento\Framework\Event\Manager class that implements the actual event dispatch method.
Events are dispatched by calling a dispatch method on the instance of the Event\Manager class and passing the name
and some data, which is optional, to it. Here's an example of a Magento core event:

$this->eventManager->dispatch(
	'customer_customer_authenticated',
	['model' => 
$this->getFullCustomerObject($customer),
'password' => $password]
);

The $this->eventManager is an instance of the previously mentioned Event\Manager class. In this case, the event name
equals to customer_customer_authenticated, while the data passed to the event is the array with two elements.

The preceding event is fired when the authenticate method is called on \Magento\Customer\Model\AccountManager, that is,
when a customer logs in.

Dispatching an event only makes sense if we expect someone to observe it and execute their code when the event is
dispatched. Depending on the area from which we want to observe events, we can define observers in one of the following XML files:

app/code/{vendorName}/{moduleName}/etc/events.xml

app/code/{vendorName}/{moduleName}/etc/frontend/events.xml

app/code/{vendorName}/{moduleName}/etc/adminhtml/events.xml

Let's define an observer that will log an e-mail adress of an authenticated user into a var/log/system.log file. We 
can use the Foggyline_Office module and add some code to it. As we are interested in the storefront, it makes sense to
put the observer in the etc/frontend/events.xml module

Let's define the app/code/Foggyline/Office/etc/frontend/events.xml file with the contents as follows:

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:noNamespaceSchemaLocation="urn:magento:framework:Event/etc/events.xsd">
	<event
name="customer_customer_authenticated">
		<observer
name="foggyline_office_customer_authenticated
" instance="Foggyline\Office\Observer\LogCustomerEmail" />
	</event>
</config>

here, we are specifying a foggyline_office_customer_authenticated observer for the customer_customer_authenticated
event. The observer is defined in the LogCustomerEmail class that is placed in the Observer module dir. The Observer 
class has to implement the Magento\Framework\Event\ObserverInterface class. The Observer interface defines a single
execute method.

The execute method hosts the observer code and is executed when the customer_customer_authenticated event is dispatched.
Let's go ahead and define the Foggyline\Office\Observer\LogCustomerEmail class in the app/code/Foggyline/Office/Observer/LogCustomerEmail.php file as follows:

namespace Foggyline\Office\Observer;

use Magento\Framework\Event\ObserverInterface;

class LogCustomerEmail implements ObserverInterface
{
	protected $logger;

	public function __construct(
		\Psr\Log\LoggerInterface $logger
	)
	{
		$this->logger = $logger;
	}

	/**
	 * 	@param \Magento\Framework\Event\Observer $observer
	 *  @return self
	 */

	public function execute(\Magento
\Framework\Event\Observer $observer)
	{
		//$password = 
$observer->getEvent()->getPassword();
		$customer = 
$observer->getEvent()->getModel();

$this->logger->info('Foggyline\Office: ' . 
$customer->getEmail());
		return $this;
	}
}

The execute method takes a single parameter called $observer of the \Magento\Framework\Event\Observer type.
The event that we are observing is passing two pieces of data within the array, namely the model and password.
We can access this by using the $observer->getEvent()->get{arrayKeyName} expression.

The $customer object is an instance of the Magento\Customer\Model\Data\CustomerSecure class, which
contains properties such as email, firstname, lastname and so on. Thus, we can extract the e-mail address from it and pass it
to logger's info method.

Now that we know how to observe existing events, let's see how we can dispatch our own events. We can dispatch events 
from almost anywhere in the code, with or without data, as shown in the following example:

$this->eventManager->dispatch('foggyline_office_foo');
// or
$this->eventManager->dispatch(
	'foggyline_office_bar',
	['var1'=>'val1', 'var2'=>'val2']
);

It is worth noting that there are two types of events; we can group them in the following way according to the way their
name is assigned.

Static:
$this->eventManager->dispatch('event_name', ...)

Dynamic:
$this->eventManager->dispatch({expression}.'_event_name', ...)

The static events have a fixed string for a name, while the dynamic ones have a name that is determined during the runtime.
Here's a nice example of core Magento functionality from afterLoad method that is defined under lib/internal/Magento/Framework/Data/AbstractSearchResult.php,
which showcases how we use both type of events:

protected function afterLoad()
{
	$this->eventManager->dispatch
('abstract_search_result_load_after',
['collection' => $this]);
	if ($this->eventPrefix && $this->eventObject) {
		$this->eventManager->dispatch($this->eventPrefix . '_load_after', [$this->eventObject => $this]);
	}
}

We can see a static event (abstract_search_result_load_after) and a dynamic event ($this->eventPrefix . '_load_after'). The $this->eventPrefix is an
expression that gets evaluated during the runtime. We should be careful when using dynamic events as they are triggered under multiple situations.
Some interesting dynamic events are the one defined on classes like the following ones:

Magento\Framework\Model\AbstractModel
	$this->_eventPrefix . '_load_before'
	$this->_eventPrefix . '_load_after'
	$this->_eventPrefix . '_save_commit_after'
	$this->_eventPrefix . '_save_before'
	$this->_eventPrefix . '_save_after'

	$this->_eventPrefix . '_delete_before'
	$this->_eventPrefix . '_delete_after'
	$this->_eventPrefix . '_delete_commit_after'
	$this->_eventPrefix . '_clear'

\Magento\Framework\Model\ResourceModel\Db\Collection\AbstractCollection
	$this->_eventPrefix . '_load_before'
	$this->_eventPrefix . '_load_after'

\Magento\Framework\App\Action\Action
	'controller_action_predispatch_' .
	$request->getRouteName()

	'controller_action_predispatch_' .
	$request->getFullActionName()

	'controller_action_postdispatch_' .
	$request->getFullActionName()

	'controller_action_postdispatch_' .
	$request->getRouteName()

Magento\Framework\View\Result\Layout
	'layout_render_before_' .
	$this->request->getFullActionName()

These events are fired on the model, collection, controller and layout classes, which are probably among the most used
backend elements that often require observing and interacting. Even though we can say that the full event name is known during
the runtime along with the dynamic event, this can be assumed even before the runtime.

For example, assuming that we want to observe 'controller_action_predispatch_' . $request->getFullActionName() for the
Foggyline_Office module's Crud controller action, the actual full event name will be 'controller_action_predispatch_foggyline_office_test_crud',
given that $request->getFullActionName() will resolve to foggyline_office_test_crud during the runtime.

Magento has eleven-out-of-the-box cache types, according to the following list. These are used across many levels within the system:

Configuration: Various XML configurations that were collected across modules and merged

Layouts: Layouts building instructions

Blocks HTML output: Page blocks HTML

Collections data: Collection data files

Reflection data: API interfaces reflection data

Database DDL operations: Results of DLL queries, such as descrbing tables or indexes

EAV types and attributes: Entity types declaration cache

Page cache: Full page caching

Translations: Translation files

Integrations configuration: Integration configuration file

Integrations API configuration: Integrations API configuration file

Web services configuration: REST and SOAP configurations, generated WSDL file.

There is also Additional Cache Management that manages the cache for the following files:

Previously generated product image files

Themes Javascript and CSS files combined to one file

Preprocessed view files and static files

Each of these caches can be cleared seperately.

We can easily define our own cache type, we can do so by first creating an app/code/Foggyline/Office/etc/cache.xml file with content:

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:noNamespaceSchemaLocation="urn:magento:framework:Cache/etc/cache.xsd">
	<type name="foggyline_office"
			instance="Foggyline\Office\Model\Cache">
		<label>Foggyline Office Example</label>
		<description>Example cache from Foggyline office module.</description>
	</type>
</config>

When defining a new Cache type, we need to specify its name and instance attributes. The name attribute of the type
element should be set to foggyline_office and should be unique across Magento. This value should match the
TYPE_IDENTIFIER constant value on the Foggyline\Office\Model\Cache class, which will be created soon.

The instance attribute holds the class name that we will use for caching.

Then, we will define the Foggyline\Office\Model\Cache class in the app/code/Foggyline/Office/Model/Cache.php file:

namespace Foggyline\Office\Model;

class Cache extends \Magento\Framework\Cache\Frontend\Decorator\TagScope
{
	const TYPE_IDENTIFIER = 'foggyline_office';

	const CACHE_TAG = 'OFFICE';

	public function __constuct(
		\Magento\Framework\App\Cache\Type\FrontendPool $cacheFrontendPool
	)
	{
		parent::__construct(
			$cacheFrontEndPool->get(self::TYPE_IDENTIFIER), self::CACHE_TAG);
	}
}

The Cache class extends from the TagScope and specifies its own values for TYPE_IDENTIFIER and CACHE_TAG, passing them along
to the parent constructor in the __construct method. With these two files (cache.xml and Cache), we have basically
defined a new cache type.

Once we have specified the cache.xml file and referenced cache class, we should be able to see our cache type in Magento
admin under the System | Tools | Cache Management menu.

on its own, simply defining a new cache does not mean that it will get filled and used by Magento.

If you would like to use the cache anywhere within your code, you can do so by first passing the instance of the cache class
to the constructor, as follows:

protected $cache;

public function __construct(
	\Foggyline\Office\Model\Cache $cache
)
{
	$this->cache = $cache;
}

Then you can execute a chunk of code, as follows:

$cacheId = 'some-specific-id';
$objInfo = null;
$_objInfo = $this->cache->load($cacheId);

if ($_objInfo) {
	$objInfo = unserialize($_objInfo);
} else {
	$objInfo = [
		'var1' => 'val1',
		'var2' => 'val2',
		'var3' => 'val3'
	];
	$this->cache->save(serialize($objInfo), $cacheId);
}

The preceeding code shows how we first try to load the value from the existing cache entry, and if there is none, we save to it.

If the cache type is set to disabled under the Cache Management menu, then the preceeding code will never save and pull data from the cache,
as it is not in effect. If you take a look at the var/cache folder of Magento at this point, you will see something similar to what's shown
in the following folder structure:

var
	cache
		mage--9
			mage---a8a_DESIGN_CHANGE_<stuff>
		mage--d
			mage---a8a_ADMIN_NOTIFICATIONS_LASTCHECK
		mage--e
			mage---a8a_CONFIGURATION_FILE_ACCESS_LEVEL_VERIFICATION
		mage--f
			mage---a8a_SOME_SPECIFIC_ID
		mage-tags
			mage---a8a_CORE_DESIGN
			mage---a8a_MAGE
			mage---a8a_OFFICE

Magento created two cache entries for us, namely var/cache/mage-tags/mage---a8a_OFFICE and var/cache/mage--f/mage---a8a_SOME_SPECIFIC_ID.

The mage---a8a_OFFICE file has only a single line of entry in this specific case, and the entry is the a8a_SOME_SPECIFIC_ID string, which obviously point
to the other file. The mage---a8a_SOME_SPECIFIC_ID file contains the actual serialized $objInfo array

The a8a_prefix and other prefixes in the cache file names are not really relevant to us: This is something that Magento adds on its own. What is relevant
to us in passing of the proper individual cache tags to the chunks or variables that we want to cache, like in the preceeding example,
and the TYPE_IDENTIFIER and CACHE_TAG tags that we set for the Cache class.

Magento provides support for widgets. Though the word "widget" might imply frontend development skills and activites, we will look at them
as part of the backend development flow because creating useful and robust widgets requires a significant amount of backend knowledge.

Magento provides several out-of-the-box widgets; Some of them are as follows:

CMS page link

CMS static block

Catalog category link

Catalog new products list

Catalog product link

Catalog products list

Orders and returns

Recently compared products

Recently viewed products

To create a fully custom widget, we start by defining app/code/Foggyline/Office/etc/widge.xml with content:

<widgets xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Widget:etc/widget.xsd">
	<widget id="foggyline_office"
		class="Foggyline\Office\Block\Widget\Example"

	placeholder_image="Magento_Cms"::images/widget_block.png">
		<label translate="true">Foggyline Office</label>
		<description translate="true">Example widget</description>
		<parameters>
			<parameter name="var1"
xsi:type="select" visible="true"
source_model"Magento\Config\Model\Config\Source\Yesno">
				<label
translate="true">Yes/No var1</label>
			</parameter>
			<parameter name="var2"
xsi:type="text" required="true"
visible="true">
				<label
translate="true">Number var2</label>
				<depends>
					<parameter name="var1"
value="1"/>
				</depends>
				<value>5</value>
			</parameter>
		</parameters>
	</widget>
</widgets>

The id widget has been set to foggyline_office, while the class powering widget has been set to 
Foggyline\Office\Block\Widget\Example. the widget class is basically a block class that extends from 
\Magento\Framework\View\Element\AbstractBlock and implements \Magento\Widget\Block\BlockInterface. The label
and description element set values appear under the Magento admin when we select the widget for use.

The parameters of a widget are its configurable options that translate into HTML form elemens, depending on the type
and source_model options that we have selected. In the following example, we will demonstrate the usage of 
select and text elements to retrieve input from a user.

Let's proceed by creating the actual Widget\Example class in the app/code/Foggyline/Office/Block/Widget/Example.php file:

namespace Foggyline\Office\Block\Widget;

class Example extends \Magento\Framework\View\Element\Text implements \Magento\Widget\Block\Blockinterface
{
	protected function _beforeToHtml()
	{
		$this->setText(sprintf(
			'example widget: var1=%s, var2=%s',
			$this->getData('var1'),
			$this->getData('var2')
		));

		return parent::_beforeToHtml();
	}
}

What is happening here, is that we are using Element\Text as a block type and not Element\Template because
we want to simplify the example, as Element\Template will require the phtml template to be defined as well.

By using Element\Text, we can simply define _beforeHtml and call the setText method to set the text string of the block's
output. We will build the output string by picking up the var1 and var2 variables, which were passed as parameters to the block.

Now, if we open the Magento admin area, go to Content | Elements | Pages, and select Home Page to edit, we 
should be able to click on the Insert Frontend App button and add our widget to the page. Alternatively, if 
we are not editing the page in the WYSIWYG mode, we can also add the widget manually to the page by using
the following stuff:

{{widget type="Foggyline\\Office\\Block\\Widget\\Example" var1="1" var2="5"}}

Finally, we should see the example widget: var1=1, var2=5 string in the browser visiting the home page of the storefront.

We can use frontend apps to create highly configurable and embedded widgets that users can easily assign to a CMS page or block.

Variables are a handy little feature of a core Magento_Variable module. Magento allows you to create custom variables
and then use them in e-mail templates, the WYSIWYG editor, or even code expressions.

The following steps outline how we can create a new variable manually:

1. In the Magento admin area, navigate to System | Other Settings | Custom Variables.

2. Click on the Add New Variable button.

3. While keeping in mind the Store View switcher, fill in the required Variable Code and Variable Name
options, and preferably one of the optional options, either Variable HTML Value or Variable Plain Value.

4. Save

Now that we have created the custom variable, we can use it in an e-mail template or the WYSIWYG editor by calling it
using the following expression:

{{customVar code=foggyline_hello}}

The preceeding expression will call for the value of the custom variable with code foggyline_hello.

Variables can be used within various code expressions, though it is not recommended to rely on the existence of an
individual variable, as an admin user can delete it at any point. The following example demonstrates how we can use
an existing variable in the code:

$storeId = 0;

$variable =
$this->_variableFactory->create()->setStoreId(
	$storeId
)->loadByCode(
	'foggyline_hello'
);

$value = $variable->getValue(
	\Magento\Variable\Model
\Variable::TYPE_HTML
);

The $this->variableFactory is an instance of \Magento\Variable\Model\VariableFactory

If used in the right way, variables can be useful. Storing information such as phone numbers or specialized 
labels that are used in CMS pages, blogs, and e-mail templates is a nice example of using custom variables.

i18n is the shorthand for internalization. Magento adds i18n support out of the box, thus adapting to
various languages and regions without application changes. Within app/functions.php, there is a __() translation
function, which is defined as follows:

function __()
{
	$argc = func_get_args();

	$text = array_shift($argc);
	if (!empty($argc) && is_array($argc[0]))
	{
		$argc = $argc[0];
	}

	return new \Magento\Framework\Phrase($text, $argc);
}

This translation function accepts a variable number of arguments and passes them to a constructor of the
\Magento\Framework\Phrase class and returns its instance. The Phrase class has the __toString method,
which then returns the translated string.

Here are a few examples of how we can use the __() function:

__('Translate me')

__('Var1 %1, Var2 %2, Var %3', time(), date('Y'), 32)

__('Copyright %1 <a href="%2">Magento</a>', date('Y'), 'http://magento.com')

Strings passed through the translation function are expected to be found under the local CSV files, such
as app/code/{vendorName}/{moduleName}/i18n/{localeCode}.csv.

Let's imagine for a moment that we have two different store views defined in the Magento admin area under Stores | Settings
| All Stores.

One store has Store | Settings | Configuration | General | Locale Options | Locale set to English (United Kingdom) and other one to 
German (Germany). The local code for English (United Kingdom) is en_GB, and for German(Germany), it is de_DE.

For the de_DE locale, we will add translation entries in the app/code/Foggyline/Office/i18n/de_DE.csv file, as follows:

"Translate me", "de_DE Translate me"
"Var1 %1, Var2 %2, Var %3", "de_DE Var1 %1, Var2 %2, Var %3"
"Copyright %1 <a
href=""%2"">Magento</a>","de_DE Copyright %1 <a href=""%2"">Mangeto</a>"

For the en_GB locale, we will add translation entires in the app/code/Foggyline/Office/i18n/en_GB.csv file, as follows:

"Translate me", "en_GB Translate me"
"Var1 %1, Var2 %2, Var %3", "en_GB Var1 %1, Var2 %2, Var %3"
"Copyright %1 <a
href=""%2"">Magento</a>","en_GB Copyright %1 <a href=""%2"">Magento</a>"

Looking at the two CSV files, a pattern emerges. We can see that the CSV files function in the following way:

Individual translation strings are provided according to every line of CSV

Each line further comprises two individual strings that are seperated by a comma

Both individual strings are surrounded by quotes

If a string contains quotes, it is escaped by a double quote
so that it does not break translation

The %1, %2, %3..%n pattern is used to mark variable placeholders that we provided during
application runtime through the code

Magento supports several commands related to its bin/magento console tool:

i18n
	i18n:collect-phrases 	Discovers phrases
in the codebase
	i18n:pack 				Saves language
package
	i18n:uninstall 			Uninstalls
language packages

If we execute a console command as follows, Magento will recursively look for translatable expressions within PHP,
PHTML or XML files that have phrases to translate:

php bin/magento i18n:collect-phrases -o
"/Users/branko/www/magento2/app/code/Foggyline/Office/
i18n/en_GB.csv" /Users/branko/www/magento2/app/code/Foggyline/Office

The output of the preceding comand will basically overwrite the app/code/Foggyline/Office/i18n/en_GB.csv file, 
which has all the Foggyline/Office module translatable phrases. This is a nice way of aggregating all the translatable
phrases into appropiate locale files, such as en_GB.csv in this case.

The translation CSV files can also be placed under the individual theme. For example, let's imagine
a situation where we add content to app/design/frontend/Magento/blank/i18n/en_GB.csv as follows:

"Translate me", "Theme_en_GB Translate me"
"Var1 %1, Var2 %2, Var %3", "Theme_en_GB Var1
%1, Var2 %2, Var %3"
"Copyright %1 <a href=""%2"">Magento</a>", "Theme_en_GB
Copyright %1 <a href=""%2"">Magento</a>"

Now, a Translate me string output of the storefront for the en_GB locale would resolve to Theme_en_GB Translate me
and not to the en_GB Translate me string.

Theme CSV translations take higher precedence than module CSV translations, thus enabling developers to override
individual module translations.

Along with CSV translation files, Magento also supports a feature called inline translation. We can activate 
the inline translation in the Magento admin area by navigating to Store | Settings | Configuration | Advanced | Developer | Translate Inline

This feature can be turned on seperately for Admin and Storefront.

As shown in the preceeding screenshot, when a feature is activated, red dotted borders appear around the HTML elements.
Hovering over an individual element shows a little book icon near the individual element at the bottom left corner.
Clicking on the book icon opens a popup with info.

It is important to know, that these red dotted borders and the book icon will only appear for strings that we passed through the __() translate function.

Here we can see various pieces of information about the string, such as the Shown, Translated, and Original string. There is also an input field
called Custom, where we can add a new translation. Inline translation strings are stored in the translation table in the DB.

NOTE: Inline translation takes higher predecence than theme CSV translation files.

Indexing is the process of transforming data by reducing it to flattened data with less DB tables. This process is run
for products, categories, and so on in order to improve the performance of a web store. Since data constantly changes,
this is not a one-time process. Rather, it's done in periods.

The Magento_Indexer module is a base of the Magento Indexing functionality.

The Magento console tool supports the following indexer commands.

indexer
	indexer:info 		Shows allowed
Indexers
	indexer:reindex 	Reindexes Data
	indexer:set-mode 	Sets index mode type
	indexer:show-mode 	Shows index mode
	indexer:status 		Shows status of Indexer

On running php bin/magento indexer:info, you will get a list of all the Magento indexers. The default ones are as
follows:

catalog_category_product 	Category Products
catalog_product_category 	Product
Categories
catalog_product_price 		Product Price
catalog_product_attribute 	Product EAV
foggyline_office_employee 	Employee flat
Data
cataloginventory_stock 		Stock
catalog_rule 				Catalog Rule
Product
catalogrule_product 		Catalog Product
Rule
catalogsearch_fulltext 		Catalog Search

You will see all the indexers listed in the Magento admin in the System | Tools | Index Management menu.

From within the admin area, we can only change the indexer mode. There are two modes of indexers:

Update on Save: Index tables are updated right after the dictionary data is changed

Update by Schedule: Index tables are updated by cron jobs according to the configured schedule

Since indexers cannot be run manually from admin, we have to rely on their manual execution or the cron execution.

Manual execution is done via the following console command:

php bin/magento indexer:reindex

The preceding command will run all the indexers at once. We can fine-tune it further to execute individual indexes
by running a console command that is similar to the following line of code:

php bin/magento indexer:reindex
catalogsearch_fulltext

Cron-executed indexers are defined via the Magento_Indexer module, as follows:

indexer_reindex_all_invalid: This will execute every minute of every hour every day. It runs the
reindexAllInvalid method on an instance of the Magento\Indexer\Model\Processor class.

indexer_update_all_views: This will execute every minute of every hour everyday. It runs the
updateMview method on an instance of the Magento\Indexer\Model\Processor class.

indexer_clean_all_changelogs: This will execute the 0th minute of every hour every day. it runs 
the clearChangelog method on an instance of the Magento\Indexer\Model\Processor class.

These cron jobs use an operating system cron job setup in such a way that the Magento cron job is triggered
every minute.

The following three statuses is what an indexer can have:

valid: The data is synchronized and no re-indexing is required

invalid: The original data was changed and the index should be updated

working: The index process is running

While we won't go into the details of actually creating a custom indexer within this chapter,
it is worth noting that Magento defines it's indexers in the vendor/magento/module-*/etc/indexer.xml file

This might come in handy for cases where we want a deeper understanding of the inner workings of an individual indexer. For example,
the catalog_product_flat indexer is implemented via the Magento\Catalog\Model\Indexer\Product\Flat class, as defined within
the vendor/magento/module-catalog/etc/indexer.xml file.

By studying the Flat class implementation in depth, you can learn how data is taken from EAV tables and flattened into a simplified structure.

The next part, is about Frontend development. 

Frontend development, is mostly tied to HTML, CSS and JS for websites or web apps.

Interchangably, it adresses accessibility, usability and performance towards reaching a satisfying user experience.
Various levels of customization we want to apply to our web store require different development skill levels.

We can make relativily simple changes to our store using just CSS. These would be the changes where we accept the
structure of the store and focus only on visuals like changing colors and images. This might be a good starting point
for less experienced devs, and those new to Magento.

A more involved approach would be to make changes to the output generated by Magento modules. This usually means tiny bits of PHP knowledge,
mostly copy-paste modify of existing code fragments. A skill level above this one would imply knowledge of making structural 
changes to our store.

This usually means mastering Magento's moderately sophisticated layout engine, where we make changes through XML definitions.
The final and highest skill level of Magento frontend, implies development of existing or new custom functionality development.

Throughout this chapter, we will take a deep dive through the following sections:

Rendering flow

View elements

Block architechture and life cycle

Templates

XML Layouts

Themes

JS

CSS

The Magento application entry point is its index.php file. All of the HTTP requests go through it.
Let's analyze the (trimmed) version of the index.php file as follows:

require __DIR__ . '/app/bootstrap.php';

$bootstrap = \Magento\Framework\App\Bootstrap::create(BP, $_SERVER);

$app => $bootstrap -> createApplication('Magento\Framework\App\Http');

$bootstrap->run($app);

Thus, we begin by including /app/bootstrap.php into the code. What happens inside the bootstrap is the inclusion of app/autoload.php
and app/functions.php. These functions file contains a single __() function, used for translation purposes, returning an instance of
the \Magento\Framework\Phrases object. 

Without going into the details of the auto-load file, it is suffice to say it handles the auto-loading of all our class files across Magento.

The second step, is simply a static create method call to obtain the instance of the \Magento\Framework\App\Bootstrap object,
storing it into the $bootstrap variable.

The third step, is calling createApplication method on the $bootstrap object. What is happening within createApplication
is nothing more than using object manager to create and return the object instance of the class we are passing to it.

Since we are passing the \Magento\Framework\App\Http class name to the createApplication method, our $app variable becomes
the instance of that class. What this means, effectively, is that our web store app is an instance of Magento\Framework\App\Http.

The last step, is to call the run method on $bootStrap object, passing it the instance of the Magento\Framework\App\Http class.
Although it looks like a simple line of code, this is where stuff gets complicated, as we will see soon.

Let's analyze the trimmed version of the \Magento\Framework\Bootstrap -> run method as follows:

public function run(\Magento\Framework\AppInterface $application)
{
	//PART 2-1
	$this->initErrorHandler();
	$this->initObjectManager();
	$this->assertMaintenance();
	$this->assertInstalled();

	//PART 2-2
	$response = $application->launch();

	//PART 2-3
	$response->sendResponse();
}

Part 2-1, handles the sort of housekeeping bits. It initializes the custom error handler,
intializes the object manager, checks if our app is in maintnance mode, and checked that its installed.

Part 2-2, we call the launch() method on $application, which is the Magento\Framework\App\Http instance.
Without going into the inner workings of the launch method for the moment, let's just say it returns the instance
of Magento\Framework\App\Response\Http\Interceptor class defined under var/generation/Magento/Framework/App/Response/Http/Interceptor.php

Note that this is an automatically generated wrapper class, extending the \Magento\Framework\App\Response\Http class.

Effectively, ignoring the interceptor, we can say that $response is an instance the \Magento\Framework\App\Response\Http class.

Finally, Part 2-3 calls the sendResponse method on $response. Though $response is an instance of the \Magento\Framework\App\Response\Http class,
the actual sendResponse method is found further down the parent tree on the \Magento\Framework\HTTP\PhpEnvironment\Response class.

The sendResponse method calls another parent class method called send. The send method can be found under the Zend\Http\PhpEnvironment\Response class.
It triggers the sendHeaders and sendContent methods. This is where the actual output gets sent to the browser, as the sendHeaders methods
is using PHP's header function and echo construct to push the output.

To reiterate on the preceeding, the flow of execution as we understand it, comes down to the following:

index.php

\Magento\Framework\App\Bootstrap->run
\Magento\Framework\App\Http->launch
\Magento\Framework\App\Response\Http->sendResponse

Though we have just made it to the end of the bootstrap's run method, it would be unfair to say we covered the rendering flow,
as we barely touched it.

We need to take a step back and take a detailed look at PART 2-2, the inner workings of the launch method. Let's take a look at the
(trimmed) version of the \Magento\Framework\App\Http->launch method as follows:

public function launch()
{
	//Part 3-1
	$frontController =
$this->_objectManager->get
('Magento\Framework\App\FrontControllerInterface');

	//Part 3-2
	$result =
$frontController->dispatch($this->_request);
	
	if ($result instanceof \Magento\Framework\Controller\ResultInterface) {
		//part 3-3

$result->renderResult($this->_response);
	} elseif ($result instanceof \Magento\Framework\App\Response\HttpInterface) {
		$this->_response = $result;
	} else {
		throw new \InvalidArgumentException('Invalid return type');
	}
	
	//part 3-4
	return $this->_response;
}

Part 3-1 creates the instance of the object whose class conforms to \Magento\Framework\App\FrontControllerInterface.
If we look under app/etc/di.xml, we can see there is a prefernce for FrontControllerInterface in favor of the \Magento\Framework\App\FrontController class.

However, if we were to debug the code and check for the actual instance class, it would show Magento\Framework\App\FrontController\Interceptor.
This is Magento adding an interceptor wrapper that then extends \Magento\Framework\App\FrontController, which we expected from the di.xml
prefernce entry.

Now that we know the real class behind the $frontController instance, we know where to look for the dispatch method. The dispatch method 
is another important step in understanding the rendering flow process. We will look into its inner workings in a bit more detail later
on.

For now, let's focus back on the $result variable of part-3-2. If we were to debug the variable, the direct class behind it would show as
Magento\Framework\View\Result\Page\Interceptor, defined under the dynamically created var/generation/Magento/Framework/View/Result/Page/Interceptor.php file.

interceptor is the wrapper of the \Magento\Framework\View\Result\Page class. Thus, it is safe to say that our $result variable is an
instance of the Page class.

The Page class extends \Magento\Framework\View\Result\Layout, which further extends \Magento\Framework\Controller\AbstractResult and implements
\Magento\Framework\Controller\ResultInterface. Quite a chain we have here, but it is important to understand it.

Notice part 3-3. Since our $result is an instance of \Magento\Framework\Controller\ResultInterface, we fall into the first if condition
that calls the renderResult method. the renderResult method itself is declared within the \Magento\Framework\View\Result\Layout class.

Without going into the details of renderResult, suffice to say that it adds HTTP headers, and content to the $this->_response object
passed to it. That same response object is what the launch method returns, as we described before in Part 2-2.

Though part-3-3 does not depict any return value, the expression $result->renderResult($this->_response) does not do any
output on its own. It modifies $this->_response that we finally return from the launch method as shown in part-3-4

To reiterate on the preceeding, the flow of execution as we understand it comes down to the following:

index.php

\Magento\Framework\App\Bootstrap->run

\Magento\Framework\App\Http->launch

\Magento\Framework\App\FrontController->dispatch

\Magento\Framework\View\Result\Page->renderResult

\Magento\Framework\App\Response\Http->sendResponse

As we mentioned while explaining Part-3-2, the dispatch method is another important step 
in the rendering flow process. Let's take a look at the (trimmed) version of the \Magento\Framework\App\FrontController->dispatch method as follows:

public function dispatch(\Magento\Framework\App\RequestInterface $request)
{
	//PART 4-1
	while (!$request->isDispatched() && $routingCycleCounter++ < 100) {
		//Part 4-2
		foreach ($this->_routerList as $router)
		{
			try {
				//PART 4-3
				$actionInstance = $router->match($request);
				if ($actionInstance) {
					$request->setDispatched(true);
											//PART 4-4
											$result =
				$actionInstance->dispatch($request);
											break;
										}
									} catch (\Magento\Framework\Exception\NotFoundException $e) {}
				
			
		}
	}

	//part 4-4 
	return $result;
}

//NOTE: Indention error on some level of where we have not found the pattern correctly

Part-4-1 and PART-4-2 in the preceeding code shows (almost) the entire dispatch method body contained within a loop.
The loop does 100 iterations, further looping through all available router types, thus giving each router 100 times to find a router match.

The router list loop includes routers of the following class types:

Magento\Framework\App\Router\Base

Magento\UrlRewrite\Controller\Router

Magento\Cms\Controller\Router

Magento\Framework\App\Router\DefaultRouter

All of the list routers implement \Magento\Framework\App\RouterInterface, making them all have the implementations of the match method.

A module can further define new routers if they choose so. As an example, imagine if we are developing a blog module. We would want our module
catching all requests on a URL that starts with a /blog/ part. This can be done by specifying the custom router, which would then show up
on the preceeding list.

Part-4-3 shows the $actionInstance variable storing the result of the router match method call. As per RouterInterface
requirements, the matcher method is required to return an instance whose class implements \Magento\Framework\App\ActionInterface. Let's
imagine we are now hitting the URL /foggyline_office/test/crud/ from the module we wrote in chaper 4.

in this case, our $router class would be \Magento\Framework\App\Router\Base and our $actionInstance would be of the class \Foggyline\Office
\Controller\Test\Crud\Interceptor.

Magento automatically adds Interceptor, through the dynamically generated var/generation/Foggyline/Office/Controller/Test/Crud/Interceptor.php file

This Interceptor class further extends our module \Foggyline\Office\Controller\Test\Crud class file.
The Crud class extends \Foggyline\Office\Controller\Test, which further extends \Magento\Framework\App\Action\Action, which implements
\Magento\Framework\App\ActionInterface. After a lengthy parent-child tree, we finally got to ActionInterface, which is what 
our match method is required to return.

Part-4-4 shows the dispatch method being called on $actionInstance. This method is implemented within \Magento\Framework\App\Action\Action, and is
expected to return an Object that implements \Magento\Framework\App\ResponseInterface. Internal to dispatch, the execute method is called,
thus running the code within our Crud controller action execute method.

Assuming our Crud controller action execute method does not return nothing, the $result object becomes an instance of Magento\Framework\App\Response\Http\Interceptor,
which is wrapped around \Magento\Framework\App\Response\Http.

Let's imagine our Crud class has been defined as follows:

/**
  * @var \Magento\Framework\View\Result\Pagefactory
  */

protected $resultPageFactory;

public function __construct( \Magento\Framework\App\Action\Context $context, \Magento\Framework\View\Result\PageFactory $resultPageFactory)
{
	$this->resultPageFactory = $resultPageFactory;
	return parent::__construct($context);
}

public function execute()
{
	$resultPage = $this->resultPageFactory->create();
	//...
	return $resultPage;
}

Debugging the $result variable now shows it's an instance of \Magento\Framework\View\Result\Page\Interceptor. This Interceptor
gets dynamically generated by Magento under var/generation/Magento/Framework/View/Result/Page/Interceptor.php
and is merely a wrapper for \Magento\Framework\View\Result\Page. This Page class further extends the \Magento\Framework\View\Result\Layout class,
and implements \Magento\Framework\App\ResponseInterface.

Finally, PART-4-4 shows the $result object of type \Magento\Framework\View\Result\Page being returned from the FrontController dispatch method.
To reiterate on the preceeding, the flow of execution as we understand it comes down to the following:

index.php

\Magento\Framework\App\Bootstrap->run

\Magento\Framework\App\Http->launch

\Magento\Framework\App\FrontController->dispatch

\Magento\Framework\App\Router\Base->match

\Magento\Framework\App\Action\Action->dispatch

\Magento\Framework\View\Result\Page->renderResult

\Magento\Framework\App\Response\Http->sendResponse

In a nutshell, what we as a frontend dev should know is that returning the Page type object from our controller
action will automatically call the renderResult method on that object. Page and Layout is where all the theme translations, layout and template loading
are triggering.

Magento's primary view elements are its UI components, containers and blocks. The following is a brief overview of each of them.

Under the vendor/magento/framework/View/Element/ folder, we can find UiComponentInterface and UiComponentFactory.
The full set of Ui components is located under the vendor/magento/framework/View/Element/ dir.

Magento implements UiComponent through a seperate module called Magento_Ui. Thus, the components themselves are 
located under the vendor/magento/module-ui/Component/ dir.

Components implement UiComponentInterface, which is defined under the vendor/magento/framework/View/Element/UiComponentInterface.php file as follows:

namespace Magento\Framework\View\Element;

use Magento\Framework\View\Element\UiComponent\ContextInterface;

interface UiComponentInterface extends BlockInterface
{
	public function getName();
	public function getComponentName();
	public function getConfiguration();
	public function render();
	public function addComponent($name, UiComponentInterface $component);
	public function getComponent($name);
	public function getChildComponents();
	public function getTemplate();
	public function getContext();
	public function renderChildComponent($name);
	public function setData($key, $value = null);
	public function getData($key = '', $index = null);
	public function prepare();
	public function prepareDataSource(array & $dataSource);
	public function getDataSourceData();
}

Notice how BlockInterface extends BlockInterface, whereas BlockInterface defines only one method requirement as follows:

namespace Magento\Framework\View\Element;

interface BlockInterface
{
	public function toHtml();
}

Since Block is an element of the interface, UiComponent can be looked at as an advanced block. Let's take a quick look
at the _renderUiComponent method of the \Magento\Framework\View\Layout class (partially) as follows:

protected function _renderUiComponent($name)
{
	$uiComponent = $this->getUiComponent($name);

	return $uiComponent ? $uiComponent->toHtml() : '';
}

This shows that UiComponent is rendered the same way as block, by calling the toHtml method on the component.
The vendor/magento/module-ui/view/base/ui_component/etc/definition.xml file contains an extensive list of several
UiComponents as follows:

dataSource:Magento\Ui\Component\DataSource

listing:Magento\Ui\Component\Listing

paging:Magento\Ui\Component\Paging

filters:Magneto\Ui\Component\Filters

container:Magento\Ui\Component\Container

form:Magento\Ui\Component\Form

price:Magento\Ui\Component\Form\Element\DataType\Price

image:Magento\Ui\Component\Form\Element\DataType\Media

nav:Magento\Ui\Component\Layout\Tabs\Nav

and more!

These components are mostly used to construct a listing and filters in the admin area.
If we do a string search for uiComponent across the entire Magento, we would mostly
find entries like the one in vendor/magento/module-cms/view/adminhtml/layout/cms_block_index.html, with stuff like:

<page xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:noNamespaceSchemaLocation="urn:magento:framework:View/Layout/etc/page_configuration.xsd">
	<body>
		<referenceContainer name="content">
			<uiComponent name="cms_block_listing"/>
		</referenceContainer>
	</body>
</page>

The value cms_block_listing of uiComponent's name attribute refers to the name of the vendor/magento/module-cms/view/adminhtml/ui_component/
cms_block_listing.xml file. Within the cms_block_listing.xml file, we have a listing component defines across more than
a few hundred lines of XML. Listing component then dataSource, container, bookmark, filterSearch, filters and so on. We will not
go into the details of these declarations, as our focus here is on more general frontend bits.

We cannot create instances of containers because they are an abstract concept, whereas we can create instances of Blocks.

Containers are rendered via the _renderContainer method of the Magento\Framework\View\Layout class, defines as follows:

protected function _renderContainer($name)
{
	$html = '';
	$children = $this->getChildNames($name);
	foreach ($children as $child) {
		$html .=
$this->renderElement($child);
	}
	if ($html == '' ||
!$this->structure->getAttribute($name, Element::CONTAINER_OPT_HTML_TAG)) {
		return $html;
}

	$htmlId =
$this->structure->getAttribute($name, Element::CONTAINER_OPT_HTML_ID);
	if ($htmlId) {
		$htmlId = ' id="' . $htmlId . '"';
	}

	$htmlClass =
$this->structure->getAttribute($name, Element::CONTAINER_OPT_HTML_CLASS);
	if ($htmlClass) {
		$htmlClass = ' class="' . $htmlClass . '"';
	}

	$htmlTag =
$this->structure->getAttribute($name, Element::CONTAINER_OPT_HTML_TAG);

	$html =
sprintf('<%1$s%2$s%3$s>%4$s</%1$s>',
$htmlTag, $htmlId, $htmlClass, $html);
	
	return $html;
}

Containers support the following extra attributes: htmlTag, htmlClass, htmlId and label. To make a little
demonstration of a container in action, let us make sure we have a module from Chapter 4. Models and Collections in
place, and then create the view/frontend/layout/foggyline_office_test_crud.xml file within the
module root folder app/code/Foggyline/Office/ with content as follows:

<page xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" layout="1column"

xsi:noNamespaceSchemaLocation="urn:magento:framework:View/Layout/etc/page_configuration.xsd">
	<head>
		<title>Office CRUD #layout</title>
	</head>
	<body>
		<container name="foobar" htmlTag="div" htmlClass="foo-bar">
			<block class="Magento\Framework\View\Element\Text" name="foo">
				<action method="setText">
					<argument name="text"
xsi:type="string"> <![CDATA[<p>The Foo</p>]]>
</argument>
				</action>
			</block>
			<block class="Magento\Framework\View\Element\Text" name="bar">
															<action method="setText">
																<argument name="text" 
xsi:type="string"> <![CDATA[<p>The bar</p>]]>
</argument>
															</action>
														</block>
													</container>
												</body>
											</page>


NOTE: Error in Indentions

The preceding XML defines a single container named foobar, and within the container there are two block
elements named foo and bar. It should kick in when we open http://{our-shop-url}/index.php/foggyline_office/test/crud/ in the browser.

Notice how the container itself is not nested within any other element, rather directly into the body. We could have
easily nested into some other container as shown:

<body>
	<referenceContainer name="content">
		<container name="foobar" htmlTag="div" htmlClass="foo-bar">

Either way, we should see the srings The Foo and The Barshown in the browser, with a full-page layout loaded, as shown
in the following screenshot.

Although containers determine the layout of the page, they do not contain actual content directly. Pieces that contain the
content and are nested within containers are called blocks. Each block can contain any number of child content blocks or
child containers. Thus, mostly every web page in Magento is formed as a mix of blocks and containers. Layout defines a
sequence of blocks on the page, not their location.

The look and feels of the blocks is determined by CSS and how the Page is rendered. When we speak of Blocks,
we almost always implicitly refer to templates as well. Templates are the thing that actually draw elements within
a page. Blocks are the thing that contain the Data. In other words, templates are PHTML or HTML files pulling data
through variables or methods sent on a linked PHP block class.

Magento defines Magento\Framework\View\Result\Page type under app/etc/di.xml as follows:

<type name="Magento\Framework\View\Result\Page">
	<arguments>
		<argument name="layoutReaderPool" 
xsi:type="object">pageConfigRenderPool</argument>
		
		<argument name="generatorPool"
xsi:type="object">pageLayoutGeneratorPool</argument>

		<argument name="template"
xsi:type="string">Magento_Theme::root.phtml</argument>	
	</arguments>
</type>

Notice the template argument is set to Magento_Theme::root.phtml. Whem Page gets 
initialized, it picks up the vendor/magento/module-theme/view/base/templates/root.pthml file.

root.phtml is defined as follows:

<!doctype Html>
<html <?php echo $htmlAttributes ?>>
	<head <?php echo $headAttributes ?>>
		<?php echo $requireJs ?>
		<?php echo $headContent ?>
		<?php echo $headAdditional ?>
	</head>
	<body data-container="body" data-mage-init='{"loaderAjax": {}, "loader": { "icon": "<?php echo $loaderIcon; ?>"}}'
	<?php echo $bodyAttributes ?>>
		<?php echo $layoutContent ?>
	</body>
</html>

Variables within root.phtml are assigned during the Magento\Framework\View\Result\Page render method call as (partially) shown:

protected function render(ResponseInterface $response)
{
	$this->pageConfig->publicBuild();

	if ($this->getPageLayout()) {
		$config = $this->getConfig();
		$this->addDefaultBodyClasses();
		$addBlock = 
$this->getLayout()->getBlock('head.additional');
		$requireJs = $this->getLayout-getBlock('require.js');
		$this->assign([
			'requireJs' => $requireJs ? $requireJs->toHtml() : null,
			'headContent' => $this->pageConfigRenderer->renderHeadContent(),
			'headAdditional' => $addBlock ? $addBlock->toHtml() : null,
			'htmlAttributes' => $this->pageConfigRenderer->renderElementAttributes($config::ELEMENT_TYPE_HTML),
			'headAttributes' => $this->pageConfigRenderer->renderElementAttributes($config::ELEMENT_TYPE_HEAD),
			'bodyAttributes' => $this->pageConfigRenderer->renderElementAttributes($config::ELEMENT_TYPE_BODY),
			'loaderIcon' => $this->getViewFileUrl('images/loader2.gif'), ]);

			$output = $this->getLayout()->getOutput();
			$this->assign('layoutContent', $output);
			$output = $this->renderPage();

			$this->translateInline->processResponseBody($output);
			$response->appendBody($output);
	} else {
		parent::render($response);
	}

	return $this;
}

The expression $this->assign is what assigns variables like layoutContent to the root.phtml template.
layoutContent is generated based on base layouts, together with all layout updates for the current page.

Whereas base layouts include the following XMLs within vendor/magento/module-theme/view/:

base/page_layout/empty.xml

frontend/page_layout/1column.xml

frontend/page_layout/2columns-left.xml

frontend/page_layout/2columns-right.xml

frontend/page_layout/3columns.xml

The expression $this->getLayout()->getOutput() is what gets all blocks marked for output. It basically finds
elements in a layout, renders them, and returns the string with its output. Along the way, the event core_layout_render_elements gets fired,
giving us one possible way of affecting the output result. At this point, most of the elements on the page are rendered.

This is important because blocks play a big role here. The rendering system will take empty.xml into account, as it too consists of a list of
containers, and every container has some blocks attached to it by other layout updates.

In a nutshell, each container has blocks assigned to it. Each block usually (but not always) renders a template. The template itself
may or may not call call other blocks, and so on. Blocks are rendered when they are called from the template.

Blocks are another one of the primary view elements in Magento. At the root of the parent tree
structure, blocks extend from the Magento\Framework\View\Element\BlockInterface.

BlockInterface sets only one requirement, the implementation of the toHtml method. This method
should return blocks HTML output.

Looking inside AbstractBlock, we can see that it has a number of methods declared. Among the most
important ones, are the following methods:

_prepareLayout: Prepares a global layout. We can redefine this method in child classes for changing the layout.

addChild: Creates a new block, sets it as a child of the current block, and returns the newly 
created block.

_toHtml: Returns an empty string. We need to override this method in descendants to produce HTML.

_beforeToHtml: Returns $this. Executes before rendering HTML, but after trying to load a cache

_afterToHtml: Processing block HTML after rendering. Returns a HTML string.

toHtml: Produces and returns a block's HTML output. This method should not be overridden. We can
override the _toHtml method in descendants if needed.

The AbstractBlock execution flow can be described as follows:

_prepareLayout

toHtml

_beforeToHtml

_toHtml

_afterToHtml

It starts with _prepareLayout and flows through a set of methods until it reaches _afterToHtml.
This is, in essence, what we need to know about block execution flow.

The most important block types are:

Magento\Framework\View\Element\Text

Magento\Framework\View\Element\Text\ListText

Magento\Framework\View\Element\Messages

Magento\Framework\View\Element\Template

All of these blocks are basically an implementation of an 
abstract block. Since the _toHtml method in AbstractBlock returns only an empty string,
all of these descendants are implenting their own version of the _toHtml method.

To demonstrate the usage of these blocks, we can use our previously, created
app/code/Foggyline/Office/view/frontend/layout/foggyline_office_test_crud.xml file:

The Text block has a setText method we can use to set its content. The way we instansiate 
the Text block and set its text value through the layout file is shown as follows:

<block class="Magento\Framework\View\Element\Text" name="example_1">
	<action method="setText">
		<argument name="text" xsi=type="string"><![CDATA[<p>Text_1</p>]]</argument>
	</action>
</block>

The ListText block extends from Text. However, it does not really support
the use of setText to set its content. This is obviously just by looking at its code,
where the $this->setText('') expression is immediately called within it's _toHtml method implementation.

Instead, what happens is that the _toHtml method loops through any child blocks
it might have and calls the layout's renderElement method on it. Basically, we might compare the ListText
block to container, as it is nearly the same purpose.

However, unlike container, block is a class so we can manipulate it from PHP.
The following is an example of using ListText, containing a few child Text blocks:

<block class="Magento\Framework\View\Element\Text\ListText" name="example_2">
	<block class="Magento\Framework\View\Element\Text" name="example_2a">
		<action method="setText">
			<argument name="text"
xsi:type="string"> <![CDATA[<p>Text_2A</p>]]>
			</argument>
		</action>
	</block>
	<block class="Magento\Framework\View\Element\Text" name="example_2b">
		<action method="setText">
			<argument name="text" xsi:type="string"><![CDATA[<p>Text_2B</p>]]>
		</action>
	</block>
</block>

The Messages block supports four methods that we can use to add content to output: addSuccess, addNotice,
addWarning and addError. The following is an example instansiating the Messages block through the
layout update file:

<block class="Magento\Framework\View\Element\Messages" name="example_3">
	<action method="addSuccess">
		<argument name="text" xsi:type="string"><![CDATA[<p>Text_3A:Success</p>]]></argument>
	</action>
	<action method="addWarning">
		<argument name="text" xsi:type="string"><![CDATA[<p>Text_3C:Warning</p>]]></argument>
	</action>
	<action method="addError">
		<argument name="text" xsi:type="string"><![CDATA[<p>Text_3D:Error</p>]]></argument>
	</action>
</block>

The preceding example should be taken with caution, since calling these setter methods in layout is not
the proper way to do it. The default Magento_Theme module already defines the Messages block that uses vendor/magento/module-theme/view/frontend/templates/messages.phtml for message rendering. Thus, for most part there is no
need to define our own messages block.

Finally, let's look at the example of the Template block as follows:

<block class="Magento\Framework\View\Element\Template" name="example_4"
template="Foggyline_Office::office/no4/template.pthml"/>

The preceeding XML will be instansiate the Template type of block and render the content of the 
view/fronend/templates/office/no4/template.phtml file within the app/code/Foggyline/Office/ dir.

On the PHP level, instansiating a new block can be accomplished using the layout object, or directly through the object manager. The layout appracoh is the preferred way. With regard to the previous examples in XML,
let's see their alternatives in PHP (assuming $resultPage is an instance of \Magento\Framework\View\Result\PageFactory)

The following is an example of instansiating the Text type of block and adding it as a child of the content container:

$block =
$resultPage->getLayout()->createBlock('Magento\Framework\View\Element\Text', 'example_1')->setText('<p>Text_1</p>');

$resultPage->getLayout()->setChild('content', $block->getNameInLayout(), 'example_1_alias');

The ListText version is done in PHP as follows:

$blockLT = $resultPage->getLayout()->createBlock('Magento\Framework\View\Element\Text\ListText', 'example_2');

$resultPage->getLayout()->setChild('content', $blockLT->getNameInLayout(), 'example_2_alias');

$block2A = $resultPage->getLayout()->createBlock('Magento\Framework\View\Element\Text', 'example_2a'
)->setText('<p>Text_2A</p>');

$resultPage->getLayout()->setChild('example_2', $block2A-getNameInLayout(), 'example_2a_alias');

$block2B = $resultPage->getLayout()->createBlock('Magento\Framework\View\Element\Text', 'example_2b'
)->setText('<p>Text_2B</p>');

$resultPage->getLayout()->setChild('example_2', $block2B->getNameInLayout(), 'example_2b_alias');

Notice how we first made an instance of the ListText block and assigned it as a child of an element
named content. Then we created two individual Text blocks and assigned them as a child of an
element named example_2, which is our ListText.

Next, let's define the Messages block as follows:

$messagesBlock =
$resultPage->getLayout()->createBlock('Magento\Framework\View\Element\Messages', 'example_3');

$messagesBlock->addSuccess('Text_3A:Success');
$messagesBlock->addNotice('Text_3B: Notice');
$messagesBlock->addWarning('Text_3C: Warning');
$messagesBlock->addError('Text_3D: Error');

$resultPage->getLayout()->setChild(
	'content', $messagesBlock->getNameInLayout(),
	'example_3_alias');

Finally, let's look at the Template block type, which we initiate as follows:

$templateBlock = $resultPage->getLayout()->createBlock('Magento\Framework\View\Element\Template',
	'example_3')->setTemplate(
		'Foggyline_Office::office/no4/template.phtml');

$resultPage->getLayout()->setChild('content', $templateBlock->getNameInLayout(), 'example_4_alias');

Whenever possible, we should set our blocks using XML layouts. Now that we know how to utilize the most
common types of Magento blocks, let's see how we can create our own block type.

Defining our own block class is as simple as creating a custom class file that extends Template. This block
class should be placed under our module Block dir. Using our Foggyline_Office module, let's create a file,
Block/Hello.php, with content as follows:

namespace Foggyline\Office\Block;

class Hello extends \Magento\Framework\View\Element\Template
{
	public function helloPublic()
	{
		return 'Hello #1';
	}

	protected function helloProtected()
	{
		return 'Hello #2';
	}

	private function helloPrivate()
	{
		return 'Hello #3';
	}
}

The preceeding code simply creates a new custom block class. We can then call this block class through our
layout file as follows:

<block class="Foggyline\Office\Block\Hello" name="office.hello" template="office/hello.phtml"/>

Finally, within our module app/code/Foggyline/Office/ dir, we create a template file,
view/frontend/templates/office/hello.phtml, with content as follows:

<?php /* @var $block Foggyline\Office\Block\Hello */ ?>
<h1>Hello</h1>
<p><?php echo $block->helloPublic() ?></p>
<p><?php //echo $block->helloProtected() ?</p>
<p><?php //echo $block->helloPrivate() ?></p>

To further understand what is happening here within the template file, let's take a deeper look
at templates themselves.

Templates are snippets of HTML mixed with PHP. The PHP part includes elements such as Variables, expressions
and class method calls. Magento uses the PHTML file extension for template files. Templates are located under
an individual module's view/{_area_}/templates/directory

In our previous example, we referred to our module template file with an expression like:

Foggyline_Office::office/hello.phtml. Since templates can belong to different modules,
we should prepend the templates with the module name as a best practice. This will help us
locate template files and avoid file conflicts.

A simple naming formula goes like this: we type the name of the module, double single colon, and then the name.
Thus making a template path like office/hello.phtml equaling to Foggyline_Office::office/hello.phtml

Within the PHTML template file we often have various PHP expressions like $block->helloPublic(). Notice the
block class Foggyline\Office\Block\Hello in the preceeding XML. An instance of this block class
becomes available to us in hello.phtml through the $block variable. Thus, an expression like
$block->helloPublic() is effectively calling the helloPublic method from an instance of the Hello class.

The Hello class is not one of the Magento core classes, but it does extend the \Magento\Framework\View\Element\Template.

Our hello.phtml template also has two more expressions: $block->helloProtected() and $block->helloPrivate().
However, these are not executed as template files can only see public methods from their $block instances.

The $this variable is also available within the PHTML template as an instance of the Magento\Framework\View\TemplateEngine\Php class.

In the preceeding template code example, we could have easily replaced $block->helloPublic() with the $this->helloPublic() expression.
The reason why this would work lies in the template engine Php class, as follows:

public function __call($method, $args)
{
	return call_user_func_array([$this->_currentBlock, $method], $args);
}

public function __isset($name)
{
	return isset($this->_currentBlock->{$name});
}

public function __get($name)
{
	return $this->_currentBlock->{$name};
}

Given that templates are included in the context of the engine rather than in the context of the block, __call redirects method calls to the
current block. Similarly, __isset redirects isset calls to the current block and __get allows read access to properties of the current block.

Though we can use both $block and $this for the same purpose within the template file, we should really opt for using $block.

Another important aspect of templates is their fallback mechanism. Fallback is the process of defining a full template path
given only its relative path. For example, office/hello.phtml falls back to the app/code/Foggyline/Office/view/frontend/templates/office/hello.phtml file.

Path resolution starts from the _toHtml method defined on the Magento\Framework\View\Element\Template class. The _toHtml method then calls
getTemplateFileName on resolver, which is an instance of \Magento\Framework\View\Element\Template\File\Resolver. Looking further,
resolver's getTemplateFileName further calls getTemplateFileName on _viewFileSystem, which is an instance of \Magento\Framework\View\Filesystem.

The method getFile is further called on an instance of \Magento\Framework\View\Design\FileResolution\Fallback\TemplateFile.getFile further triggers
the resolve method on the Magento\Framework\View\Design\FileResolution\Fallback\Resolver\Simple instance, which further calls
the getRule method on the Magento\Framework\View\Design\Fallback\RulePool instance.

The RulePoll class is the final class in the chain here. getRule finally calls the createTemplateFileRule method, which creates
the rule that detects where the file is located. While running the getRule method, Magento checks against the following
types of fallback rules:

file

locale

template

static

email

It is worth spending some time to study the inner workings of the RulePool class, as it showcases detailed fallbacks for the listed rules.

Up to this point, we briefly touched on layout XMLs. Layout XML is a tool to build the pages of the Magento application in a modular and flexible manner.
It enables us to describe the page layout and content placement. Looking at XML root nodes, we differentiate two types of layouts:

layout: XML wrapper in <layout>

page: XML wrapper in <page>

Page layouts represents a full page in HTML, where as layout layouts represent a part of a page. The layout type is a subset
of the page layout type. Both types of layout XML files are validated by the XSD schema found under the vendor/magento/framework/View/Layout/etc/ dir:

layout-layout_generic.xsd

page-page_configuration.xsd

Based on the application components that provide <layout> and <page> elements, we can further section them as base and theme layouts.
The base layouts are provided by the modules, usually at the following locations:

<module_dir>/view/frontend/layout: page configuration and generic layout files.

<module_dir>/view/frontend/page_layout: page layout files

The theme layouts are provided by the themes, usually at the following locations:

<theme_dir>/<Namespace>_<Module>/layout: Page congirautioin and genric layout files

<theme_dir>/<Namespace>_<Module>/page_layout: page layout files

Magento will load and merge all module and theme XML files on the appropiate page. Once files are merged and XML instructions are processed,
 the result is rendered and sent to the browser for display. Having two different layout XML files, where both reference the same block,
means that the second one with the same name in the sequence will replace the first one.

When the XML files are loaded, Magento applies an inheritance theme at the same time. We can apply a theme and it will look for the parent
until a theme without a parent is reached.

In addition to the merging of files from each module, layout files from within module directories can also be extended or overriden by
themes. Overriding layout XML is not a good practice, but it might be necessary at times.

To override the base layout files provided by the module within the <module_dir>/view/frontend/layout/ dir.

We need to create an XML file with the same name in the app/design/frontend/<vendor>/<theme>/<Namespace_Module>/layout/override/base/ dir

To override the theme layout files provided by the parent theme within the <parent_theme_dir>/<Namespace>_<Module>/layout/ dir

We need to create an XML file with the same name in the app/design/frontend/<vendor>/<theme>/<Namespace_Module>/layout/override/theme/<Parent_Vendor>/<parent_theme>/ dir

Layouts can be both overriden and extended. The recommended way to customize layout is to extend it through a custom theme. We can do so by simply
adding a custom XML layout file with the same name in the app/design/frontend/{vendorName}/{theme}/{vendorName}_{moduleName}/layout/ dir

Layouts, as we say in the previous examples, support a large number of directives: page page, head, block, and so on. The practical use of these
directives and how they mix together is a challenge on its own. Giving full details on each and every directive is beyond the scope of this book.
However, what we can do is to show how to figure out the use of an individual dir, which we might need at a given time. For that 
purpose, it is highly recommended to use an IDE environment like NetBeans PHP or PhpStorm that provides an autocomplete on XMLs that inlcude XSD.

The following is an example of defining an external schema to Phpstorm, where we are simply saying that the urn:magento:framework:View/Layout/etc/page_configuration.xsd alias
belongs to the vendor/magento/framework/View/Layout/etc/page_configuration.xsd file 

This way, PhpStorm will know how to provide autocomplete while we type around XML files.

As an example, let's take a look at how we could use the css directive to add an external CSS file to our page. With an IDE that supports
autocomplete as soon as we type the css directive, within the page | head element, autocomplete might throw out something like the following:

//A dropdown list of stuff

A list of available attributes is shown, such as src, sizes, ie_condition, src_type and so on. IDEs like PhpStorm will allow us
to right-click an element or its attribute and go to the definition. Looking into the definition for the src attribute gets us into the
vendor/magento/framework/View/Layout/etc/head.xsd file that defines the CSS elements as follows:

<xs:complexType name="linkType">
	<xs:attribute name="src" type="xs:string" use="required"/>
	<xs:attribute name="defer" type="xs:string"/>
	<xs:attribute name="ie_condition" type="xs:string"/>
	<xs:attribute name="charset" type="xs:string"/>
	<xs:attribute name="hreflang" type="xs:string"/>
	<xs:attribute name="media" type="xs:string"/>
	<xs:attribute name="rel" type="xs:string"/>
	<xs:attribute name="rev" type="xs:string"/>
	<xs:attribute name="sizes" type="xs:string"/>
	<xs:attribute name="target" type="xs:string"/>
	<xs:attribute name="type" type="xs:string"/>
	<xs:attribute name="src_type" type="xs:string"/>
</xs:complexType>

All of these attributes can be set on the css element, and as such get their autocomplete as shown.

Although it is not required to use a robust IDE with Magento, it certainly helps to have one that understands
XML and XSD files to the level of providing autocomplete and validation.

By default, Magento comes with two themes, named Blank and Luma.
If we log in to the Magento admin area, we can see a list of available themes under the Content | Design | Themes menu, as shown 
in the following screenshot:

//picture

Magento themes support a parent-child relationship, something we noted previously, that is visible on the preceeding image within the Parent Theme column.

The following steps outline the process of creating our own theme:

Under {Magento root directory}/app/design/frontend, create a new dir bearing our vendor name, Foggyline.

Within the vendor dir, create a new dir bearing the theme name, jupiter. 

Within the jupiter dir, create the registration.php file with content as follows:

<?php
\Magento\Framework\Component\ComponentRegistrar:register(
	\Magento\Framework\Component\ComponentRegistrar::THEME,
	'frontend/Foggyline/jupiter',
	__DIR__
);

Copy vendor/magento/theme-frontend-blank/theme.xml into our theme, app/design/frontend/Foggyline/jupiter/theme.xml, changing the content as follows:

<theme xmlns:xsi="http://www.w3.org/2001/XMLSchema- instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:Config/etc/theme.xsd">
	<title>Foggyline Jupiter</title>
	<parent>Magento/blank</parent>
	<media>

<preview_image>media/preview.jpg</preview_image>
	</media>
</theme>

Create the app/design/frontend/Foggyline/jupiter/media/preview.jpg image file to serve as the theme preview image (the one used in the admin area)

Optionally, create seperate dirs for static files such as styles, fonts, JS, and images. These are stored within the web sub dir of our theme app/design/frontend/Foggyline/jupiter folder like follows:

web/css

web/css/source/

web/css/source/components/

web/images/

web/js/

Within the theme web dir, we store general theme static files. If our theme contains module-specific static files, these are stored
under the corresponding vendor module subdirs, like app/design/frontend/Foggyline/jupiter/{vendorName_moduleName}/web/.

Optionally, we can create the theme logo.svg image under our theme web/images/ folder.

Once we are done in the preceeding steps, looking back ino the admin area under Content | Design | Themes menu, we should now see 
our theme listed as shown in the following SS:

//stuff

Whereas clicking on the name will bring up a screen with relevnat info.

Notice how the previous two screens do not show any options to apply the theme. They are only listing out available
themes and some basic information next to each theme. Our custom theme shows an interesting relationship, where a parent and a child can belong
to different vendors.

Applying the theme requires the following extra steps:

Make sure our theme appears in the theme list, under the Content | Design | Themes menu.

Go to Stores | Settings | Configuration | General | Design.

In the Store View drop-down field, we select the store view where we want to apply the theme, as shown in the upper-left corner of the
stuff.

On the Design Theme tab, we select our newly created theme in the Design Theme drop-down, as shown on the right-hand side of the preceeding image. Save the configs

Under System | Tools | Cache Management, select and refresh the invalid cache types and click on the Flush Catalog Images Cache, Flush Javascript/CSS cache and Flush Static Files Cache buttons.

Finally, to see our changes applied, reload the storefront pages in the browser.

There is a lot more ot be said about Themes that can fit into a book of it's own.

Magento uses quite a large chunk of different JS libs:

Knockout

Ext JS

jQuery

jQuery UI

modernizr

Prototype

RequireJS

scrip.aculo.us

moment.js

Underscore.js

gruntjs

AngularJS

jasmine

and a few others.

Though a frontend dev is not required to know the ins and outs of every lib, it is recommended to at least have a basic insight into most of them.

It is worth running find {MAGENTO-DIR}/-name\*.js> js-list.txt on the console to get a full list of each and every JS file in Magento. Spending
a few minutes glossing over the list might serve as a nice future memo when working with JS bits in Magento.

The RequireJS and jQuery libs are probably the most interesting ones, as they often step into the spotlight during frontend dev.
RequireJS plays a big role in Magento, as it loads other JS files. Using a modular script loader like RequireJS improves the speed of
code. Speed improvements comes from removing JS from the header and asynch or lazy loading JS resources in the BG.

JS resources can be specified as follows:

Library level for all libs in the Magento code base (lib/web).

Module level for all libs in a module (app/code/{vendorName}/{moduleName}/view/{area}/web).

Theme for all libs in a theme (app/design/{area}/{vendorName}/{theme}/{vendorName}_{moduleName}/web).

All libs in a theme (app/design/{area}/{vendorName}/{theme}/web). Though possible, it is not recommended using this level to specify JS resources.

Notification messages

Magento implements the notification message mechanism via the Messages module. The messages module conforms to \Magento\Framework\Message\ManagerInterface.
Though the interface itself does not impose any session relation, an implementation adds interface-defined types of messages to a session and
allows access to those messages later.

In the app/etc/di.xml file, there is a preference defined for \Magento\Framework\Message\ManagerInterface towards the Magento\Framework\Message\Manager class

Message\ManagerInterface specifies four types of messages, namely error, warning, notice and success.

The types of messages are followed by several key methods in the Message\Manager class, such as addSuccess, addNotice, addWarning, addError, and addException.

The addException method is basically a wrapper for addError that accepts an exception object as a parameter.

Let's try to run the following code in the execute method of app/code/Foggyline/Office/Controller/Test/Crud.php:

$resultPage =
$this->resultPageFactory->create();

$this->messageManager->addSuccess('Success-1');
$this->messageManager->addSuccess('Success-2');
$this->messageManager->addNotice('Notice-1');

$this->messageManager->addNotice('Notice-2');
$this->messageManager->addWarning('Warning-1');
$this->messageManager->addWarning('Warning-2');

$this->messageManager->addError('Error-1');
$this->messageManager->addError('Error-2');

return $resultPage;

Once this code is executed, the result as follows, will be shown in the page of the browser:

//basically coloured tabs with Denotions of what they are will appear stacked in a list

Notification messages appear both in frontend and admin area.

The frontend layout vendor/magento/module-theme/view/frontend/layout/default.xml file defines it as follows:

<page layout="3columns"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-
instance" xsi:noNamespaceSchemaLocation=
"../../../../../../../lib/internal/Magento/Framework/View/Layout
/etc/page_configuration.xsd">
	<update handle="default_head_blocks"/>
	<body>
		<!-- ... -->
		<referenceContainer
name="column.top">
			<container name="page.messages"
htmlTag="div" htmlClass="page messages">
				<block
class="Magento\Framework\View\Element
\Messages" name="messages" as="messages"
template="Magento_Theme::messages.phtml"/>
			</container>
		</referenceContainer>
		<!-- ... -->
	</body>
</page>

The template file that renders the messages is view/frontend/templates/messages.phtml in the Magento_Theme module. By looking at the
Magento\Framework\View\Element\Messages class, you will see that the _toHtml method branches into if-else statements, depending on wether 
template is set or not.

In case the template is not set, _toHtml interally calls the _renderMessagesByType method, which renders messages in the HTML format
that are grouped by type.

The view/adminhtml/layout/default.xml admin layout file in the Magento_AdminNotification module defines it as follows:

<page xmlns:xsi="http://www.w3.org
/2001/XMLSchema-instance"
xsi:noNamespaceSchemaLocation="urn:magento:
framework:View/Layout
/etc/page_configuration.xsd">
	<body>
		<referenceContainer
name="notifications">
			<block
class="Magento\AdminNotification\Block
\System\Messages" name="system_messages"
as="system_messages" before="-" template=
"Magento_AdminNotification::system/messages.p
html"/>
		</referenceContainer>
	</body>
</page>

The template file that renders the messages is
view/adminhtml/templates/system
/messages.phtml in the Magento_AdminNotification
module. When you look at the Magento\AdminNotification\Block\System\Messages class,
we will see that it's _toHtml is calling the \Magento\Framework\View\Element\Template class.

This means that the output is relying on the view/adminHtml/templates/system/messages.phtml file in the
Magento_AdminNotification module.

Sessions in Magento conform to Magento\Framework\Session\SessionManagerInterface. In the app/etc/di.xml file,
there is a definition preference for the SessionManagerInterface class which points to the Magento\Framework\Session\SessionManager
class, which in turn implements the SessionManagerInterface class.

There is one important object that gets instansiated in the SessionManager instance that conforms to \Magento\Framework\Session\Config\ConfigInterface.

On looking at app/etc/di.xml file, we can see a preference for ConfigInterface pointing to a Magento\Framework\Session\Config class type.

To fully understand the session behavior in Magento, we should study the inner workings of both the SessionManager and Session\Config classes.
Magento uses cookies to keep track of a session. These cookies have a default lifetime of 3,600 seconds. When a session
is established, a cookie with the name of PHPSESSID is created in the browser.

The value of the cookie equals the session name. By default, sessions are stored in files in the var/session dir of Magento's root Install.

If you have a look at these session files, you will see that session information is being stored in serialized strings that are divided into groupings
such as _session_validator_data, _session_hosts, default, customer_website_1, and checkout as follows:

_session_validator_data
	|a:4:{s:11:"remote_addr";s:9:"127.0.0.1";s:8:
_session_hosts
	|a:1:{s:12:"magento2.loc";b:1;}
default
	|a:3:{s:9:"_form_key";s:16:"u3sNaa26Ii21nveV"
customer_website_1
	|a:0:{}
checkout
	|a:0:{}

This is not the finite list of grouping. Modules that implement their own session handling bits can add their own groups.

We can store and retrieve information in a session by simply using expressions like the following ones:

$this->sessionManager->setFoggylineOfficeVar1
('Office1');
$this->sessionManager->getFoggylineOfficeVar1
();

The preceeding expressions will create and get an entry from the session under the default group.
We can get the entire content of the default session group simply by using the $this->sessionManager->getData() expression,
which will return an array of data that is similar to the following one:

array(3) {
	["_form_key"] => string(16)
"u3sNaa26Ii21neV"
	["visitor_data"] => array(14) {
		["last_visit_at"] => string(19)
"2015-08-19 07:40:03"
		["session_id"] => string(26)
"8p82je0dkqq1o00lanlr6bj6m2"
		["visitor_id"] => string(2) "35"
		["server_addr"] => int(213076433)
		["remote_addr"] => int(213076433)
		["http_secure"] => bool(false)
		["http_host"] => string(12)
"magento2.loc"
		["http_user_agent"] => string(121)
"Mozaill/5.0 ..."
		["http_accept_language"] => string(41)
"en-US, en;"
		["http_accept_charset"] => string(0) ""
		["first_visit_at"] => string(19)
"2015-08-19 07:40:03"
		["is_new_visitor"] => bool(false)
	}
	["foggyline_office_var_1"] => string(7)
"Office1"
}

As you can see, the foggyline_office_var_1 value is right there among other session values.
There are several useful methods of ConfigInterface that we can use to fetch session configuration information; a few
of these methods are as follows:

getCookieSecure

getCookieDomain

getCookieHttpOnly

getCookieLifetime

getName

getSavePath

getUseCookies

getOptions

Here's a result example of the getOptions method call on the Session\Config instance:

array(9) {
	["session.save_handler"] => string(5)
"files"
	["session.save_path"] => string(39) "/Users
/branko/www/magento2/var/session/"
	["session.cookie_lifetime"] => int(3600)
	["session.cookie_path"] => string(1) "/"
	["session.cookie_domain"] => string(12)
"magento2.loc"
	["session.cookie_httponly"] => bool(true)
	["session.cookie_secure"] => string(0) ""
	["session.name"] => string(9) "PHPSESSID"
	["session.use_cookies"] => bool(true)
}

Cookies often go hand in hand with sessions. Besides being used to link to a certain session, cookies are often
used to store some information on the client side, thus tracking or identifying the return users and customers.

Besides the pure PHP approach with the setcookie function, we can manage cookies in Magento through an instance
of Magento\Framework\Stdlib\CookieManagerInterface. When you look at app/etc/di.xml file, you will see
that the preference for CookieManagerInterface points to a class of the Magento\Framework\Stdlib\Cookie\PhpCookieManager type

The following restrictions are worth noting when it comes to Magento cookies:

We can set maximum of 50 cookies in the system. Otherwise, Magento will throw an Unable to send the cookie. Maximum number of cookies would be exceeded exception.
We can store a cookie with a maximum size of 4096 bytes. Otherwise, Magento will throw an Unable to send the cookie. Size of \'%name\' is %size bytes exception.

By imposing these restrictions, Magento ensures that we are compatible with most browsers.

The CookieManagerInterface class, among other things, specifies the setSensitiveCookie method requirement. This method sets a value
in a private cookie with the given $name $value pairing. Sensitive cookies have HttpOnly set to true and thus cannot be accessed by JS.

As we will soon demonstrate in the following examples, to set a public or private cookie, we can help ourselves by using instances of the following:

\Magento\Framework\Stdlib\Cookie\CookieMetadataFactory

\Magento\Framework\Stdlib\CookieManagerInterface

\Magento\Framework\Session\Config\ConfigInterface

We can set public cookies in the following way:

$cookieValue = 'Just some value';
$cookieMetadata =
$this->cookieMetadataFactory
	->createPublicCookieMetadata()
	->setDuration(3600)

->setPath($this->sessionConfig->getCookiePath())

->setDomain($this->sessionConfig->getCookieDomain())

->setSecure($this->sessionConfig->getCookieSecure())

->setHttpOnly($this->sessionConfig->getCookieHttpOnly());

$this->cookieManager
	->setPublicCookie('cookie_name_1', 
$cookieValue, $cookieMetadata);

The preceeding code will result in a cookie, that is HttpOnly.

We can also set private cookies, as follows:

$cookieValue = 'Just some value';

$cookieMetadata =
$this->cookieMetadataFactory
	->createSensitiveCookieMetadata()
	->setPath($this->sessionConfig->getCookiePath())

	->setDomain($this->sessionConfig->getCookieDomain());

$this->cookieManager
	->setSensitiveCookie('cookie_name_2',
$cookieValue, $cookieMetadata);

This will result in a private cookie. Interestingly, both the public and private cookies in the preceeding example show that HttpOnly is checked off
because by default, a Magento admin has Stores | Settings | Configuration | General | Web | Default Cookie Settings | Use HTTP Only set to yes.

Since we are using the setHttpOnly method in the public cookie example, we simply picked up the config value via $this->sessionConfig->getCookieHttpOnly() and 
passed it on. If we comment out that line, we will see that public cookie does not really set HttpOnly by default.

Magento supports the messages logging mechanism via its \Psr\Log\LoggerInterface class. The LoggerInterface class has a preference defined
within app/etc/di.xml file for the Magento\Framework\Logger\Monolog class type. The actual crux of implementation is actually in
the Monolog parent class named Monolog\Logger, which comes from the Monolog vendor.

The LoggerInterface class uses the following eight methods to write logs to the eight RFC 5424 levels:

debug

info

notice

warning

error

critical

alert

emergency

To use a logger, we need to pass the LoggerInterface class to a constructor of a class from within we want to use it
and then simply make one the following method calls:

$this->logger->log(\Monolog\Logger::DEBUG,
'debug msg');
$this->logger->log(\Monolog\Logger::INFO,
'info msg');
$this->logger->log(\Monolog\Logger::NOTICE,
'notice msg');
$this-logger->log(\Monolog\Logger::WARNING,
'warning msg');
$this->logger->log(\Monolog\Logger::ERROR,
'error msg');
$this-logger->log(\Monolog\Logger::CRITICAL,
'critical msg');
$this->logger->log(\Monolog\Logger::ALERT,
'alert msg');
$this->logger->log(\Monolog
\Logger::EMERGENCY, 'emergency msg');

Alternatively, the preferred shorter version through individual log level type methods is as follows:

$this->logger->debug('debug msg');
$this->logger->info('info msg');
$this->logger->notice('notice msg');
$this->logger->warning('warning msg');
$this->logger->error('error msg');
$this->logger->critical('critical msg');
$this->logger->alert('alert msg');
$this->logger->emergency('emergency msg');

Both approaches result in the same two log files being created in Magento, which are as follows:

var/log/debug.log

var/log/system.log

The debug.log file contains only the debug level type of the log,
while the rest are saved under system.log

Entries within these logs will then look as follows:

[2015-11-21 09:42:18] main.DEBUG: debug msg
{"is-exception":false} []
[2015-11-21 09:42:18] main.INFO: info msg [] []
[2015-11-21 09:42:18] main.NOTICE: notice msg [] []
[2015-11-21 09:42:18] main.WARNING: warning msg [] []
[2015-11-21 09:42:18] main.ERROR: error msg [] []
[2015-11-21 09:42:18] main.CRITICAL: critical msg [] []
[2015-11-21 09:42:18] main.ALERT: alert msg [] []
[2015-11-21 09:42:18] main.EMERGENCY: emergency msg [] []

Each of these logger methods can accept an entire array of arbitrary data called context, as follows:

$this->logger->info('User logged in.', ['user'=>'Branko', 'age'=>32]);

The preceeding expression will produce the following entry in system.log:

[2015-11-21 09:42:18] main.INFO: User logged in. {"user":"Branko", "age":32} []

We can manually delete the log files from var/log dir, and Magento will automatically create it again when needed.

Magento also has another logging mechanism in place, where it logs the following actions in log_* tables in a DB:

log_customer

log_quote

log_summary

log_summary_type

log_url

log_url_info

log_visitorz

log_visitor_info

log_visitor_online

It is worth noting that this DB logging is not related in anyway to the Psr logger taht was described previously. While Psr logger
serves developers within the code to group and log certain messages according to the Psr standard, the DB logging logs
the live data that is result of user/customer interaction in the browser.

By default, Magento keeps DB logs for around 180 days. This is a config option that can be controlled in the Magento admin
area under the Stores | Settings | Configuration | Advanced | System | Log Cleaning tab with other related log options.

There we can set frequency, duration of save, log cleaning, start times, error email recipients, error email senders, error email templates.

These config options, only bare meaning OS cron is triggering Magento cron. (i.e, they only take effect if the OS cron uses the Magento Cron)

We can execute two commands on terminal: php bin/magento log:status to get the current state information about log tables and php bin/magento log:clean
to force the cleaning of tables

Magento has a built-in profiler that can be used to identify performance problems on the server side. In a nutshell,
the profiler can tell us the execution time of certain chunks of code. There is nothing that great with its behavior.

We can only get the execution time of code blocks or individual expressions that have been wrapped by the profiler's start
and stop methods. On its own, Magento calls for the profiler extensively across its code. However,
we cant see it in effect as the profiler output is disabled by default.

Magento supports three profiler outputs, namely html, csvfile and firebug.

To enable the profiler, we can edit .htaccess and add one of the following expressions:

SetEnv MAGE_PROFILER "html"

SetEnv MAGE_PROFILER "csvfile"

SetEnv MAGE_PROFILER "firebug"

The HTML type of profiler will show its output into the footer area of a page that we open in the browser, as shown in the following illustration:

Timer id 					Time 		Avg 		Cnt 	Emalloc 	RealMem

cache_frontend_create 		0.046384	0.023192	2 		1,479,184 	1,572,864

cache_load 					0.014226 	0.004742 	3 		454.796 	524,288

magento 					0.168286 	0.168286  	1 		4,086,732 	3,670,016

. cache_load 				0.013186 	0.001884 	7 		430,260 	524,288

. store.resolve 			0.080572 	0.080572 	1 		2,132,144 	2,097,152

. . EVENT:model_load_before 0.002523 	0.002523 	1 		133,904 	0

. . . cache_load 			0.00193 	0.0000967 	2 		40,436 		0

The csv file type of profiler will output into var/log/profiler.csv as shown:

cache_frontend_create,0.056334,0.028267, 2, "1,479,196", "1,572,864"
etc.
magento->cache_load,0.010538, etc.
magento->store.resolve->EVENT:model_load_before etc.

The profiler outputs, are as follows:

Time profiler shows the time spent from Profiler::start to Profiler::stop

Avg profiler shows the average time spent from Profiler::start to Profiler::stop for cases
where Cnt is greater than one

Cnt profiler shows the integer value of how many times we have started the profiler with the same timer name.
For example, if we have caled \Magento\Framework\Profiler::start('foggyline:office'); twice, somewhere in the code,
cnt will have been set to 2.

Emalloc profiler stands for amount of memory allocated to PHP. It is a mix of the core PHP memory_get_usage function
without the true parameter passed to it and the timer values.

RealMem profiler also stands for the amount of memory allocated to PHP whose final value is also obtained
via the memory_get_usage function minus the timer values, but this time with the true parameter passed to it.

We can easily add our own Profiler::start calls anywhere in the code. Every Profiler::start should be followed by
some code expressions and then finalized with a Profiler::stop call, as follows:

\Magento\Framework\Profiler::start('foggyline:office');
sleep(2); /* Code block or single expression here */
\Magento\Framework\Profiler::stop('foggyline:office');

Depending on where we call the profiler in the code, the resulting output should be similar to the one shown in the following
formatting:

. . CONTROLLER_ACTION:foggyline_office_test_crud 	2.077258 2.077258  1  239,732 	262,144
. . . action_body 									- II -    - II -  -II- -II-       -II-
. . . . foggyline:office 							2.000966  2.000966 1  1,308 	 	0
. . . . postdispatch 								0.052955  0.52955  1  55,952        0

Magento implements the observer pattern through \Magento\Framework\Event\ManagerInterface.
In app/etc/di.xml, there is a preference for MagentoInterface that points to the Magento\Framework\Event\Manager\Proxy class type.

The Proxy class further extends the \Magento\Framework\Event\Manager class that implements the actual event dispatch method.
Events are dispatched by calling a dispatch method on the instance of the Event\Manager class and passing the name
and some data, which is optional, to it. Here's an example of a Magento core event:

$this->eventManager->dispatch(
	'customer_customer_authenticated',
	['model' => 
$this->getFullCustomerObject($customer),
'password' => $password]
);

The $this->eventManager is an instance of the previously mentioned Event\Manager class. In this case, the event name
equals to customer_customer_authenticated, while the data passed to the event is the array with two elements.

The preceding event is fired when the authenticate method is called on \Magento\Customer\Model\AccountManager, that is,
when a customer logs in.

Dispatching an event only makes sense if we expect someone to observe it and execute their code when the event is
dispatched. Depending on the area from which we want to observe events, we can define observers in one of the following XML files:

app/code/{vendorName}/{moduleName}/etc/events.xml

app/code/{vendorName}/{moduleName}/etc/frontend/events.xml

app/code/{vendorName}/{moduleName}/etc/adminhtml/events.xml

Let's define an observer that will log an e-mail adress of an authenticated user into a var/log/system.log file. We 
can use the Foggyline_Office module and add some code to it. As we are interested in the storefront, it makes sense to
put the observer in the etc/frontend/events.xml module

Let's define the app/code/Foggyline/Office/etc/frontend/events.xml file with the contents as follows:

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:noNamespaceSchemaLocation="urn:magento:framework:Event/etc/events.xsd">
	<event
name="customer_customer_authenticated">
		<observer
name="foggyline_office_customer_authenticated
" instance="Foggyline\Office\Observer\LogCustomerEmail" />
	</event>
</config>

here, we are specifying a foggyline_office_customer_authenticated observer for the customer_customer_authenticated
event. The observer is defined in the LogCustomerEmail class that is placed in the Observer module dir. The Observer 
class has to implement the Magento\Framework\Event\ObserverInterface class. The Observer interface defines a single
execute method.

The execute method hosts the observer code and is executed when the customer_customer_authenticated event is dispatched.
Let's go ahead and define the Foggyline\Office\Observer\LogCustomerEmail class in the app/code/Foggyline/Office/Observer/LogCustomerEmail.php file as follows:

namespace Foggyline\Office\Observer;

use Magento\Framework\Event\ObserverInterface;

class LogCustomerEmail implements ObserverInterface
{
	protected $logger;

	public function __construct(
		\Psr\Log\LoggerInterface $logger
	)
	{
		$this->logger = $logger;
	}

	/**
	 * 	@param \Magento\Framework\Event\Observer $observer
	 *  @return self
	 */

	public function execute(\Magento
\Framework\Event\Observer $observer)
	{
		//$password = 
$observer->getEvent()->getPassword();
		$customer = 
$observer->getEvent()->getModel();

$this->logger->info('Foggyline\Office: ' . 
$customer->getEmail());
		return $this;
	}
}

The execute method takes a single parameter called $observer of the \Magento\Framework\Event\Observer type.
The event that we are observing is passing two pieces of data within the array, namely the model and password.
We can access this by using the $observer->getEvent()->get{arrayKeyName} expression.

The $customer object is an instance of the Magento\Customer\Model\Data\CustomerSecure class, which
contains properties such as email, firstname, lastname and so on. Thus, we can extract the e-mail address from it and pass it
to logger's info method.

Now that we know how to observe existing events, let's see how we can dispatch our own events. We can dispatch events 
from almost anywhere in the code, with or without data, as shown in the following example:

$this->eventManager->dispatch('foggyline_office_foo');
// or
$this->eventManager->dispatch(
	'foggyline_office_bar',
	['var1'=>'val1', 'var2'=>'val2']
);

It is worth noting that there are two types of events; we can group them in the following way according to the way their
name is assigned.

Static:
$this->eventManager->dispatch('event_name', ...)

Dynamic:
$this->eventManager->dispatch({expression}.'_event_name', ...)

The static events have a fixed string for a name, while the dynamic ones have a name that is determined during the runtime.
Here's a nice example of core Magento functionality from afterLoad method that is defined under lib/internal/Magento/Framework/Data/AbstractSearchResult.php,
which showcases how we use both type of events:

protected function afterLoad()
{
	$this->eventManager->dispatch
('abstract_search_result_load_after',
['collection' => $this]);
	if ($this->eventPrefix && $this->eventObject) {
		$this->eventManager->dispatch($this->eventPrefix . '_load_after', [$this->eventObject => $this]);
	}
}

We can see a static event (abstract_search_result_load_after) and a dynamic event ($this->eventPrefix . '_load_after'). The $this->eventPrefix is an
expression that gets evaluated during the runtime. We should be careful when using dynamic events as they are triggered under multiple situations.
Some interesting dynamic events are the one defined on classes like the following ones:

Magento\Framework\Model\AbstractModel
	$this->_eventPrefix . '_load_before'
	$this->_eventPrefix . '_load_after'
	$this->_eventPrefix . '_save_commit_after'
	$this->_eventPrefix . '_save_before'
	$this->_eventPrefix . '_save_after'

	$this->_eventPrefix . '_delete_before'
	$this->_eventPrefix . '_delete_after'
	$this->_eventPrefix . '_delete_commit_after'
	$this->_eventPrefix . '_clear'

\Magento\Framework\Model\ResourceModel\Db\Collection\AbstractCollection
	$this->_eventPrefix . '_load_before'
	$this->_eventPrefix . '_load_after'

\Magento\Framework\App\Action\Action
	'controller_action_predispatch_' .
	$request->getRouteName()

	'controller_action_predispatch_' .
	$request->getFullActionName()

	'controller_action_postdispatch_' .
	$request->getFullActionName()

	'controller_action_postdispatch_' .
	$request->getRouteName()

Magento\Framework\View\Result\Layout
	'layout_render_before_' .
	$this->request->getFullActionName()

These events are fired on the model, collection, controller and layout classes, which are probably among the most used
backend elements that often require observing and interacting. Even though we can say that the full event name is known during
the runtime along with the dynamic event, this can be assumed even before the runtime.

For example, assuming that we want to observe 'controller_action_predispatch_' . $request->getFullActionName() for the
Foggyline_Office module's Crud controller action, the actual full event name will be 'controller_action_predispatch_foggyline_office_test_crud',
given that $request->getFullActionName() will resolve to foggyline_office_test_crud during the runtime.

Magento has eleven-out-of-the-box cache types, according to the following list. These are used across many levels within the system:

Configuration: Various XML configurations that were collected across modules and merged

Layouts: Layouts building instructions

Blocks HTML output: Page blocks HTML

Collections data: Collection data files

Reflection data: API interfaces reflection data

Database DDL operations: Results of DLL queries, such as descrbing tables or indexes

EAV types and attributes: Entity types declaration cache

Page cache: Full page caching

Translations: Translation files

Integrations configuration: Integration configuration file

Integrations API configuration: Integrations API configuration file

Web services configuration: REST and SOAP configurations, generated WSDL file.

There is also Additional Cache Management that manages the cache for the following files:

Previously generated product image files

Themes Javascript and CSS files combined to one file

Preprocessed view files and static files

Each of these caches can be cleared seperately.

We can easily define our own cache type, we can do so by first creating an app/code/Foggyline/Office/etc/cache.xml file with content:

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:noNamespaceSchemaLocation="urn:magento:framework:Cache/etc/cache.xsd">
	<type name="foggyline_office"
			instance="Foggyline\Office\Model\Cache">
		<label>Foggyline Office Example</label>
		<description>Example cache from Foggyline office module.</description>
	</type>
</config>

When defining a new Cache type, we need to specify its name and instance attributes. The name attribute of the type
element should be set to foggyline_office and should be unique across Magento. This value should match the
TYPE_IDENTIFIER constant value on the Foggyline\Office\Model\Cache class, which will be created soon.

The instance attribute holds the class name that we will use for caching.

Then, we will define the Foggyline\Office\Model\Cache class in the app/code/Foggyline/Office/Model/Cache.php file:

namespace Foggyline\Office\Model;

class Cache extends \Magento\Framework\Cache\Frontend\Decorator\TagScope
{
	const TYPE_IDENTIFIER = 'foggyline_office';

	const CACHE_TAG = 'OFFICE';

	public function __constuct(
		\Magento\Framework\App\Cache\Type\FrontendPool $cacheFrontendPool
	)
	{
		parent::__construct(
			$cacheFrontEndPool->get(self::TYPE_IDENTIFIER), self::CACHE_TAG);
	}
}

The Cache class extends from the TagScope and specifies its own values for TYPE_IDENTIFIER and CACHE_TAG, passing them along
to the parent constructor in the __construct method. With these two files (cache.xml and Cache), we have basically
defined a new cache type.

Once we have specified the cache.xml file and referenced cache class, we should be able to see our cache type in Magento
admin under the System | Tools | Cache Management menu.

on its own, simply defining a new cache does not mean that it will get filled and used by Magento.

If you would like to use the cache anywhere within your code, you can do so by first passing the instance of the cache class
to the constructor, as follows:

protected $cache;

public function __construct(
	\Foggyline\Office\Model\Cache $cache
)
{
	$this->cache = $cache;
}

Then you can execute a chunk of code, as follows:

$cacheId = 'some-specific-id';
$objInfo = null;
$_objInfo = $this->cache->load($cacheId);

if ($_objInfo) {
	$objInfo = unserialize($_objInfo);
} else {
	$objInfo = [
		'var1' => 'val1',
		'var2' => 'val2',
		'var3' => 'val3'
	];
	$this->cache->save(serialize($objInfo), $cacheId);
}

The preceeding code shows how we first try to load the value from the existing cache entry, and if there is none, we save to it.

If the cache type is set to disabled under the Cache Management menu, then the preceeding code will never save and pull data from the cache,
as it is not in effect. If you take a look at the var/cache folder of Magento at this point, you will see something similar to what's shown
in the following folder structure:

var
	cache
		mage--9
			mage---a8a_DESIGN_CHANGE_<stuff>
		mage--d
			mage---a8a_ADMIN_NOTIFICATIONS_LASTCHECK
		mage--e
			mage---a8a_CONFIGURATION_FILE_ACCESS_LEVEL_VERIFICATION
		mage--f
			mage---a8a_SOME_SPECIFIC_ID
		mage-tags
			mage---a8a_CORE_DESIGN
			mage---a8a_MAGE
			mage---a8a_OFFICE

Magento created two cache entries for us, namely var/cache/mage-tags/mage---a8a_OFFICE and var/cache/mage--f/mage---a8a_SOME_SPECIFIC_ID.

The mage---a8a_OFFICE file has only a single line of entry in this specific case, and the entry is the a8a_SOME_SPECIFIC_ID string, which obviously point
to the other file. The mage---a8a_SOME_SPECIFIC_ID file contains the actual serialized $objInfo array

The a8a_prefix and other prefixes in the cache file names are not really relevant to us: This is something that Magento adds on its own. What is relevant
to us in passing of the proper individual cache tags to the chunks or variables that we want to cache, like in the preceeding example,
and the TYPE_IDENTIFIER and CACHE_TAG tags that we set for the Cache class.

Magento provides support for widgets. Though the word "widget" might imply frontend development skills and activites, we will look at them
as part of the backend development flow because creating useful and robust widgets requires a significant amount of backend knowledge.

Magento provides several out-of-the-box widgets; Some of them are as follows:

CMS page link

CMS static block

Catalog category link

Catalog new products list

Catalog product link

Catalog products list

Orders and returns

Recently compared products

Recently viewed products

To create a fully custom widget, we start by defining app/code/Foggyline/Office/etc/widge.xml with content:

<widgets xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Widget:etc/widget.xsd">
	<widget id="foggyline_office"
		class="Foggyline\Office\Block\Widget\Example"

	placeholder_image="Magento_Cms"::images/widget_block.png">
		<label translate="true">Foggyline Office</label>
		<description translate="true">Example widget</description>
		<parameters>
			<parameter name="var1"
xsi:type="select" visible="true"
source_model"Magento\Config\Model\Config\Source\Yesno">
				<label
translate="true">Yes/No var1</label>
			</parameter>
			<parameter name="var2"
xsi:type="text" required="true"
visible="true">
				<label
translate="true">Number var2</label>
				<depends>
					<parameter name="var1"
value="1"/>
				</depends>
				<value>5</value>
			</parameter>
		</parameters>
	</widget>
</widgets>

The id widget has been set to foggyline_office, while the class powering widget has been set to 
Foggyline\Office\Block\Widget\Example. the widget class is basically a block class that extends from 
\Magento\Framework\View\Element\AbstractBlock and implements \Magento\Widget\Block\BlockInterface. The label
and description element set values appear under the Magento admin when we select the widget for use.

The parameters of a widget are its configurable options that translate into HTML form elemens, depending on the type
and source_model options that we have selected. In the following example, we will demonstrate the usage of 
select and text elements to retrieve input from a user.

Let's proceed by creating the actual Widget\Example class in the app/code/Foggyline/Office/Block/Widget/Example.php file:

namespace Foggyline\Office\Block\Widget;

class Example extends \Magento\Framework\View\Element\Text implements \Magento\Widget\Block\Blockinterface
{
	protected function _beforeToHtml()
	{
		$this->setText(sprintf(
			'example widget: var1=%s, var2=%s',
			$this->getData('var1'),
			$this->getData('var2')
		));

		return parent::_beforeToHtml();
	}
}

What is happening here, is that we are using Element\Text as a block type and not Element\Template because
we want to simplify the example, as Element\Template will require the phtml template to be defined as well.

By using Element\Text, we can simply define _beforeHtml and call the setText method to set the text string of the block's
output. We will build the output string by picking up the var1 and var2 variables, which were passed as parameters to the block.

Now, if we open the Magento admin area, go to Content | Elements | Pages, and select Home Page to edit, we 
should be able to click on the Insert Frontend App button and add our widget to the page. Alternatively, if 
we are not editing the page in the WYSIWYG mode, we can also add the widget manually to the page by using
the following stuff:

{{widget type="Foggyline\\Office\\Block\\Widget\\Example" var1="1" var2="5"}}

Finally, we should see the example widget: var1=1, var2=5 string in the browser visiting the home page of the storefront.

We can use frontend apps to create highly configurable and embedded widgets that users can easily assign to a CMS page or block.

Variables are a handy little feature of a core Magento_Variable module. Magento allows you to create custom variables
and then use them in e-mail templates, the WYSIWYG editor, or even code expressions.

The following steps outline how we can create a new variable manually:

1. In the Magento admin area, navigate to System | Other Settings | Custom Variables.

2. Click on the Add New Variable button.

3. While keeping in mind the Store View switcher, fill in the required Variable Code and Variable Name
options, and preferably one of the optional options, either Variable HTML Value or Variable Plain Value.

4. Save

Now that we have created the custom variable, we can use it in an e-mail template or the WYSIWYG editor by calling it
using the following expression:

{{customVar code=foggyline_hello}}

The preceeding expression will call for the value of the custom variable with code foggyline_hello.

Variables can be used within various code expressions, though it is not recommended to rely on the existence of an
individual variable, as an admin user can delete it at any point. The following example demonstrates how we can use
an existing variable in the code:

$storeId = 0;

$variable =
$this->_variableFactory->create()->setStoreId(
	$storeId
)->loadByCode(
	'foggyline_hello'
);

$value = $variable->getValue(
	\Magento\Variable\Model
\Variable::TYPE_HTML
);

The $this->variableFactory is an instance of \Magento\Variable\Model\VariableFactory

If used in the right way, variables can be useful. Storing information such as phone numbers or specialized 
labels that are used in CMS pages, blogs, and e-mail templates is a nice example of using custom variables.

i18n is the shorthand for internalization. Magento adds i18n support out of the box, thus adapting to
various languages and regions without application changes. Within app/functions.php, there is a __() translation
function, which is defined as follows:

function __()
{
	$argc = func_get_args();

	$text = array_shift($argc);
	if (!empty($argc) && is_array($argc[0]))
	{
		$argc = $argc[0];
	}

	return new \Magento\Framework\Phrase($text, $argc);
}

This translation function accepts a variable number of arguments and passes them to a constructor of the
\Magento\Framework\Phrase class and returns its instance. The Phrase class has the __toString method,
which then returns the translated string.

Here are a few examples of how we can use the __() function:

__('Translate me')

__('Var1 %1, Var2 %2, Var %3', time(), date('Y'), 32)

__('Copyright %1 <a href="%2">Magento</a>', date('Y'), 'http://magento.com')

Strings passed through the translation function are expected to be found under the local CSV files, such
as app/code/{vendorName}/{moduleName}/i18n/{localeCode}.csv.

Let's imagine for a moment that we have two different store views defined in the Magento admin area under Stores | Settings
| All Stores.

One store has Store | Settings | Configuration | General | Locale Options | Locale set to English (United Kingdom) and other one to 
German (Germany). The local code for English (United Kingdom) is en_GB, and for German(Germany), it is de_DE.

For the de_DE locale, we will add translation entries in the app/code/Foggyline/Office/i18n/de_DE.csv file, as follows:

"Translate me", "de_DE Translate me"
"Var1 %1, Var2 %2, Var %3", "de_DE Var1 %1, Var2 %2, Var %3"
"Copyright %1 <a
href=""%2"">Magento</a>","de_DE Copyright %1 <a href=""%2"">Mangeto</a>"

For the en_GB locale, we will add translation entires in the app/code/Foggyline/Office/i18n/en_GB.csv file, as follows:

"Translate me", "en_GB Translate me"
"Var1 %1, Var2 %2, Var %3", "en_GB Var1 %1, Var2 %2, Var %3"
"Copyright %1 <a
href=""%2"">Magento</a>","en_GB Copyright %1 <a href=""%2"">Magento</a>"

Looking at the two CSV files, a pattern emerges. We can see that the CSV files function in the following way:

Individual translation strings are provided according to every line of CSV

Each line further comprises two individual strings that are seperated by a comma

Both individual strings are surrounded by quotes

If a string contains quotes, it is escaped by a double quote
so that it does not break translation

The %1, %2, %3..%n pattern is used to mark variable placeholders that we provided during
application runtime through the code

Magento supports several commands related to its bin/magento console tool:

i18n
	i18n:collect-phrases 	Discovers phrases
in the codebase
	i18n:pack 				Saves language
package
	i18n:uninstall 			Uninstalls
language packages

If we execute a console command as follows, Magento will recursively look for translatable expressions within PHP,
PHTML or XML files that have phrases to translate:

php bin/magento i18n:collect-phrases -o
"/Users/branko/www/magento2/app/code/Foggyline/Office/
i18n/en_GB.csv" /Users/branko/www/magento2/app/code/Foggyline/Office

The output of the preceding comand will basically overwrite the app/code/Foggyline/Office/i18n/en_GB.csv file, 
which has all the Foggyline/Office module translatable phrases. This is a nice way of aggregating all the translatable
phrases into appropiate locale files, such as en_GB.csv in this case.

The translation CSV files can also be placed under the individual theme. For example, let's imagine
a situation where we add content to app/design/frontend/Magento/blank/i18n/en_GB.csv as follows:

"Translate me", "Theme_en_GB Translate me"
"Var1 %1, Var2 %2, Var %3", "Theme_en_GB Var1
%1, Var2 %2, Var %3"
"Copyright %1 <a href=""%2"">Magento</a>", "Theme_en_GB
Copyright %1 <a href=""%2"">Magento</a>"

Now, a Translate me string output of the storefront for the en_GB locale would resolve to Theme_en_GB Translate me
and not to the en_GB Translate me string.

Theme CSV translations take higher precedence than module CSV translations, thus enabling developers to override
individual module translations.

Along with CSV translation files, Magento also supports a feature called inline translation. We can activate 
the inline translation in the Magento admin area by navigating to Store | Settings | Configuration | Advanced | Developer | Translate Inline

This feature can be turned on seperately for Admin and Storefront.

As shown in the preceeding screenshot, when a feature is activated, red dotted borders appear around the HTML elements.
Hovering over an individual element shows a little book icon near the individual element at the bottom left corner.
Clicking on the book icon opens a popup with info.

It is important to know, that these red dotted borders and the book icon will only appear for strings that we passed through the __() translate function.

Here we can see various pieces of information about the string, such as the Shown, Translated, and Original string. There is also an input field
called Custom, where we can add a new translation. Inline translation strings are stored in the translation table in the DB.

NOTE: Inline translation takes higher predecence than theme CSV translation files.

Indexing is the process of transforming data by reducing it to flattened data with less DB tables. This process is run
for products, categories, and so on in order to improve the performance of a web store. Since data constantly changes,
this is not a one-time process. Rather, it's done in periods.

The Magento_Indexer module is a base of the Magento Indexing functionality.

The Magento console tool supports the following indexer commands.

indexer
	indexer:info 		Shows allowed
Indexers
	indexer:reindex 	Reindexes Data
	indexer:set-mode 	Sets index mode type
	indexer:show-mode 	Shows index mode
	indexer:status 		Shows status of Indexer

On running php bin/magento indexer:info, you will get a list of all the Magento indexers. The default ones are as
follows:

catalog_category_product 	Category Products
catalog_product_category 	Product
Categories
catalog_product_price 		Product Price
catalog_product_attribute 	Product EAV
foggyline_office_employee 	Employee flat
Data
cataloginventory_stock 		Stock
catalog_rule 				Catalog Rule
Product
catalogrule_product 		Catalog Product
Rule
catalogsearch_fulltext 		Catalog Search

You will see all the indexers listed in the Magento admin in the System | Tools | Index Management menu.

From within the admin area, we can only change the indexer mode. There are two modes of indexers:

Update on Save: Index tables are updated right after the dictionary data is changed

Update by Schedule: Index tables are updated by cron jobs according to the configured schedule

Since indexers cannot be run manually from admin, we have to rely on their manual execution or the cron execution.

Manual execution is done via the following console command:

php bin/magento indexer:reindex

The preceding command will run all the indexers at once. We can fine-tune it further to execute individual indexes
by running a console command that is similar to the following line of code:

php bin/magento indexer:reindex
catalogsearch_fulltext

Cron-executed indexers are defined via the Magento_Indexer module, as follows:

indexer_reindex_all_invalid: This will execute every minute of every hour every day. It runs the
reindexAllInvalid method on an instance of the Magento\Indexer\Model\Processor class.

indexer_update_all_views: This will execute every minute of every hour everyday. It runs the
updateMview method on an instance of the Magento\Indexer\Model\Processor class.

indexer_clean_all_changelogs: This will execute the 0th minute of every hour every day. it runs 
the clearChangelog method on an instance of the Magento\Indexer\Model\Processor class.

These cron jobs use an operating system cron job setup in such a way that the Magento cron job is triggered
every minute.

The following three statuses is what an indexer can have:

valid: The data is synchronized and no re-indexing is required

invalid: The original data was changed and the index should be updated

working: The index process is running

While we won't go into the details of actually creating a custom indexer within this chapter,
it is worth noting that Magento defines it's indexers in the vendor/magento/module-*/etc/indexer.xml file

This might come in handy for cases where we want a deeper understanding of the inner workings of an individual indexer. For example,
the catalog_product_flat indexer is implemented via the Magento\Catalog\Model\Indexer\Product\Flat class, as defined within
the vendor/magento/module-catalog/etc/indexer.xml file.

By studying the Flat class implementation in depth, you can learn how data is taken from EAV tables and flattened into a simplified structure.

The next part, is about Frontend development. 

Frontend development, is mostly tied to HTML, CSS and JS for websites or web apps.

Interchangably, it adresses accessibility, usability and performance towards reaching a satisfying user experience.
Various levels of customization we want to apply to our web store require different development skill levels.

We can make relativily simple changes to our store using just CSS. These would be the changes where we accept the
structure of the store and focus only on visuals like changing colors and images. This might be a good starting point
for less experienced devs, and those new to Magento.

A more involved approach would be to make changes to the output generated by Magento modules. This usually means tiny bits of PHP knowledge,
mostly copy-paste modify of existing code fragments. A skill level above this one would imply knowledge of making structural 
changes to our store.

This usually means mastering Magento's moderately sophisticated layout engine, where we make changes through XML definitions.
The final and highest skill level of Magento frontend, implies development of existing or new custom functionality development.

Throughout this chapter, we will take a deep dive through the following sections:

Rendering flow

View elements

Block architechture and life cycle

Templates

XML Layouts

Themes

JS

CSS

The Magento application entry point is its index.php file. All of the HTTP requests go through it.
Let's analyze the (trimmed) version of the index.php file as follows:

require __DIR__ . '/app/bootstrap.php';

$bootstrap = \Magento\Framework\App\Bootstrap::create(BP, $_SERVER);

$app => $bootstrap -> createApplication('Magento\Framework\App\Http');

$bootstrap->run($app);

Thus, we begin by including /app/bootstrap.php into the code. What happens inside the bootstrap is the inclusion of app/autoload.php
and app/functions.php. These functions file contains a single __() function, used for translation purposes, returning an instance of
the \Magento\Framework\Phrases object. 

Without going into the details of the auto-load file, it is suffice to say it handles the auto-loading of all our class files across Magento.

The second step, is simply a static create method call to obtain the instance of the \Magento\Framework\App\Bootstrap object,
storing it into the $bootstrap variable.

The third step, is calling createApplication method on the $bootstrap object. What is happening within createApplication
is nothing more than using object manager to create and return the object instance of the class we are passing to it.

Since we are passing the \Magento\Framework\App\Http class name to the createApplication method, our $app variable becomes
the instance of that class. What this means, effectively, is that our web store app is an instance of Magento\Framework\App\Http.

The last step, is to call the run method on $bootStrap object, passing it the instance of the Magento\Framework\App\Http class.
Although it looks like a simple line of code, this is where stuff gets complicated, as we will see soon.

Let's analyze the trimmed version of the \Magento\Framework\Bootstrap -> run method as follows:

public function run(\Magento\Framework\AppInterface $application)
{
	//PART 2-1
	$this->initErrorHandler();
	$this->initObjectManager();
	$this->assertMaintenance();
	$this->assertInstalled();

	//PART 2-2
	$response = $application->launch();

	//PART 2-3
	$response->sendResponse();
}

Part 2-1, handles the sort of housekeeping bits. It initializes the custom error handler,
intializes the object manager, checks if our app is in maintnance mode, and checked that its installed.

Part 2-2, we call the launch() method on $application, which is the Magento\Framework\App\Http instance.
Without going into the inner workings of the launch method for the moment, let's just say it returns the instance
of Magento\Framework\App\Response\Http\Interceptor class defined under var/generation/Magento/Framework/App/Response/Http/Interceptor.php

Note that this is an automatically generated wrapper class, extending the \Magento\Framework\App\Response\Http class.

Effectively, ignoring the interceptor, we can say that $response is an instance the \Magento\Framework\App\Response\Http class.

Finally, Part 2-3 calls the sendResponse method on $response. Though $response is an instance of the \Magento\Framework\App\Response\Http class,
the actual sendResponse method is found further down the parent tree on the \Magento\Framework\HTTP\PhpEnvironment\Response class.

The sendResponse method calls another parent class method called send. The send method can be found under the Zend\Http\PhpEnvironment\Response class.
It triggers the sendHeaders and sendContent methods. This is where the actual output gets sent to the browser, as the sendHeaders methods
is using PHP's header function and echo construct to push the output.

To reiterate on the preceeding, the flow of execution as we understand it, comes down to the following:

index.php

\Magento\Framework\App\Bootstrap->run
\Magento\Framework\App\Http->launch
\Magento\Framework\App\Response\Http->sendResponse

Though we have just made it to the end of the bootstrap's run method, it would be unfair to say we covered the rendering flow,
as we barely touched it.

We need to take a step back and take a detailed look at PART 2-2, the inner workings of the launch method. Let's take a look at the
(trimmed) version of the \Magento\Framework\App\Http->launch method as follows:

public function launch()
{
	//Part 3-1
	$frontController =
$this->_objectManager->get
('Magento\Framework\App\FrontControllerInterface');

	//Part 3-2
	$result =
$frontController->dispatch($this->_request);
	
	if ($result instanceof \Magento\Framework\Controller\ResultInterface) {
		//part 3-3

$result->renderResult($this->_response);
	} elseif ($result instanceof \Magento\Framework\App\Response\HttpInterface) {
		$this->_response = $result;
	} else {
		throw new \InvalidArgumentException('Invalid return type');
	}
	
	//part 3-4
	return $this->_response;
}

Part 3-1 creates the instance of the object whose class conforms to \Magento\Framework\App\FrontControllerInterface.
If we look under app/etc/di.xml, we can see there is a prefernce for FrontControllerInterface in favor of the \Magento\Framework\App\FrontController class.

However, if we were to debug the code and check for the actual instance class, it would show Magento\Framework\App\FrontController\Interceptor.
This is Magento adding an interceptor wrapper that then extends \Magento\Framework\App\FrontController, which we expected from the di.xml
prefernce entry.

Now that we know the real class behind the $frontController instance, we know where to look for the dispatch method. The dispatch method 
is another important step in understanding the rendering flow process. We will look into its inner workings in a bit more detail later
on.

For now, let's focus back on the $result variable of part-3-2. If we were to debug the variable, the direct class behind it would show as
Magento\Framework\View\Result\Page\Interceptor, defined under the dynamically created var/generation/Magento/Framework/View/Result/Page/Interceptor.php file.

interceptor is the wrapper of the \Magento\Framework\View\Result\Page class. Thus, it is safe to say that our $result variable is an
instance of the Page class.

The Page class extends \Magento\Framework\View\Result\Layout, which further extends \Magento\Framework\Controller\AbstractResult and implements
\Magento\Framework\Controller\ResultInterface. Quite a chain we have here, but it is important to understand it.

Notice part 3-3. Since our $result is an instance of \Magento\Framework\Controller\ResultInterface, we fall into the first if condition
that calls the renderResult method. the renderResult method itself is declared within the \Magento\Framework\View\Result\Layout class.

Without going into the details of renderResult, suffice to say that it adds HTTP headers, and content to the $this->_response object
passed to it. That same response object is what the launch method returns, as we described before in Part 2-2.

Though part-3-3 does not depict any return value, the expression $result->renderResult($this->_response) does not do any
output on its own. It modifies $this->_response that we finally return from the launch method as shown in part-3-4

To reiterate on the preceeding, the flow of execution as we understand it comes down to the following:

index.php

\Magento\Framework\App\Bootstrap->run

\Magento\Framework\App\Http->launch

\Magento\Framework\App\FrontController->dispatch

\Magento\Framework\View\Result\Page->renderResult

\Magento\Framework\App\Response\Http->sendResponse

As we mentioned while explaining Part-3-2, the dispatch method is another important step 
in the rendering flow process. Let's take a look at the (trimmed) version of the \Magento\Framework\App\FrontController->dispatch method as follows:

public function dispatch(\Magento\Framework\App\RequestInterface $request)
{
	//PART 4-1
	while (!$request->isDispatched() && $routingCycleCounter++ < 100) {
		//Part 4-2
		foreach ($this->_routerList as $router)
		{
			try {
				//PART 4-3
				$actionInstance = $router->match($request);
				if ($actionInstance) {
					$request->setDispatched(true);
											//PART 4-4
											$result =
				$actionInstance->dispatch($request);
											break;
										}
									} catch (\Magento\Framework\Exception\NotFoundException $e) {}
				
			
		}
	}

	//part 4-4 
	return $result;
}

//NOTE: Indention error on some level of where we have not found the pattern correctly

Part-4-1 and PART-4-2 in the preceeding code shows (almost) the entire dispatch method body contained within a loop.
The loop does 100 iterations, further looping through all available router types, thus giving each router 100 times to find a router match.

The router list loop includes routers of the following class types:

Magento\Framework\App\Router\Base

Magento\UrlRewrite\Controller\Router

Magento\Cms\Controller\Router

Magento\Framework\App\Router\DefaultRouter

All of the list routers implement \Magento\Framework\App\RouterInterface, making them all have the implementations of the match method.

A module can further define new routers if they choose so. As an example, imagine if we are developing a blog module. We would want our module
catching all requests on a URL that starts with a /blog/ part. This can be done by specifying the custom router, which would then show up
on the preceeding list.

Part-4-3 shows the $actionInstance variable storing the result of the router match method call. As per RouterInterface
requirements, the matcher method is required to return an instance whose class implements \Magento\Framework\App\ActionInterface. Let's
imagine we are now hitting the URL /foggyline_office/test/crud/ from the module we wrote in chaper 4.

in this case, our $router class would be \Magento\Framework\App\Router\Base and our $actionInstance would be of the class \Foggyline\Office
\Controller\Test\Crud\Interceptor.

Magento automatically adds Interceptor, through the dynamically generated var/generation/Foggyline/Office/Controller/Test/Crud/Interceptor.php file

This Interceptor class further extends our module \Foggyline\Office\Controller\Test\Crud class file.
The Crud class extends \Foggyline\Office\Controller\Test, which further extends \Magento\Framework\App\Action\Action, which implements
\Magento\Framework\App\ActionInterface. After a lengthy parent-child tree, we finally got to ActionInterface, which is what 
our match method is required to return.

Part-4-4 shows the dispatch method being called on $actionInstance. This method is implemented within \Magento\Framework\App\Action\Action, and is
expected to return an Object that implements \Magento\Framework\App\ResponseInterface. Internal to dispatch, the execute method is called,
thus running the code within our Crud controller action execute method.

Assuming our Crud controller action execute method does not return nothing, the $result object becomes an instance of Magento\Framework\App\Response\Http\Interceptor,
which is wrapped around \Magento\Framework\App\Response\Http.

Let's imagine our Crud class has been defined as follows:

/**
  * @var \Magento\Framework\View\Result\Pagefactory
  */

protected $resultPageFactory;

public function __construct( \Magento\Framework\App\Action\Context $context, \Magento\Framework\View\Result\PageFactory $resultPageFactory)
{
	$this->resultPageFactory = $resultPageFactory;
	return parent::__construct($context);
}

public function execute()
{
	$resultPage = $this->resultPageFactory->create();
	//...
	return $resultPage;
}

Debugging the $result variable now shows it's an instance of \Magento\Framework\View\Result\Page\Interceptor. This Interceptor
gets dynamically generated by Magento under var/generation/Magento/Framework/View/Result/Page/Interceptor.php
and is merely a wrapper for \Magento\Framework\View\Result\Page. This Page class further extends the \Magento\Framework\View\Result\Layout class,
and implements \Magento\Framework\App\ResponseInterface.

Finally, PART-4-4 shows the $result object of type \Magento\Framework\View\Result\Page being returned from the FrontController dispatch method.
To reiterate on the preceeding, the flow of execution as we understand it comes down to the following:

index.php

\Magento\Framework\App\Bootstrap->run

\Magento\Framework\App\Http->launch

\Magento\Framework\App\FrontController->dispatch

\Magento\Framework\App\Router\Base->match

\Magento\Framework\App\Action\Action->dispatch

\Magento\Framework\View\Result\Page->renderResult

\Magento\Framework\App\Response\Http->sendResponse

In a nutshell, what we as a frontend dev should know is that returning the Page type object from our controller
action will automatically call the renderResult method on that object. Page and Layout is where all the theme translations, layout and template loading
are triggering.

Magento's primary view elements are its UI components, containers and blocks. The following is a brief overview of each of them.

Under the vendor/magento/framework/View/Element/ folder, we can find UiComponentInterface and UiComponentFactory.
The full set of Ui components is located under the vendor/magento/framework/View/Element/ dir.

Magento implements UiComponent through a seperate module called Magento_Ui. Thus, the components themselves are 
located under the vendor/magento/module-ui/Component/ dir.

Components implement UiComponentInterface, which is defined under the vendor/magento/framework/View/Element/UiComponentInterface.php file as follows:

namespace Magento\Framework\View\Element;

use Magento\Framework\View\Element\UiComponent\ContextInterface;

interface UiComponentInterface extends BlockInterface
{
	public function getName();
	public function getComponentName();
	public function getConfiguration();
	public function render();
	public function addComponent($name, UiComponentInterface $component);
	public function getComponent($name);
	public function getChildComponents();
	public function getTemplate();
	public function getContext();
	public function renderChildComponent($name);
	public function setData($key, $value = null);
	public function getData($key = '', $index = null);
	public function prepare();
	public function prepareDataSource(array & $dataSource);
	public function getDataSourceData();
}

Notice how BlockInterface extends BlockInterface, whereas BlockInterface defines only one method requirement as follows:

namespace Magento\Framework\View\Element;

interface BlockInterface
{
	public function toHtml();
}

Since Block is an element of the interface, UiComponent can be looked at as an advanced block. Let's take a quick look
at the _renderUiComponent method of the \Magento\Framework\View\Layout class (partially) as follows:

protected function _renderUiComponent($name)
{
	$uiComponent = $this->getUiComponent($name);

	return $uiComponent ? $uiComponent->toHtml() : '';
}

This shows that UiComponent is rendered the same way as block, by calling the toHtml method on the component.
The vendor/magento/module-ui/view/base/ui_component/etc/definition.xml file contains an extensive list of several
UiComponents as follows:

dataSource:Magento\Ui\Component\DataSource

listing:Magento\Ui\Component\Listing

paging:Magento\Ui\Component\Paging

filters:Magneto\Ui\Component\Filters

container:Magento\Ui\Component\Container

form:Magento\Ui\Component\Form

price:Magento\Ui\Component\Form\Element\DataType\Price

image:Magento\Ui\Component\Form\Element\DataType\Media

nav:Magento\Ui\Component\Layout\Tabs\Nav

and more!

These components are mostly used to construct a listing and filters in the admin area.
If we do a string search for uiComponent across the entire Magento, we would mostly
find entries like the one in vendor/magento/module-cms/view/adminhtml/layout/cms_block_index.html, with stuff like:

<page xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:noNamespaceSchemaLocation="urn:magento:framework:View/Layout/etc/page_configuration.xsd">
	<body>
		<referenceContainer name="content">
			<uiComponent name="cms_block_listing"/>
		</referenceContainer>
	</body>
</page>

The value cms_block_listing of uiComponent's name attribute refers to the name of the vendor/magento/module-cms/view/adminhtml/ui_component/
cms_block_listing.xml file. Within the cms_block_listing.xml file, we have a listing component defines across more than
a few hundred lines of XML. Listing component then dataSource, container, bookmark, filterSearch, filters and so on. We will not
go into the details of these declarations, as our focus here is on more general frontend bits.

We cannot create instances of containers because they are an abstract concept, whereas we can create instances of Blocks.

Containers are rendered via the _renderContainer method of the Magento\Framework\View\Layout class, defines as follows:

protected function _renderContainer($name)
{
	$html = '';
	$children = $this->getChildNames($name);
	foreach ($children as $child) {
		$html .=
$this->renderElement($child);
	}
	if ($html == '' ||
!$this->structure->getAttribute($name, Element::CONTAINER_OPT_HTML_TAG)) {
		return $html;
}

	$htmlId =
$this->structure->getAttribute($name, Element::CONTAINER_OPT_HTML_ID);
	if ($htmlId) {
		$htmlId = ' id="' . $htmlId . '"';
	}

	$htmlClass =
$this->structure->getAttribute($name, Element::CONTAINER_OPT_HTML_CLASS);
	if ($htmlClass) {
		$htmlClass = ' class="' . $htmlClass . '"';
	}

	$htmlTag =
$this->structure->getAttribute($name, Element::CONTAINER_OPT_HTML_TAG);

	$html =
sprintf('<%1$s%2$s%3$s>%4$s</%1$s>',
$htmlTag, $htmlId, $htmlClass, $html);
	
	return $html;
}

Containers support the following extra attributes: htmlTag, htmlClass, htmlId and label. To make a little
demonstration of a container in action, let us make sure we have a module from Chapter 4. Models and Collections in
place, and then create the view/frontend/layout/foggyline_office_test_crud.xml file within the
module root folder app/code/Foggyline/Office/ with content as follows:

<page xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" layout="1column"

xsi:noNamespaceSchemaLocation="urn:magento:framework:View/Layout/etc/page_configuration.xsd">
	<head>
		<title>Office CRUD #layout</title>
	</head>
	<body>
		<container name="foobar" htmlTag="div" htmlClass="foo-bar">
			<block class="Magento\Framework\View\Element\Text" name="foo">
				<action method="setText">
					<argument name="text"
xsi:type="string"> <![CDATA[<p>The Foo</p>]]>
</argument>
				</action>
			</block>
			<block class="Magento\Framework\View\Element\Text" name="bar">
															<action method="setText">
																<argument name="text" 
xsi:type="string"> <![CDATA[<p>The bar</p>]]>
</argument>
															</action>
														</block>
													</container>
												</body>
											</page>


NOTE: Error in Indentions

The preceding XML defines a single container named foobar, and within the container there are two block
elements named foo and bar. It should kick in when we open http://{our-shop-url}/index.php/foggyline_office/test/crud/ in the browser.

Notice how the container itself is not nested within any other element, rather directly into the body. We could have
easily nested into some other container as shown:

<body>
	<referenceContainer name="content">
		<container name="foobar" htmlTag="div" htmlClass="foo-bar">

Either way, we should see the srings The Foo and The Barshown in the browser, with a full-page layout loaded, as shown
in the following screenshot.

Although containers determine the layout of the page, they do not contain actual content directly. Pieces that contain the
content and are nested within containers are called blocks. Each block can contain any number of child content blocks or
child containers. Thus, mostly every web page in Magento is formed as a mix of blocks and containers. Layout defines a
sequence of blocks on the page, not their location.

The look and feels of the blocks is determined by CSS and how the Page is rendered. When we speak of Blocks,
we almost always implicitly refer to templates as well. Templates are the thing that actually draw elements within
a page. Blocks are the thing that contain the Data. In other words, templates are PHTML or HTML files pulling data
through variables or methods sent on a linked PHP block class.

Magento defines Magento\Framework\View\Result\Page type under app/etc/di.xml as follows:

<type name="Magento\Framework\View\Result\Page">
	<arguments>
		<argument name="layoutReaderPool" 
xsi:type="object">pageConfigRenderPool</argument>
		
		<argument name="generatorPool"
xsi:type="object">pageLayoutGeneratorPool</argument>

		<argument name="template"
xsi:type="string">Magento_Theme::root.phtml</argument>	
	</arguments>
</type>

Notice the template argument is set to Magento_Theme::root.phtml. Whem Page gets 
initialized, it picks up the vendor/magento/module-theme/view/base/templates/root.pthml file.

root.phtml is defined as follows:

<!doctype Html>
<html <?php echo $htmlAttributes ?>>
	<head <?php echo $headAttributes ?>>
		<?php echo $requireJs ?>
		<?php echo $headContent ?>
		<?php echo $headAdditional ?>
	</head>
	<body data-container="body" data-mage-init='{"loaderAjax": {}, "loader": { "icon": "<?php echo $loaderIcon; ?>"}}'
	<?php echo $bodyAttributes ?>>
		<?php echo $layoutContent ?>
	</body>
</html>

Variables within root.phtml are assigned during the Magento\Framework\View\Result\Page render method call as (partially) shown:

protected function render(ResponseInterface $response)
{
	$this->pageConfig->publicBuild();

	if ($this->getPageLayout()) {
		$config = $this->getConfig();
		$this->addDefaultBodyClasses();
		$addBlock = 
$this->getLayout()->getBlock('head.additional');
		$requireJs = $this->getLayout-getBlock('require.js');
		$this->assign([
			'requireJs' => $requireJs ? $requireJs->toHtml() : null,
			'headContent' => $this->pageConfigRenderer->renderHeadContent(),
			'headAdditional' => $addBlock ? $addBlock->toHtml() : null,
			'htmlAttributes' => $this->pageConfigRenderer->renderElementAttributes($config::ELEMENT_TYPE_HTML),
			'headAttributes' => $this->pageConfigRenderer->renderElementAttributes($config::ELEMENT_TYPE_HEAD),
			'bodyAttributes' => $this->pageConfigRenderer->renderElementAttributes($config::ELEMENT_TYPE_BODY),
			'loaderIcon' => $this->getViewFileUrl('images/loader2.gif'), ]);

			$output = $this->getLayout()->getOutput();
			$this->assign('layoutContent', $output);
			$output = $this->renderPage();

			$this->translateInline->processResponseBody($output);
			$response->appendBody($output);
	} else {
		parent::render($response);
	}

	return $this;
}

The expression $this->assign is what assigns variables like layoutContent to the root.phtml template.
layoutContent is generated based on base layouts, together with all layout updates for the current page.

Whereas base layouts include the following XMLs within vendor/magento/module-theme/view/:

base/page_layout/empty.xml

frontend/page_layout/1column.xml

frontend/page_layout/2columns-left.xml

frontend/page_layout/2columns-right.xml

frontend/page_layout/3columns.xml

The expression $this->getLayout()->getOutput() is what gets all blocks marked for output. It basically finds
elements in a layout, renders them, and returns the string with its output. Along the way, the event core_layout_render_elements gets fired,
giving us one possible way of affecting the output result. At this point, most of the elements on the page are rendered.

This is important because blocks play a big role here. The rendering system will take empty.xml into account, as it too consists of a list of
containers, and every container has some blocks attached to it by other layout updates.

In a nutshell, each container has blocks assigned to it. Each block usually (but not always) renders a template. The template itself
may or may not call call other blocks, and so on. Blocks are rendered when they are called from the template.

Blocks are another one of the primary view elements 

//CONTINUATION FROM 191 IN RELATIVITY TO DESKTOP

Javascript resources can be specified as follows:

Library level for all libraries in the Magento code base (lib/web).

Module level for all libraries in a module (app/code/{vendorName}/{moduleName}/view/{area}/web).

Theme for all libraries in a theme (app/design/{area}/{vendorName}/{theme}/{vendorName}_{moduleName}/web).

All libraries in a theme (app/design/{area}/{vendorName}/{theme}/web). Though possible,
 it is not recommended using this level to specify JS resources.

 It is recommended to specify JS resources in the templates rather than in the layout updates. This way,
  we ensure processing of the resource through RequireJS.

  To work with the RequireJS lib, specify the mapping of JS resources, that is, assign
  the aliases to resources, Use requires-config.js to create the mapping.

  To make our configurations more precise and specific for different modules/themes,
  we can identify mapping in the require-config.js file at several levels depending on our needs.
  Configurations are collected and executed in the following order:

  Library Configs

  Configs at Module level

  Configs at theme module level for the ancestor theme

  Config at the theme module level for a current theme

  Configs at the theme level for the ancestor themes

  Configs at the theme level for the current theme

  When we speak of JS in Magento, we can hear various terms like componen and widget.
  We can easily divide those terms by describing the type of JS in Magento as per following list:

  JS Component (JS Component): This can be any single JS file decorated as an AMD (short for Asynch Module Def) module

  Ui Component: A JS component located in the Magento_Ui module

  jQuery UI widget: a JS component/widget provided by the jQuery UI library used in Magento

  jQuery widget: A custom widget created using jQuery UI Widget Factory and decorated as an AMD module

  There are two ways we can initialize a JS component in template files:

  Using the data-mage-init attribute

  Using the <script> tag

  The data-mage-init attribute is parsed on a DOM ready event. Since it is initialized on a certain
  element, the script is called only for that particular element, and is not automatically
  initialized for other elements of the same type on the page.

  An example of data-mage-init usage would be something like the following:

  <div data-mage-init='{"<componentName>":{...}}'></div>

  The <script> tag initialization is done without relation to any specific element or in relation
  to a specific element but no direct access to the element. The script tags has to have an
  attribute, type="text/x-magento-init". An example of <script> tag initialization would be something
  like the following:

  <script type="text/x-magento-init">
  	//Specific element but no direct access to the element
  	"<element selector>": {
  		"<jsComponent1>": ...,
  		"<jsComponent2>": ...
  	},
  	//Without relation to any specific element
  	"*": {
  		"<jsComponent3">: ...
  	}
  </script>

  Depending on the situation and desired level of expressiveness, we can either opt for
  usage of data-mage-init or attribute or <script> tag

  To create a custom component in JS:

  Let's go through a practical example of creating a JS component within our Foggyline_Office module
  in a form of the jQuery widget as follows:

  First we add our entry to app/code/Foggyline/Office/view/frontend/require-js-config.js, as shown:

  var config = {
  	map: {
  		'*': {
  			foggylineHello: 'Foggyline_Office/js/foggyline-hello'
  		}
  	}
  };

  Then we add the actual JS app/code/Foggyline/Office/view/frontend/web/js/foggyline-hello.js with content as follows:

  define([
  	"jquery",
  	"jquery/ui"],
  	function($){
  		"use strict";

  		$.widget('mage.foggylineHello', {
  			options: {
  			},
  			_create: function () {	
  				alert(this.options);
  				//my code here
  			}
  		});

  		return $.mage.foggylineHello;
  	});

  Finally, we call our JS component within some PHTML template, let's say app/code/Foggyline/Office/view/frontend/templates/office/hello.phtml, as show:

  <div data-mage-init='{"foggylineHello": {"myVar1": "myValue1", "myVar2": "myValue2"}}'>Foggyline</div>

  Once we refresh the frontend, we should see the result of alert(this.options) in the browser showing
  myVar1 and myVar2.

  The data-mage-init part basically triggers as soon as the page loads. It is not triggered via some click
  or similar event on top of the div element; it is triggered on page load.

  If we don't see the desired result in the browser, we might need to fully clear the cache in the admin area.

  Magento uses a PHP port of the official LESS processor to parse .less files into .css files. LESS is a CSS
  preprocessor that extends the CSS language by adding various features to it, like variables, mixins and functions.

  All of this makes CSS more maintainable, extendable and easier to theme. Frontend devs are thus expected
  to write LESS files that Magento then converts to appropiate CSS variants.

  It is worth running find {MAGENTO-DIR}/-name\*.less > less-list.txt on the console to get a full
  list of each and every LESS file in Magento. Spending a few minutes glossing over the list 
  might serve as a nice future memo when working with style sheet bits in Magento.

  We can customize the storefront looks and feel through one of the following approaches:

  Override the default LESS files - only if our theme inherits from the default
  or any other theme, in which case we can override the actual LESS files

  Create our own LESS files using the built-in LESS preprocessor

  Create our own CSS files, optionally having compiled them using a third-party CSS preprocessor

  Within the individual frontend theme dir, we can find style sheets at the following locations:

  {vendorName}_{moduleName}/web/css/source/

  {vendorName}_{moduleName}/web/css/source/module/

  web/css/

  web/css/source/

  CSS files can be included in a page through templates and layout files. A recommended way is
  to include them through layout files. If we want our style sheets to be available
  through all pages on the frontend, we can add using the default_head_blocks.xml file.

  If we look at the blank theme, it uses vendor/magento/theme-frontend-blank/Magento_Theme/layout
  /default_head_blocks.xml defined as follows:

  <page xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:noNamespaceSchemaLocation="urn:magento:framework:View/Layout/etc/page_configuration.xsd">
  	<head>
  		<css src="css/styles-m.css"/>
  		<css src="css/styles-l.css"/
 media="screen and (min-width: 768px)"/>
 		<css src="css/print.css"
 media="print"/>
 	</head>
 </page>

 All it takes for us to copy this file in the same location under our custom theme; assuming it's
 the jupiter theme from the preceding examples, that would be app/design/frontend/Foggyline/jupiter/Magento_Theme/layout/default_head_blocks.xml 

 Then we simply modify the file to include our CSS

 When run, Magento will try to find the included CSS file. If a CSS file  is not found, it then searches
 for the same filenames with a .less extension. This is part of the built-in preprocessing mechanism.

 Throughout previous chapters, we learned how to use some of the backend components
 so that storeowners can manage and manipulate the data such as customers, products, categories,
 orders and so on. Sometimes this is not enough, like when we are pulling data in or out from third-party
 systems. In cases like these, the Magento Web API framework makes it easy to call Magento services through
 REST or SOAP.

 In this chapter, we will cover the following topics:

 User Types

 Authenticating methods

 REST versus SOAP

 Hands-on with token-based authentication

 Hands-on with OAuth-based authentication

 OAuth-based Web API calls

 Hands-on with session-based authentication

 creating custom Web APIs

 Search Criteria Interface for list filtering

 Before we can start making Web API calls, we must authenticate
 our identity and have the necessary permissions (authoriziation) to access the API resource.
 Authentication allows Magento to identify the caller's user type. Based on the 
 user's (administrator, integration, customer or guest) access rights, the API's calls' resource
 accessibility is determined.

 The list of resources that we can access depends on our user type and is defined within our module
 webapi.xml config file.

 There are three types of users known to API, listed as follows:

Administrator or integration: Resources for which administrators or integrators are authorized.
For example, if administrators are authorized for the Magento_Cms::page resource, they can make a
POST /V1/cmsPage call.

Customer: Resources for which customers are authorized. These are resources with anonymous or self permission.

Guest users: Resources for which guests are authorized. These are the resources with anonymous permission.

Two files play a crucial role toward defining an API: our module acl.xml and webapi.xml files.

acl.xml is where we define our module access control list (ACL). It defines an available set of permissions
to access the resources. The acl.xml files across all Magento modules are consolidated to build an
ACL tree that is used to select allowed admin resources or third-party integration's access (System | Extensions | Integrations | Add New Integration | Available APIs)

webapi.xml is where we define Web API resources and their permissions. When we create
webapi.xml, the permissions definen in acl.xml are referenced to create access rights for each
API resource.

Let's take a look at the following (truncated) webapi.xml from the core Magento_Cms module:

<routes xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Webapi:etc/webapi.xsd">
	...
	<route url="/V1/cmsPage" method="POST">
		<service class="Magento\Cms\Api\PageRepositoryInterface" method="save" />
		<resources>
			<resource ref="Magento_Cms::page"/>
		</resources>
	</route>
	...
	<route url="/V1/cmsBlock/search" method="GET">
		<service class="Magento\Cms\Api\BlockRepositoryInterface" method="getList" />
		<resources>
			<resource ref="Magento_Cms::block" />
		</resources>
	</route>
	...
</routes>

In the preceeding webapi.xml file for the CMS page API, only a user with Magento_Cms::page authorization
can access POST /V1/cmsPage or GET /V1/cmsBlock/search.

We will get back to a more detailed explonation of route later on in our examples; for the moment,
our focus is on resource. We can assign multiple child resource elements under resources. In cases like these,
it would be sufficient for a user to have any of those ACLs assigned to be able to make an API call.

The actual authorization is then granted to either an admin or integration, defined in the Magento admin,
with full group or a specific resource selected in the ACL tree as shown in the following SS:

//pic of role resources

Given that webapi.xml and acl.xml go hand in hand, let's take a look at the (truncated) acl.xml file from
the core Magento_Cms module:

<resources>
	<resource id="Magento_Backend::admin">
		<resource
id="Magento_Backend::content">
			<resource
id="Magento_Backend::content_elements">
				<resource
id="Magento_Cms::page" ...>
					....
				</resource>
			</resource>
		</resource>
	</resource>
</resource>

Notice how the position of the Magento_Cms::page resource is nested under Magento_Backend::content_elements,
which in turn is nested under Magento_Backend::content, which is further nested under Magento_Backend::admin

This tells Magento where to render the ACL under Magento admin when showing the Roles Resources tree as shown
in the previous screenshot. This does not mean that the user authorized against Magento_Cms::page resource
won't be able to access the API if all those parent Magento_Backend resources are granted to him as well.

Authorizing against a resource is sort of a flat thing. There is no tree check when authorizing. Thus,
each resource is required to have unique id attribute value on a resource element when defined 
under acl.xml

The resources just defined are what we listed before as resources for which admins or integrators are authorized.

The customer, on the other hand, is assigned a resource named anonymous or self. If we were to do a full
<resource ref="anonymous" /> string search across all Magento core modules, several occurences would show up.

Let's take a look at the (truncated) core module vendor/magento/module-catalog/etc/webapi.xml file:

<route url="/V1/products" method="GET">
	<service class="Magento\Catalog\Api\ProductRepositoryInterface" method="getList"/>
	<resources>
		<resource ref="anonymous"/>
	</resources>
</route>

The preceeding XML defines an API endpoint path with a value of /V1/products, available via the
HTTP GET method. It further defines a resource called anonymous, which means either the currently
logged-in customer or guest user can call this API endpoint.

This basically means that each resource has a "access level", that it defines, which defines who can access things via GET or POST.

anonymous is a special permission that does not need to be defined in acl.xml. As such, it will not show up
in the permissions tree under Magento admin. This simply means that the current resource in webapi.xml can be
accessed without the need for authentication.

Finally, we take a look at the self resource, whose example we can find under the (truncated) vendor/magento/module-customer/etc/webapi.xml as follows:

<route url="/V1/customers/me" method="PUT">
	<service class="Magento\Customer\Api\CustomerRepositoryInterface" method="save"/>
	<resources>
		<resources ref="self"/>
	</resources>
	<data>
		<parameter name="customer.id"
force="true">%customer_id%</parameter>
	</data>
</route>

self is a special kind of access that enables a user to access resources they own, assuming
we already have an authenticated session with the system. For example, GET /V1/customers/me fetches
the logged-in customer's details. This is something that is typically useful for JS-based components/widgets.

Mobile apps, third-party apps and JS components/widgets (storefront or admin) are the three
main types of clients as seen by Magento. Though a client is basically everything communicating with our
APIs, each type of client has a preffered authentication method.

Magento supports three types of authentication methods, listed as follows:

Token-based authentication

OAuth-based authentication

Session-based authentication

Token-based authentication is most suitable for mobile apps, where a token acts like an electronic key
providing access to the Web API's. The general concept behind a token-based auth system is relativily simple.

The user provides a username and password during initial authentication in order to obtain a time-limited token
from the system. If a token is succesfully obtained, all subsequent API calls are then made with that token.

OAuth-based authentication is most suitable for third-party apps that integrate with Magento. Once an
app is authorized through the OAuth 1.0a handshake process, it gains access to Magento Web APIs.
There are three key terminlogoies we must understand here: user(resource owner), client (consumer) and
server(service provider).

The user or resource owner is the one who is being asked to allow access to its protected resource. Imagine a
customer as a user (resource owner) allowing access to its orders to some third-party apps. In such a case,
this third-party app would be the client (consumer), whereas Magento and its Web API would be the server (Service provider).

Session-based authentication is probably the simplest one to grasp. As a customer, you log in to the
Magento storefront with your customer credentials. As an admin, you log in to the Magento admin with your
admin creds. 

The Magento Web API framework uses your logged-in session info to verify your identity and authorize access
to the requested resource.

Magneto supports both SOAP (short for Simple Object Access Protocol) and REST (short for Representational
State Transfer) types of communication with the Web API. Authentication methods themselves are not really 
bound to any of them. We can use the same authentication method and Web API method calls with both SOAP and REST.

Some of the REST specifics we might outline as follows:

We run REST Web API calls through cURL commands or a REST client.

Requests support HTTP verbs: GET, POST, PUT or DELETE.

A HTTP header requires an authorized parameter, specifying the authentication token with the Bearer HTTP authorization scheme, Authorization: Bearer <TOKEN>. <TOKEN> is then authentication token returned by the Magento token service.

We can use the HTTP header Accept: application/<FORMAT>, where <FORMAT> is either JSON or XML.

We run SOAP Web API calls through cURL commands or a SOAP client.

A Web Service Definition Language (WSDL) file is generated only for services that we request.
There is no one big merged WSDL file for all services.

The Magento Web API uses WSDL 1.2, compliant with WS-I 2.0 Basic Profile.

Each Magento service interface that is part of a service contract is represented as a separate service in the 
WSDL.

Consuming several services implies specifying them in the WSDL endpoint URL in a comma-separated manner,
for example:

http://<magento.host>/soap/<optional_store_code>?wsdl&services=<service_name_1>,<service_name_2>.

We can get a list of all available services by hitting a URL  like:

http://<SHOP-URL>/soap/default?wsdl_list in the browser.

The following REST and SOAP examples will make extensive use of cURL, which is essentialy
a program that allows you to make HTTP requests from the cmd line or different
language implementations (such as PHP). We can further describe cURL as the console browser,
or our view source tool for the web.

Anything we can do with various fancy REST and SOAP libs, we can do with cURL as well: it is just considered
to be a more low-level approach.

Doing SOAP requests with cURL or anything else that does not have WSDL/XML parsing implemented internally is cumbersome. Thus, using PHP SoapClient or something more robust is a must. SoapClient is an integrated,
actively maintained part of PHP, and is thus generally available.

With negative points being pointed, we will still present all of our API calls with console cURL, PHP cURL and
PHP SoapClient examples. Given that libs abstract so much functionality, it is absolutely essential
that a dev has a solid understanding of cURL, even for making SOAP calls.

The crux of token-based auth is as follows:

Client requests access with a username and PW

Application validates credentials

App provides a signed token to the client

The following code example demonstrates the console cURL REST-like request for the customer user:

curl -X POST "http://magento2.ce/rest/V1/integration/customer/token"\
	-H "Content-Type:application/json"\
	-d '{"username":"john@change.me", "password": "abc123"}'

The following code example demonstrates the PHP cURL REST-like request for the customer user:

$data = array('username' => 'john@change.me', 'password' => 'abc123');
$data_string = json_encode($data); //Just JSON encode the data object

$ch = curl_init('http://magento2.ce/rest/V1/integration/customer/token'); //initiate the curl on the token
	curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'POST'); //make a custom post request
	curl_setopt($ch, CURLOPT_POSTFIELDS, $data_string); //the post fields is the JSON 
	curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); //return the transfer result
	curl_setopt($ch, CURLOPT_HTTPHEADER, array('Content-Type: application/json', 'Content-Length: ' . strlen($data_string)) //the http header is an array assigning type and content length of the data_string
);

$result = curl_exec($ch); //Execute the curl object and store the result

The following code example demonstrates the console cURL SOAP-like request for the customer user:

curl -X POST -H 'Content-Type: 
application/soap+xml;
charset=utf-8; action="integrationCustomerTokenServiceV1CreateCustomerAccessToken"' //Make a post request with the 
//header defined as a soap/xml request with charset utf 8, make the action to be creating a custom token service
-d @request.xml http://magento2.ce/index.php/soap/default?services=integrationCustomerTokenServiceV1 //pass the xml ///data as POST body data

Notice the -d @request.xml part. Here, we are saying to the curl command to take the content of the request.xml
file and pass it on as POST body data where the content of the request.xml file for the preceeding curl command is
defined as follows:

<?xml version="1.0" encoding="UTF-8"?> //version 1.0 of xml with utf 8 coding
<env:Envelope xmlns:env="http://www.w3.org/2003/05/soap-envelope" //define the xmlns url to be a soap envelope
xmlns:nsl="http://magento2.ce/index.php/soap/default? //Dfine the nsl to be the relevant module we are using
services=integrationCustomerTokenServiceV1">
	<env:Body> //Define the body
<nsl:integrationCustomerTokenServiceV1CreateCustomer AccessTokenRequest> //Define the contents of the nsl
<username>john@change.me</username> //Username
			<password>abc123</password> //pw
</nsl:integrationCustomerTokenServiceV1CreateCustomer AccessTokenRequest> //end of NSL
	</env:Body> //End of body
</env:Envelope> //End of Envelope

The following code example demonstrates the PHP cURL SOAP-like request for the customer user:

$data_string = file_get_contents('request.xml'); //get the contents of the request.xml

$ch = curl_init('http://magento2.ce/index.php/soap/default?services=integrationCustomerTokenServiceV1'); /initialize //curl
	curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'POST'); //Set options, make a customrequest, a POST one
	curl_setopt($ch, CURLOPT_POSTFIELDS, $data_string); //make the postfield be the xml file
	curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); //return the transfer data
	curl_setopt($ch, CURLOPT_HTTPHEADER, array( //define the header of the HTTP request
	'Content-type: application/soap+xml; //the type is soap+xml
charset=utf-8; //charset utf-8
action="integrationCustomerTokenServiceV1 CreateCustomerAccessToken"', //Create a CustomerAccessToken
	'Content-Length: ' . strlen($data_string)) //define the length
);

$result = curl_exec($ch); //Save the results from executing the POSt request against the SOAP structure

The following code example demonstrates the usage of PHP SoapClient to make a Web API call:

$request = new SoapClient( //make a SoapClient request
	'http://magento2.ce/index.php
/soap/default?wsdl&services=
integrationCustomerTokenServiceV1', //Run the soap request against the tokenService
	array('soap_version' => SOAP_1_2, 'trace' => 1) //array of values
);

$token = 
$request->integrationCustomerTokenServiceV1Create CustomerAccessToken(array('username' => 
'john@change.me', 'password' => 'abc123')); //make a request against the integration of creating CustomerAccessToken

The API call for admin user authentication is nearly identical, and depends on which one of three approaches we take. The difference is merely in using https://magento2.ce/rest/V1/integration/admin/token as the endpoint URL in the case of REST, and using http://magento2.ce/index.php/soap/default?services=integrationCustomerTokenServiceV1.

Additionally, for a SOAP call, we are calling integrationAdminTokenServiceV1CreateAdminAccessToken on the
$request object.

In the case of successful authentication, for both the customer and admin API call, the response would be
a random-looking-32-characters-long string that we call token. This token is further saved to 
the oauth_token table in the DB, under the token column.

This might be a bit confusing with regard to what the oauth_token table has to do with token authentication.

If we think about it, token-based authentication can be looked at as a simplified version of OAuth, where the user
would authenticate using a username and PW and then give the obtained time-expiring token to some
third-party app to use it.

In case of failed auth, the server returns HTTP 401 Unauthorized, with a body containing a JSON message:

{"message":"Invalid login or password:"}

Notice how we are able to call the API method, though we are not already authenticated?
This means we must be calling an API defined by the anonymous type of resource. A quick look at 
the API endpoint gives us a hint to the location of its definition. Looking under the vendor/magento/module-integration/etc/webapi.xml file, we can see the following (truncated) XML:

<route url="/V1/integration/admin/token" method="POST">
	<service class="Magento\Integration\Api\AdminTokenServiceInterface" method="createAdminAccessToken"/>
	<resources>
		<resource ref="anonymous"/>
	</resources>
</route>

<route url="/V1/integration/customer/token" method="POST">
	<service class="Magento\Integration\Api\CustomerTokenServiceInterface" method="createCustomerAccessToken"/>
	<resources>
		<resource ref="anonymous"/>
	</resources>
</route>

We can clearly see how even token-based authentication itself is defined as API, using the 
anonymous resource so that everyone can access it. In a nutshell, token-based auth is a feature
of the Magento\Integration module.

Now that we have our auth token, we can start making other API calls. Remember, tokens simply
means we have been authenticated against a given username and PW. It does not mean we get full access
to all Web API methods. This further depends on wether our customer or user has the proper access role.

OAuth-based authentication is the most complex, yet most flexible one supported by Magento. Before we get
to use it, the merchant must register our external application as integration with the Magento instance.
Placing ourselves in the role of the merchant, we do so in the Magento admin area under
System | Extensions | Integrations. Clicking on the Add New Integration button opens the screen
as shown in the following SS:

The value External Book App is the freely given name of our external app. If we were connecting it with
Twitter, we could have easily put its name here. Next to Name, we have the Email, Callback URL, and Identity Link URL fields. The value of e-mail is not really that important.

The callback URL and identity link URL define the external app endpoint that recieves OAuth creds.
The values of these links point to external app that stands as the OAuth client. We will come back to it 
in a moment.

In the API tab under the Available APIs pane, we set Resource Access to the value of All or Custom.
If set to Custom, we can further fine-tune the resources in the Resources option we want to 
allow access to this integration as shown in the following SS:

//STUff

We should always give the minimal required resources to the external App we are using. This way,
we minimize possible security risks. The preceeding SS shows us defining only Sales, Products, Customer and
Marketing resources to the integration. This means that the API user would not be able to use content resources,
such as save or delete pages.

If we click the Save button now, we should be redirected back to the System | Extensions | Integrations screen as
shown in the following SS:

//Stuff

There are three things to focus our attention on here. First, we are seeing an Integration not secure
message. This is because when we defined our callback URL and identity link URL, we use HTTP and not HTTPS protocol. When doing real-world connections, for security reasons, we need to be sure to use HTTPS. Further, we notice how the Status column still says Inactive.

The Active link, to the right of the Status column, is the preceding steps before the two-legged OAuth handshake
starts. Only an Admin with access to integration listing in the backend can initiate this.

At this point, we need to pull the entire PHP code behind the External Book App OAuth client from here,
https://github.com/ajzele/B05032-BookAppOauthClient and place it into the root of our Magento installation
under the pub/external-book-app/ folder as shown in the SS:

//Stuff

The function of these files is to simulate our own mini-OAuth client. We will not go into much detail
about the content of these files. It is more important to look at it as an external OAuth client app.
The callback-url.php and identity-link-url.php files will execute when Magento triggers the callback and
identity link URL's as configed under the output image on the previous page.

Once the OAuth client file are in place, we go back to our integrations listing. Here, we click
on the Activate link. This opens a modal box, asking us to approve access to the API resources
as shown in the following SS:

//STUFF

Notice how API resources listed here match those few we set under the API tab when creating integration.
There are only two actions we can do here really: either click Cancel or Allow to start the two-legged OAuth handshake. Clicking the Allow button does two things in parallel.

First, it instantly posts the credentials to the endpoint (callback URL) specified when creating
the External Book App integration. The HTTP POST from Magento to the callback URL contains parameters
with values similar to the following:

Array(
	[oauth_consumer_key] => //stuff
	[oauth_consumer_secret] => //stuff
	[store_base_url] => http://magento2-merchant.loc/index.php/
	[oauth_verifier] => //stuff
)

Basically, a HTTP POST request is hitting the callback-url.php file whose content as follows:

session_id('BookAppOAuth');
session_start();

$_SESSION['oauth_consumer_key'] = $_POST['oauth_consumer_key'];
$_SESSION['oauth_consumer_secret'] = $_POST['oauth_consumer_secret'];
$_SESSION['store_base_url'] = $_POST['store_base_url'];
$_SESSION['oauth_verifier'] = $_POST['oauth_verifier'];

session_write_close();

header('HTTP/1.0 200 OK');

echo 'Response';

We can see that params passed by Magento are stored into an external
app session named BookAppOAuth. Later on, within the check-login.php file, these params will
be used to instansiate the BookAppOAuthClient, which will further be used to get a request token,
which is a pre-authorized token.

Parallel to Callback URL HTTP POST, we have a popup window opening as shown in the following SS:

//STUFF

The login form we see in the popup is just some dummy content we placed under the identity-link-url.php file.
Magento passes two values to this file via HTTP GET.
These are consumer_id and success_call_back. The consumer_id value is the ID of our integration
we created in the admin area.

It is up to the OAuth client app to decide if it wants to do anything with this value or not.
The success_call_back URL points to our Magento adminintegration/loginSuccessCallback path.

If we take a look at the code of the identity-link-url.php file, we can see form is set to do the POST action
on the URL like check-login.php?consumer_id={$consumerId}&callback_url={$callbackUrl}.

If we not click the Login button, the form will POST data to the check-login.php file passing it consumer_id and callback_url within the URL as GET parameters.

The content of check-login.php is defined as follows: //All of these are partial

require '../../vendor/autoload.php';

$consumer = $_REQUEST['consumer_id'];
$callback = $_REQUEST['callback_url'];

session_id('BookAppOAuth');
session_start();

$consumerKey = $_SESSION['oauth_consumer_key'];
$consumerSecret = $_SESSION['oauth_consumer_secret'];

$magentoBaseUrl = rtrim($_SESSION['store_base_url'], '/');
$oauthVerifier = $_SESSION['oauth_verifier'];

define('MAGENTO_BASE_URL', $magentoBaseUrl);

$credentials = new \OAuth\Common\Consumer\Credentials($consumerKey, $consumerSecret,
$magentoBaseUrl);

$oAuthClient = new BookAppOauthClient($credentials);

$requestToken = $oAuthClient->requestRequestToken();

$accessToken = $oAuthClient->requestAccessToken($requestToken->getRequestToken(), $oauthVerifier, 
$requestToken->getRequestTokenSecret()
);

header('Location: '. $callback);

To keep thing simple, we have no real user login check here. We might have added
one above the OAuth-related calls, and then authenticate the user against some username and
password before allowing it to use OAuth. However, for simplicitys sake, we omitted this part
from our sample OAuth client app.

Within the check-login.php file, we can see that based on the previously stored session params
we perform the following:

Instansiate the \OAuth\Common\Consumer\Credentials object passing it the oauth_consumer_key,
oauth_consumer_secret, store_base_url stored in the session

Instansiate the BookAppOauthClient object passing its constructor the entire credentials object

Use the OauthClient object to get the request token

Use the request token to get a long-lived access token

If everything executes successfully, the popup window closes and we get redirected back to the integrations
listing. The difference now is that looking at the grid, we have an Active status and next to it
we have a Reauthorize link.

What we are really after at this point are Access Token and Access Token Secret. We can see those
if we edit the External Book App integration. These values should now be present on the Integration 
Details tab.

Access Token is the key to all of our further API calls, and with it we successfully finish our
auth bits of OAuth-based authentication.

Once we have obtained OAuth access token, from the preceeding steps, we can start making
Web API calls to other methods. Even though the Web API coverage is the same for both
REST and SOAP, there is a significant difference when making method calls.

For the purpose of giving a more robust example, we will be targeting the customer group save method,
(partially) defined in the vendor/magento/module-customer/etc/webapi.xml as follows:

<route url="/V1/customerGroups" method="POST">
	<service class="Magento\Customer\Api\GroupRepositoryInterface" method="save"/>
	<resources>
		<resource ref="Magento_Customer::group"/>
	</resources>
</route>

To use the access token to make Web API calls, like POST /V1/customerGroups, we need to include
these request parameters in the authorization request header in the call:

oauth_consumer_key, available from the Magento admin area, under the integration edit screen.

oauth_nonce, random value, uniquely generated by the application for each request

oauth_signature_method, name of the signature method used to sign the request.
Valid values are: HMAC-SHA1-RSA-SHA1, and PLAINTEXT.

Even though the Outh protocol supports PLAINTEXT, Magento does not. We will be using HMAC-SHA1

oauth_timestamp, integer value. Unix-like timestmap.

oauth_token, available from the Magento admin area, under the integration edit screen.

oauth_version, Magento supports Oauth 1.0a, thus we use 1.0

oauth_signature, generated signature value, omitted from the signature generation process.

To generate an OAuth 1.0a HMAC-SHA1 signature or a HTTP request takes focused effort,
if done manually.

We need to determine the HTTP method and URL of the request, which equals to POST
http://magento2-merchant.loc/rest/V1/customerGroups. It is important to use
the correct protocol here, so make sure that the https:// or http:// portion of the URL
matches the actual request sent to the API.

We then gather all of the parameters included in the request. There are two such locations
for these additional params: the URL (as part of the query string) and the request body.

In the HTTP request, the params are URL encoded, but we need to collect the raw values.
In addition to the request parameters, every oauth_* param needs to be included
in the signature, except the oauth_signature itself.

The params are normalized into a single string as follows:

Params are sorted by name, using lexicographical byte value ordering. If two or more
params share the same name, they are sorted by their value. 

Params are concatenated in their sorted order into a single string.
For each param, the name is seperated from the corresponding value by an = character (ASCII code 61),
even if the value is empty. Each name-value pair is seperated by an & char (ASCII code 38).

Further, we define the signing key as a value of {Consumer Key}+{&}+{Access Token Secret}.

Once we apply the string normalization rules to params and determine the signing key,
we call hash_hmac('sha1', $data, {Signing Key}, true) to get the final oauth_signature value.

This should get us the oauth_signature as a random 28-chars long string.

Understanding how to generate the signature string is important, but getting it right every
time is tedious and time consuming. We can help ourselves by instansiating the objects
of the built-in \OAuth\Common\Consumer\Credentials and \OAuth\OAuth1\Signature\Signature classes,
as partially shown:

$credentials = new \OAuth\Common\Consumer\Credentials($consumerKey, $consumerSecret, $magentoBaseUrl);
$signature = new \OAuth\OAuth1\Signature\Signature($credentials);

$signature->setTokenSecret($accessTokenSecret);
$signature->setHashingAlgorithm('HMAC-SHA1');

echo $signature->getSignature($uri, array('oauth_consumer_key' => $consumerKey,
	'oauth_nonce' => 'per-request-unique-token',
	'oauth_signature_method' => 'HMAC-SHA1',
	'oauth_timestamp' => '1437319569',
	'oauth_token' => $accessToken,
	'oauth_version' => '1.0',
), 'POST');

Now that we have the oauth_signature value, we are ready to do our console curl REST example. It comes down
to running the following on a console:

curl -X POST http://magento2.ce/rest/V1/customerGroups -H 'Content-Type: application/json'
	-H 'Authorization: OAuth oauth_consumer_key="<stuff>",
	oauth_nonce="per-request-token-by-app-1",
	oauth_signature_method="HMAC-SHA1",
	oauth_timestamp="143719569",
	oauth_token="<stuff>",
	oauth_version="1.0",
	oauth_signature="<stuff>"'

	-d '{"group": {"code": "The Book Writer", "tax_class_id": "3"}}'

Note that the previous command is merely visually broken into new lines. It should all be
a single line on a console. Once executed, the API call will create a new customer group
called The Book Writer. A logical question one might ask looking at the curl
command is how come we did not normalize the POST data passed as JSON via the -d flag switch.

This is because the parameters in the HTTP POST request body are only taken into consideration
for signature generation if content-type is application/x-www-form-urlencoded.

The console cURL SOAP requests do not require usage of the OAuth signature. We can execute a 
SOAP request passing Authorization: Bearer { Access Token value } into the request header,
like shown in the following example:

curl -x POST http://magento2.ce/index.php/soap/default?services=customerGroupRepositoryV1 -H 'Content-Type:
application/soap+xml; charset=utf-8; action="customerGroupRepositoryV1Save"' -H 'Authorization: Bearer
<some value>' -d @request.xml

Where request.xml is as follows:

<?xml version="1.0" encoding="UTF-8"?>
<env:Envelope xmlns:env="http://www.w3.org/2003/05/soap_envelope"
xmlns:nsl="http://magento2.ce/index.php/soap/default?services=customerGroupRepositoryV1">
	<env:Body>
	<ns1:customerGroupRepositoryV1SaveRequest>
				<group>
					<code>The Book Writer</code>
					<taxClassId>3</taxClassId>
				</group>
	</ns1:customerGroupRepositoryV1SaveRequest>
	</env:Body>
</env:Envelope>

NOTE: MIght be someerror in terms of indention

The following code example demonstrates the PHP cURL SOAP-like request for the
customer group save method call:

$request = new SoapClient('http://magento2.ce/index.php/soap/?wsdl&services=customerGroupRepositoryV1',
	array(
		'soap_version' => SOAP_1_2,
		'stream_context' => =>
stream_context_create(array(
			'http' => array(
				'header' => 'Authorization: Bearer <something>')
			)
		)
	)
);

$response = $request->customerGroupRepositoryV1Save(array
(
	'group' => array(
		'code' => 'The Book Writer',
		'taxClassId' => 3
	)
));

Notice how the method name customerGroupRepositoryV1Save actually comprises
service name customerGroupRepositoryV1, plus the Save name of the actual method
within the Service.

We can get a list of all services defined by opening a URL like 
http://magento2.ce/soap/default?wsdl_list in the browser (Depending on Magento installation)

Session-based authentication is the third and most simple type of authentication in Magento.
We do not have any complexities of token-passing here. As the customer, we log in to the
Magento storefront with our customer credentials. As an admin, we log in to the 
Magento admin with our admin credentials. 

Magento uses a cookie named PHPSESSID to track the session where our login state is stored.
The Web API framework uses our logged-in session information to verify our identity
and authorize access to the requested resource.

Customers can access resources that are configured with anonymous or self-permission in the webapi.xml
config file, like GET /rest/V1/customers/me.

If we try to open the http://magento2.ce/rest/V1/customers/me URL while in the browser, but not logged
in as the customer, we would get a response as follows:

<response>
	<message>Consumer is not a authorized to access %resources</message>
	<parameters>
		<resources>self</resources>
	</parameters>
</response>

If we log in as a customer and then try to open that same URL, we would get a response as follows:

<response>
	<id>2</id>
	<group_id>1</group_id>
	<created_at>2015-11-22 14:15:33</created_at>
	<created_in>Default Store View</created_in>
	<email>john@change.me</email>
	<firstname>John</firstname>
	<lastname>Doe</lastname>
	<store_id>1</store_id>
	<website_id>1</website_id>
	<adresses/>
	<disable_auto_group_change>0</disable_auto_group_change>
</response>

Admin users can access resources that are assigned to their Magento admin profile.

Magento comes with a solid number of API methods that we can call. However, sometimes
this is not enough, as our business needs dictate additional logic, and we need to be able to
add our own methods to the Web API.

The best part of creating our own API's is that we do not have to be concerned about making them
REST or SOAP. Magento abstracts this so that our API methods are automatically available for 
REST or SOAP calls.

Adding new API's conceptually evolves around two things: defining business logic through various classes,
and exposing it via the webapi.xml file. However, as we will soon see, there is a lot of boilerplate to it.

Let's create a miniature module called Foggyline_Slider, on which we will demonstrate create (POST), update (PUT),
delete (DELETE) and list (GET) method calls.

Create a module registration file, app/code/Foggyline/Slider/registration.php, with content (partial)
as follows:

\Magento\Framework\Component\ComponentRegistrar::register(\Magento\Framework\Component\ComponentRegistrar::MODULE,
	'Foggyline_Slider',
	__DIR__
);

Create a module config file, app/code/Foggyline/Slider/etc/module.xml with content as follows:

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:Module /etc/module.xsd">
	<module name="Foggyline_Slider" setup_version="1.0.0"/>
</config>

Create an install script where our future models will persist module data. We do so by creating
the app/code/Foggyline/Slider/Setup/InstallSchema.php file with content as follows:

namespace Foggyline\Slider\Setup;

use Magento\Framework\Setup\InstallSchemaInterface;
use Magento\Framework\Setup\ModuleContextInterface;
use Magento\Framework\Setup\SchemaSetupInterface;

class InstallSchema implements InstallSchemaInterface
{
	public function install(SchemaSetupInterface $setup, ModuleContextInterface $context)
	{
		$installer = $setup;
		$installer->startSetup();

		/** Create table 'foggyline_slider_slide' */

		$table = $installer->getConnection()->newTable($installer->getTable('foggyline_slider_slide'))
			->addColumn(
				'slide_id',
				\Magento\Framework\DB\Ddl\Table::TYPE_INTEGER,
				null,
				['identity' => true,
'unsigned' => true, 'nullable' => false,
'primary' => true],
				'Slide Id'
			)
			->addColumn(
				'title',
				\Magento\Framework\DB\Ddl\Table::TYPE_TEXT,
				200,
				[],
				'Title'
		)
		->setComment('Foggyline Slider Slide');

$installer->getConnection()->createTable($table);
		...
		$installer->endSetup();


	}
}

Now we specify our ACL for our resources. Our resources are going to be CRUD
actions we do on our module entities. We will structure our module in a way that slide
and image are separate entities, where one slide can have mutliple image entities linked to it.

Thus, we would like to be able to control access to save and delete actions separately for each
entity. We do so by defining the app/code/Foggyline/Slider/etc/acl.xml file as follows:

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:noNamespaceSchemaLocation="urn:magento:framework:Acl/etc/acl.xsd">
	<acl>
		<resources>
			<resource id="Magento_Backend::admin">
				<resource id="Magento_Backend::content">
					<resource id="Magento_Backend::content_elements">
						<resource id="Foggyline_Slider::slider" title="Slider" sortOrder="10">
							<resource id="Foggyline_Slider::slide" title="Slider Slide" sortOrder="10">
								<resource id="Foggyline_Slider::slide_save" title="Save Slide" sortOrder="10" />
								<resource id="Foggyline_Slider"::slide_delete" title="Delete Slide" sortOrder="20" />
							</resource>
							<resource id="Foggyline_Slider::image" title="Slider Image" sortOrder="10">
								<resource id="Foggyline_Slider::image_save" title="Save Image" sortOrder="10" />
								<resource id="Foggyline_Slider::image_delete" title="Delete Image" sortOrder="20" />
							</resource>
						</resource>
					</resource>
				</resource>
			</resource>
		</resource>
	</acl>
</config>

As we can see, the XML is driven in a hierarchy matter akin to HTML with accessing of classes and functions, to which
they have sort orders and they have titles, ids, identifiers etc.

Generally, all xmlns is defined to be what kind of a instance of something iti s (XMLSchema etc.)
and it then also checks for the location in the xsi, to which it refers to either being a no namespace schema location, or it refers to a namespace one by virtue of dir pathing

Now that the ACL has been set, we define our Web API resources within the app/code/Foggyline/Slider/etc/webapi.xml (partial) as follows:

<routes xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:noNamespaceSchemaLocation=
"urn:magento:module:Magento_Webapi:etc/webapi.xsd">
	<route url="/V1/foggylineSliderSlide/:slideId" method="GET">
		<service class="Foggyline\Slider\Api\
			<resources>
				<resource
		ref="Foggyline_Slider::slide" />
			</resources>
		</route>
		//NOTE: Error due to unclosed service enclosure???
		<route url="/V1/foggylineSliderSlide/search" method="GET">
			<service class="Foggyline\Slider\Api\SlideRepositoryInterface" method="getList" />
			<resources>
				<resource ref="anonymous" />
			</resources>
		</route>
		<route url="/V1/foggylineSliderSlide" method="POST">
			<service class="Foggyline\Slider\Api\SlideRepositoryInterface" method="save" />
			<resources>
				<resource
		ref="Foggyline_Slider::slide_save" />
			</resources>
		</route>
		<route url="/V1/foggylineSliderSlide/:id" method="PUT">
			<service class="Foggyline\Slider\Api\SlideRepositoryInterface" method="save" />
			<resources>
				<resource
		ref="Foggyline_Slider::slide_save" />
			</resources>
		</route>
		<route url="/V1/foggylineSliderSlide/:slideId" method="DELETE">
			<service class="Foggyline\Slider\Api\SlideRepositoryInterface" method="deleteById"/>
			<resources>
				<resource ref="Foggyline_Slider::slide_delete" />
			</resources>
		</route>
		<route url="/V1/foggylineSliderImage/:imageId" method="GET">
			<service class="Foggyline\Slider\Api\ImageRepositoryInterface" method="getById" />
			<resources>
				<resource />
			</resources>
		</route>
		<route url="/V1/foggylineSliderImage/search" method="GET">
			<service class="Foggyline\Slider\Api\ImageRepositoryInterface" method="getList" />
			<resources>
				<resource
		ref="Foggyline_Slider::image" />
			</resources>
		</route>
		<route url="/V1/foggylineSliderImage" method="POST">
			<service class="Foggyline\Slider\Api\ImageRepositoryInterface" method="save" />
			<resources>
				<resource
		ref="Foggyline_Slider::image_save" />
			</resources>
		</route>
		<route url="/V1/foggylineSliderImage/:id" method="PUT">
			<service class="Foggyline\Slider\Api\ImageRepositoryInterface" method="save" />
				<resources>
					<resource
		ref="Foggyline_Slider::image_save" />
				</resources>
			</route>
			<route url="/V1/foggylineSliderImage/:imageId" method="DELETE">
				<service class="Foggyline\Slider\Api\ImageRepositoryInterface" method="deleteById" />
				<resources>
					<resource
		ref="Foggyline_Slider::image_delete" />
				</resources>
			</route>
		</routes>

//NOTE: THe above structure is a bit wonky due to inconsistency on level of the book, but generally the 
structure is the same.

Notice how each of those service class attributes point to the interface, not the class.
This is the way we should build our exposable services, always having an interface definition
behind them. As we will soon see, using di.xml, this does not mean Magento will try
to create object from these interfaces directly.

In the /etc/di.xml, partially:

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:noNamespaceSchemaLocation="urn:magento:framework:ObjectManager/etc/config.xsd">

	<preference for="Foggyline\Slider\Api\Data\SlideInterface"
	type="Foggyline\Slider\Model\Slide"/>

	<preference for="Foggyline\Slider\Api\SlideRepositoryInterface" type="Foggyline\Slider\Model\SlideRepository"/>
	...
</config>

What is happening here is that we are telling Magento something like, "hey, whenever you need to
pass around an instance that conforms to the Foggyline\Slider\Api\Data\SlideInterface interface,
preferably use the Foggyline\Slider\Model\Slide class for it."

At this point, we still do not have any of those interfaces or model classes created. 
When creating APIs, we should first start by defining interfaces, and then our models
should extend from those interfaces.

Interface Foggyline\Slider\Api\Data\SliderInterface is defined within the app/code/Foggyline/Slider/Api/Data/SliderInterface.php as follows:

namespace Foggyline\Slider\Api\Data;

/**
* @api
*/

interface SlideInterface
{
	const PROPERTY_ID = 'slide_id';
	const PROPERTY_SLIDE_ID = 'slide_id';
	const PROPERTY_TITLE = 'title';

	/**
	* Get Slide entity 'slide_id' property value
	* @return int|null
	*/

	public function getId();

	/**
	* Set Slide entity 'slide_id' property value
	* @param int $id
	* @return $this
	*/
	public function setId($id);

	/**
	* Get Slide entity 'slide_id' property value
	* @return int|null
	*/
	public function getSlideId();

	/**
	* Set Slide entity 'slide_id' property value
	* @param int $slideId
	* @return $this
	*/
	public function setSlideId($slideId);

	/**
	* Get Slide entity 'title' property value
	* @return string|null
	*/
	public function getTitle();
	
	/**
	* Set Slide entity 'title' property value
	* @param string $title
	* @return $this
	*/

	public function setTitle($title);
}

We are going for ultimate simplification here. Our Slide entity only really has
ID and title values. The id and slide_id point to the same field in the DB and the
implementation of their getters and setters should yield the same result.

Although API/Data/*.php interfaces become blueprint requirements
for our data models, we also have Api/*RepositoryInterface.php files. The idea here is to
extract create, update, delete and search and similar data-handling logic away
from the data model class into its own class.

This way, our model classes become more pure data and business logic classes while the rest
of persistence and search-related logic moves into these repo classes.

Our Slide Repository Interface is defined within the 
app/code/Foggyline/Slider/Api/SliderRepositoryInterface.php file as follows:

namespace Foggyline\Slider\Api;

/**
* @api
*/

interface SlideRepositoryInterface
{
	/**
	* Retrieve slide entry.
	* @param int $slideId
	* @return  \Foggyline\Slider\Api\Data\SlideInterface
	* @throws \Magento\Framework\Exception\NoSuchEntityException If slide with the 
	specified id does not exist. 
	* @throws \Magento\Framework\Exception\LocalizedException

		*/
		public function getById($slideId);

		/**
		* Save slide
		* @param \Foggyline\Slide\Api\Data\SlideInterface $slide
		* @return \Foggyline\Slider\Api\Data\SlideInterface
		* @throws \Magento\Framework\Exception\LocalizedException
		*/

		public function save(\Foggyline\Slider\Api\Data\SlideInterface $slide);

		/**
		* Retrieve slides matching the specified criteria.
		* @param \Magento\Framework\Api\SearchCriteriaInterface $searchCriteria
		* @return \Magento\Framework\Api\SearchResultsInterface
		* @throws \Magento\Framework\Exception\LocalizedException
		*/

		public function getList(\Magento\Framework\Api\SearchCriteriaInterface $searchCriteria);

		/**
		* Delete slide by ID.
		* @param int $slideId
		* @return bool true on success
		* @throws \Magento\Framework\Exception\LocalizedException
		*/

		public function deleteById($slideId);
}

With interfaces in place, we can move on to model class. In order to persist and fetch
data in a DB, our Slide entity really needs three files under the Model dir.
These are called data model, resource class and collection class.

The data model class is defined under the app/code/Foggyline/Slider/Model/Slide.php as follows:

namespace Foggyline\Slider\Model;

class Slide extends \Magento\Framework\Model\AbstractModel implements \Foggyline\Slider\Api\Data\SlideInterface{
	/** 
	* Initialize Foggyline Slide Model
	*
	* @return void
	*/
	protected function _construct()
	{
		/* _init($resourceModel) */
		$this->_init('Foggyline\Slider\Model\ResourceModel\Slide');
	}

	/**
	* Get Slide entity 'slide_id' property value
	*
	* @api
	* @return int|null
	*/

	public function getId()	
	{
		return $this->getData(self::PROPERTY_ID);
	}

	/**
	* Set Slide entity 'slide_id' property value
	*
	* @api
	* @param int $id
	* @return $this
	*/
	public function setId($id)
	{
		$this->setData(self::PROPERTY_ID, $id);
		return $this;
	}

	/**
	* Get Slide entity 'slide_id' properety value
	*
	* @api
	* @return int|null
	*/
	public function getSlideId()
	{
		return $this->getData(self::PROPERTY_SLIDE_ID);
	}

	/**
	* Set Slide entity 'slide_id' property value
	*
	* @api
	* @param int $slideId
	* @return $this
	*/

	public function setSlideId($slideId)
	{
		$this->setData(self::PROPERTY_SLIDE_ID, $slideId);
		return $this;
	}

	/**
	* Get Slide entity 'title' property value 
	*
	* @api
	* @return string|null
	*/

	public function getTitle(){
		return
$this->getData(self::PROPERTY_TITLE);
	}

	/**
	* Set Slide entity 'title' property value
	*
	* @api
	* @param string $title
	* @return $this
	*/

	public function setTittle($title)
	{
		$this->setData(self::PROPERTY_TITLE,
		$title);
	}
}

Following the model data class is the model resource class, defined in the app/code/Foggyline/Slider/Model/ResourceModel/Slide.php file:

namespace Foggyline\Slider\Model\ResourceModel;

/**
* Foggyline Slide resource
*/

class Slide extends \Magento\Framework\Model\ResourceModel\Db\AbstractDb
{
	/**
	* Define main table
	*
	* @return void
	*/
	protected function _construct()
	{
		/* _init($mainTable, $idFieldName) */

	$this->_init('foggyline_slider_slide', 'slide_id');
	}
}

Finally, the third bit, is the model collection class, defined in the 
app/code/Foggyline/Slider/Model/ResourceModel/Slide/Collection.php file as follows:

namespace Foggyline\Slider\Model\ResourceModel\Slide;

/**
* Foggyline slides collection
*/
class Collection extends \Magento\Framework\Model\ResourceModel\Db\Collection\AbstractCollection
{
	/**
	* Define resource model and model 
	*
	* @return void
	*/
	protected function _construct()
	{
		/* _init($model, $resourceModel) */
		$this->_init('Foggyline\Slider\Model\Slide', 'Foggyline\Slider\Model\ResourceModel\Slide');
	}
}

If we were to manually instansiate the model data class now,
we would be able to persist the data in the DB. To complete the
di.xml requirements, we still lack one more final ingridient - the Model/SlideRepository class file.

Let us go and create the app/code/Foggyline/Slider/Model/SlideRepository.php file with
content as follows:

namespace Foggyline\Slider\Model;

use Magento\Framework\Api\DataObjectHelper;
use Magento\Framework\Api\SearchCriteriaInterface;
use Magento\Framework\Exception\CouldNotDeleteException;
use Magento\Framework\Exception\CouldNotSaveException;
use Magento\Framework\Exception\NoSuchEntityException;
use Magento\Framework\Reflection\DataObjectProcessor;

class SlideRepository implements \Foggyline\Slider\Api\SlideRepositoryInterface
{
	/**
	* @var \Foggyline\Slider\Model\ResourceModel\Slide
	*/

	protected $resource;

	/**
	* @var \Foggyline\Slider\Model\SlideFactory
	*/

	protected $slideFactory;

	/**
	* @var \Foggyline\Slider\Model\ResourceModel\Slide\CollectionFactory
	*/
	protected $slideCollectionFactory;

	/**
	* @var \Magento\Framework\Api\SearchResultsInterface
	*/

	protected $searchResultsFactory;

	/**
	* @var \Magento\Framework\Api\DataObjectHelper
	*/
	protected $dataObjectHelper;

	/**
	* @var \Magento\Framework\Reflection\DataObjectProcessor
	*/

	protected $dataObjectProcessor;

	/**
	* @var \Foggyline\Slider\Api\Data\SlideInterfaceFactory
	*/

	protected $dataSlideFactory;

	/**
	* @param ResourceModel\Slide $resource
	* @param SlideFactory $slideFactory
	* @param ResourceModel\Slide\CollectionFactory $slideCollectionFactory
	* @param \Magento\Framework\Api\SearchResultsInterface $searchResultsFactory
	* @param DataObjectHelper $dataObjectHelper
	* @param DataObjectProcessor $dataObjectProcessor
	* @param \Foggyline\Slider\Api\Data\SlideInterfaceFactory $dataSlideFactory

	public function __construct(
		\Foggyline\Slider\Model\ResourceModel\Slide $resource,
		\Foggyline\Slider\Model\SlideFactory $slideFactory,
		\Foggyline\Slider\Model\ResourceModel\Slide\CollectionFactory $slideCollectionFactory,
		\Magento\Framework\Api\SearchResultsInterface $searchResultsFactory,
		\Magento\Framework\Api\DataObjectHelper $dataObjectHelper,
		\Magento\Framework\Reflection\DataObjectProcessor $dataObjectProcessor,
		\Foggyline\Slider\Api\Data\SlideInterfaceFactory $dataSlideFactory
	)
	{
		$this->resource = $resource;
		$this->slideFactory = $slideFactory;
		$this->slideCollectionFactory = $slideCollectionFactory;
		$this->searchResultsFactory = $searchResultsFactory;
		$this->dataObjectHelper = $dataObjectHelper;
		$this->dataObjectProcessor = $dataObjectProcessor;
		$this->dataSlideFactory = $dataSlideFactory;
	}
	...
}

It might appear that there is a lot going on here, but really,
we are just passing on some class and interface names to the constructor
in order to instansiate the objects we will use across individual service
methods defined in the webapi.xml file.

The first service method on our list is getById, defined within SlideRepository.php as follows:

/**
* Retrieve slide entity
*
* @api
* @param int $slideId
* @return \Foggyline\Slider\Api\Data\SlideInterface
* @throws \Magento\Framework\Exception\LocalizedException
*/
public function getById($slideId)
{
	$slide = $this->slideFactory->create();
	$this->resource->load($slide, $slideId);
	if (!$slide->getId()) {
		throw new NoSuchEntityException(__('Slide with id %1 does not exist.', $slideId))<
	}
	return $slide;
}

Then we have the save method, defined within SlideRepository.php as follows:

/**
* Save slide.
*
* @param \Foggyline\Slider\Api\Data\SlideInterface $slide
* @return \Foggyline\Slider\Api\Data\SlideInterface
* @throws \Magento\Framework\Exception\LocalizedException
*/
public function save(\Foggyline\Slider\Api\Data\SlideInterface $slide)
{
	try {
		$this->resource->save($slide);
	} catch (\Exception $exception) {
		throw new CouldNotSaveException(__($exception->getMessage()));
	}
	return $slide;
}

The save method addresses both POST and PUT requests 
defined in webapi.xml, thus effectively handling the creation
of new slides or update of existing ones.

Going further, we have the getList method, defined within SlideRepository.php as follows:

/**
* Retrieve slides matching the specified criteria.
*
* @param \Magento\Framework\Api\SearchCriteriaInterface $searchCriteria
* @return \Magento\Framework\Api\SearchResultsInterface
* @throws \Magento\Framework\Exception\LocalizedException
*/
public function getList(\Magento\Framework\Api\SearchCriteriaInterface $searchCriteria)
{
	$this->searchResultsFactory->setSearchCriteria($searchCriteria);

	$collection = $this->slideCollectionFactory->create();

	foreach
	($searchCriteria->getFilterGroups() as $filterGroup){
		foreach($filterGroup->getFilters() as $filter) {
			$condition = $filter->getConditionType() ?: 'eq';

			$collection->addFieldToFilter($filter->getField(), [$condition => $filter->getValue()]);
		}
	}

	$this->searchResultsFactory->setTotalCount($collection->getSize());
	$sortOrders = $searchCriteria->getSortOrders();
	if($sortOrders) {
		foreach($sortOrders as $sortOrder) {
			$collection->addOrder($sortOrder->getField(),
(strtoupper($sortOrder->getDirection()) === 'ASC') ? 'ASC' : 'DESC'
		);
		}
	}

$collection->setCurPage($searchCriteria->getCurrentPage());

$collection->setPageSize($searchCriteria->getPageSize());
	$slides = [];
	/** @var \Foggyline\Slider\Model\Slide $slideModel */
	foreach ($collection as $slideModel){
		$slideData = $this->dataSlideFactory->create();
		$this->dataObjectHelper->populateWithArray(
			$slideData,
			$slideModel->getData(),
			'\Foggyline\Slider\Api\Data\SlideInterface');
		$slides[] = $this->dataObjectProcessor->buildOutputDataArray(
			$slideData,
			'\Foggyline\Slider\Api\Data\SlideInterface'
			);
	}

	$this->searchResultsFactory->setItems($slide);
	return $this->searchResultsFactory;
}

Finally, we have the deleteById method, defined within SlideRepository.php as follows:

/**
* Delete Slide
*
* @param \Foggyline\Slider\Api\Data\SlideInteface $slide
* @return bool
* @throws CouldNotDeleteException
*/
public function delete(\Foggyline\Slider\Api\Data\SlideInterface $slide)
{
	try {
		$this->resource->delete($slide);
	} catch (\Exception $exception) {
		throw new CouldNotDeleteException(__($exception->getMessage()));
	}
	return true;
}

/**
* Delete slide by an ID.
*
* @param int $slideId
* @return bool true on success
* @throws \Magento\Framework\Exception\NoSuchEntityException
* @throws \Magento\Framework\Exception\LocalizedException
*/
public function deleteById($slideId)
{
	return $this->delete($this->getById($slideId));
}

Keep in mind that we have only covered the Slide entity
in the preceeding partial example,w hich is enough to preceed with other API call examples.

Since all of our defined API's are resource protected, we first need to
authenticate as the admin user, assuming the admin user has access to all our custom
resources that encompass the ones we defined. For simplicity sake, we will use the token-based
auth method, examples of which are given previously in the chapter. Once authenticated,
we should have a 32 random chars long token.

Once the token has been obtained, we will test the following API calls using console
cURL, PHP cURL, PHP SoapClient, and console SOAP style cURL examples.

GET /V1/foggylineSliderSlide/:slideId, calls the getById service method, requires
the Foggyline_Slider::slide resource

GET /V1/foggylineSliderSlide/search, calls the getList service method, requires the
Foggyline_Slider::slide resource

POST /V1/foggylineSliderSlide, calls the save service method, requires the Foggyline_Slider::slide_save resource

PUT /V1/foggylineSliderSlide/:id, calls the save service method, requires the Foggyline_Slider::slive_save resource

DELETE /V1/foggylineSliderSlide/:slideId, calls the deleteById service method, requires the
Foggyline_Slider::slide_delete resource

The console cURL style for executing GET /V1/foggylineSliderSlide/:slideId is done as follows:

curl -X GET -H 'Content-type: application/json' \ -H 'Authorization: Bearer <token>' \
http://magento2.ce/rest/V1/foggylineSliderSlide/1

The PHP cURL style for executing GET /V1/foggylineSliderSlide/:slideId is done as follows:

$ch = curl_init('http://magento2.ce/rest/V1/foggylineSliderSlide/1');
curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'GET');
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
curl_setopt($ch, CURLOPT_HTTPHEADER, array('Content-Type: application/json',
	'Authorization: Bearer <token>'));

$result = curl_exec($ch);

The response for console and PHP cURL style should be a JSON string similar
to the following one:

{"slide_id":1, "title":"Awesome stuff #1"}

The PHP SoapClient style for executing GET /V1/foggylineSliderSlide/:slideId is done as follows:

$request = new SoapClient('http://magento2.ce/index.php/soap/?wsdl&services=foggylineSliderSlideRepositoryV1',
	array('soap_version' => SOAP_1_2, 'stream_context' => stream_context_create(array('http' => array(
		'header' => 'Authorization: Bearer <token>'))
		)
	)
);

$response = $request->foggylineSliderSlideRepositoryV1GetById(array('slideId'=>1));

The response for PHP SoapClient style should be the stdClass PHP obj as follows:

object(stdClass) #2 (1) {
	["result"] => object(stdClass) #3 (2) {
		["slideId"] => int(1)
		["title"] => string(16) "Awesome stuff #1"
	}
}

The console SOAP style cUrl for executing GET /V1/foggylineSliderSlide/:slideId is done as follows:

curl -X POST -H 'Content-Type: application/soap+xml;
	charset=urf-8;
	action="foggylineSliderSlideRepositoryV1GetById"'
	-H 'Authorization: Bearer <token>' -d @request.xml\ http://magento2.ce/index.php
	/soap/default?services=foggylineSliderSlideRepositoryV1

Where request.xml is as follows:

<?xml version="1.0" encoding="UTF-8"?>
<env:Envelope xmlns:env="http://www.w3.org/2003/05/soap-envelope"
xmlns:ns1="http://magento2.ce/index.php/soap/default?services=\
foggylineSliderSlideRepositoryV1">
	<env:Body>

<ns1:foggylineSliderSlideRepositoryV1GetByIdRequest>
		//Since the ns1 is based on normal indention
		//we are practically 2 steps into indention
			<slideId>1</slideId>
		</ns1:foggylineSliderSlideRepositoryV1GetByIdRequest>
	</env:Body>
</env:Envelope>

Notice how we did not really do a GET, rather a POST type of request.
Also, the URL to which we are pointing our POST is not really the same as
with previous requests. This is because Magento SOAP requests are always
POST (or PUT) type, as the data is submitted in a XML format. 

XML format in return specifies the service, and the request header action
specifies the method to be called on the service.

The response for console SOAP style cURL should be an XML as follows:

<?xml version="1.0" encoding="UTF-8"?>
<env:Envelope xmlns:env="http://www.w3.org/2003/05/soap-envelope"
xmlns:ns1="http://magento2.ce/index.php/soap/default?
services=foggylineSliderSlideRepositoryV1">
	<env:Body>
		<ns1:foggylineSliderSlideRepositoryV1GetByIdResponse>
			<result>
				<slideId>1</slideId>
				<title>Awesome stuff #1</title>
			</result>
		</ns1:foggylineSliderSlideRepositoryV1GetByIdResponse>
	</env:body>
</env:Envelope>

The console cURL style for executing GET/V1/foggylineSliderSlide/search is done as follows:

curl -X GET -H 'Content-type: application/json' \
-H 'Authorization: Bearer <token>' \
"http://magento2.ce/rest/V1/foggylineSliderSlide/search?search_criteria%5Bfilter_groups
//In reality, a lot of repetition of the % comparators follows here, but they are so many
//that i will not write them here, as it is just repetition ad infinitum"

The PHP cURL style for executing GET/V1/foggylineSliderSlide/search is done as follows:

$searchCriteriaJSON = '{
	"search_criteria": {
		"filter_groups": [
			{
				"filters": [
					{
						"field": "title",
						"value": "%some%",
						"condition_type": "like"
					}
				]
			}
		],
		"current_page": 1,
		"page_size": 10,
		"sort_orders": [
			{
				"field": "slide_id",
				"direction": "ASC"
			}
		]
	}
}';

$searchCriteriaQueryString = 
http_build_query(json_decode($searchCriteriaJSON));

$ch = curl_init('http://magento2.ce/rest/V1/foggylineSliderSlide/search?' .
$searchCriteriaQueryString);

curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'GET');
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
curl_setopt($ch, CURLOPT_HTTPHEADER, array(
	'Content-Type: application/json',
	'Authorization: Bearer <token>'
));

$result = curl_exec($ch);

The response for console and PHP cURL style should be a JSON string
similar to the following one:

{"items":[{"slide_id":2,"title":"Just some other slider"}, {"slide_id":1, "title": "Awesome
Stuff #1"}], "search_criteria": {"filter_groups": [{"filters": [{"field":"title", "value":"%some%",
"condition_type":"like"}]}], "sort_orders": [{"field":"slide_id", "direction":"-1"}],
"page_size":10,"current_page":1}, "total_count:2"}

The PHP SoapClient style for executing GET /V1/foggylineSlidersSlide/search is done as follows:

$searchCriteria = [
	'searchCriteria' =>
		[
			'filterGroups' =>
				[
					[
						'filters' =>
							[
								[
									'field' => 'title',
									'value' => '%some%',
									'condition_type' => 'like',
								],
							],
					],
				],
			'currentPage' => 1,
			'pageSize' => 10,
			'sort_orders' => 
				[
					[
						'field' => 'slide_id',
						'direction' => 'ASC',
					],
				],
		],
];

$request = new SoapClient('http://magento2.ce/index.php/soap/?wsdl&services=
foggylineSliderSlideRepositoryV1',
	array(
		'soap_version' => SOAP_1_2,
		'trace'=>1,
		'stream_context' => stream_context_create(array('http' => array( 'header' => 'Authorization: Bearer <token>')
			)
		)
	)	
);

$response => $request->foggylineSliderSlideRepositoryV1GetList($searchCriteria);

The response for PHP SoapClient style should be the stdClass PHP object as follows:

object(stdClass)#2 (1) {
	["result"]=>object(stdClass)#3 (3) {
		["items"]=>
		object(stdClass)#4 (0) {
		}
		["searchCriteria"]=>object(stdClass)#5 (3) {
			["filterGroups"]=>object(stdClass)#6 (1) {
				["item"]=>object(stdClass)#7 (1) {
					["filters"]=>object(stdClass)#8 (1) {
						object(stdClass)#9 (2) {
							["field"]=>string(5) "title"
							["value"]=>string(6) "%some%"
						}
					}
				}
			}
			["pageSize"]=>int(10)
			["currentPage"]=>int(1)
		}
		["totalCount"]=>int(0)
	}
}

The console SOAP style cURL for executing GET /V1/foggylineSliderSlide/search is done as follows:

curl -X POST \
-H 'Content-Type: application/soap+xml; charset=utf-8; action="foggylineSliderSlideRepositoryV1GetList"' \
-h 'Authorization: Bearer <token>' \ 
-d @request.xml \
http://magento2.ce/index.php/soap/default?services=foggylineSliderSlideRepositoryV1

Where request.xml has content as follows:

<?xml version="1.0" encoding="UTF-8"?>
<env:Envelope xmlns:env="http://www.w3.org/2003/05/soap-envelope" xmlns:ns1="http://magento2.ce/index.php/soap
/default?services=foggylineSliderSlideRepositoryV1">
	<env:Body>
		<ns1:foggylineSliderSlideRepositoryV1GetListRequest>
			<searchCriteria>
				<filterGroups>
					<item>
						<filters>
							<item>
								<field>title</field>
								<value>%some%</value>
							</item>
						</filters>
					</item>
				</filterGroups>
				<pageSize>10</pageSize>
				<currentPage>1</currentPage>
			</searchCriteria>
		</ns1:foggylineSliderSlideRepositoryV1GetListRequest>
	</env:Body>
</env:Envelope>

Notice we did not really do GET, rather POST. Also, the URL
to which we are pointing our POST is not really the same as the previous requests.
This is because Magento SOAP requests are always POST type, as the data is submitted
XML format. XML format in return specifies the service and the request header action specifies
the method to be called on the service.

The response for console SOAP style cURL should be an XML as follows:

<?xml version="1.0" encoding="UTF-8"?>
<env:Envelope xmlns:env="http://www.w3.org/2003/05/soap-envelope"
xmlns:ns1="http://magento2.ce/index.php/soap/default?services=foggylineSliderSlideRepositoryV1">
	<env:Body>
		<ns1:foggylineSliderSlideRepositoryV1GetListResponse>
			<result>
				<items/>
					<searchCriteria>
						<filterGroups>
							<item>
								<filters>
									<item>
										<field>title</field>
										<value>%some%</value>
									</item>
								</filters>
							</item>
						</filterGroups>
						<pageSize>10</pageSize>
					<currentPage>1</currentPage>
					</searchCriteria>
				<totalCount>0</totalCount>
			</result>
		</ns1:foggylineSliderSlideRepositoryV1GetListResponse>
	</env:Body>
</env:Envelope>

The save (as new) service method call example:

The console cURL for executing POST /V1/foggylineSliderSlide is done as follows:

curl -X POST -H 'Content-type: application/json' \
-H 'Authorization: Bearer <token>' \
-d '{"slide": {"title": "API test"}}' \
http://magento2.ce/rest/V1/foggylineSliderSlide/

The PHP cURL style for executing POST /V1/foggylineSliderSlide is done as follows:

$slide = json_encode(['slide' => ['title' => 'API test']]);

$ch = curl_init('http://magento2.ce/rest/V1/foggylineSliderSlide');
curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'POST');
curl_setopt($ch, CURLOPT_POSTFIELDS, $slide);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
curl_setopt($ch, CURLOPT_HTTPHEADER, array(
	'Content-Type: application/json',
	'Content-Length: ' . strlen($slide),
	'Authorization: Bearer <token>'
));

$result = curl_exec($ch);

The response for console and PHP cURL style should be a JSON string similar
to the following one:

{"slide_id": 4, "title":"API test"}

The PHP SoapClient style for executing POST /V1/foggylineSliderSlide is done as follows:

$slide = ['slide'=>['title'=> 'API test']];

$request = new SoapClient('http://magento2.ce/index.php/soap?wsdl&services=foggylineSliderSlideRepositoryV1',
	array(
		'soap_version' => SOAP_1_2,
		'trace'=>1,
		'stream_context' => stream_context_create(array(
			'http' => array(
				'header' =>
					'Authorization: Bearer <token>')
			)
		)
	)	
);

$response = $request->foggylineSliderSlideRepositoryV1Save($slide);

The response for PHP SoapClient style should be the stdClass PHP object as follows:

object (stdClass) #2 (1) { //The # denotes argv length
	["result"]=>object(stdClass)#3 (2) {
		["slideId"]=>int(6)
		["title"]=>string(8) "API Test"
	}
}

The console SOAP style cURL for executing POST/V1/foggylineSliderSlide is done as follows:

curl -X POST \
-H 'Content-Type: application/soap+xml; charset=utf-8;
action="foggylineSliderSlideRepositoryV1Save"'\
-H 'Authorization: Bearer <token>'\
-d @request.xml http://magento2.ce/index.php/soap/default?services=foggyline
SliderSlideRepositoryV1

Where request.xml has content as follows:

<?xml version="1.0" encoding="UTF-8"?>
<env:Envelope xmlns:env="http://www.w3.org/2003/05/soap-envelope" xmlns:ns1="http://magento2.ce/index.php
/soap/default?services=foggylineSliderSlideRepositoryV1">
	<env:Body>
		<ns1:foggylineSliderSlideRepositoryV1SaveRequest>
			<slide>
				<title>API test</title>
			</slide>
		</ns1:foggylineSliderSlideRepositoryV1SaveRequest>
	</env:Body>
</env:Envelope>

The response for console SOAP style cURL should be an xml as follows:

<?xml version="1.0" encoding="UTF-8"?>
<env:Envelope xmlns:env="http://www.w3.org/2003/05/soap-envelope" xmlns:ns1="http://magento2.ce/index.php/soap
/default?services=foggylineSliderSlideRepositoryV1">
	<env:Body>
		<ns1:foggylineSliderSlideRepositoryV1SaveResponse>
			<result>
				<slideId>8</slideId>
				<title>API test</title>
			</result>
		</ns1:foggylineSliderSlideRepositoryV1SaveResponse>
	</env:Body>
</env:Envelope>

The save (as update) service method call examples

The console cURL style for executing PUT /V1/foggylineSliderSlide/:id is done as follows:

curl -X PUT -H 'Content-type: application/json' \
-H 'Authorization: Bearer <token>'\
-d '{"slide": {"slide_id":2, "title": "API update test"}}' \
http://magento2.ce/rest/V1/foggylineSliderSlide/2

The PHP cURL style for executing PUT /V1/foggylineSliderSlide/:id is done as follows:

$slideId = 2;
$slide = json_encode(['slide' => ['slide_id' => $slideId, 'title'=> 'API update test']]);

$ch = curl_init('http://magento2.ce/rest/V1/foggylineSliderSlide/' . $slideId);
curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'PUT');
curl_setopt($ch, CURLOPT_POSTFIELDS, $slide);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
curl_setopt($ch, CURLOPT_HTTPHEADER, array('Content-Type: application/json', 
'Content-Length: ' . strlen($slide), 'Authorization: Bearer <token>'
));

$result = curl_exec($ch);

The response for console and PHP cURL style should be a JSON string similar to the following one:

{"id":2, "slide_id":2, "title":"API update test"}

The PHP SoapClient style for executing PUT /V1/foggylineSliderSlide/:id is done as follows:

$slideId = 2;
$slide = ['slide'=>['slideId' => $slideId, 'title' => 'API update test']];

$request = new SoapClient('http://magento2.ce/index.php/soap/?wsdl&services=foggylineSlider
SlideRepositoryV1', 
	array(
		'soap_version' => SOAP_1_2,
		'trace'=>1,
		'stream_context' => stream_context_create(array(
			'http' => array(
				'header' => 'Authorization: Bearer <token>')
			)
		)
	)
);

$response $request->foggylineSliderSlideRepositoryV1Save($slide);

The response for PHP SoapClient style should be the stdClass PHP object as follows:

object(stdClass)#2 (1) {
	["result"]=>
	object(stdClass)#3 (2) {
		["slideId"]=>
		int (2)
		["title"]=>
		string (15) "API update test"
	}
}

The console SOAP style cURL for executing PUT /V1/foggylineSliderSlide/:id is done as follows:

curl -X PUT \
-H 'Content-Type: application/soap+xml; charset=utf-8; action="foggylineSlideRepositoryV1Save"'
-H 'Authorization: Bearer <token>' \
-d @request.xml http://magento2.ce/index.php/soap/default?services=
foggylineSliderSlideRepositoryV1

where request.xml has content as follows:

<?xml version="1.0" encoding="UTF-8"?>
<env:Envelope xmlns:env="http://www.w3.org/2003/05/soap-envelope" 
xmlns:ns1="http://magento2.ce/index.php/soap/default?services=foggylineSliderSlideRepositoryV1">
	<env:Body>
		<ns1:foggylineSliderSlideRepositoryV1SaveRequest>
			<slide>
				<slideId>2</slideId>
				<title>API update test</title>
			</slide>
		</ns1:foggylineSliderSlideRepositoryV1SaveRequest>
	</env:Body>
</env:Envelope>

The response for console SOAP style cURL should be an xml as follows:

<?xml version="1.0" encoding="UTF-8"?>
<env:Envelope xmlns:env="http://www.w3.org/2003/05/soap-envelope" 
xmlns:ns1="http://magento2.ce/index.php/soap/default?services=foggylineSliderSlideRepositoryV1">
	<env:Body>
		<ns1:foggylineSliderSlideRepositoryV1SaveResponse>
			<result>
				<slideId>2</slideId>
				<title>API Update Test</title>
			</result>
		</ns1:foggylineSliderSlideRepositoryV1SaveResponse>
	</env:Body>
</env:Envelope>

The deleteById service method call examples

The console cURL style for executing DELETE /V1/foggylineSliderSlide/:slideId is done as follows:

curl -X DELETE -H 'Content-type: application/json' \
-H 'Authorization: Bearer <token>' \
http://magento2.ce/rest/V1/foggylineSliderSlide/3

the PHP cURL style for executing DELETE /V1/foggylineSliderSlide/:slideId is done as follows:

$slideId = 4;

$ch = curl_init('http://magento2.ce/rest/V1/foggylineSliderSlide/' . $slideId);
curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'DELETE');
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
curl_setopt($ch, CURLOPT_HTTPHEADER, array(
	'Content-Type: application/json',
	'Authorization: Bearer <token>'
));

$result = curl_exec($ch);

The response for console and PHP cURL style should be a JSON string similar to the following one:

true

The PHP SoapClient style for executing DELETE /V1/foggylineSliderSlide/:slideId is done as follows:

$slideId = 2;

$request = new SoapClient(
	'http://magento2.ce/index.php/soap/?wsdl&services=foggylineSliderSlideRepositoryV1',
		array(
			'soap_version' => SOAP_1_2,
			'trace'=>1,
			'stream_context' => stream_context_create(array(
					'http' => array(
						'header' => 
		'Authorization: Bearer <token>')
					)
			)
	)
); //Indention error somewhere here

$response => $request->
foggylineSliderSlideRepositoryV1DeleteById(array('slideId' => $slideId));

The response for PHP SoapClient style should be the stdClass PHP object as follows:

object (stdClass)#2 (1) {
	["result"]=>bool(true)
}

The console SOAP style cURL for executing DELETE /V1/foggylineSliderSlide/:slideId is done as follows:

curl -X POST \
-H 'Content-Type: application/soap+xml; charset=utf-8;
action="foggylineSliderSlideRepositoryV1DeleteById"' \
-H 'Authorization: Bearer <token>' \
-d @request.xml
http://magento2.ce/index.php/soap/default?services=foggylineSliderSlideRepositoryV1

Where request.xml has contents as follows:

<?xml version="1.0" encoding="UTF-8"?>
<env:Envelope xmlns:env="http://www.w3.org/2003/05/soap-envelope" xmlns:ns1="http://magento2.ce/index.php
/soap/default?servicesfoggylineSliderSlideRepositoryV1">
	<env:Body>
		<ns1:foggylineSliderSlideRepositoryV1DeleteByIdRequest>
			<slideId>5</slideId>
		</ns1:foggylineSliderSlideRepositoryV1DeleteByIdRequest>
	</env:Body>
</env:Envelope>

The response for console SOAP style cURL should be an xml as follows:

<?xml version="1.0" encoding="UTF-8"?>
<env:Envelope xmlns:env="http://www.w3.org/2003/05/soap-envelope"
xmlns:ns1="http://magento2.ce/index.php/soap/default?services=
foggylineSliderSlideRepositoryV1">
	<env:Body>
		<ns1:foggylineSliderSlideRepositoryV1DeleteByIdResponse>
			<result>true</result>
		</ns1:foggylineSliderSlideRepositoryV1DeleteByIdResponse>
	</env:Body>
</env:Envelope>

The preceeding API call examples cover all of our custom-defined APIs for the Slide entity.

Looking back at the $searchCriteria variable, we used the GET type of HTTP method,
passing the entire variable as a query string. If we think about it, we could have
specified POST during the Web API resource definition and packed the 
content of the $searchCriteria variable into the request body.

Although the GET method approach might look a bit dirtier, imagine if we assigned
the anonymous or self role to the resource: We would be able to simply open a lengthy URL
in the browser and have the search results. Think of a possible widget use,
where a widget would simply do an AJAX request to the URL and fetch the results for the guests
or the customer.

The full module source code can be found here: <url>
Aside from the Slide entity, the full module code indludes the
Image entity as well. Since each slide can contain multiple
images, we can further test the Image API calls analogous to the preceeding calls.

Search Criteria Interface for list filtering:

Knowing how to do a proper list filtering to fetch the entities
that match a certain lookup is essential for the effective use of
getList services across core Magento and possibly custom-coded API's.

An example is fetching the list of customers registered within the last 24 hours for the
latest added product.

Let's take a look back at our app/code/Foggyline/Slider/etc/webapi.xml file, the bit where
we defined the service method="getList". The service class is defined as Foggyline\Slider\
Api\SlideRepositoryInterface, which is defined as a preference for the Foggyline\Slider\Model\
SlideRepository class.

Finally, within the SlideRepository class, we have the actual getList Method getList is defined
as follows:

getList(\Magento\Framework\Api\SearchCriteriaInterface $searchCriteria);

We can see that the getList method takes only one parameter, object instance,
that compiles with SearchCriteriaInterface called $searchCriteria.

What this means is we already have the (incomplete) JSON object of the following type to 
pass to the getList method:

{
	"search_criteria": {

	}
}

In order to further understand the inner workings of search_criteria, we need to understand
SearchCriteriaInterface, which is (partially) defined as follows:

interface SearchCriteriaInterface
{
	/* @param \Magento\Framework\Api\Search\FilterGroup[] $filterGroups */
	public function setFilterGroups(array $filterGroups = null);

		/* @param \Magento\Framework\Api\SortOrder[] $sortOrders */

	public function setSortOrders(array $sortOrders = null);

	/* @param int $pageSize */
	public function setPageSize($pageSize);

	/* @param int $currentPage */
	public function setCurrentPage($currentPage);
}

Every interface getter and setter method expects the values to be found in 
passed API parameters. What this means,is that the getPageSize() and setPageSize()
methods would expect search_criteria to have an integer type page_size property on it.

Similarly, the getFilterGroups() and setFilterGroups() methods would expect
search_criteria to have an array of \Magento\Framework\Api\Search\FilterGroup passed to it.

These insights bring us to an incomplete JSON objecto f the following type to pass to the 
getList method:

{
	"search_criteria": {
		"filter_groups": [
		],
		"current_page": 1,
		"page_size": 10,
		"sort_orders": []
	}
}

Now we have got to the point where we need to determine what goes into filter_groups
and sort_orders, since these are not simple types but compound values.

Looking further into \Magento\Framework\Api\Search\FilterGroup, we see the 
definition of the getFilters() and setFilters() methods that work with an array
of \Magento\Framework\Api\Filter objects. 

What this means is that filter_groups has a property filter that is 
an array of individual filter objects defined as \Magento\Framework\Api\Filter.

With this in mind, we are now down to the following form of the search_criteria JSON
object:

{
	"search_criteria": {
		"filter_groups": [
			{
				"filters": [
				]
			}
		],
		"current_page": 1,
		"page_size": 10
		"sort_orders": [
		]
	}
}

Looking further into individual \Magento\Framework\Api\Filter, through it's getters
and setters it defines we can conclude properties like field, value and condition_type.

This brings us one step further to finalizing our search_criteria JSON object,
which is now structured as follows:

{
	"search_criteria": {
		"filter_groups": [
			{
				"filters":[
					{
						"field": "title",
						"value": "%some%",
						"condition_type": "like"
					}
				]
			}
		],
		"current_page": 1,
		"page_size": 10,
		"sort_orders": [
		]
	}
}

Let us take a look at sort_orders as the last outstanding bit. sort_orders
is of type \Magento\Framework\Api\SortOrder, which has getters and setters
for the field and direction properties. Knowing this, we are able to fully
construct our search_criteria JSON object (or array) that we would be passing
to the getList() service method call as follows:

{
	"search_criteria": {
		"filter_groups": [
			{
				"filters": [
					{
						"field": "title",
						"value": "%some%",
						"condition_type": "like"
					}
				]
			}
		],
		"current_page": 1,
		"page_size": 10,
		"sort_orders": [
			{
				"field": "slide_id",
				"direction": -1
			}
		]
	}
}

What happens when we define multiple entries under filter_groups, filters, or sort_orders?
The logical expectation would be that these break into AND and OR operators in SQL
when they hit the DB. Surprisingly, this is not always the case, at least not with our preceeding example.
Since the actual implementation of the getList method is left for us to handle, we can decide how
we want to handle the filter groups and filters.

Looking back at our getList method, as (partially) shown next, we are not doing anything to imply an
OR operator, so everything ends up with an AND condition on the DB:

foreach ($searchCriteria->getFilterGroups() as $filterGroup) {
	foreach ($filterGroup->getFilters() as $filter){
	$condition = $filter->getConditionType() ?: 'eq';

	$collection->addFieldToFilter($filter->getField(), [$condition => $filter->getValue()]);
	}
}

The preceeding code simply loops through all filter groups, pulling in all filters
within the group and calling the same addFieldToFilter method for everything.
Similar behavior is implement across core Magento modules. Although
the filtering itself follows the \Magento\Framework\Api\SearchCriteriaInterface interface,
there is no unified Magento-wide approach to force AND and OR operators in filtering.

However, Magento core API's like GET products do implement both AND and OR conditions.
In cases like these, filter groups result in OR and filters within the group result in
AND conditions.

Following best practices, we should make sure our modules that implement search criteria do
so respecting the filter_groups/filters and OR/AND relationship.

In this chapter, we covered a lot of ground relating to Magento API's. There is much more left to be
said, but the steps outlined here should be enough to get us started even with more advanced
API usage. We started the chapter with learning about types of users and the authentication methods
supported.

Strong emphasis was placed on making several types of API calls, like console cURL, PHP cURL, PHP
SoapClient, and console cURL SOAP. This was to encourage developers to understand the inner 
workings of API calls more deeply than just using high-level libraries.

Throughout the next chapter, we will look into some of the major sections of Magento.

THE MAJOR FUNCTIONAL AREAS

The Magento platform comprises various modules that deliver various bits of functionality.
Developers are often more in touch with one group of functionality than others.
Examples of some of the most commonly used functionalities include those related to
CMS blocks and pages, categories, products, customers, imports, custom product types,
custom payment, and shipping modules.

This is not to say that other functionalities are less important. In this chapter,
we will take a quick look at the functionalities in the Magento admin area,
PHP code, and API calls. The chapter is divided into the following sections:

CMS Management 

Catalog Management

Customer Management

Products and customer import

Custom product types

Custom offline shipping methods

The intention is not to go into the details of each functional
area. Rather, the aim is to show the admin interface and the corresponding
programmatic and API approach towards basic management.

Content is what helps differentiate one store from another.
Quality content can boost a store's visibility on search engines,
provides informative insight to the customers who buy products,
and provide credibility and trust. Magento provides a solid content
management system, which can be used to create rich content for a store.

We can use it to manage blocks and pages too.

A CMS block is a small modular unit of content that can be positioned
almost anywhere on a page. They can even be called into another blocks.
Blocks support HTML and JavaScript as it's content. Therefore, they are able
to display static information such as text, images and embedded video as well
as dynamic information.

Blocks can be created via an admin interface, APIs or Code.

The following steps outline the block creation process from within an admin interface:

1. Log in to the Magento admin area.

2. In the Content | Elements | Blocks menu, click on Add New Block. This opens
a screen that is similar to the following one:

<SS>

Fill in some values for the required fields (Block Title, Identifier, Store View, Status, and Content)
and click on the Save Block button.

Once the block is saved, you will see the You saved the block. success message in the browser.
CMS blocks are stored in the cms_block and cms_block_store tables in a DB.

The Identifier value is probably the most interesting aspect here.
We can use it in a CMS page, another CMS block, or some code to fetch the block
that we have just created.

Assuming that we have created a block with the Identifier value of foggyline_hello,
we can call it in the CMS page or another block by using the following expression:

{{widget type="Magento\\Cms\\Block\\Widget\\Block" template="widget/static_block/default.phtml"
block_id="foggyline_hello"}}

We can also pass the actual integer ID value of a block to the preceeding expression,
as follows:

{{widget type="Magento\\Cms\\Block\\Widget\\Block" template="widget/static_block/default.phtml" block_id="2"}}

However, this approach requires us to know the actual integer ID of a block.

The preceeding expressions show that blocks are included in a page or another block via a widget,
which is also known as a frontend app. A widget of the Magento\Cms\Block\Widget\Block class
type is using the widget/static_block/default.phtml template file to render the
actual CMS block.

Besides the manual creation of blocks via the admin interface, we can create CMS blocks by using
code, as shown in the following code snippet:

$model = $this->_objectManager->create('Magento\Cms\Model\Block');
$model->setTitle('Test Block');
$model->setIdentifier('test_block');
$model->setContent('Test Block!');
$model->setIsActive(true);
$model->save();

Here, we used the instance manager to create a new model instance of the
Magento\Cms\Model\Block class. Then, we set some properties through defined
methods and finally called the save method.

We can load and update the existing blocks using a code snippet that is similar
to the following code:

$model = $this->_objectManager->create('Magento\Cms\Model\Block');
//$model->load(3);
$model->load('test_block');
$model->setTitle('Updated Test Block');
$model->setStores([0]);
$model->save();

The block's load method accepts either an integer value of a block ID or
a string value of a block identifier.

Finally, we can manage the creation and updating of blocks through the available
APIs method. The following code snippet shows how a CMS block is created via a console 
cURL REST API call:

curl -X POST "http://magento2.ce/index.php/rest/V1/cmsBlock" \
	-H "Content-Type:application/json" \
	-H "Authorization: Bearer <token>" \
	-d '{"block": {"identifier": "test_api_block", "title": "Test API Block",
	"content": "API Block Content"}}'

The bearer string is just a login token that we obtain by first
running the authentication API call, as described in the previous chapter.
Once we have the authentication token, we can make V1/cmsBlock POST request, passing a JSON
object as data.

Managing blocks via API

We can get the newly created CMS block through an API by
executing a snippet of code that looks like this:

curl -X GET "http://magento2.ce/index.php/rest/V1/cmsBlock/4" \
	-H "Content-Type:application/json" \
	-H "Authorization: Bearer <token>"

We can update the existing CMS block by using an API and executing a snippet of 
code that is similar to this:

curl -X PUT "http://magento2.ce/index.php/rest/V1/cmsBlock/4" \
	-H "Content-Type:application/json" \
	-H "Authorization: Bearer <token>" \
	-d '{"block": {"title": "Updated Test API Block"}}'

Here, we used the HTTP PUT method and passed the integer 4 as part of the 
V1/cmsBlock/4 URL. The number 4 represents the ID value of the block in the DB.

CMS pages are robust content units unlike CMS blocks, which are simply
embedded into certain pages. The CMS page can have it's own URL. Examples of CMS
pages are pages such as 404 Not Found, Home page, Enable Cookies, and Privacy and Cookie Policy.
The idea, when it comes to dealing with CMS pages, is that we can control the 
content area of a page without affecting site-wide elements such as header, footer, or sidebars.

Magento does not really comes with many out-of-the-box CMS pages other than the ones
that were listed previously.

Like blocks, pages can also be created via the admin interface, APIs or code.

The following steps outline the page creation process from within the admin interface:

1. Log in to Magento admin area.

2. In the Content | Elements | Pages menu, click on Add New Page. This opens a screen
that is similar the one shown in the SS:

<ss>

3. Fill in some values for the required fields (Page Title, Store View, Status and Content) and click
on the Save Block button.

Once the page is saved, you will see the You saved this page. success message in the browser.
CMS pages are stored in the cms_page and cms_page_store tables in the DB.

Assuming that we have created a page with Page Title value Info, we can access this page in a 
browser via a URL such as http://magento2.ce/info. Though we could have to specify
the URL Key value in the New Page edit screen, Magento automatically assigns URL Key
that matches Page Title.

Managing pages via code

Besides the manual creation through the admin interface, we can create CMS pages via code,
as shown in the following code snippet:

$model =
$this->_objectManager->create('Magento\Cms\Model\Page');
$model->setTitle('Test page');
$model->setIdentifier('test-page');
$model->setPageLayout('1column');

$model->setContent('Test page!');
$model->setIsActive(true);
$model->setStores([0]);
$model->save();

Here, we used the instance manager to create a new model instance of the
Magento\Cms\Model\Page class. Then, we set some properties through 
the defined methods and finally called the save method. The URL Key that we set through
the admin Interface is actually an identifier that we set via the setIdentifier method call.

We can load and update the existing pages by using a code snippet that is similar to the following one:

$model = 
$this->_objectManager->create('Magento\Cms\Model\Page');
//$model->load(6);
$model->load('test-page');
$model->setContent('Updated Test page!');
$model->save();

The page model load method accepts either an integer ID value of a page identifier (URL Key).

Finally, we can manage the creation and updating of pages through the available APIs method.
The following code snippet shows how a CMS page is created via a console cURL REST API call:

curl -X POST "http://magento2.ce/index.php/rest/V1/cmsPage" \
	-H "Content-Type:application/json" \
	-H "Authorization: Bearer <token>" \
	-d '{"page": {"identifier": "test-api-page", "title": "Test API Page",
	"content": "API Block Content"}}'

Once we have the authentication token, we can make a V1/cmsPage POST request, passing on the
JSON object as data.

We can get the newly created CMS page through an API by executing a snippet of code that is similar
to the following one:

curl -X GET "http://magento2.ce/index.php/rest/V1/cmsPage/7" \
	-H "Content-Type:application/json" \
	-H "Authorization: Bearer <token>"

We can update the existing CMS page through an API by executing a snippet of code that is similar
to the following one:

curl -X PUT "http://magento2.ce/index.php/rest/V1/cmsPage/7" \
	-H "Content-Type:application/json" \
	-H "Authorization: Bearer <token>" \
	-d '{"page": {"content": "Updated Test API Page", "identifier": "updated-page"}}'

Here, we used the HTTP PUT method, passing the integer 7 as a part of the V1/cmsPage/7 URL
The number 7 represents the ID value of the page in the DB.

The Magento_Catalog module is one of the backbones of the entire Magento platform. It
provides robust support for the inventory management of various product types.
This module is what manages products, categories and their attributes, the display on the frontend
and many more things.

We can access the catalog functionality within the Magento admin area by navigating to Products |
Inventory | Catalog or Products | Inventory | Category.

If we start with a blank Magento installation, we will probably
start with categories as one of the first entities to be created.
We can manually create categories by performing the following steps:

1. Log in to the Magento admin area.

2. Go to the Products | Inventory | Category menu.
This opens a screen that is similar to the one shown in the following SS:

<ss>

On the left-hand side of the screen, click on Default Category. Then, when the page reloads,
click on the Add Subcategory button.

Though it may seem that nothing has happened, as the screen does not change, we should now
fill in the required options in the General Information tab, setting Name to some string value and
Is Active to Yes.

Finally, click on the Save Category button.

The new category should now be created. To the left screen area,
if you click on the name of the newly created category, you will see its ID value
above the General Information tab, as shown in the following SS:

Knowing the Category ID enables you to directly test it on a storefront simply by opening
a URL such as http://magento2.ce/index.php/catalog/category/view/id/3 in the browser, where the number
3 is the ID of the category. You will see a loaded category page that probably shows the
We can't find products matching teh selection message, which is good, as we haven't assigned
products to a Category.

Though we will not go into its details, it is worth noting that we have simply scratched
the surface here, as categories enable us to provide many additional options using the
Display Settings, Custom Design tabs.

Given that categories are EAV entities, their data is stored across several tables in the DB,
as follows:

catalog_category_entity

catalog_category_entity_datetime

catalog_category_entity_decimal

catalog_category_entity_int

catalog_category_entity_text

catalog_category_entity_varchar

There are a few additional tables that link categories to products:

catalog_category_product

catalog_category_product_index

catalog_category_product_index_tmp

catalog_url_rewrite_product_category

Besides the manual creation through the admin interface, we can create
categories via code, as shown in the following code snippet:

$parentId = \Magento\Catalog\Model\Category::TREE_ROOT_ID;

$parentCategory = $this->_objectManager->create('Magento\Catalog\Model\Category')->load($parentId);

$category = $this->_objectManager->create('Magento\Catalog\Model\Category');

$category->setPath($parentCategory->getPath());
$category->setParentId($parentId);
$category->setName('Test');
$category->setIsActive(true);

$category->save();

What is specific here is that when creating a new category, we first created a 
$parentCategory instance, which represents the root category object. We used
the Category model TREE_ROOT_ID constant as the ID value of a parent category ID.

Then, we created an instance of the category, set its path, parent_id, name, and is_active value.

We can further manage category creation through the available APIs method. The following code snippet
shows category creation via the console cURL REST API call:

curl -X POST "http://magento2.ce/index.php/rest/V1/categories" \
	-H "Content-Type:application/json" \
	-H "Authorization: Bearer <token>" \
	-d '{"category": {"parent_id": "1", 
"name": "Test API Category", "is_active": true}}'

The bearer string is just a login token that we obtain by first running the authentication API call,
as described in the previous chapter. Once we have the authentication token, we can make a /V1/categories POST
request, passing a JSON object as data.

We can get the newly created category as a JSON object through an API by executing a snippet
of code that looks like the following one:

curl -X GET "http://magento2.ce/index.php/rest/V1/categories/9" \
	-H "Content-Type:application/json" \
	-H "Authorization: Bearer <token>"

Now, let's look at how to create a new product. We can manually create products
by performing the following steps:

Log in to the Magento admin area.

In the Products | Inventory | Catalog menu, click on the Add Product button. This opens a screen
similar to the one shown in the following SS:

<ss>

Now, fill in the required options on the Product Details tab.

Finally, click on the save button.

If it is successfully saved, the page reloads and shows the You saved the product, mesage.

Like categories, we have barely scratched the surface of products here.
Looking at the other available tabs, there are a large number of additional options
that can be assigned to a product. Simply assigning the required options should be
enough for us to see the product on the store's frontend on a URL such
as http://magento2.ce/index.php/catalog/product/view/id/4, where the number 4 is
the ID value of a product.

Products are also EAV entities, whose data is stored across several tables in a DB, as follows:

catalog_product_entity

catalog_product_entity_datetime

catalog_product_entity_decimal

catalog_product_entity_gallery

catalog_product_entity_group_price

catalog_product_entity_int

catalog_product_entity_media_gallery

catalog_product_entity_media_gallery_value

catalog_product_entity_text

catalog_product_entity_tier_price

catalog_product_entity_varchar

There are also a large number of other table referencing products such as
catalog_product_bundle_selection, but these are mostly used to link bits of
functionalities.

Besides the manual creation through the admin interface, we can create products via code,
as shown in the following code snippet:

$catalogConfig = $this->_objectManager->create('Magento\Catalog\Model\Config');

$attributeSetId = $catalogConfig->getAttributeSetId(4, 'Default');

$product = $this->_objectManager->create('Magento\Catalog\Model\Product');

$product->setTypeId(\Magento\Catalog\Model\Product\Type::TYPE_SIMPLE)
		->setAttributeSetId($attributeSetId)

		->setWebsiteIds([$this->storeManager->getWebsite()->getId()])
		->setStatus(\Magento\Catalog\Model\Product\Attribute\Source\Status::STATUS_ENABLED)
		->setStockData(['is_in_stock' => 1, 'manage_stock' => 0])
		-setStoreId(\Magento\Store\Model\Store::DEFAULT_STORE_ID)
		->setVisibility(\Magento\Catalog\Model\Product\Visibility::VISIBILITY_BOTH);

$product
	->setName('Test API')
	->setSku('test-api')
	->setPrice(19.99);

$product->save();

The following example uses the REST API to create a new simple product:

curl -X POST "http://magento2.ce/index.php/rest/V1/products" \
	-H "Content-Type:application/json" \
	-H "Authorization: Bearer <token>" \
	-d '{"product": {"sku": "test_api_1", "name":"Test API #1", "attribute_set_id":4, "price":19.99,
	"status":1,
	"visibility":4, "type_id":"simple", "weight":1}}'

The Bearer token should have been previously obtained by using an authentication request.
The response should be a JSON object that contains all the exposed product data.

We can get the existing product as information through an API that executes a snippet of code,
as follows:

curl -X GET "http://magento2.ce/index.php/rest/V1/products/product_dynamic_125" \
	-H "Content-Type:application/json"

The product_dynamic_125 part inn the preceeding URL stands for this specific products
SKU value. The response is a JSON object that contains all the exposed product data.

The entire list of the available catalog APIs can be seen in the vendor/magento/module-catalog/etc/webapi.xml file.

Managing customers is another important aspect of the Magento platform. Most of the time,
customer creation is something that is left for a new customer to do. A new 
customer who visits a store initiates the registration process and finishes
up with a customer account being created.

Once registered, customers can then further edit their account details on the storefront
under the My Account page, which is usually available on a link such as 
http://magento2.ce/index.php/customer/account/index/.

As a part of this section, we are interested in the possibility of managing
customer accounts by using the admin area, code, and API.

The following steps outline the customers account creation process from within the admin interface:

1. Log in to Magento admin area.

2. In the Customer | All Customers menu, click on the Add New Customer button.
	This opens a screen that looks similar to the one shown in the following
	ss:
<ss>

Fill in some values for the required fields (Associate to Website, Group, First Name, Last Name, and
Email) and click on the Save Customer button.

Once the customer is saved, you will see the You saved the customer. success message in the browser.
The associate to Website value is probably the most important value for cases like this one,
where customer accounts are being indirectly created by a user who's not a customer.

Since Magento supports the setting up of multiple websites, customer accounts can be set
to either the Global or Per Website value, depending on the Stores | Settings | Configuration |
Customers | Customer Configuration | Account Sharing Option | Share Customer Accounts option.

Thus, if the Share Customer Accounts options has been set to Per Website, it is of the 
utmost importance to point the Associate the Website value to the proper website.
Otherwise, a customer account will be created but the customer won't be able to log
in to it on the storefront.

The Magento_Customer module uses the EAV structure to store customer data. Thus,
there is no single table that stores customer information. Rather, multiple table
exist depending on the customer property and it's data type.

The following list comprises tables that store customer entity:

customer_entity

customer_entity_datetime

customer_entity_decimal

customer_entity_int

customer_entity_text

customer_entity_varchar

Customer accounts will not really be completed without a customer address. The address
can be added via the Addresses tab under the customer edit screen in the admin area, as shown
in the following SS:

<ss>

Note that Magento enables us to set one of the addresses as Default Shipping Address and Default
Billing Address.

Like the customer entity, the customer address entity also uses the EAV structure to store its data.
The following list comprises tables that store the customer address entity:

customer_address_entity

customer_address_entity_datetime

customer_address_entity_decimal

customer_address_entity_int

customer_address_entity_text

customer_address_entity_varchar

Besides the manual creation via the admin interface, we can create
customers via code, as shown in the following code snippet:

$model = $this->_objectManager->create('Magento\Customer\Model\Customer');
$model->setWebsiteId(1);
$model->setGroupId(1);
$model->setFirstName('John');
$model->setLastName('Doe');
$model->setEmail('john.doe@mail.com');
$model->save();

Here, we are using the instance manager to create a new model instance of the
Magento\Customer\Model\Customer class. We can then set some properties through
the defined methods and finally call the save method.

We can load and update an existing customer by using a code snippet that is similar
to the following one:

$model = $this->_objectManager->create('Magento\Customer\Model\Customer');
$model->setWebsiteId(1);
//$model->loadByEmail('john.doe@mail.com');
$model->load(1);
$model->setFirstName('Updated John');
$model->save();

We can use either the load or loadByEmail method call. The load method accepts the integer ID
value of the existing customer entity, while loadByEmail accepts a string e-mail address.
It is worth noting that setWebsiteId has to be called prior to any of the load methods.
Otherwise, we will get an error message that says A customer website ID must be specified
when using the website scope.

Finally, we can manage the creation and updating of customer information using the available
API method. The following code snippet shows how to create a customer via a
console cURL REST API call:

curl -X POST "http://magento2.ce/index.php/rest/V1/customers" \
	-H "Content-Type:application/json" \
	-H "Authorization: Bearer <token>" \
	-d '{"customer": {"website_id": 1, "group_id": 1, "firstName": "John", "lastName": "Doe",
	"email": "john.doe@mail.com"}, "password":"abc123"}'

Once we have the authentication token, we can make a V1/customers POST request, passing a JSON
object as data.

We can get the newly created customer via an API by executing a snippet of code that is similar
to the following one:

curl -X GET "http://magento2.ce/index.php/rest/V1/customers/24" \
	-H "Content-Type:application/json" \
	-H "Authorization: Bearer <token>"

We can update an existing customer through an API by executing a snippet of code that is similar
to the following one:

curl -X PUT "http://magento2.ce/index.php/rest/V1/customers/24" \
	-H "Content-Type:application/json" \
	-H "Authorization: Bearer <token>" \
	-d '{"customer": {"id":24, "website_id": 1, "firstName": "John Updated", "lastname": "Doe",
	"email": "john2@mail.com"},
	"password_hash": "<a hash>:1"}'

Here, we used the HTTP PUT method, passing the integer 24 as a part of the V1/customers/24 and as part
of the body URL. The number 24 represents the ID value of a customer in the DB. Also, note the
password_hash value; without it, the update will fail.

Similar to customers, we can create a customer address using code, as shown in the following
code snippet:

$model = $this->_objectManager->create('Magento\Customer\Model\Address');
//$model->setCustomer($customer);
$model->setCustomerId(24);
$model->setFirstName('John');
$model->setLastName('Doe');
$model->setCompany('Foggyline');
$model->setStreet('Test street');
$model->setCity('London');
$model->setCountryId('GB');
$model->setPostcode('GU22 7PY');
$model->setTelephone(<number>);
$model->setIsDefaultBilling(true);
$model->setIsDefaultShipping(true);
$model->save();

Here, we used the instance manager to create a new model instance of the Magento\Customer\Model\Address
class. We then set some properties through the defined methods and finally called the save method.

We can load and update the existing customer address by using a code snippet that is similar
to the following one:

$model = $this->_objectManager->create('Magento\Customer\Model\Address');
$model->load(22);
$model->setCity('Update London');
$model->save();

Here, we used the load method to load an existing address by its ID value. Then,
we called the setCity method passing it the updated string. After the save method is executed,
the address should reflect the change.

Surprisingly, a customer address cannot be created or updated directly via an API call, as there is no
POST or PUT REST API defined. However, we can still get the existing customer address information by using
an API, as follows:

curl -X GET "http://magento2.ce/index.php/rest/V1/customers/addresses/22" \
	-H "Content-Type:application/json" \
	-H "Authorization: Bearer <token>"

The entire list of available customer APIs can be seen in the vendor/magento/module-customer/etc/webapi.xml
file.

Magento provides an out-of-the-box mass import and export function via the following modules:

AdvancedPricingImportExport

BundleImportExport

CatalogImportExport

ConfigurableImportExport

CustomerImportExport

GroupedImportExport

ImportExport

TaxImportExport

The heart of the import functionality actually lies in the ImportExport module,
while other modules provide individual import and export entities through the 
vendor/magento/module-{partialModuleName}-import-export/etc/import.xml and
vendor/magento/module-{partialModuleName}-import-export/etc/export.xml

These functionalities can be accessed from the Magento admin area from the System | Data Transfer
menu. They enable us to export and import several entity types, such as Advanced Pricing,
Products, Customers Main File, and Customer Addresses.

The following SS shows the Entity Type options for the Import Settings screen.

<ss>

Next to Import Settings, when we select Entity Type for import, the Import Behavior section
appears, as shown in the following SS:

<ss>

Most entity types have similar options for Import Behavior. Most of the time, we will be
interested in the Add/Update behavior.

Since importing is a bit more complicated process than exporting, we will focus
on importing and the CSV file format. More specifically, our focus is on Products,
Customers Main File, and Customer Addresses imports.

When working with a clean Magento installation, the following columns are required during the product
import in order to make the product visible on the storefront afterwards:

sku (for example: "test-sku"): This can have almost any value as long as it is unique across Magento.

attribute_set_code(for example, "Default"): This can have any of the values found in a DB
when the SELECT DISTINCT attribute_set_name FROM eav_attribute_set; query is executed.

product_type(for example, "simple"): This can have the value of simple, configurable, grouped,
virtual, bundle or downloadable. Additionally, if we create or install a third-party
module that adds a new product type, we can use that one as well.

categories(for example, "Root/Shoes"): Create a full category path using the "Root category name/Child
category name/Child child category name" syntax. If there are multiple categories, then a pipe
("|") is used to seperate them. An example of this is "Root category name/Child category name/Child child
category name| Root category name/Child_2 category name".

product_websites (for example, "base"): This can have the values found in 
a DB when the SELECT DISTINCT code FROM store_website; query is executed.

name (for example: "Test"): This can have almost any value.

product_online (for example: "1"): This can be either 1 for visible or 0 for not visible.

visibility (For example, "Catalog Search"): This can have the values of
"Not Visible Individually", "Catalog", "Search", or "Catalog, Search".

price (for example "9.99"): This can be an integer or a decimal value.

qty (for example, "100"): This can be an integer or a decimal value.

Though the products will get imported just with the preceeding list that comprises a set of columns,
we usually would like to assign additional information to them, such as descriptions and images.
We can do so with the help of the following columns:

description (for example, "The description"): This can have any string value. HTML and JS 
are supported.

short_description (for example, "The short description"): This can have any string value. HTML 
and JS are supported.

base_image (for example, butterfly.jpg): This is the final import image name.

small_image (for example, galaxy.jpg)

thumbnail_image (for example, serenity.jpg) 

Regarding the import of images, we need only to provide the final image name as long as the
Images File Dir path is set during the import. We can use a relative path for the Magento installation,
such as var/export, var/import and var/export/some/dir

Once the import is finished, it is suggested to run the php bin/magento indexer:reindex command
via the console. Otherwise, the products won't be visible on the storefront until the
indexer is run.

Once the reindexing is done, we can try opening storefront URL, which looks like http://magento2.ce/index.php/catalog/product/view/id/1. The number 1 in this case is a newly imported product ID.

When working with a clean Magento installation, the following columns are required during a customer's
main file import in order for our customer to be able to successfully log in to the store afterwards:

email (for example, <john.doe@fake.mail>): an e-mail as a string

_website(for example, base): This can have any of the values found in the DB when the
SELECT DISTINCT code FROM store_website; query is executed

firstname(for example, John): a string value

lastName(for example, Doe): a string value

group_id(for example, 1): This can have any of the values found
in the database when the SELECT customer_group_id code FROM customer_group WHERE customer_group_id != 0;
query is executed

Though a customer will be able to log in to the storefront with just the previously listed set of columns,
we usually would like to assign other relevant pieces of info. We can do so with the help of the following columns:

gender (for example, Male): This can be either Male or Female

taxvat (for example, <token number>): any valid VAT number, though an import will accept
even the invalid ones

dob (for example, 1983-01-16): date of birth

prefix (for example, Mr): any string value

middlename (for example, the dev guy): Any string

suffix (for example, engineer): any string value

password (for example, 123abc): Any string value that
has a minimum length of 6 characters, as defined via
\Magento\CustomerImportExport\Model\Import\Customer::MIN_PASSWORD_LENGTH

We need to pay special attention to the password column. This is a clear
text password. Therefore, we need to be careful not to distribute a
CSV file in a nonsecure manner. Ideally, we can provide the password_hash
column instead of password. However, entries under the password_hash
column will need to be hashed via the same algorithm as the one that was
called within the hashPassword method of the Magento\Customer\Model\Customer class.

This further calls the getHash method on an instance of the Magento\Framework\Encryption\Encryptor
class, which finally resolves to the md5 or sha256 algorithm.

When working with a clean Magento installation, the following columns are
required during the customer address import in order for our customers to be able to
successfully use the addresses on the storefront afterwards:

_website (for example, base): This can have any of the values found in the database
when the SELECT DISTINCT code FROM store_website; query is executed.

_email (for example, john@change.me) : an e-mail adress as a string value

_entity_id

firstname (for example, John): any string value

lastname (for example, Doe): any string value

street (for example, Ashton Lane): any string

city (for example, Austin): Any string

telephone (for example, 00 385 91 111 000): Any string value

country_id (for example, GB): the country code in the ISO-2 format

postcode (for example, TX 78753): any string value

Though a customer will be able to use the addresses on the storefront with just
a listed set of columns, we usually would like to assign other relevant pieces of information.

We can do so with the help of the following columns:

region (For example, California): This can be blank, a free form string,
or a specific string that matches any of the values found in the DB when the SELECT
DISTINCT default_name FROM directory_country_region; query is executed.

On running SELECT DISTINCT country_id FROM directory_country_region;, 13 different
country codes that have entries within the directory_country_region table are shown-
AT, BR, CA, CH, DE, EE, ES, FI, FR, LT, LV, RO, US. This means that countries with
that code need to have a proper region name assigned.

company (for example, Foggyline): This can be any string value.

fax (for example, 00 385 91 111 000): this can be any string value

middlename (for example, the developer): this can be any string value

prefix (for example, Mr): This can be any string value

suffix (for example, engineer): This can be any string value

vat_id (for example, HR33311122299): This can be any valid VAT number, though import
will accept even the non-valid ones

_address_default_billing_ (for example, "1"): This can be either "1" (logical yes) or "0" (Logical no),
to flag the address as being the default billing address.

_address_default_shipping_ (for example, "1"): This can be either "1" as yes or "0" as no, to flag the
address as being default billing address.

While CSV imports are a great and relatively fast way to mass import products, customers and 
their addresses, there are some limitations to it. CSV is simply flat data. We cannot
apply any logic to it. depending on how clean and valid the data is, the CSV import
might do just fine.

Otherwise, we might want to opt for APIs. We need to keep in mind that a CSV import is much
faster than the API creation of products and customers because CSV imports work directly
by bulk inserting on the DB, while APIs instansiate full models, respect the event observer,
etc.

Magento provides the following six out-of-the-box product types:

Simple products

Configurable Products

Grouped products

Virtual products

Bundle products

Downloadable products

Each product has its specifics. For example, the virtual and downloadable products do not have 
the weight attribute. Therefore, they are excluded from the standard shipping calculations.
With custom coding around built-in product types, by using observers and plugins we can achieve
almost any functionality.

However, this is not enough sometimes or there is no solution to the requirement. In cases such 
as thoose, we might need to create our own product type that will match the project requirements
in a more streamlined way. 

Let's create a miniature module called Foggyline_DailyDeal that will add a new product type to Magento.

Start by creating a module registration file named app/code/Foggyline/DailyDeal/registration.php
that has the following partial content:

\Magento\Framework\Component\ComponentRegistrar::register(\Magento\Framework\Component\Component\
ComponentRegistrar::MODULE, 'Foggyline_DailyDeal', __DIR__);

Then create an app/code/Foggyline/DailyDeal/etc/module.xml with the following content:

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:noNamespaceSchemaLocation="urn:magento:framework:Module/etc/module.xsd">
	<module name="Foggyline_DailyDeal" setup_version="1.0.0">
		<sequence>
			<module name="Magento_Catalog"/>
		</sequence>
	</module>
</config>

Now, create an app/code/Foggyline/DailyDeal/etc/product_types.xml file that has the following
content:

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:
Magento_Catalog:etc/product_types.xsd">
	<type name="foggylinedailydeal"
		label="Daily Deal"
		modelInstance="Foggyline\DailyDeal\Model\Product\Type\DailyDeal"
		composite="false"
		isQty="true"
		canuseQtyDecimals="false">
		<priceModel instance="Foggyline\DailyDeal\Model\Product\Price"/>
		<indexerModel instnace="Foggyline\DailyDeal\Model\ResourceModel\Indexer\Price"/>
		<stockIndexermodel instance="Foggyline\DailyDeal\Model\ResourceModel\Indexer\Stock"/>
		<!-- customAttributes parsed by Magento\Catalog\Model\ProductTypes\Config -->
		<customAttributes>
			<attribute name="is_real_product" value="true"/>					
			<attribute name="refundable" value="false"/>
			<attribute name="taxable" value="true"/>
		</customAttributes>
	</type>
</config>

the customAttributes element is parsed by vendor/magento/module-catalog/Model/ProductTypes/Config.php.

Create an app/code/Foggyline/DailyDeal/Model/Product/Type/DailyDeal.php file with the partial
content as follows:

namespace Foggyline\DailyDeal\Model\Product\Type;

class DailyDeal extends \Magento\Catalog\Model\Product\Type\AbstractType
{
	const TYPE_DAILY_DEAL = 'foggylinedailydeal';

	public function deleteTypeSpecificData(\Magento\Catalog\Model\Product $product)
	{
		//TODO: Implement deleteTypeSpecificData() method.
	}
}

Now, create an app/code/Foggyline/DailyDeal/Model/Product/Price.php with the partial
content as follows:

namespace Foggyline\DailyDeal\Model\Product;

class Price extends \Magento\Catalog\Model\Product\Type\Price
{
	
}

After htis is done, create an app/code/Foggyline/DailyDeal/Model/ResourceModel/Indexer/Price.php
file with partial content as follows:

namespace Foggyline\DailyDeal\Model\resourceModel\Indexer;

class Price extends \Magento\Catalog\Model\ResourceModel\Product\Indexer\Price\DefaultPrice
{
	
}

Then, create an app/code/Foggyline/DailyDeal/Model/ResourceModel/Indexer/Stock.php file with
partial content as follows:

namespace Foggyline\DailyDeal\Model\ResourceModel\Indexer;

class Stock extends \Magento\CatalogInventory\Model\ResourceModel\Indexer\Stock\DefaultStock
{
	
}

Finally, create an app/code/Foggyline/DailyDeal/Setup/InstallData.php file with content as follows:

namespace Foggyline\DailyDeal\Setup;

class InstallData implements \Magento\Framework\Setup\InstallDataInterface
{
	private $eavSetupFactory;

	public function __consturct(\Magento\Eav\Setup\EavSetupFactory $eavSetupFactory)
	{
		$this->eavSetupFactory = $eavSetupFactory;
	}

	public function install(
		\Magento\Framework\Setup\ModuleDataSetupInterface $setup,
		\Magento\Framework\Setup\ModuleContextInterface $context)
	{
		//The "foggylinedailydeal" type specifics
	}
}

Extend the install method from within the InstallData class by adding the following
foggylinedailydeal type specifics to it:

$eavSetup = $this->eavSetupFactory->create(['setup' => $setup]);
$type = \Foggyline\DailyDeal\Model\Product\Type\DailyDeal::TYPE_DAILY_DEAL;

$fieldList = ['price', 
			'special_price',
			'special_from_date',
			'minimal_price',
			'cost',
			'tier_price',
			'weight',
];

//make these attributes applicable to foggylinedailydeal products
foreach ($fieldList as $field) {
	$applyTo = explode(',', //explode the list and run them as being what is being applied to
						$eavSetup->getAttribute(\Magento\Catalog\Model\Product::ENTITY, $field,
						'apply_to')
	);

	if (!in_array($type, $applyTo)) { //if the type is not int he array
		$applyTo[] = $type; //the applyTo array is the $type
		$eavSetup->updateAttribute(\Magento\Catalog\Model\Product::ENTITY,
			$field,
			'apply_to',
			implode(',', $applyTo) //update the attribute by accessing the product entity
			//and imploding it into the list 
		);
	}
}

Now, run the php bin/magneto setup:upgrade from the console.

If you now open the Products | Inventory | Catalog menu in the admin area and click
on the dropdown ion next to the Add Product button, you will see the Daily Deal product
type on the list, as shown in the following SS:

<ss>

Clicking on the Daily deal product type in the dropdown list should open the product
edit page, as shown in the following SS:

<ss>

There is no noticable difference between the custom product type edit screen and one of the
built-in product types.

Assuming that we have named the product Daily Deal Test Product and saved it,
we should be able to see it on the storefront, as shown in the following SS:

<ss>

If we add the product to the cart and perform a checkout, an order should be created just as with any other
product type. Within the admin area, on the order view page, under Items Ordered, we should be able
to see the Product on the list, as shown in the following ss:

<ss>

Again, there is no noticable difference between the custom product type and the built-in product type
that is rendering under the Items Ordered section.

Finally, we should run the php bin/magento indexer:reindex command on the console. Even though
we haven't really implemented any code within the indexers, this is just to ensure that none
of the existing indexers broke.

The entire module can be downloaded from https://github.com/ajzele/B05032-Foggyline_DailyDeal.

Magento provides several out-of-the-box offline shipping methods, such as Flatrate, Freeshipping,
Pickup and Tablerate. We can see those in the vendor/magento/module-offline-shipping/Model/Carrier
dir.

However, project requirements quite often are such that we need a custom code shipping method where
a special business logic is applied. Thus, the shipping price calculation can be 
controlled by us. In such cases, knowing how to code our own offline shipping method might come in ahdny.

Let's go ahead and create a small module called Foggyline_Shipbox that provides Magento an extra 
offline shipping method.

Start by creating a module registration file named app/code/Foggyline/Shipbox/registration.php 
with partial content as follows:

\Magento\Framework\Component\ComponentRegistrar::register(
	\Magento\Framework\Component\ComponentRegistrar::MODULE,
		'Foggyline_Shipbox',
		__DIR__
);

Then, create an app/code/Foggyline/Shipbox/etc/module.xml file with the following content:

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magneto:framework:Module/etc/module.xsd">
	<module name="Foggyline_Shipbox" setup_version="1.0.0">
		<sequence>
			<module name="Magento_OfflineShipping"/>
		</sequence>
	</module>
</config>

Now, create an app/code/Foggyline/Shipbox/etc/config.xml with content as follows:

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:
module:Magento_Store:etc/config.xsd">
	<default>
		<carriers>
			<shipbox>
				<active>0</active>
				<sallowspecific>0</sallowspecific>
				<model>Foggyline\Shipbox\Model\Carrier\Shipbox</model>
				<name>Shipbox</name>
				<price>4.99</price>
				<title>Foggyline Shipbox</title>
				<specificerrmsg>This shipping method is not available. To use this
				shipping method, please contact us.</specificerrmsg>
			</shipbox>
		</carriers>
	</default>
</config>

After this is done, create an app/code/Foggyline/Shipbox/etc/adminhtml/system.xml file
with content as follows:

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Config:etc/system_file.xsd">
	<system>
		<section id="carriers">
			<group id="shipbox" translate="label" type="text" sortOrder="99"
			showInDefault="1" showInWebsite="1" showInStore="1">
				<label>Foggyline Shipbox</label>
				<field id="active" translate="label" type="select" sortOrder="1" 
				showInDefault="1" showInWebsite="1" showInStore="0">
					<label>Enabled</label>
					<source_model>Magento\Config\Model\Source\Yesno</source_model>
				</field>
				<field id="name" translate="label" type="text" sortOrder="3" 
				showInDefault="1" showInWebsite="1" showInStore="1">
					<label>Method Name</label>
				</field>
				<field id="price" translate="label" type="text" sortOrder="5" 
				showInDefault="1" showInWebsite="1"
				showInStore="0">
					<label>Price</label>
					<validate>validate-number validate-zero-or-greater</validate>
				</field>
				<field id="title" translate="label" type="text" sortOrder="2"
				showInDefault="1" showInWebsite="1"
				showInStore="1">
					<label>Title</label>
				</field>
				<field id="sallowspecific" translate="label" type="select"
				sortOrder="90" showInDefault="1" showInWebsite="1" showInStore="0">
					<label>Ship to Applicable Countries</label>
					<frontend_class>shipping-applicable-country</frontend_class>
					<source_model>Magento\Shipping\Model\Config\Source\AllSpecificcountries</source_model>
				</field>
				<field id="specificcountry" translate="label" type="multiselect"
				sortOrder="91" showInDefault="1" showInWebsite="1" showInStore="0">
					<label>Ship to Specific Countries</label>
					<source_model> Magento\Directory\Model\Config\Source\Country</source_model>
					<can_be_empty>1</can_be_empty>
				</field>
			</group>
		</section>
	</system>
</config>

Now, create an app/code/Foggyline/Shipbox/Model/Carrier/Shipbox.php file with partial content as follows:

namespace Foggyline\Shipbox\Model\Carrier;

use Magento\Quote\Model\Quote\Address\RateRequest;

class Shipbox extends \Magento\Shipping\Model\Carrier\AbstractCarrier implements \Magento\Shipping\Model\
Carrier\CarrierInterface
{
	protected $_code = 'shipbox';
	protected $_isFixed = true;
	protected $ _rateResultFactory;
	protected $ _rateMethodFactory;

	public function __construct(
		\Magento\Framework\App\Config\ScopeConfigInterface $scopeConfig,
		\Magento\Quote\Model\Quote\Address\RateResult\ErrorFactory $rateErrorFactory,
		\Psr\Log\LoggerInterface $logger,
		\Magento\Shipping\Model\Rate\ResultFactory $rateResultFactory,
		\Magento\Quote\Model\Quote\Address\RateResult\MethodFactory $rateMethodFactory,
		array $data = []
	)
	{
		$this->_rateResultFactory = $rateResultFactory;
		$this->_rateMethodFactory = $rateMethodFactory;
		parent::__construct($scopeConfig, $rateErrorFactory, $logger, $data);
	}

	public function collectRates(RateRequest $request)
	{
		//implements business logic
	}

	public function getAllowedMethods()
	{
		return ['shipbox' => $this->getConfigData('name')];
	}
}

Extend the collectRates method in the Carrier\Shipbox class as follows:

public function collectRates(RateRequest $request)
{
	if (!$this->getConfigFlag('active')){
		return false;
	}

	//Do some filtering of items in cart
	if ($request->getAllItems()) {
		foreach ($request->getAllItems() as $item)
		{
			//$item->getQty();
			//$item->getFreeShipping()
			//$item->isShipSeparately()
			//$item->getHasChildren()
			//$item->getProduct()->isVirtual()

			//...
		}
	}
	//After filtering, start forming final price
	//Final price does not have to be fixed like below

	$shippingPrice = $this->getConfigData('price');
	$result = $this->_rateResultFactory->create();

	$method = $this->_rateMethodFactory->create();

	$method->setCarrier('shipbox');
	$method->setCarrierTitle($this->getConfigData('title'));

	$method->setMethod('shipbox');
	$method->setMethodTitle($this->getConfigData('name'));

	$method->setPrice($shippingPrice);
	$method->setCost($shippingPrice);

	$result->append($method);

	return $result;
}

In the Magento admin area, if you now look under Stores | Settings | Configuration | Sales | Shipping Methods,
you will see Foggyline Shipbox on the list, as shown in the following SS:

<ss>

Set the Enabled option to Yes and click the Save Config button.

If you now run the SELECT * FROM core_config_data WHERE path LIKE "%shipbox%"; query on
the MySQL server, you will see results that are similar to the ones shown in the following SS:

<ss>

Note how there is no direct code within the code snippets in the preceeding screenshots that is related to
Ship to Applicable Countries and Ship to Specific Countries option, because the handling of these options
is built into the parent AbstractCarrier class. Thus, simply by adding the sallowspecific option
in config.xml and system.xml, we enabled a feature where the shipping method can be shown or hidden
from certain countries.

The crux of the implementation comes down to the collectRates method. This is where we implement
our own business logic that should calculate the shipping price based on the items in the cart.
We can use the $request->getAllItems() in the collectRates method to fetch the collection
of all the cart items, traverse through them, form a final shipping price based on various 
conditions and so on.

Now, let's go ahead and jump to the storefront in order to test the checkout. We should be able 
to see our method on the checkout, as shown in the following ss:

<ss>

If we complete one order, we should further see the shipping method details on the order itself.
Within the admin area, under Sales Operations | Orders, if we View our order in the Payment & Shipping Method
section, we should see the shipping method, as shown in the following ss:

<ss>

Similarly, in the Order Totals section, we should see the shipping amount in Shipping & Handling, as shown
in the following content:

<ss>

With this, we conclude our custom offline shipping method module. The full module can be found at
https://github.com/ajzele/B05032-Foggyline_Shipbox.

Magento provides several out-of-the-box offline payment methods, such as Banktransfer, Cashondelivery,
Checkmo and Purchaseorder. You can see them in the vendor/magento/module-offline-payments/Model dir.

When it comes to payment methods, it is more common to use an online payment provider (gateway) , such as Paypal
or Braintree. Sometimes, project requirements may be such that we may need a custom coded payment method.

You will need to think of programmatic product import and order creation script that might specialize
in some specifically labeled payment method. Thus, the payment process will be controlled by us.

In such cases, knowing how to code our own offline payment method might come in handy. It is worth noting
that while we can make an offline payment that will grab a user's credit card info, it is not really
advisable to do so unless our infrastructure is PCI-compliant.

Let's go ahead and create a small module called Foggyline_Paybox that provides Magento an extra offline payment method.

Start by creating a module registration file named app/code/Foggyline/Paybox/registration.php with partial
content as follows:

\Magento\Framework\Component\ComponentRegistrar::register(\Magento\Framework\Component\ComponentRegistrar::MODULE,
	'Foggyline_Paybox',
	__DIR__
);

Then, create an app/code/Foggyline/Paybox/etc/module.xml file with the following content:

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework
:Module/etc/module.xsd">
	<module name="Foggyline_Paybox" setup_version="1.0.0">
		<sequence>
			<module name="Magento_OfflinePayments"/>
		</sequence>
	</module>
</config>

After this is done, create an app/code/Foggyline/Paybox/etc/config.xml file with the following
content:

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instnace" xsi:noNamespaceSchemaLocation="urn:magento:
module:Magento_Store:etc/config.xsd">
	<default>
		<payment>
			<paybox>
				<active>0</active>
				<model>Foggyline\Paybox\Model\Paybox</model>
				<order_status>pending</order_status>
				<title>Foggyline Paybox</title>
				<allowspecific>0</allowspecific>
				<group>Offline</group>
			</paybox>
		</payment>
	</default>
</config>

Then, create the app/code/Foggyline/Paybox/etc/payment.xml file with the following content:

<payment xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:
Magento_Payment:etc/payment.xsd">
	<methods>
		<method name="paybox">
			<allow_multiple_address>1</allow_multiple_address>
		</method>
	</methods>
</payment>

Now, create an app/code/Foggyline/Paybox/etc/adminhtml/system.xml file with the following content:

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:
Magento_Config:etc/system_file.xsd">
	<system>
		<section id="payment">
			<group id="paybox" translate="label" type="text" sortOrder="30"
showInDefault="1" showInWebsite="1"
showInStore="1">
				<label>Paybox</label>
				<field id="active" translation="label" type="select" sortOrder="1" showInDefault="1"
showInWebsite="1" showInStore="0">
					<label>Enabled</label>
					<source_model> Magento\Config\Model\Config\Source\Yesno</source_model>
				</field>
				<field id="order_status" translate="label" type="select" sortOrder="20" showInDefault="1"
showInWebsite="1" showInStore="0">
					<label>New Order Status</label>
					<source_model>Magento\Sales\Model\Config\Source\Order\Status\NewStatus</source_model>
				</field>
				<field id="sort_order" translate="label" type="text" sortOrder="100" showInDefault="1" 
showInWebsite="1" showInStore="0">
					<label>Sort Order</label>
					<frontend_class>validate-number</frontend_class>
				</field>
				<field id="title" translate="label" type="text" sortOrder="10" showInDefault="1"
showInWesbtei="1" showInStore="1">
					<label>Titlte</label>
				</field>
				<field id="allowspecific" translate="label" type="allowspecific"
sortOrder="50" showInDefault="1" showInWebsite="1" showInStore="0">
					<label>Payment from Applicable Countries </label>
					<source_model>Magento\Payment\Model\Config\Source\Allspecificcountries</source_model>
				</field>
				<field id="specificcountry" translate="label" type="multiselect" sortOrder="51" showInDefault="1"
showInWebsite="1" showInStore="0">
					<label>Payment from Specific Countries</label>
					<source_model>Magento\Directory\Model\Config\Source\Country</source_model>
					<can_be_empty>1</can_be_empty>
				</field>
				<field id="payable_to" translate="label" sortOrder="61" showInDefault="1"
showInWebsite="1" showInStore="1">
					<label>Make Check Payable to</label>
				</field>
				<field id="mailing_address" translate="label" type="textarea" sortOrder="62"
showInDefault="1" showInWebsite="1" showInStore="1">
					<label> Send check to</label>
				</field>
				<field id="min_order_total" translate="label" type="text" sortOrder="98"
showInDefault="1" showInWebsite="1" showInStore="0">
					<label>Minimum Order Total</label>
				</field>
				<field id="max_order_total" translate="label" type="text" sortOrder="99" 
showInDefault="1" showInWebsite="1" showInStore="0">
					<label>Maximum Order total</label>
				</field>
				<field id="model"></field>
			</group>
		</section>
	</system>
</config>

Create an app/code/Foggyline/Paybox/etc/frontend/di.xml file with the following content:

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:
ObjectManager/etc/config.xsd">
	<type name="Magento\Checkout\Model\CompositeConfigProvider">
		<arguments>
			<argument name="configProviders" xsi:type="array">
				<item name="offline_payment_paybox_config-provider" xsi:type="object">Foggyline\Paybox\Model\
PayboxConfigProvider
				</item>
			</argument>
		</arguments>
	</type>
</config>

After this is done, create an app/code/Foggyline/Paybox/Model/Paybox.php file with the following content:

namespace Foggyline\Paybox\Model;

class Paybox extends \Magento\Payment\Model\Method\AbstractMethod
{
	const PAYMENT_METHOD_PAYBOX_CODE = 'paybox';
	protected $_code = self::PAYMENT_METHOD_PAYBOX_CODE;

	protected $_isOffline = true;

	public function getPayableTo()
	{
		return $this->getConfigData('payable_to');
	}

	public function getMailingAddress()
	{
		return $this->getConfigData('mailing_address');
	}
}

Now, create an app/code/Foggyline/Paybox/Model/PayboxConfigProvider.php file with the 
following content:

namespace Foggyline\Paybox\Model;

class PayboxConfigProvider implements \Magento\Checkout\Model\ConfigProviderInterface
{
	protected $methodCode = \Foggyline\Paybox\Model\Paybox::PAYMENT_METHOD_PAYBOX_CODE;
	protected $method;
	protected $escaper;

	public function __construct(\Magento\Payment\Helper\Data\ $paymentHelper
	)
	{
		$this->method = $paymentHelper->getMethodInstance($this->methodCode);
	}

	public function getConfig()
	{
		return $this->method->isAvailable() ? [ 'payment' => [ 'paybox' => [ 'mailingAddress' => \
		$this => getMailingAddress, 
			'payableTo' => $this->getPayableTo(),
			],
		],
	], : [];
	}

	protected function getMailingAddress()
	{
		$this->method->getMailingAddress();
	}

	protected function getPayableTo()
	{
		return $this->method->getPayableTo();
	}
}

Copy the entire vendor/magento/module-offline-payments/view/frontend/layout/checkout_index_index.xml. Magento core file
into the app/code/Foggyline/Paybox/view/frontend/layout/checkout_index_index.xml module.
Then edit the module's checkout_index_index.xml module file by replacing the entire
<item name="offline-payments" xsi:type="array"> element and it's children with the following code:

<item name="foggline-offline-payments" xsi:type="array">
	<item name="component" xsi:type="string">
Foggyline_Paybox/js/view/payment/foggline-offline-payments</item>
	<item name="methods" xsi:type="array">
		<item name="paybox" xsi:type="array">
			<item
name="isBillingAddressRequired" xsi:type="boolean">true</item>
		</item>
	</item>
</item>

Then, create an app/code/Foggyline/Paybox/view/frontend/web/js/view/payment/offline-payments.js with the
following content:

/*browser:true*/
/*global define*/
define(
	[
		'uiComponent',
		'Magento_Checkout/js/model/payment/renderer-list'
	],
	function (
		Component, 
		rendererList
	){
		'use strict';
		renderList.push(
			{
				type: 'paybox',
				component: 'Foggyline_Paybox/js/view/payment/method-renderer/paybox'
			}
		);
		return Component.extend({});
	}
);

After this is done, create an app/code/Foggyline/Paybox/view/frontend/web/js/view/payment/method-renderer/paybox.js
with content as follows:

/*browser:true */
/*global define*/
define(
	[
		'Magento_Checkout/js/view/payment/default'
	],
	function (Component) {
		'use strict';

		return Component.extend({
			defaults: {
				template:
'Foggyline_Paybox/payment/paybox'
			},

			getMailingAddress: function () {
				return
			
window.checkoutConfig.payment.paybox.mailingAddress;
		},

		getPayableTo: function () {
			return
window.checkoutConfig.payment.paybox.payableTo;
			}
		});
	}
);

Now, create an app/code/Foggyline/Paybox/view/frontend/web/template/payment/paybox.html file with the content as follows:

<div class="pament-method" data-bind="css:{'_active': (getCode() == isChecked())}">
	<div class="payment-method-title fieldchoice">
		<input type="radio"
				name="payment[method]"
				class="radio"
				data-bind="attr: {'id': getCode()}, value: getCode(), checked: isChecked,
				click: selectPaymentMethod, visible: isRadioButtonVisible()" />
		<label data-bind="attr: {'for': getCode()}" class="label"><span 
data-bind="text: getTitle()"></span></label>
	</div>
	<div class="payment-method-content">
		<div class="payment-method-billing-address">
			<!-- ko foreach:
$parent.getRegion(getBillingAddressFormName()) --> <!-- ko template: getTemplate() --><!-- /ko -->
			<!-- /ko -->
		</div>
		<!-- ko if: getMailingAddress() || getPayableTo() -->
			<dl class="items check payable">
				<!-- ko if: getPayableTo() -->
				<dt class="title"><!-- ko i18n: 'Make Check payble to:' --><!-- /ko --></dt>
				<dd class="content"><!-- ko i18n: getPayableTo() --><!-- /ko --></dd>
				<!-- /ko -->
				<!-- ko if: getMailingAddress() -->
				<dt class ="title"><!-- kod i18n: 'Send Check toxyz:' --><!-- /ko --></dt>
				<dd class="content">
					<address class="paybox mailing address" data-bind="html": 
$t(getMailingAddress())"></address>
				</dd>
				<!-- /ko -->
			</dl>
			<!-- /ko -->
			<div class="checkout-agreements-block">
				<!-- ko foreach:
$parent.getRegion('before-place-order') -->
				<!-- ko template: getTemplate() --><!-- /ko -->
			</div>
			<div class="actions-toolbar>"
				<div class="primary">
					<button class="action primary checkout"
	type="submit"
	data-bind="click: placeOrder, 
				attr: {title: $t('Place Order')}, 
				css: {disabled: !isPlaceOrderActionAllowed()},
				enable: (getCode() == isChecked()) " 
				disabled>
				<span data-bind="i18n: 'Place Order'"></span>
				</button>
			</div>
		</div>
	</div>
</div>

With this, we conclude our custom offline payment method module. the enitre module
can be found at https://github.com/ajzele/B05032-Foggyline_Paybox.

In this chapter, we touched upon some of the most common bits of functionality that developers
come in contact with. We learned where to look in the admin area and how to programmaticaly
manage the entities behind these functionalities.

Thus, we were effectively able to manually and progamatiically create and fetch CMS pages,
blocks, categories, and products. We also learned how to create product and customer import scripts.
Finally, we studied how to create our own custom product type, simple payment and shipment module.

The following chapter will guide us through Magento's in-built tests and how we can use them 
to effectively QA an application to keep it healthy.

Software testing can be defined as a critical step in the development life cycle.
this step is often silently overlooked by a number of devs because a certain amount of 
time need to be invested into writing a decent test suite for a code base.

Rather than being a single one-time activity, writing tests is a process that follows our
code as it grows and changes. Test results should at any given time, validate and
verify that our software works as expected, thus meeting the business and technical requirements.

Writing tests should follow writing the actual application code early on in the life cycle. 
This helps prevent defects from being introduced in the code.

On a high level, we can divide tests into the following categories:

Static: Application code is not executed during testing. Possible errors are found by inspecting
the application code files and not on their execution.

Dynamic: Application code is executed during testing. Possible errors are found while checking
for functional behavior of an application

In this chapter, we will take a look at the testing options that Magento offers. Along the way,
we will build a basic module with some testing features in it.

Magento provides several types of tests out of the box. We can see a list of these tests
on running the following command on the console in the Magento root folder:

php bin/magento dev:tests:run -help

The results of this command is output that looks like this:

Usage:
	dev:tests:run [type]
Arguments:
	type Type of tests to run. Available types: all, unit, integration, integration-all,
	static, static-all, integrity, legacy, default (default: "default")

This output originates from the Console/Command/DevTestsRunCommand.php file in the core
Magento_Developer module. Looking at the output, we might say that there are actually nine
types of tests, which are as follows:

all

unit

integration

integration-all

static

static-all

integrity

legacy

default

However, these are not unique types of tests: these are combinations, as we will soon see.

Let's take a closer look at the code in the DevTestsRunCommand class and it's setupTestInfo method.

The setupTestInfo method defines the internal commands property, as follows:

$this->commands = [
	'unit' 			=> ['../tests/unit', ''],
	'unit-performance' 			=> ['../tests/performance/framework/tests/unit', ''],
	'unit-static' 			=> ['../tests/static/framework/tests/unit', ''],
	'unit-integration' 		=> ['../tests/integration/framework/tests/unit', ''],
	'integration' 			=> ['../tests/integration', ''],
	'integration-integrity' => ['../tests/integration', 'testsuite/Magento/Test/Integrity'],
	'static-default' 		=> ['../tests/static', ''],
	'static-legacy' 		=> ['../tests/static', 'testsuite/Magento/Test/Legacy'],
	'static-integration-js' => ['../tests/static', ' testsuite/Magento/Test/Js/Exemplar'],
	];

Furthermore, we can see the types property in the setupTestInfo method defined in the following way:

$this->types = [
	'all' 		=>
array_keys($this->commands),
	'unit' 		=> ['unit', 'unit-performance', 'unit- static', 'unit-integration'],
	'integration' => ['integration'],
	'integration-all' => ['integration', 'integration-integrity'],
	'static' 		=> ['static-default'],
	'static-all' 	=> ['static-default', 'static-legacy', 'static-integration-js'],
	'integrity' 	=> ['static-default', 'static-legacy', 'integration-integrity'],
	'legacy' 		=> ['static-legacy'],
	'default' 		=> [
		'unit',
		'unit-performance',
		'unit-static',
		'unit-integration',
		'integration',
		'static-default',
	],
];

The types property logically groups one or more tests into a single name that is found under the commands property.
We can see how like unit single type encompasses the unit, unit-performance, unit-static and unit-integration
tests in it.

The command property points to the disk location of the actual test library. Relative to the 
Magento root installation folder, tests can be found in the dev/tests/dir

Unit tests are designed to test individual class methods in isolation, asserting all possible
combinations and taking care of the smallest testable part of an application. Magento uses
the PHPUnit testing framework for its unit tests.

Being highly focused, unit tests make it easy to identify the root cause of issues
if a certain test fails. We can specifically trigger the unit tests from the root of the
Magento installation by using the following command:

php bin/magento dev:tests:run unit

Once triggered, Magento will run the execute command in the vendor/magento/module-developer/Console/Command
/DevTestsRunCommand.php file. Since the unit type is mapped to several commands, what will happen
internally is that Magento will change the dirs from one dir to another, as follows:

dev/tests/unit

dev/tests/performance/framework/tests/unit

dev/tests/static/framework/tests/unit

dev/tests/integration/framework/tests/unit

We can say that all of these dirs are considered unit test dirs.

Within each of these dirs, Magento internally runs the passthru ($command, $returnVal) method,
where the $command param gets resolved to a string similar to the following one:

php /www/magento2/./vendor/phpunit/phpunit/phpunit

The PHPUnit will then look for the phpunit.xml config file accordingly in each of these dirs.
If phpunit.xml does not exist, we need to copy the contents of phpunit.xml.dist into phpunit.xml.

Let's take a closer look at the dev/tests/unit/phpunit.xml file for testsuite, filter, whitelist and other
configuration elements.

The following default testsuite dir list is found in the dev/tests/unit/phpunit.xml file, which 
lists the dirs in which you need to look for tests files prefixed with Test.php:

../../../app/code/*/*/Test/Unit
../../../dev/tools/*/*/Test/Unit
../../../dev/tools/*/*/*/Test/Unit
../../../lib/internal/*/*/Test/Unit
../../../lib/internal/*/*/*/Test/Unit

../../../setup/src/*/*/Test/Unit
../../../update/app/code/*/*/Test/Unit

../../../vendor/*/module-*/Test/Unit
../../../vendor/*/framework/Test/Unit
../../../vendor/*/framework/*/Test/Unit

the list is relative to the dev/tests/unit/ dir. for example, if we take a look at the first
line in the preceeding code and then look at the Magento_Catalog module, it is clear
that the Test files are found under the app/code/<vendorName>/<moduleName>/Test/ dir and it's
sub-dirs.

Everything suffixed with Test.php in these folders will get executed as part of a unit test.

If we were building our own module, we could easily make a copy of dev/tests/unit/phpunit.xml.dist,
properly edit testsuite and filter > whitelist to quickly execute only our module's unit tests,
thus saving some time on avoiding frequent execution of the entire Magento unit tests.

Integration tests test the interaction between individual components, layers, and an environment.
They can be found in the dev/tests/integration dir. Like unit tests,
Magento also uses PHPUnit for integration tests. Thus, the difference between a unit and an integration
test is not that much of a technical nature, rather, it is of a logical nature.

To specifically trigger integration tests only, we can execute the following command on the console:

php bin/magento dev:tests:run integration

When executed, Magento internally changes the dir to dev/tests/integration and executes a command that
is similar to the following one:

php /Users/branko/www/magento2/./vendor/phpunit/phpunit/phpunit

The integration dir has it's own phpunit.xml.dist file. Looking at it's testsuite definition,
we can see that it is pointing to all the Test.php suffix files that are found in
the dev/tests/integration/testsuite dir.

Static tests do not really run the code, they analyze it. They are used
to verify that the code conforms to certain coding standards, such as PSR-1. We can find
them under the dev/tests/static dir.

To specifically trigger static tests only, we can execute the following
command on the console:

php bin/magento dev:tests:run static

When executed, Magento internally changes the dir to dev/tests/static and 
executes a command that is similar to the following one:

php /Users/brank/www/magento2/./vendor/phpunit/phpunit/phpunit

The static dir has it's own phpunit.xml.dist file. Looking at it's testsuite definition,
you will see the following four test suites defined:

JavaScript static code analysis

PHP coding standard verification

Code integrity tests

XSS unsafe output test

JSHint, a JavaScript code quality tool, is used for JavaScript static
code analysis. For PHP code standard verification, the elements of PHP_CodeSniffer libs
are used.

PHP_CodeSniffer tokenizes PHP, JS and CSS files and detects violations of a defined
set of coding standards.

Integrity tests check how an app is linked. They check for such things as merged
config validation. Basically, they tell us if your app should be able to run.

We can specifically trigger the integrity tests from the root of the Magento installation
by using the following command:

php bin/magento dev:tests:run integrity

When this is executed, Magento first internally changes the dir to dev/tests/static and 
then executes two commands that are similar to the following ones:

php /Users/branko/www/magento2/./vendor/phpunit/phpunit/phpunit

php /Users/branko/www/magento2/./vendor/phpunit/phpunit/phpunit testsuite/Magento/Test/Legacy

Then, Magento internally changes the dir to dev/tests/integration and executes a command that is
similar to the following one:

php /Users/branko/www/magento2/./vendor/phpunit/phpunit/phpunit testsuite/Magento/Test/Integrity

Integration tests also utilize the PHPUnit to write the actual tests.

Legacy tests comprises fragments of libs that help devs port their modules to a new version
of Magento.

We can trigger legacy tests specifically from the root of the Magento installation by using
the following command:

php bin/magento dev:tests:run legacy

When this is executed, Magento first internally changes the dir to /dev/tests/static and 
then executes a command, which is similar to the following one:

php /Users/branko/www/magento2/./vendor/phpunit/phpunit/phpunit testsuite/Magento/Test/Legacy

Once this is triggered, the code runs a check for obsolete access lists, connections,
menus, responses, system config, and a few other things.

Performance tests can be found under the setup/performance-toolkit/ dir. These tests
require Apache JMeter to be installed and are available on the console via  the jmeter command.

Apache JMeter can be downloaded and installed by the following instr at:

http://jmeter.apache.org

The crux of the performance test is defined in the benchmark.jmx file, which can be opened
in the JMeter GUI tool, as shown in the following ss:

<ss>

As shown in the preceeding ss, the default benchmark.jmx tests are sectioned
into three thread groups that are named setUp Thread Group, Customer Checkout, and 
tearDown Thread Group. We might want to additionally click on each group and configure
it with some extra params, thus possibly changing the Number of Threads (users), as shown
in the following SS.

We can then simply save the changes as modifications to the benchmark.jmx file or a file
with a new name:

<ss>

We can manually trigger a performance test from the console without using a GUI interface by running
the following command:

jmeter -n -t /Users/branko/www/magento2/setup/performance-toolkit/benchmark.jmx
-l /Users/branko/Desktop/jmeter-tmp/results.jtl \
-Jhost="magento2.ce" \
-Jbase_path="/" \
-Jreport_save_path="/Users/branko/report" \
-Jloops=2 \
-Jurl_suffix=".html" \
-Jcustomer_email="john.doe@email.loc" \
-Jcustomer_password="abc123" \
-Jadmin_path="/admin_nwb0bx" \
-Jadmin-password="abc123" \
-Jresponse_time_file_name="/Users/branko/report/AggregateGraph.csv" \
-Jsimple_product_url_key="simple-product-1" \
-Jsimple_product_name="Simple Product 1" \
-Jconfigurable_product_url_key="configurable-product-1" \
-Jconfigurable_product_name="Configurable Product 1" \
-Jcategory_url_key="category-1" \
-Jcategory_name="Category 1" \
-Jsleep_between_steps=50

The console parameters that are listed here and which start
with -J also match the names of the Used Defined Variables test toolkit, as shown
in the preceeding SS.

We need to be careful and set them according to the Magento installation. The -n parameter
instructs jmeter to run in the run nongui mode. The -t parameter is where we set the 
path of the test(.jmx) file to run. The -l parameters sets the file 
where we need to log samples to.

Functional tests mimic the user interaction with our app. They literally mean testing in the form
of browser interaction, which involves clicking on the page, adding products to the cart
and so on. For this purpose, Magento uses Magento Testing Framework (MTF). It's a 
PHP wrapper around Selenium, which is a portable software testing framework
for web apps. 

MTF is not available out of the box via the console. It can be downloaded at https://github.com/magento/mtf

The following requirements need to be met before installing MTF:

Git must be installed

Firefox must be installed

The PHP openssl extension must be installed and enabled

Java version 1.6 or later is required and it's JAR executable must be in the system PATH.

The Selenium standalone server, which is available at http://www.seleniumhq.org/, needs to be
downloaded.

The download should provide a JAR file that we will later need to refer to.

Magento must be installed and configured to not use the secret URL key. We can set the
secret URL key option by navigation to Stores | Configuration | Advanced | Admin | Security | Add Secret Key to URLs
[Yes/No] and setting it to No.

Once the minimal reqs have been fulfilled, we can install MTF as follows:

Run the composer install command from the dev/tests/functional/ dir. This creates a 
new dir named vendor; MTF is pulled from the git repo at https://github.com/magento/mtf. 
We should see a new dir named vendor that is created with the checked off MTF. The vendor dir
contains the content that is shown in the following ss:

<ss>

Run the generate.php file from the dev/tests/functional/utils/ dir. This should give us a
console output that is similar to the following one:

|| Item 			|| Count || Time ||
|| Page Classes 	|| 152 	 || 0 	 ||
|| Fixture Classes 	|| 46 	 || 0 	 ||
etc.

The generator tool creates factories for fixtures,
handlers, repos, page objects and block objects. When MTF is initialized, the factories
are pregenerated to facilitate the creation and running of tests.

Before we can actually run the tests, there are a few more things that we need to config:

1. Edit the dev/tests/functional/phpunit.xml file.
Under the php element, for name="app_frontend_url", set the value of the actual URL for the
Magento storefront under test. For name="app_backend_url", set the value of the
actual URL for the Magento admin URL under test. For name="credentials_file_path", set the
value of ./credentials.xml

If phpunit.xml does not exist, we need to create it and copy the contents of dev/tests/functional/phpunit.xml.dist
into it and then edit it afterwards.

Edit the dev/tests/functional/etc/config.xml file. Under the app element, find it and edit the info
about backendLogin, backendPassword, and appBackendUrl so that it matches that of our store.

If config.xml does not exist, we need to create it and copy the contents of dev/tests/functional/etc/config.xml.dist
into it and then edit it afterwards.

Edit the dev/tests/functional/credentials.xml file. chances are that we will not need this
on a blank Magento installation, as we can see by default the entries for the fedex, ups, dhl US, and dhl
EU carriers, which haven't been set on the freshly installed Magento.

If credentials.xml does not exist, we need to create it and copy the contents of dev/tests/functional/credentials.xml.dist into it and then edit it afterwards.

Run the java -jar {selenium_dir}/selenium-server.jar command via the console. This is to ensure that
the Selenium server is running.

Open a new console or a console tab and execute the phpunit command in the dev/tests/functional/ dir.
This command should open the Firefox browser and start running test cases in it, simulating a user clicking
on the browser window and filling in the form inputs.

While a test is running, Magento will log all the failed tests under the dev/tests/functional/var/log dir in
a structure that is similar ot the one following ss:

var/log/<All Tests>, <magento>/backend/<GlobalSearchEntityTest>, <NavigateMenuTest>/ etc.

The log path can be configed in the dev/tests/functional/phpunit.xml file under the php element
with name="basedir".

if we want to target a specific test within the entire test suite, we can simply trigger a command
like the following one in the dev/tests/functional/ dir:

phpunit tests/app/Magento/Customer/Test/TestCase/RegisterCustomerFrontendEntityTest.php

The preceeding command will run a single test called RegisterCustomerFrontEntityTest.php

We can also use a shorter form expression for the same thing, as follows:

phpunit --filter RegisterCustomerFrontendEntityTest

Once this is executed, the browser should open and simulate the customer registration process
on the storefront.

Now that we took a quick look at all the type of tests that Magento offers,
let's take a step back and look at unit tests again. In practice, unit tests are 
probably the ones that we will be writing most of the time.

With this in mind, let's grab the Foggyline_Unitly module from https://github.com/ajzele/B05032-Foggyline_Unitly
and start writing unit tests for it.

If you do not already have the Foggyline_Unitly module in the code base that was part of the
previous chapters, then you need to place its content under app/code/Foggyline/Unitly and execute
the following commands on the console from root of the Magento dir:

php bin/magento module:enable Foggyline_Unitly 
php bin/magento setup:upgrade

The tests that we will write reside in the module's Test/Unit dir. This makes the
entire path of the test dir look like app/code/Foggyline/Unitly/Test/Unit/.

Magento knows that it needs to look inside this folder simply because of the test suite dir
definintions found in the dev/tests/unit/phpunit.xml file, as shown in the following
piece of code:

<directory suffix="Test.php">
	../../../app/code/*/*/Test/Unit
</directory>

The structure of files and the folder within the individual module Test/Unit dir also follows
the structure of that module's files and folders. The following SS shows a structure of
the Test/Unit dir for the Magento_Catalog module:

Test/Unit/<tons of Dirs about different tests>

This shows that almsot any PHP class can be unit tested irrespective of the fact that 
it is a controller, block, helper, module, observer or something else. To keep things
simple, we will focus on the controller and block unit tests in relation to the
Foggyline_Unitly module, which is structured as follows:

Unitly/Block/Hello/Shout.php

Unitly/Controller/Hello/Shout.php
Unitly/Controller/Hello.php

Unitly/etc/frontend/routes.xml
Unitly/etc/module.xml

Unitly/Model/User.php

Unitly/Test

Unitly/view/frontend -> layout/foggyline_unitly_hello_shout.xml
			-> templates/unitly/hello/shout.phtml

Let's start by first writing a test for the Foggyline\Unitly\Controller\Hello\Shout controller class.
The Shout class, ignoring the __construct, has only one method called execute.

We will write a test for it under the same dir structure, relative to the module's Test\Unit dir,
placing the test under the app/code/Foggyline/Unitly/Test/Unit/Controller/Hello/ShoutTest.php file,
as follows:

namespace Foggyline\Unitly\Test\Unit\Controller\Hello;

class ShoutTest extends \PHPUnit_Framework_TestCase
{
	protected $resultPageFactory;
	protected $controller;

	public function setUp()
	{
		/* setUp() code here */
	}

	public function testExecute()
	{
		/* testExecute() code here */
	}
}

Every unit test in the Magento module dir extends from the \PHPUnit_Framework_TestCase class. The
setUp method is called before the test is executed; we can think of it as PHP's __construct.
Here, we would usually set up the fixtures, open a network connection, or perform similar actions.

The testExecute method name is actually formed from test + the method name from the class that we are testing.
Since the Shout class has an execute method, the test method formed becomes test + execute.

By capitalizing the first letter of the class method name the final name is testExecute.

Now, let's go ahead and replace /* setUp() code here */ with content as follows:

$request = $this->getMock('Magento\Framework\App\Request\Http', [], [], '', false);

$context = $this->getMock( 
	'\Magento\Framework\App\Action\Context', ['getRequest'], [], '', false);

$context->expects($this->once())
	->method('getRequest')
	->willReturn($request);

$this->resultPageFactory = $this->
getMockBuilder('Magento\Framework\View\Result\PageFactory')
	->disableOriginalConstructor()
	->setMethods(['create'])
	->getMock();

$this->controller = new \Foggyline\Unitly\Controller\Hello\Shout($context, $this->resultPageFactory);

The whole concept of tests is based on mocking the objects that we need to work with. We use the 
getMock method that returns a mock object for a specified class. Besides the class name, the getMock
method accepts quite a bit of other arguments.

The second $methods parameter marks the names of the methods that are replaced with a test double.
Providing null for the $methods parameter means that no methods will be replaced. The third param for the
getMock method stands for $arguments, which are params that are passed to the original class constructor.

We can see from the preceeding code that the $request mock object does not provide any $methods or
$arguments params to get its getMock method. On the other hand, the $context object passes on the array
with a single getRequest element in it. Once the $context object is initialized, it then calls
the expects method, which registers a new expectation in the mock object and returns InvocationMocker on which
we call method and willReturn.

In this case, the instance on the previously initated $request object is passed to willReturn. We used
getMockBuilder to create a Result\PageFactory mock object and instansitaed the Shout controller action
class, passing the context and result page mocks to it.

All the code in this setUp method served a purpose in getting out the controller instnace, which will be
used in the testExecute method.

The final, private, and static methods cannot be mocked. They are ignored by the PHPUnit's test functionality
because they retain their original behavior.

Let's go ahead and replace the /* testExecute() code here */ with content, as follows:

$title = $this->getMockBuilder('Magento\Framework\View\Page\Title')
	->disableOriginalConstructor()
	->getMock();
$title->expects($this->once())
	->method('set')
	->with('Unitly');

$config = $this->
getMockBuilder('Magento\Framework\View\Page\Config')
	->disableOriginalConstructor()
	->getMock();
$config->expects($this->once())
	->method('getTitle')
	->willReturn($tutle);

$page = $this->
getMockBuilder('Magento\Framework\View\Result\Page')
	->disableOriginalConstructor()
	->getMock();
$page->expects($this->once())
	->method('getConfig')
	->willReturn($config);

$this->resultPageFactory->expects($this->once())
	->method('create')
	->willReturn($page);

$result = $this->controller->execute();

$this->assertInstanceOf('Magento\Framework\View\Result\Page', $result);

In the preceeding code, we checked into the page title, page, and result page object.
To get to the page title from within the controller code, we would normally use an expression
such as $resultPage->getConfig()->getTitle(). This expression involves three objects.

The $resultPage object calls getConfig() method, which returns the instance of the Page\Config object.
This object calls for the getTitle method, which returns an instnace of the Page\Title object.
Thus, we are mocking and testing all the three objects.

Now that we took a look at the controller test case, let's see how we can make one for 
the block class. Create an app/code/Foggyline/Unitly/Test/Unit/Block/Hello/ShoutTest.php file with
content as follows:

namespace Foggyline\Unitly\Test\Unit\Block\Hello;

class ShoutTest extends \PHPUnit_Framework_TestCase
{
	/**
	 * @var \Foggyline\Unitly\Block\Hello\Shout
	 */

	protected $block;

	protected function setUp()
	{
		$objectManager = new \Magento\Framework\TestFramework\Unit\Helper\ObjectManager($this);
		$this->block = $objectManager->getObject('Foggyline\Unitly\Block\Hello\Shout');
	}

	public function testGreeting()
	{
		$name = 'Foggyline';

		$this->assertEquals('Hello'.$this->block->escapeHtml($name),
							$this->block->greeting($name)
		);
	}
}

Here, we have also defined the setUp method and testGreeting. The testGreeting method is used
as a test for the greeting method on the Shout block class.

Conceptually, there is no difference between unit testing a controller, block, or model class.
Therefore, we will omit the model unit test in this example. What's important for you to realize,
is that the test is what we make of it. Technically speaking, we can test a single
method for various cases or just the most obvious one.

However, to serve the purpose of the tests in a better way, we should test it for any possible
number of result combinations. Let's go ahead and create a dev/tests/unit/foggyline-unitly-phpunit.xml file
with content as follows:

<phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://schema.phpunit.de/4.1/phpunit.xsd"
					colors="true"
					bootstrap="./framework/bootstrap.php"
					>
	<testsuite name="Foggyline_Unitly - Unit Tests">
		<directory suffix="Test.php">
			../../../app/code/Foggyline/Unitly/Test/Unit
		</directory>
	</testSuite>
	<php>
		<ini name="date.timezone" value="Europe/Zagreb"/>
		<ini name="xdebug.max_nesting_level" value="200"/>
	</php>
	<filter>
		<whitelist
addUncoveredFilesFromWhiteList="true">
			<directory suffix=".php">
				../../../app/code/Foggyline/Unitly/*
			</directory>
		</whitelist>
	</filter>
	<logging>
		<log type="coverage-html" target="coverage_dir/Foggyline_Unitly/test-reports/coverage"
charset="UTF-8" yui="true" higlight="true"/>
	</logging>
</phpunit>

finally, we can execute only our own module unit tests by running a command
such as phpunit -c foggyline-unitly-phpunit.xml

Once tests are executed, we should be able to see the entire code coverage report in the dev/tests/unit/coverage_dir/Foggyline_Unitly/test-reports/coverage/index.html file, as shown:

<ss>

The SS demonstrates how detailed the code coverage is, which shows even percenages and lines of code
covered with the test.

in this chapter, we took a look at the testing facility embedded into Magento through
the libs in the root dev/tests/dir and the Magento_Developer module. We learned how
to run all of its test types and suited a simple example of writing our own unit tests. 
The examples that are given here do not do justice to the PHPUnit, given its robustness.

More info about PHPUnit can be found at https://phpunit.de/

We will now move on to the final chapter of this book, where we will reiterate the things
that we learned so far and develop a functional miniature module that involves
some basic testing.

Based on the knowledge aquired from previous chapters, we will now build a miniature Helpdesk
module. Though miniature, the module will showcase the usage of several important
Magento platform features as we go through the following sections:

Registering a module (registration.php and module.xml)

Creating a config file(config.xml)

Creating e-mail templates(email_templates.xml)

Creating a system config file (system.xml)

Creating access control lists (acl.xml)

Creating an installation script (InstallSchema.php)

Managing entity persistence (model, resource, collection)

Building a frontend interface

Building a backend interface

Creating unit tests

Module requirements are as follows:

Name used, Foggyline/Helpdesk

Data to be stored in table is called foggyline_helpdesk_ticket

Tickets entity will contain ticket_id, customer_id, title, severity, created_at and
status properties.

The customer_id property is to be foreign key on the customer_entity table.

There will be three available ticket severity values: low, medium and high

If not specified, the default severity value for new tickets is low

There will be two available ticket statuses: opened and closed

If not specified, the default status value for new tickets is opened

Two e-mail templates: store_owner_to_customer_email_template

and

customer_to_store_owner_email_template are to be defined for pushing e-mail updates
upon ticket creation and status change

Customers will be able to submit a ticket through their My Account section

Customers will not be able to edit any existing tickets

Once a customer submits a new ticket, transactional e-mail (let's call it Foggyline- Helpdesk - Customer
| Store Owner) is sent to the store owner

Configurable option is required for possibly overriding Foggyline - Helpdesk - Customer | Store Owner
e-mail

Admin users will be able to access a list of all tickets under Customers | Helpdesk Tickets

Admin users will be able to change ticket status from Opened to Closed and the other way around

Once an admin user changes the ticket status, transactional e-mail (let's call it Foggyline - Helpdesk
- Store Owner | Customer) is sent to the customer

Configurable option is required for possibly overriding Foggyline - Helpdesk - Store Owner | Customer
e-mail

With the requirements outlined, we are ready to begin our module development.

REGISTERING A MODULE

We first start by defining the app/code/Foggyline/Helpdesk/registration.php file with the
following content:

<?php
\Magento\Framework\Component\ComponentRegistrar::register(\Magento\Framework\Component\ComponentRegistrar::MODULE,
'Foggyline_Helpdesk', __DIR__);
?>

We then define the app/code/Foggyline/Helpdesk/etc/module.xml file with the following content:

<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:
framework:Module/etc/module.xsd">
	<module name="Foggyline_Helpdesk" setup_version="1.0.0">
		<sequence>
			<module name="Magento_Store"/>
			<module name="Magento_Customer"/>
		</sequence>
	</module>
</config>

Looking at the preceeding file, if we strip away the boilerplate that repeats itself accross all modules,
we are left with three important things here:

The module name attribute, defined as Foggyline_Helpdesk. We need to be sure to follow a certain
pattern when naming our modules, like Vendor +_+ Module name. The module name attribute can contain 
only letters and numbers [A-Z, a-z, 0-9, _].

The schema setup_version attribute that defines our module version. Its value can only
contain numbers between 0-9. Our example sets teh value of 1.0.0 for the setup_version

The sequence module name attribute, which defines module dependencies. Our module basically
says it requires Magento_Store and Magento_Customer modules to be enabled.

Once this file is in place, we need to go to the command line, change the dir to that of Magento
installation, and simply execute the following command:

php bin/magento module:enable Foggyline_Helpdesk

However, if we open either the admin of the frontend area in our browser, we might get an error page,
which generates the following error under the var/reports/ folder:

Please upgrade your database: Run "bin/magento setup:upgrade" from the Magento root dir.

Luckily, the error is pretty self-descriptive so we simply move back to the console, change the dir
to the Magento root folder, and execute the following command:

php bin/magento setup:upgrade

Execute commands will activate our module

We can confirm that by looking under the app/etc/config.php file, as shown
in this ss:

app/etc/config.php //Contains all of the settings of stuff

Further, if we log in to the admin area, and go to Stores | Configuration | Advanced | Advanced, we should
see our module listed there, as in the following ss:

<ss>

Now, we will create an app/code/Foggyline/Helpdesk/etc/config.xml file with content as follows:

<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:
module:Magento_Store:etc/config.xsd">
	<default>
		<foggyline_helpdesk>
			<email_template>
				<customer>
					foggyline_helpdesk_email_template_customer
				</customer>
				<store_owner>
					foggyline_helpdesk_email_template_store_owner
				</store_owner>
			</email_template>
		</foggyline_helpdesk>
	</default>
</config>

This might look confusing at first as to where the default | foggyline_helpdesk | email_template
structure comes from. The structure itself denotes the position of our configuration values 
that we will map to the admin interface visible in our browser under the Stores | Configuration section.

Given that all things visual regarding the Stores | Configuration section originate 
from system.xml files, this structure we have now in config.xml will then map to another system.xml
file which we will define soon.

Right now, just remember the structure and values contained within the customer and store_owner
attributes. These values will further map to another email_templates.xml file, which we will soon create.

There is one more important thing regarding the config.xml file. We need to be very careful of the
xsi:noNamespaceSchemaLocation attribute value. This value needs to be set to urn:magento:module:Magento_Store
:etc/config.xsd. It's an alias that actually points to the vendor/magento/module-store/etc/config.xsd file.

Our module requirements specify that two e-mail templates need to be defined.

Hints to this have already been given in the app/code/Foggyline/Helpdesk/etc/config.xml
file previously defined. The actual definition of e-mail templates available to our modules is
done through the app/code/Foggyline/Helpdesk/etc/email_templates.xml file, with
content as follows:

<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:
module:Magento_Email:etc/email_templates.xsd">
	<template id="foggyline_helpdesk_email_template_customer" label="Foggyline Helpdesk - Customer Email"
file ="store_owner_to_customer.html" type="html" module="Foggyline_Helpdesk" area="frontend"/>
	<template id="foggyline_helpdesk_email_template_store_owner" label="Foggyline Helpdesk - Store Owner Email"
file="customer_to_store_owner.html" type="html" module="Foggyline_Helpdesk" area="frontend"/>
</config>

Looking into email_templates.xsd, we can conclude that the value for id, label, file, type,
and module are all required. id should be defined unique to our module, giving some sensible
and reasonable code name to our e-mail templates, as this code name is going to be used
further in other XML files or in code.

What we defined as ID values here, can be found under app/code/Foggyline/Helpdesk/etc/config.xml,
as the value of default | foggyline_helpdesk | email_template | customer and default |
foggyline_helpdesk | email_template | store_owner elements.

If it is not yet fully clear what the connection between the two is; we will get to it
when we start building our system.xml file soon.

The value of the label attribute is something that is visible later on, within the
Magento admin area under Marketing | Communications | Email Templates, so be sure to
put something user friendly and easily recognizable here.

Further, the values of the file attribute point to the location of the following files:

app/code/Foggyline/Helpdesk/view/frontend/email/customer_to_store_owner.html

app/code/Foggyline/Helpdesk/view/frontend/email/store_owner_to_customer.html

The content of the files will be set such later on, in the code, we will need to
pass it on certain variables in order to fill in the variable placeholders.

The customer_to_store_owner.html e-mail template, with content as follows, will be triggered
later on in the code when a customer creates a new ticket:

<!--@subject New Ticket Created @-->
<h1>Ticket #{{var ticket.ticket_id}}
created</h1>

<ul>
	<li>Id: {{var ticket.ticket_id}}</li>
	<li>Title: {{var ticket.title}}</li>
	<li>Created_at: {{var ticket.created_at}}</li>
	<li>Severity: {{var ticket.severity}}</li>
</ul>

Later on, we will see how to pass the ticket object as a variable into the template,
in order to enable calls like {{var ticket.title}} within the HTML template.

The store_owner_to_customer.html e-mail template, with content as follows, will be triggered
later on in the code when the store owner changes the status of a ticket:

<!--@subject Ticket Updated @-->
<h1>Ticket #{{var ticket.ticket_id}} updated</h1>
<p>Hi {{var customer_name}}.</p>

<p>Status of your ticket #{{var ticket.ticket_id}} has been updated</p>

<ul>
	<li>Title: {{var ticket.title}}</li>
	<li>Created_at: {{var ticket.created_at}}</li>
	<li>Severity: {{var ticket.severity}}</li>
</ul>

If we now log in to the Magento admin area, go under Marketing | Communications | Email Templates, click
on the Add New Template button, and we should be able to see our two e-mail templates under the Template
drop-down, as shown in the following SS:

<ss>

If we look back at our config.xml and email_templates.xml, there is still
no clear connection as to what default | foggyline_helpdesk | email_template | customer 
and default | foggyline_helpdesk | email_template | store_owner under config.xml actually
do.

That is because we still lack two more ingredients that will link them together:
the app/code/Foggyline/Helpdesk/etc/adminhtml/system.xml and app/code/Foggyline/Helpdesk/etc/acl.xml files

The system.xml file is essentialy the Stores | Configuration interface builder. Entires we define in our
module's system.xml file will render certain parts of the Stores | Configuration interface
under the Magento admin area.

Unlike the previous two XML files, this config file is located under an additional subfolder,
so its full path goes like app/code/Foggyline/Helpdesk/etc/adminhtml/system.xml with content as follows:

<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Config:etc/system_file.xsd">
	<system>
		<tab id="foggyline" translate="label" sortOrder="200">
			<label>Foggyline</label>
		</tab>
		<section id="foggyline_helpdesk" translate="label" type="text" sortOrder="110"
showInDefault="1" showInWebsite="1" showInStore="1">
			<label>Helpdesk</label>
			<tab>foggyline</tab>
			<resource>Foggyline_Helpdesk::helpdesk</resource>
			<group id="email_template" translate="label" type="text" sortOrder="1"
showInDefault="1" showInWebsite="1" showInStore="1">
				<label>Email Template Options</label>
				<field id="customer" translate="label" type="select" sortOrder="1"
showInDefault="1" showInWebsite="1" showInStore="1">
				<label>Store Owner to Customer Email Template</label>
				<source_model>Magento\Config\Model\Config\Source\Email\Template</source_model>
			</field>
			<field id="store_owner" translate="label" type="select" sortOrder="1" 
showInDefault="1" showInWebsite="1" showInStore="1">
				<label>Customer to Store Owner Email Template</label>
				<source_model>Magento\Config\Model\Config\Source\Email\Template</source_model>
			</field>
		</group>
	</section>
</system>
</config>

//NOTE: ERROR IN TERMS OF INDENTION SOMEWHERE HERE

Even though we have a lot going on in this file, it can all be summed up in a few important bits.

Determining where we want to show our module configuration options is a matter of choice. Either
we define and use our own tab or we use an existing tab from one of the core modules. It really
comes down to where we decide to put our config options.

system.xml defines one tab, as noted by the tab element assigned id attribute value of foggyline.
We can have multiple tabs definder under a single system.xml file. The tab element attribute
id needs to be unique under all tabs, not just those defined within our module. Within the tab
element, we have a label element with the value of Foggyline.

This value is what shows up under the Magento admin Stores | Configuration area.

The final results should be as shown in the following image:

<ss>

Magento has six pre-existing tabs defined (General, Service, Advanced, Catalog, Customer, Sales) across
its core modules. We can easily get a list of all defined tabs in Magento just by doing a search
for the tab string, filtering only on files named system.xml.

Next to the tab element, we have the config | system | section element. This is the element
within which we further define what are to become HTML input fields or accepting config options,
as visible on the previous image.

We can have multiple sections defined within a single system.xml file. The actual
section element attributes require us to specify the id attribute value, which in our 
example is set to foggyline_helpdesk. Other important section element attributes are shownInWebsite
and showInStore. These can have either 0 or 1 as a value.

Depending on our module business logic, we might find a good reason for choosing one value
over the other.

Looking further, the elements contained within our section element are:

label: This specifies the label we will see under the Magento admin Store | Configuration area.

tab: This specifies the ID value of a tab under which we want this section to appear,
which in our case equals to foggyline.

resource: This specifies the ACL resource ID value.

group: This specifies the group of fields. Similar to the section element,
it also has id, sortOrder, showInWebsite, and showInStore attributes.

Further, the group element has child field elements, which translate to HTML input fields
under the Magento admin Store | Configuration area.

We define two fields, customer and store_owner.
Similar to section and group, field elements also have id, sortOrder, showInWebsite, and showInStore
attributes.

Notice how field further contains child elements that define its options. Given that our field
element type attribute was set to select with both fields, we needed to define the source_model
element within each field. Both fields have the same source_model value which points to the 
Magento core class, Magento\Config\Model\Config\Source\Email\Template.

Looking into that class, we can see it implements \Magento\Framework\Option\ArrayInterface
and defines the tOptionArray method. During rendering the admin Stores | Configuration area
Magento will call this method to fill in the values for the select HTML element.

Understanding what we can do with system.xm comes down to understanding what is defined
under vendor/magento/module-config/etc/system_file.xsd and studying existing Magento
core module system.xml files to get some examples.

As noted previously, our system.xml has a resource element that points to the app/code/Foggyline/Helpdesk/etc/acl.xml file, which we will look into.

The app/code/Foggyline/Helpdesk/etc/acl.xml file is where we define our module access control list
resources. Access control list resources are visible under the Magento admin System | Permissions | User Roles area,
when we click on the Add New Role button, as shown in the following SS:

<ss>

Looking at the preceeding ss, we can see our Helpdesk Section under Stores | Settings | Configuration.
How did we put it there? We have defined it in our app/code/Foggyline/Helpdesk/etc/acl.xml
with content as follows:

<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:Acl/etc/acl.xsd">
	<acl>
		<resources>
			<resource
id="Magento_Backend::admin">
				<resource
id="Magento_Customer::customer">
					<resource
id="Foggyline_Helpdesk::ticket_manage" title="Manage Helpdesk Tickets" />
				</resource>
				<resource
id="Magento_Backend::stores">
					<resource
id="Magento_Backend::stores_settings">
						<resource
id="Magento_Config::config">
							<resource id="Foggyline_Helpdesk::helpdesk" title="Helpdesk Section" />
						</resource>
					</resource>
				</resource>
			</resource>
		</resource>
	</acl>
</config>

Looking at the provided code, the immediate conclusion is that resources can be nested into each other.
It is unclear how we should know where to nest our custom-defined resource with an ID value of Foggyline_Helpdesk::helpdesk. The simple answer is we followed the Magento structure.

By looking into a few of the Magento core modules system.xml files and their acl.xml files,
a pattern emerged where modules nest their resource under Magento_Backend::admin | Magento_Backend::stores |
Magento_Backend::stores_settings | Magento_Config::config.

These are all existing resources defined in core Magento, so we are merely referencing them,
not defining them. The only resource we are defining in our acl.xml file is our own which we are 
then referencing from our system.xml file. We can define other resources within acl.xml
and not all would be nested into the same structure as Foggyline_Helpdesk::helpdesk.

The value of the title attribute we assign to a resource element is shown in the admin area, as in the
previous ss.

Be sure to use a descriptive label so that our module resource is easily recognizable.

InstallSchema, or install script, is a way for us to set up tables in the DB that will be used to persist
our models later on. If we look back at the module requirements, the following fields need to be created
in the foggyline_helpdesk_ticket table:

ticket_id

customer_id

title

severity

created_at

status

Our InstallSchema is defined under the app/code/Foggyline/Helpdesk/Setup/InstallSchema.php
file with partial content as follows:

<?php

namespace Foggyline\Helpdesk\Setup;

use Magento\Framework\Setup\InstallSchemaInterface;
use Magento\Framework\Setup\ModuleContextInterface;
use Magento\Framework\Setup\SchemaSetupInterface;

/**
 * @codeCoverageIgnore
 */

class InstallSchema implements InstallSchemaInterface
{
	public function install(SchemaSetupInterface $setup, ModuleContextInterface $context)
	{
		$installer = $setup;

		$installer->startSetup();

		$table = $installer->getConnection()
			->newTable($installer->
getTable('foggyline_helpdesk_ticket'))
		/* ->addColumn ... */
		/* ->addIndex ... */
		/* ->addForeignKey ... */
		->setComment('Foggyline Helpdesk Ticket');

$installer->getConnection()->createTable($table);
		
		$installer->endSetup();
	}
}	

The InstallSchema class conforms to InstallSchemaInterface by implementing a single
install method. Within this method, we start the installer, create new tables, create new fields,
add indexes and foreign keys to the table, and finally end the installer, as shown in the
following code:

->addColumn(
	'ticket_id',
	\Magento\Framework\DB\Ddl\Table::TYPE_INTEGER,
	null,
	['identity' => true, 'unsigned' => true, 'nullable' => false, 'primary' => true], 'Ticket Id'
)
->addColumn(
	'customer_id',
	\Magento\Framework\DB\Ddl\Table::TYPE_INTEGER,
	null,
	['unsigned' => true],
	'Customer Id'
)
->addColumn(
	'title',
	\Magento\Framework\DB\Ddl\Table::TYPE_TEXT,
	null,
	['nullable' => false],
	'Title'
)
->addColumn(
	'severity',
	\Magento\Framework\DB\Ddl\Table::TYPE_SMALLINT,
	null,
	['nullable' => false],
	'Severity'
)
->addColumn(
	'created_at',
	\Magento\Framework\DB\Ddl\Table::TYPE_TIMESTAMP,
	null,
	['nullable' => false],
	'Created At'
)
->addColumn(
	'status',
	\Magento\Framework\DB\Ddl\Table::TYPE_SMALLINT,
	null,
	['nullable' => false],
	'Status'
)
->addIndex(
	$installer->getIdxName('foggyline_helpdesk_ticket', ['customer_id']),
		['customer_id']
)
->addForeignKey(
$installer->getFkName('foggyline_helpdesk_ticket', 'customer_id', 'customer_entity',
'entity_id'),
	'customer_id',
	$installer->getTable('customer_entity'),
	'entity_id',
	\Magento\Framework\DB\Ddl\Table::ACTION_SET_NULL
)

The provided code shows each of the fields from the module requirement being 
added to the DB using the addColumn method call and passing it certain params such as the field
type and nullable state. It is worth getting familiar with the addColumn, addIndex and 
addForeignKey methods as these are most commonly used when specifying new tables for our modules.

We could further deepen our understanding of the installation script by studying how other core
modules handle the InstallSchema.php file, following a good DB design practice, we should
always create indexes and foreign keys on our table when referencing data from other tables.

With InstallSchema in place, we now have conditions for entity persistence. Our next step
is to define model, resource, and collection classes for the Ticket entity.

The Ticket entity model class is defined under the app/code/Foggyline/Helpdesk/Model/Ticket.php
file with content as follows:

<?php

namespace Foggyline\Helpdesk\Model;

class Ticket extends \Magento\Framework\Model\AbstractModel
{
	const STATUS_OPENED = 1;
	const STATUS_CLOSED = 2;
	const SEVERITY_LOW = 1;
	const SEVERITY_MEDIUM = 2;
	const SEVERITY_HIGH = 3;

	protected static $statusesOptions = [
		self::STATUS_OPENED => 'Opened',
		self::STATUS_CLOSED => 'Closed',
	];

	protected static $severitiesOptions = [
		self::SEVERITY_LOW => 'Low',
		self::SEVERITY_MEDIUM => 'Medium',
		self::SEVERITY_HIGH => 'High',
	];

	/**
	 * Initialize resource model
	 * @return void
	 */
	protected function _construct()
	{
		$this->_init('Foggyline\Helpdesk\Model\ResourceModel\Ticket');
	}

	public static function getSeveritiesOptionArray()
	{
		return self::$severitiesOptions;
	}

	public function getStatusAsLabel()
	{
		return self::$statusesOptions[$this->getStatus()];
	}

	public function getSeverityAsLabel()
	{
		return self::$severityOptions[$this->getSeverity()];
	}
}

Reading the preceeding code, we see it extends the \Magento\Framework\Model\AbstractModel class,
which further extends the Magento\Framework\Object class. This brings a lot of extra methods into our
Ticket model class, such as load, delete, save, toArray, toJson, toString, toXml and so on.

The only actual requirement for us is to define the _construct method that, through the _init function
call, specifies the resource class the model will be using when persisting data. We have set this
value to Foggyline\Helpdesk\Model\ResourceModel\Ticket, which will be the next class we will define,
the so-called resource class.

We have further defined several constants, STATUS_* and SEVERITY_*, as a sign of good programming
practice and not to hardcode values that we will use across the code, which we can centralize
into a class constant. These constants, in a way, map to our module requirements.

Additionally, we have three additional methods (getSeveritiesOptionArray, getStatusAsLabel, and
getSeverityAsLabel) that we will use later on in our block class and template file.

The Ticket entity resource class is defined under app/code/Foggyline/Helpdesk/Model/ResourceModel/Ticket.php
with content as follows:

<?php

namespace Foggyline\Helpdesk\Model\ResourceModel;

class Ticket extends \Magento\Framework\Model\ResourceModel\Db\AbstractDb
{
	/**
	* Initialize resource model
	* Get table name from config
	*
	* @return void
	*/

	protected function _construct()
	{
		$this->_init('foggyline_helpdesk_ticket', 'ticket_id');
	}
}

We can see the code extends the \Magento\Framework\Model\ResourceModel\Db\AbstractDb class,
which further extends the \Magento\Framework\Model\ResourceModel\AbstractResource class.

This brings a lot of extra methods into our Ticket resource class, such as load, delete, save, commit,
rollback and so on.

The only actual requirement for us is to define the _construct method, through which we 
call the _init function that accepts two parameters. The first parameter of the _init
function specifies the table name foggyline_helpdesk_ticket and the second parameter
specifies identifying the ticket_id column within that table where we will be persisting data.

Finally, we define the Ticket entity collection class under app/code/Foggyline/Helpdesk/Model/ResourceModel/Ticket/Collection.php with content as follows:

<?php

namespace Foggyline\Helpdesk\Model\ResourceModel\Ticket;

class Collection extends \Magento\Framework\Model\ResourceModel\Db\Collection\AbstractCollection
{
	/**
	* Constructor
	*
	* @return void
	*/
	protected function _construct()
	{
		$this->_init('Foggyline\Helpdesk\Model\Ticket', 'Foggyline\Helpdesk\Model\ResourceModel\Ticket');
	}
}

The collection class code extends the \Magento\Framework\Model\ResourceModel\Db\Collection\AbstractCollection class,
which further extends the \Magento\Framework\Data\Collection\AbstractDb class, which further extends
\Magento\Framework\Data\Collection. The final parent collection class then implements the following
interfaces:

\IteratorAggregate,\Countable,
Magento\Framework\Option\ArrayInterface, and Magento\Framework\Data\CollectionDataSourceInterface.
Through this deep inheritance, a large number of methods become available to our collection class,
such as count, getAllIds, getColumnValues, getFirstItem, getLastItem and so on.

With regard to our newly defined collection class, the only actual requirement for us to define
is the _construct method. Within the _construct method, we call the _init function to which
we pass two parameters. The first parameter specifies the Ticket model class Foggyline\Helpdesk\Model\Ticket
and the second parameter specifies the Ticket resource class Foggyline\Helpdesk\Model\ResourceModel\Ticket.

The three classes we just defined (model, resource, collection) act as an overall single entity persistence
mechanism. With the currently defined code, we are able to save, delete, update, lookup with filtering,
and list our Ticket entities, which we demonstrate in the upcoming sections.

Now that we have defined the necessary minimum for data persistence functionality, we can move forward
to building a frontend interface. The module requirement says that customers should be able to submit
a ticket through their My Account section. We will therefore add a link called
Helpdesk Tickets under the customer's My Account section.

The following are needed for a fully functional frontend:

A route that will map to our controller

A controller that will catch requests from a mapped route

A controller action that will load the layout

Layout XMLs that will update the view making it look as if we are on the My Account
section while providing content of our own

A block class to power our template file

A template file that we will render into the content area of a page

A controller action that will save the New Ticket form once it is posted

We start by defining a route within the app/code/Foggyline/Helpdesk/etc/frontend/routes.xml
file with content as follows:

<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:App/etc/routes.xsd">
	<router id="standard">
		<route id="foggyline_helpdesk" frontName="foggyline_helpdesk">
			<module
name="Foggyline_Helpdesk"/>
	</router>
</config>

Note that the route element id and frontName attributes have the same value, but they do not serve the
same purpose, as we will see soon.

Now we define our controller app/code/Foggyline/Helpdesk/Controller/Ticket.php file with
content as follows:

<?php

namespace Foggyline\Helpdesk\Controller;

abstract class Ticket extends \Magento\Framework\App\Action\Action
{
	protected $customerSession;

	public function __construct(\Magento\Framework\App\Action\Context $context,
\Magento\Customer\Model\Session $customerSession
	)
	{
		$this->customerSession = $customerSession; //Assign the session
		parent::__construct($context); //get context from parent
	}

	public function dispatch(\Magento\Framework\App\RequestInterface $request) //run a dispatch on the request
	{
		if(!$this->customerSession->authenticate()) { //Run to see if Customer is authenticated
			$this->_actionFlag->set('', 'no-dispatch', true); //set the no-dispatch actionFlag

			if(!$this->customerSession->getBeforeUrl()){ //If there is no redirection in place
				$this->customerSession->setBeforeUrl($this->_redirect->getRefererUrl()); //Set a redirection in place
			}
		}
		return parent::dispatch($request); //Run dispatch on the parents request
	}
}

Our controller loads the customer session object through its constructor. The customer session object
is then used within the dispatch method to check if the customer is authenticated or not.
If the customer is not authenticated, all frontend actions in the Browser that leads to this controller
will result in the customer being redirected to the login screen

Once the controller is in place, we can then define the actions that extend from it. Each action
is a class file on its own, extending from the parent class. We will now define our index action,
the one that render the view under My Account | Helpdesk Tickets, within the app/code/Foggyline/Helpdesk/Controller/Ticket/Index.php with content as follows:

<?php

namespace Foggyline\Helpdesk\Controller\Ticket;

class Index extends \Foggyline\Helpdesk\Controller\Ticket
{
	public function execute()
	{
		$resultPage = $this->resultFactory->create(\Magento\Framework\Controller\ResultFactory::TYPE_PAGE);
		return $resultPage;
	}
}

Controller action code lives within the execute method of its class. We simply extend
from the \Foggyline\Helpdesk\Controller\Ticket controller class and define the necessary
logic within the execute method. Simply calling loadLayout and renderLayout is enough to
render the page on the frontend.

The frontend XML layout handles reside under the app/code/Foggyline/Helpdesk/view/frontend/layout folder.
Having the route ID, controller and controller action is enough for us to determine the handle name,
which goes by the formula of:

{route_id}_{controller name}_{controller action name}.xml

Thus, we define an index action layout within the app/code/Foggyline/Helpdesk/view/frontend/layout/foggyline_helpdesk_ticket_index.xml file with content as follows:

<?xml version="1.0"?>

<page xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:View/Layout/etc/page_configuration.xsd">
	<update handle="customer_account"/>
	<body>
		<referenceContainer name="content">
			<block class="Foggyline\Helpdesk\Block\Ticket\Index"
			name="foggyline.helpdesk.ticket.index" template="Foggyline_Helpdesk::ticket/index.phtml"
			cacheable="false" />
		</referenceContainer>
	</body>
</page>

Notice how we immediately call the update directive, passing it the customer_account handle
attribute value. This is like saying, "Include everything from the customer_account handle into our handle here."

We are further referencing the content block, within which we define our own custom block type Foggyline\Helpdesk\Block\Ticket\Index. Though a block class can specify its own template, we are using
a template attribute with a module-specific path.

Foggyline_Helpdesk::ticker/index.phtml, to assign a template to a block.

Simply including the customer_account handle is not enough; We need something
extra to define our link under the My Account section. We define this extra something
under the app/code/Foggyline/Helpdesk/view/frontend/layout/customer_account.xml file
with content as follows:

<?xml version="1.0"?>
<page xmlns:xsi="http://www.w3.org/2001-XMLSchema-instance" xsi:noNamespaceLocation="urn:magento:framework:View/Layout/etc/page_configuration.xsd">
	<head>
		<title>Helpdesk Tickets</title>
	</head>
	<body>
		<referenceBlock name="customer_account_navigation">
			<block class="Magento\Framework\View\Element\Html\Link\Current" name="foggyline-helpdesk-ticket">
				<arguments>
					<argument name="path" xsi:type="string"> foggyline_helpdesk/ticket/index </argument>
					<argument name="label" xsi:type="string">Helpdesk Tickets</argument>
				</arguments>
			</block>
		</referenceBlock>
	</body>
</page>

What is happening here is that we are referencing an existing block called customer_account_navigation
and defining a new block within it of class Magento\Framework\View\Element\Html\Link\Current.

This block accepts two parameters: the path that is set to our controller action and the label that is
set to Helpdesk Tickets.

The Foggyline\Helpdesk\Block\Ticket\Index block class we pointed from foggyline_helpdesk_ticket_index.xml is 
defined under the app/code/Foggyline/Helpdesk/Block/Ticket/index.php with content as follows:

<?php

namespace Foggyline\Helpdesk\Block\Ticket;

class Index extends \Magento\Framework\View\Element\Template
{
	/**
	* @var \Magento\Framework\Stdlib\DateTime
	*/

	protected $dateTime;

	/**
	* @var \Magento\Customer\Model\Session
	*/
	protected $customerSession;

	/**
	* @var \Foggyline\Helpdesk\Model\TicketFactory
	*/
	protected $ticketFactory;

	/**
	* @param \Magento\Framework\View\Element\Template\Context $context
	* @param array $data
	*/

	public function __construct(
		\Magento\Framework\View\Element\Template\Context $context, 
		\Magento\Framework\Stdlib\DateTime $dateTime,
		\Magento\Customer\Model\Session $customerSession,
		\Foggyline\Helpdesk\Model\TicketFactory $ticketFactory,
		array $data = []
	)
	{
		$this->dateTime = $dateTime;
		$this->customerSession = $customerSession;
		$this->ticketFactory = $ticketFactory;
		parent::__construct($context, $data);
	}

	/**
	* @return \Foggyline\Helpdesk\Model\ResourceModel\Ticket\Collection
	*/

	public function getTickets()
	{
		return $this->ticketFactory
			->create()
			->getCollection()
			->addFieldToFilter('customer_id',
$this->customerSession->getCustomerId());
	}

	public function getSeverities()
	{
		return \Foggyline\Helpdesk\Model\Ticket::getSeveritiesOptionArray();
	}
}

The reason why we defined the Foggyline\Helpdesk\Block\Ticket block class instead of using
just \Magento\Framework\View\Element\Template is because we wanted to define some helper
methods we could then use in our index.phtml template. These methods are getTickets (which we will
use for listing all customer tickets) and getSeverities(which we will use for creating a dropdown
of possible severities to choose from when creating a new ticket).

The template is further defined under the app/code/Foggyline/Helpdesk/view/frontend/templates/ticket/index.phtml
file with content as follows:

<?php $tickets = $block->getTickets() ?>
<form
	id="form-validate"
	action="<?php echo $block->
getUrl('foggyline_helpdesk/ticket/save') ?>"
	method="post">
	<?php echo
$block->getBlockHtml('formkey') ?>
	
	<div class="field title required">
		<label class="label" for="title">
<span> <?php echo __('Title') ?></span>
</label>

		<div class="control">
			<input
				id="title"
				type="text"
				name="title"
				data-validate="{required:true}"
				value=""
				placeholder="<?php echo __('Something descriptive') ?>"/>
		</div>
	</div>
	<div class="field severity">
		<label lass="label for severity">
<span><?php echo __('Severity') ?></span>
</label>
		<div class="control">
			<select name="severity">
				<?php foreach
($block->getSeverities() as $value => $name);
?>
					<option value="<?php echo
$value ?>"><?php echo
$this->escapeHtml($name) ?></option>
				<?php endforeach; ?>
			</select>
		</div>
	</div>
	<button type="submit" class="action save primary">
		<span><?php echo __('Submit Ticket')?></span>
	</button>
</form>

<script>
	require([
		'jquery',
		'mage/mage'
	], function($) {
		var dataForm = $('#form-validate');
		dataForm.mage('validation', {});
	});
</script>

<?php if ($tickets->count()): ?>
	<table class="data-grid">
		<?php foreach ($tickets as $ticket):
?>
			<tr>
				<td><?php echo
$ticket->getId() ?></td>
				<td><?php echo
$block->escapeHtml($ticket->getTitle()) ?></td>
				<td><?php echo
$ticket->getCreatedAt() ?></td>
				<td><?php echo
$ticket->getSeverityAsLabel() ?></td>
				<td><?php echo
$ticket->getStatusAsLabel() ?></td>
			</tr>
		<?php endforeach; ?>
	</table>
<?php endif; ?>

Though this is a big chunk of code, it is easily readable as it is divided into a few very different
role-playing chunks.

The $block variable is actually the same as if we wrote $this, which is a rference to the instance of the
Foggyline\Helpdesk\Block\Ticket class where we defined the actual getTickets method. Thus, the
$tickets variable is first defined as a collection of tickets that belong to the currently
logged-in customer.

We then specified a form with a POST method type and an action URL that points to our Save controller action.
Within the form, we have a $block->getBlockHtml('formkey') call, which basically returns a 
hidden input field named form_key whose value is a random string.

Form keys in Magento are a means of preventing against Cross-Site Request Forgery (CRSF), so we need
to be sure to use them on any form we define. As part of the form, we have also defined
a title input field, severity select field, and submit button. Notice the CSS classes tossed around,
which guarantee that our forms look will match to those of other Magento forms.

Right after the closing form tag, we have a RequireJS type of JavaScript inclusion for validation.
Given that our form ID value is set to form-validate, the Javascript dataForm variable binds to it
and triggers a validation check when we press the Submit button.

We then have a count check and a foreach loop that renders all possibly existing customer tickets.

The final result of the template code can be seen in the following image:

<ss>

There is one more piece we are missing in order to complete our frontend functionality - a controller
action that will save the New Ticket form once it is posted. We define this action within the app/code/Foggyline/Helpdesk/Controller/Ticket/Save.php file with content as follows:

<?php

namespace Foggyline\Helpdesk\Controller\Ticket;

class Save extends \Foggyline\Helpdesk\Controller\Ticket
{
	protected $transportBuilder;
	protected $inlineTranslation;
	protected $scopeConfig;
	protected $storeManager;
	protected $formKeyValidator;
	protected $dateTime;
	protected $ticketFactory;

	public function __construct(\Magento\Framework\App\Action\Context $context,
	\Magento\Customer\Model\Session $customerSession,
	\Magento\Framework\Mail\Template\TransportBuilder $transportBuilder,
	\Magento\Framework\Translate\Inline\StateInterface $inlineTranslation,
	\Magento\Framework\App\Config\ScopeConfigInterface $scopeConfig,
	\Magento\Store\Model\StoreManagerInterface $storeManager,
	\Magento\Framework\Data\Form\FormKey\Validator $formKeyValidator,
	\Magento\Framework\Stdlib\DateTime $dateTime,
	\Foggyline\Helpdesk\Model\TicketFactory $ticketFactory
	)
	{
		$this->transportBuilder = $transportBuilder;
		$this->inlineTranslation = $inlineTranslation;
		$this->scopeConfig = $scopeConfig;
		$this->storeManager = $storeManager;
		$this->formKeyValidator = $formKeyValidator;
		$this->dateTime = $dateTime;
		$this->ticketFactory = $ticketFactory;
		$this->messageManager = $context->getMessageManager();
			parent::__construct($context, $customerSession);
	}

	public function execute()
	{
		$resultRedirect = $this->resultRedirectFactory->create();

		if(!$this->formKeyValidator->validate($this->getRequest())){
			return $resultRedirect->setRefererUrl();
		}

		$title = $this->getRequest()->getParam('title');
		$severity = $this->getRequest()->getParam('severity');

		try{
			/* Save Ticket */

			$ticket = $this->ticketFactory->create();

			$ticket->setCustomerId($this->customerSession->getCustomerId());
			$ticket->setTitle($title);
			$ticket->setSeverity($severity);

			$ticket->setCreatedAt($this->dateTime->formatDate(true));
			$ticket->setStatus(\Foggyline\Helpdesk\Model\Ticket::STATUS_OPENED);
			$ticket->save();

			$customer = $this->customerSession->getCustomerData();

			/* Send email to store owner */
			$storeScope = \Magento\Store\Model\ScopeInterface::SCOPE_STORE;

			$transport = $this->transportBuilder->setTemplateIdentifier($this->scopeConfig->
getValue('foggyline_helpdesk/email_template/store_owner', $storeScope))
->setTemplateOptions(
	[
		'area' => \Magento\Framework\App\Area::AREA_FRONTEND,
		'store' => $this->storeManager->getStore()->getId(),
	]
)
->setTemplateVars(['ticket' => $ticket])
->setFrom([
	'name' => $customer->getFirstName() . '' . $customer->getLastName(), 
	'email' => $customer->getEmail()
	])

addTo($this->scopeConfig->getValue(
'trans_email/ident_general/email',
$storeScope))
		->getTransport();

	$transport->sendMessage();

$this->inlineTranslation->resume();

$this->messageManager->addSuccess(__('Ticket successfully created'.));
		} catch(Exception $e) {
			$this->messageManager->addError(__('Error occurred during ticket creation.'));
		}
		return $resultRedirect->setRefererUrl();
	}
}

First, we look at __construct to see what params are passed to it. Given that the code we run in the
execute method needs to check if the form key is valid, create a ticket in the DB, pass on the ticket
and some customer info to the e-mail that is being sent to the store owner; Then we get 
an idea of what kind of objects are being passed around.

The execute method starts by checking the validity of the form key. If the form key is invalid,
we return with a redirection to the referring URL.

Passing the form key check, we grab the title and severity variables as passed by the form.
We then instansiate ticket entity by the ticket factory create method and simply set the ticket
entity values one by one. 

Note that the Ticket entity model Foggyline\Helpdesk\Model\Ticket does not really have methods like
setSeverity on its own. This is the inherited property of its \Magento\Framework\Object parent class.

Once the ticket entity is saved, we initiate the transport builder object, passing along all of the
required parameters for successful e-mail sending. Notice how setTemplateIdentifier uses our system.xml
config option foggyline_helpdesk/email_template/store_owner. 

This, if not specifically set under the admin Store | Config | Foggyline | Helpdesk area,
has a default value defined under config.xml that points to the e-mail template ID in the email_templates.xml file.

setTemplateVars expects the array or instance of \Magento\Framework\Object to be passed ot it.
We pass the entire $ticket object to it, just nesting it under the ticket key, thus making the props of 
a Ticket entity, like a title, become available in the e-mail HTML template as {{var ticket.title}}

When a customer now submits the New Ticket form from My Account | Helpdesk Tickets, the HTTP POST request
will hit the save controller action class. If the preceeding code is successfully executed, the ticket
is saved to the DB and redirection back to My Account | Helpdesk Tickets will occur showing a Ticket successfully
created message, in the browser.

Until now, we have been dealing with setting up general module configs, e-mail templates,
frontend route, frontend layout, block and template. What remains to complete the module
requirements is the admin interface, where the store owner can see submitted tickets and change
statuses from open to closed.

The following are needed for a fully functional admin interface as per the requirements:

ACL resource used to allow or disallow to the ticket listing

Menu item linking to tickets listing the controller action

Route that maps to our admin controller

Layout XMLs that map to the ticket listing the controller action

Controller action for listing tickets

Full XML layout grid definition within layout XMLs defining grid, custom column
renderers and custom dropdown filter values

Controller action for closing tickets and sending e-mails to customers

We start by adding a new ACL resource entry to the previously defined app/code/Foggyline/Helpdesk/etc/acl.xml
file, as a child of the Magento_Backend::admin resource as follows:

<resource id="Magento_Customer::customer">
	<resource
id="Foggyline_Helpdesk::ticket_manage" title="Manage Helpdesk Tickets"/>
</resource>

On its own, the defined resource entry does not do anything. This resource will later be used
within the menu and controller.

The menu item linking to the tickets listing the controller action is defined
under the app/code/Foggyline/Helpdesk/etc/adminhtml/menu.xml file as follows:

<?xml version="1.0"?>

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Backend:etc/menu.xsd">
	<menu>
		<add
id="Foggyline_Helpdesk::ticket_manage"
title="Helpdesk Tickets"
module="Foggyline_Helpdesk"

parent="Magento_Customer::customer"
action="foggyline_helpdesk/ticket/index"

resource="Foggyline_Helpdesk::ticket_manage"/>
	</menu>
</config>

We are using the menu | add element to add a new menu item under the Magento admin area.
The position of an item within the admin area is defined by the attribute parent,
which in our case means under the existing Customer menu.

If the parent is omitted, our item would appear as a new item on a menu. The title attribute
value is the label we will see in the menu. the id attribute has to uniquely differentiate our
menu item from others. The resource attribute references the ACL resource defined in the 
app/code/Foggyline/Helpdesk/etc/acl.xml file.

If a role of a logged-in user does not allow him to use the Foggyline_Helpdesk::ticket_manage resource,
the user would not be able to see the item menu.

Now, we add a route that maps to our admin controller, by defining the app/code/Foggyline/Helpdesk/etc/adminhtml/routes.xml file as follows:

<?xml version="1.0"?>

<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:App/etc/routes.xsd">
	<router id="admin">
		<route id="foggyline_helpdesk"
frontName="foggyline_helpdesk">
			<module
name="Foggyline_Helpdesk"/>
		</route>
	</router>
</config>

The admin route definition is almost identical to the frontend router definition, where the difference primarily
lies in the router id value, which equals to the admin here

With the router definition in place, we can now define our three layout XMLs, under the app/code/Foggyline/Helpdesk/view/adminhtml/layout dir, which map to the ticket listing the controller action:

foggyline_helpdesk_ticket_grid.xml

foggyline_helpdesk_ticket_grid_block.xml

foggyline_helpdesk_ticket_index.xml

The reason we define three layout files for a single action controller and not one is because
of the way we use the listing in control in the Magento admin area.

The content of the foggyline_helpdesk_ticket_index.xml file is defined as follows:

<?xml version="1.0" encoding="UTF-8"?>

<page xmlns:xsi:="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:View/Layout/etc/page_configuration.xsd">
	<update handle="formkey"/>
	<update
handle="foggyline_helpdesk_ticket_grid_block"/>
	<body>
		<referenceContainer name="content">
			<block class="Foggyline\Helpdesk\Block\Adminhtml\Ticket" name="admin.block.helpdesk.ticket.grid.container">
		</block>
		</referenceContainer>
	</body>
</page>

Two update handles are specified, one pulling in formkey and the other pulling in foggyline_helpdesk_ticket_grid_block. We then reference the content container and define a new block of the Foggyline\Helpdesk\Block\Adminhtml\Ticket class with it.

We could have used Magento\Backend\Block\Widget\Grid\Container as a block class name. However, given
that we needed some extra logic, like removing the Add New button, we opted for a custom class that then
extends the \Magento\Backend\Block\Widget\Grid\Container and adds the requried logic.

The Foggyline\Helpdesk\Block\Adminhtml\Ticket class is defined under the app/code/Foggyline/Helpdesk/Block/Adminhtml/Ticket.php file as follows:

<?php

namespace Foggyline\Helpdesk\Block\Adminhtml;

class Ticket extends \Magento\Backend\Block\Widget\Grid\Container
{
	protected function _construct()
	{
		$this->_controller = 'adminhtml';
		$this->_blockGroup = "Foggyline_Helpdesk";
		$this->_headerText = __('Tickets');

		parent::_construct();

		$this->removeButton('add');
	}
}

Not much is happening in the Ticket block class here. Most importantly, we extend from
\Magento\Backend\Block\Widget\Grid\Container and define _controller and _blockGroup, as these
serve as a sort of glue for telling our grid where to find other possible block classes.

Since we won't have an Add New ticket feature in admin, we are calling the removeButton method to remove
the default Add New button from the grid container.

Back to our second XML layout file, the foggyline_helpdesk_ticket_grid.xml file, which we
defined as follows:

<?xml version="1.0"?>

<layout xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceLocation="urn:magento:framework:View/Layout/etc/layout_generic.xsd">
	<update handle="formkey"/>
	<update
handle="foggyline_helpdesk_ticket_grid_block"/>
	<container name="root">
		<block class="Magento\Backend\Block\Widget\Grid\Container"
name="admin.block.helpdesk.ticket.grid.container" template="Magento_Backend::widget/grid/container/empty.phtml"/>
	</container>
</layout>

Notice how the content of foggyline_helpdesk_ticket_grid.xml is nearly 
identical to that of foggyline_helpdesk_ticket_index.xml. The only difference between the two
is the value of the Block class and the template attribute. The Block class is defined as
Magento\Backend\Block\Widget\Grid\Container, where we previously defined it as Foggyline\Helpdesk\Block\Adminhtml\Ticket.

If we look at the content of the \Magento\Backend\Block\Widget\Grid\Container class, we can see the following
property defined:

protected $_template = 'Magento_Backend::widget/grid/container.phtml';

If we look at the content of the vendor/magento/module-backend/view/adminhtml/templates/widget/grid/container.phtml and vendor/magento/module-backend/view/adminhtml/templates/widget/grid/container/empty.phtml files,
the difference can be easily spotted. container/empty.phtml only returns grid HTML, whereas container.phtml
returns buttons and grid HTML.

Given that foggyline_helpdesk_ticket_grid.xml will be a handle for the AJAX loading grid listing during 
sorting and filtering, we need it to return only grid HTML upon reload.

We now move on to the third and largest of XML's layout files, the app/code/Foggyline/Helpdesk/view/adminhtml/layout/foggyline_helpdesk_ticket_grid_block.xml file. Given the size of it, we will split it into two code chunks
as we explain them one by one.

The first part, or initial content of the foggyline_helpdesk_ticket_grid_block.xml file, is
defined as follows:

<?xml version="1.0" encoding="UTF-8"?>

<page xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:View/Layout/etc/page_configuration.xsd">
	<body>
		<referenceBlock name="admin.block.helpdesk.ticket.grid.container">
			<block class="Magento\Backend\Block\Widget\Grid" name="admin.block.helpdesk.ticket.grid" as="grid">
				<arguments>
					<argument name="id" xsi:type="string"> ticketGrid</argument>
					<argument name="dataSource" xsi:type="object">
					Foggyline\Helpdesk\Model\ResourceModel\Ticket\Collection
					</argument>
					<argument name="default_sort" xsi:type="string">ticket_id</argument>
					<argument name="default_dir" xsi:type="string">desc</argument>
					<argument name="save_parameters_in_session" xsi:type="boolean">true</argument>
					<argument name="use_ajax" xsi:type="boolean">true</argument>
				</arguments>
				<block class="Magento\Backend\Block\Widget\Grid\ColumnSet" name="admin.block.helpdesk.ticket.grid.columnSet" as="grid.columnSet">
					<!-- Column definitions here -->
				</block>
			</block>
		</referenceBlock>
	</body>
</page>

Notice <!-- Column definitions here -->; we will come back to that soon. For now,
let's analyze what is happening here. Right after a body element, we have a reference to
admin.block.helpdesk.ticket.grid.container which is a content block child defined under
the foggyline_helpdesk_ticket_grid.xml and foggyline_helpdesk_ticket_index.xml files.

Within this reference, we are defining another block of class Magento\Backend\Block\Widget\Grid,
passing it a name of our choosing and an alias Further, this block has an arguments list and another
block of class Magento\Backend\Block\Widget\Grid\ColumnSet as child elements.

Through the arguments list we specify the:

id: Set to the value of ticketGrid, we can set any value we want here, ideally sticking to formula {entity name}

dataSource: Set to the value of Foggyline\Helpdesk\Model\ResourceModel\Ticket\Collection, which is the name
of our Ticket entity resource class.

default_sort: Set to the value of ticket_id, which is the property of the Ticket entity by which we want to sort.

default_dir: Set to the value of desc, to denote a descending order of sorting. This value functions
together with default_sort as a single unit.

save_parameters_in_session: Set to true, this is easiest to explain using the following example: if we do
some sorting and filtering on the Ticket grid and then move on to another part of the admin area, then come
back to the Ticket grid, if this value is set to yes, the grid we will see will have those
filters and sorting set.

use_ajax: Set to true, when grid filtering and sorting is triggered, an AJAX loader kicks in and reloads only
the grid area and not the whole page.

Right after the grid blocks argument list, we have the grid column set. This brings us to the second
part of foggyline_helpdesk_ticket_grid_block.xml content. We simply replace the <!-- Columns Here -->
comment with the following:

<block class="Magento\Backend\Block\Widget\Grid\Column" as="ticket_id">
	<arguments>
		<argument name="header" xsi:type="string" translate="true">ID</argument>
		<argument name="type" xsi:type="string">number</argument>
		<argument name="id" xsi:type="string">ticket_id</argument>
		<argument name="index" xsi:type="string">ticket_id</argument>
	</arguments>
</block>
<block class="Magento\Backend\Block\Widget\Grid\Column" as="title">
	<arguments>
		<argument name="header" xsi:type="string" translate="true">Title</argument>
		<argument name="type" xsi:type="string">string</argument>
		<argument name="id" xsi:type="string">title</argument>
		<argument name="index" xsi:type="string">title</argument>
	</arguments>
</block>
<block class="Magento\Backend\Block\Widget\Grid\Column" | as="severity">
	<arguments>
		<argument name="header" xsi:type="string" translate="true">Severity</argument>
		<argument name="index" xsi:type="string">severity</argument>
		<argument name="type" xsi:type="string">options</argument>
		<argument name="options" xsi:type="options" model="Foggyline\Helpdesk\Model\Ticket\Grid\Severity"/>
		<argument name="renderer" xsi:type="string">Foggyline\Helpdesk\Block\Adminhtml\Ticket\Grid\Renderer\Severity</argument>
		<argument name="header_css_class" xsi:type="string"> col-form_id</argument>
		<argument name="column_css_class" xsi:type="string"> col-form_id</argument>
	</arguments>
</block>
<block class="Magento\Backend\Block\Widget\Grid\Column" as="status">
	<arguments>
		<argument name="header" xsi:type="string" translate="true">Status</argument>
		<argument name="index" xsi:type="string">status</argument>
		<argument name="type" xsi:type="string">options</argument>
		<argument name="options" xsi:type="options" model="Foggyline\Helpdesk\Modal\Ticket\Grid\Status"/>
		<argument name="renderer" xsi:type="string"> Foggyline\Helpdesk\Block\Adminhtml\Ticket\Grid\Renderer\Status
		</argument>
		<argument name="header_css_class" xsi:type="string"> col-form_id</argument>
		<argument name="column_css_class" xsi:type="string"> col-form_id</argument>
	</arguments>
</block>
<block class="Magento\Backend\Block\Widget\Grid\Column" as="action">
	<arguments>
		<argument name="id" xsi:type="string">action</argument>
		<argument name="header" xsi:type="string" translate="true">Action</argument>
		<argument name="type" xsi:type="string">action</argument>
		<argument name="getter" xsi:type="string">getId</argument>
		<argument name="filter" xsi:type="boolean">false</argument>
		<argument name="sortable" xsi:type="boolean">false</argument>
		<argument name="actions" xsi:type="array">
			<item name="view_action" xsi:type="array">
				<item name="caption" xsi:type="string" translate="true">Close</item>
				<item name="url" xsi:type="array">
					<item name="base" xsi:type="string">*/*/close</item>
				</item>
				<item name="field" xsi:type="string">id</item>
			</item>
		</argument>
		<argument name="header_css_class" xsi:type="string"> col-actions</argument>
		<argument name="column_css_class" xsi:type="string"> col-actions</argument>
	</arguments>
</block>

Similar to grid, column definitions also have arguments that define its look and behavior:

header: Mandatory, the value we want to see as a label on top of the column

type: Mandatory, can be anything from: date, datetime, text, longtext, options, store,
number, currency, skip-list, wrapline and country

id: Mandatory, a unique value that identifies our column, preferably matching the name
of the entity property

index: Mandatory, the database column name

options: Optional, if we are using a type like options, then for the options argument
we need to specify the class like Foggyline\Helpdesk\Model\Ticket\Grid\Severity that implements
\Magento\Framework\Option\ArrayInterface, meaning it provides the toOptionArray method that
then fills the values of options during grid rendering.

renderer: Optional, as our Ticket entities store severity and status as integer vals in the db,
columns would render those ints into columns, which is not really useful. We want to turn those
ints into labels. In order to do so, we need to rewrite the rendering bit of a single table cell,
which we do with the help of the renderer argument.

The value we pass to it, Foggyline\Helpdesk\Block\Adminhtml\Ticket\Grid\Renderer\Severity,
needs to be a class that extends \Magento\Backend\Block\Widget\Grid\Column\Renderer\AbstractRenderer
and does its own implementation of the render method.

header_css_class: Optional, if we prefer to specify a custom header class.

column_css_class: Optional, if we prefer to specify a custom column class.

The Foggyline\Helpdesk\Block\Adminhtml\Ticket\Grid\Renderer\Severity class, defined 
in the app/code/Foggyline/Helpdesk/Block/Adminhtml/Ticket/Grid/Renderer/Severity.php file
as follows:

<?php

namespace Foggyline\Helpdesk\Block\Adminhtml\Ticket\Grid\Renderer;

class Severity extends \Magento\Backend\Block\Widget\Grid\Column\Renderer\AbstractRenderer
{
	protected $ticketFactory;

	public function __construct(\Magento\Backend\Block\Context $context,
	\Foggyline\Helpdesk\Model\TicketFactory $ticketFactory,
	array $data = []
	)
	{
		parent::__construct($context, $data);
		$this->ticketFactory = $ticketFactory;
	}

	public function render(\Magento\Framework\DataObject $row)
	{
		$ticket = $this->ticketFactory->create()->load($row->getId());

		if($ticket && $ticket->getId()){
			return $ticket->getSeverityAsLabel();
		}
		return '';
	}
}

Here, we are passing the instance of the ticket factory to the constructor and then using
that instance within the render method to load a ticket based on the ID value fetched from 
the current row.

Given that $row->getId() returns the ID of the ticket, this is a nice way to reload the entire ticket
entity and then fetch the full label from the ticket model by using $ticket->getSeverityAsLabel().

Whatever string we return from this method is what will be shown under the grid row.
Another renderer class that is referenced within the foggyline_helpdesk_ticket_grid_block.xml file
is Foggyline\Helpdesk\Block\Adminhtml\Ticket\Grid\Renderer\Status, and we define its content under
the app/code/Foggyline/Helpdesk/Block/Adminhtml/Ticket/Grid/Renderer/Status.php file as follows:

<?php

namespace Foggyline\Helpdesk\Block\Adminhtml\Ticket\Grid\Renderer;

class Status extends \Magento\Backend\Block\Widget\Grid\Column\Renderer\AbstractRenderer
{
	protected $ticketFactory;

	public function __construct(\Magento\Backend\Block\Context $context,
	\Foggyline\Helpdesk\Model\TicketFactory $ticketFactory, 
	array $data = []
	)
	{
		parent::__construct($context, $data);
		$this->ticketFactory = $ticketFactory;
	}

	public function render(\Magento\Framework\DataObject $row)
	{
		$ticket = $this->ticketFactory->create()->load($row->getId());

		if ($ticket && $ticket->getId()){
			return $ticket->getStatusAsLabel();
		}

		return '';
	}
}

Given that it too is used for a renderer, the content of the Status class is nearly
identical to the content of the Severity class. We pass on the ticket factory object
via the constructor, so we have it internally for usage within the render method.

Then we load the Ticket entity using the ticket factory and ID value fetched from a $row object.
As a result, the column will contain the label value of a status and not its integer value.

Besides referencing renderer classes, our foggyline_helpdesk_ticket_grid_block.xml file
also references the options class for the Severity field.

We define the Foggyline\Helpdesk\Model\Ticket\Grid\Severity options class under the 
app/code/Foggyline/Helpdesk/Model/Ticket/Grid/Severity.php file as follows:

<?php

namespace Foggyline\Helpdesk\Model\Ticket\Grid;

class Severity implements \Magento\Framework\Option\ArrayInterface
{
	public function toOptionArray()
	{
		return \Foggyline\Helpdesk\Model\Ticket::getSeveritiesOptionArray();
	}
}

The options value from XML layouts refers to a class that has to implement the toOptionArray method,
which returns an array of arrays, such as the following example:

return [
	['value'=>'theValue1', 'theLabel1'],
	['value'=>'theValue2', 'theLabel2'],
];

Our Severity class simply calls the static method we have defined on the Ticket class,
the getSeveritiesOptionArray, and passes along those values.

Up to this point, we have defined the menu item, ACL resource, XML layouts, block, options class
and renderer classes. What remains to connect it all are controllers. We will need three controller
actions (Index, Grid and Close), all extending from the same admin Ticket controller.

We define the admin Ticket controller under the app/code/Foggyline/Helpdesk/Controller/Adminhtml/Ticket.php file
as follows:

<?php

namespace Foggyline\Helpdesk\Controller\Adminhtml;

class Ticket extends Magento\Backend\App\Action
{
	protected $resultPageFactory;
	protected $resultForwardFactory;
	protected $resultRedirectFactory;

	public function __construct(\Magento\Backend\App\Action\Context $context,
	\Magento\Framework\View\Result\PageFactory $resultPageFactory,
	\Magento\Backend\Model\View\Result\ForwardFactory $resultForwardFactory
	)
	{
		$this->resultPageFactory = $resultPageFactory;
		$this->resultForwardFactory = $resultForwardFactory;
		$this->resultRedirectFactory = $context->getResultRedirectFactory();
		parent::__construct($context);
	}

	protected function _isAllowed()
	{
		return $this->_authorization->isAllowed('Foggyline_Helpdesk::ticket_manage');
	}

	protected function _initAction()
	{	
		$this->_view->loadLayout();
		$this->_setActiveMenu('Foggyline_Helpdesk::ticket_manage'
		)->_addBreadcrumb(
			__('Helpdesk'),
			__('Tickets')
		);
		return $this;
	}
}

There are a few things to note here:

$this->resultPageFactory

$this->resultForwardFactory

$this->resultRedirectFactory are objects to be used on the child (Index, Grid and Close),
so we do not have to initiate them in each child class separately.

The _isAllowed() method is extremely important every time we have custom-defined controller
or controller action that we want to check against our custom ACL resource.

Here, we are the isAllowed method call on the \Magento\Framework\AuthorizationInterface
type of object ($this->_authorization). The param passed to the isAllowed method call should
be the ID value of our custom ACL resource.

We then have the _initAction method, which is used for setting up logic shared across child classes,
usually things like loading the entire layout, setting up the active menu flag, and adding 
breadcrumbs.

Moving forward, we define the Index controller action within the app/code/Foggyline/Helpdesk/Controller/Adminhtml/Ticket/Index.php file as follows:

<?php

namespace Foggyline\Helpdesk\Controller\Adminhtml\Ticket;

class Index extends \Foggyline\Helpdesk\Controller\Adminhtml\Ticket
{
	public function execute()
	{
		if($this->getRequest()->getQuery('ajax')){
			$resultForward = $this->resultForwardFactory->create();
			$resultForward->forward('grid');
			return $resultForward;
		}
		$resultPage = $this->resultPageFactory->create();

		$resultPage->setActiveMenu('Foggyline_Helpdesk::ticket_manage');

		$resultPage->getConfig()->getTitle()->prepend(__('Tickets'));

		$resultPage->addBreadcrumb(__('Tickets'),
		__('Tickets'));
		$resultPage->addBreadcrumb(__('Manage Tickets'), __('Manage Tickets'));

		return $resultPage;
	}
}

Controller actions execute within their own class, within the execute method. Our execute method
first checks if the coming request is the AJAX param within it. If there is an AJAX param, the request
is forwaded to the Grid action of the same controller.

If there is no AJAX controller, we simply create the instance of the \Magento\Framework\View\Result\PageFactory object, and set title, active menu item, and breadcrumbs in it.

A logical question at this point would be how does all of this work and where can we see it. If we log
in to the Magento admin area, under the Customers menu we should be able to see the Helpdesk Tickets menu item.

This time, defined previously within app/code/Foggyline/Helpdesk/etc/adminhtml/menu.xml, says the menu
action attribute equals to foggyline_helpdesk/ticket/index, which basically translates to the Index action
of our Ticket controller.

Once we click on the Helpdesk Tickets link, Magento will hit the Index action within its Ticket
controller and try to find the XML file that has the matching route {id}+{controller name}+{controller action name}+{xml file extension}, which in our case translates to {foggyline_helpdesk}+{ticket}+{index}+{xml}

At this point, we should be able to see the screen, as shown in the following SS:

<ss>

However, if we now try to use sorting or filtering, we would get a broken layout. This is because
based on arguments defined under the foggyline_helpdesk_ticket_grid_block.xml file,
we are missing the controller Grid action. When we use sorting or filtering, the AJAX request
hits the Index controller and asks to be forwarded to the Grid action, which we haven't defined yet.

We now define the Grid action within the app/code/Foggyline/Helpdesk/Controller/Adminhtml/Ticket/Grid.php file
as follows:

<?php

namespace Foggyline\Helpdesk\Controller\Adminhtml\Ticket;

class Grid extends \Foggyline\Helpdesk\Controller\Adminhtml\Ticket
{
	public function execute()
	{
		$this->_view->loadLayout(false);
		$this->_view->renderLayout();
	}
}

There is only one execute method with the Grid controller action class, which is expected.
The code within the execute method simply calls the loadLayout(false) method to
prevent the entire layout loading, making it load only the bits defined under the
foggyline_helpdesk_ticket_grid.xml file. This effectively returns the grid HTML to the AJAX,
which refreshes the grid on the page.

Finally, we need to handle the Close action link we see on the grid. This link was 
defined as part of the column definition within the foggyline_helpdesk_ticket_grid_block.xml
file and points to */*/close, which translates to "router as relative from current URL/ controller as relative from current URL / close action", which further equals to our Ticket controller Close action.

We define the Close controller action under the app/code/Foggyline/Helpdesk/Controller/Adminhtml/Ticket/Close.php file as follows:

<?php

namespace Foggyline\Helpdesk\Controller\Adminhtml\Ticket;

class Close extends \Foggyline\Helpdesk\Controller\Adminhtml\Ticket
{
	protected $ticketFactory;
	protected $customerRepository;
	protected $transportBuilder;
	protected $inlineTranslation;
	protected $scopeConfig;
	protected $storeManager;

	public function __construct(\Magento\Backend\App\Action\Context $context,
	\Magento\Framework\View\Result\ForwardFactory $resultForwardFactory,
	\Foggyline\Helpdesk\Model\TicketFactory $ticketFactory,
	\Magento\Customer\Api\CustomerRepositoryInterface $customerRepository,
	\Magento\Framework\Mail\Template\TransportBuilder $transportBuilder,
	\Magento\Framework\Translate\Inline\StateInterface $inlineTranslation,
	\Magento\Framework\App\Config\ScopeConfigInterface $scopeConfig,
	\Magento\Store\Model\StoreManagerInterface $storeManager)
	{
		$this->ticketFactory = $ticketFactory;
		$this->customerRepository = $customerRepository;
		$this->transportBuilder = $transportBuilder;
		$this->inlineTranslation = $inlineTranslation;
		$this->scopeConfig = $scopeConfig;
		$this->storeManager = $storeManager;
		parent::__construct($context, $resultPageFactory, $resultForwardFactory);
	}

	public function execute()
	{
		$ticketId = $this->getRequest()->getParam('id');
		$ticket = $this->ticketFactory->create()->load($ticketId);

		if($ticket && $ticket->getId()){
			try{
				$ticket->setStatus(\Foggyline\Helpdesk\Model\Ticket::STATUS_CLOSED);
				$ticket->save();

				$this->messageManager->addSuccess(__('Ticket successfully closed.'));

				/* Send email to Customer */
				$customer = $this->customerRepository->getById($ticket->getCustomerId());
				$storeScope = \Magento\Store\Model\ScopeInterface::SCOPE_STORE;
				$transport = $this->transportBuilder->setTemplateIdentifier($this->scopeConfig->
getValue('foggyline_helpdesk/email_template/customer', $storeScope))
				->setTemplateOptions([
					'area' => \Magento\Framework\App\Area::AREA_ADMINHTML,
					'store' => $this->storeManager->getStore()->getId(),
					]
				)
				->setTemplateVars([
'ticket' => $ticket, 'customer_name' => $customer -> getFirstname()
				])
				->setForm([
					'name' => $this->scopeConfig->getValue('trans_email/ident_general/name', $storeScope),
				'email' => $this->scopeConfig->getValue('trans_email/ident_general/email', $storeScope)])
				->addTo($customer->getEmail())
					->getTransport();
					$transport->sendMessage();

				$this->inlineTranslation->resume();

				$this->messageManager->addSuccess(__('Customer notified via email.'));
			} catch (Exception $e) {
				$this->messageManager->addError(__('Error with closing ticket action.'));
			}
		}

		$resultRedirect = $this->resultRedirectFactory->create();
			$resultRedirect->setPath('*/*/index');

		return $resultRedirect;
	}
}

The Close action controller has two seperate roles to fulfill. One is to change
the ticket status; the other is to send an e-mail to the customer using the proper
e-mail template. The class constructor is being passed a lot of params that all
instansiate the object we will be juggling around.

Within the execute action, we first check for the existence of the id parameter and then
try to load a Ticket entity through the ticket factory and then try to load a Ticket entity
through the ticket factory, based on the provided ID value. If the ticket exists,
we set its status label to \Foggyline\Helpdesk\Model\Ticket::STATUS_CLOSED and save it.

Following the ticket save is the e-mail sending code, which is very similar to the one
that we already saw in the customer New Ticket save action. The difference is that the e-mail
goes out from the admin user to the customer this time.

We are setting the template ID to the config value at path foggyline_helpdesk/email_template/customer.
The setTemplateVars method is passed to the member array this time, both ticket and customer_name,
as they are both used in the e-mail template. The setForm method is passed the general store username
and e-mail, and the sendMessage method is called on the transport object.

Finally, using the resultRedirectFactory object, the user is redirected back to the tickets grid.
With this, we finalze our module functional requirement.

Though we are done with the functional requirement of a module, what remains for us as devs 
is to write tests. There are several types of tests, such as unit, functional integration and so on.
To keep things simple, within this chapter we will cover only unit tests across a single model class.

This chapter assumes that we have PHPUnit configed and available on the CMD line. If this is not the case,
PHPUnit can be installed using instructions from the https://phpunit.de/ website.

To build and run tests using the PHPUnit testing framework, we need to define test locations
and other config options via an XML file. Magento defines this XML config file under
dev/tests/unit/phpunit.xml.dist.

Let's make a copy of that file under dev/tests/unit/phpunit-foggyline-helpdesk.xml with
adjustments as follows:

<?xml version="1.0" encoding="UTF-8"?>

<phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://schema.phpunit.de/4.1/phpunit.xsd" colors="true" bootstrap="./framework/bootstrap.php">
	<testsuite name="Foggyline_Helpdesk - Unit Tests">
		<directory suffix="Test.php">
../../../app/code/Foggyline/Helpdesk/Test/Unit
		</directory>
	</testsuite>
	<php>
		<ini name="date.timezone" value="Europe/Zagreb"/>
		<ini name="xdebug.max_nesting_level" value="200"/>
	</php>
	<filter>
		<whitelist addUncoveredFilesFromWhiteList="true">
			<directory suffix=".php">
../../../app/code/Foggyline/Helpdesk/*
			</directory>
			<exclude>
				<directory>../../../app/code/Foggyline/Form/Helpdesk</directory>
			</exclude>
		</whitelist>
	</filter>
	<logging>
		<log type="coverage-html" target="coverage_dir/Foggyline_Helpdesk/test-reports/coverage" 
charset="UTF-8" yui="true" highlight="true"/>
	</logging>
</phpunit>

We are making a special XML config file for our module alone because we want to quickly run a few of the
tests contained within our module alone and not the entire Magento app/code folder.

Given that the actual art of writing unit tests is beyond the scope of this book and writing a full
unit test with 100% code coverage for this simple module would require at least a dozen more pages,
we will only write a single test, one that covers the Ticket entity model class.

We define our Ticket entity model class test under the app/code/Foggyline/Helpdesk/Test/Unit/Model/TicketTest.php file as follows:

<?php

namespace Foggyline\Helpdesk\Test\Unit\Model;

class TicketTest extends \PHPUnit_Framework_TestCase
{
	protected $objectManager;
	protected $ticket;

	public function setUp()
	{
		$this->objectManager = new \Magento\Framework\TestFramework\Unit\Helper\ObjectManager($this);
		$this->ticket = $this->objectManager->getObject('Foggyline\Helpdesk\Model\Ticket');
	}

	public function testGetSeveritiesOptionArray()
	{
		$this->assertNotEmpty(\Foggyline\Helpdesk\Model\Ticket::getSeveritiesOptionArray());
	}

	public function testGetStatusAsLabel()
	{
		$this->ticket->setStatus(\Foggyline\Helpdesk\Model\Ticket::STATUS_CLOSED);

		$this->assertEquals(\Foggyline\Helpdesk\Model\Ticket::$statusesOptions [\Foggyline\Helpdesk\Model\Ticket::STATUS_CLOSED], 
		$this->ticket->getStatusAsLabel());
	}

	public function testGetSeverityAsLabel()
	{
		$this->ticket->setSeverity(\Foggyline\Helpdesk\Model\Ticket::SEVERITY_MEDIUM);

		$this->assertEquals(\Foggyline\Helpdesk\Model\Ticket::$severitiesOptions [\Foggyline\Helpdesk\Model\Ticket::SEVERITY_MEDIUM],

		$this->ticket->getSeverityAsLabel()
		);
	}
}

The location of test files should map those of the files being tested. The naming of the
test file should also follow the naming of the file being tested with the suffix Test attached to it.
This means that if our Ticket model is located under the modules Model/Ticket.php file, then our test
should be located under Test/Unit/TicketTest.php

Our Foggyline\Helpdesk\Test\Unit\Model\TicketTest extends the \PHPUnit_Framework_TestCase class.
There is a setUp method we need to define, which acts like a constructor, where we set up
the variables and everything that requires initializing.

Using Magento ObjectManager, we instansiate the Ticket model, which is then used within the
test Methods. The actual test methods follow a simple naming pattern, where the name
of the method from the Ticket model matches the {test}+{method name} from the TicketTest class.

We defiend our four test methods:

testGetSeveritiesOptionArray,
testGetStatusesOptionArray,
testGetStatusAsLabel,
testGetSeverityAsLabel.

Within the test methods, we are using only assertEquals and assertNotEmpty
methods from the PHPUnit testing frameworklibrary to do basic checks.

We can now open a console, change the dir to our Magento install dir, and execute
the following command:

phpunit -c dev/tests/unit/phpunit-foggyline-helpdesk.xml

After the command executes, the console should show an output as shown:

PHPUnit 4.7.6 by Sebastian Bergmann and contributors ....

Time: 528 ms, Memory: 11.50Mb

OK (4 tests, 4 assertions)

Generating code coverage report in HTML format ... done

Looking back at our dev/tests/unit/phpunit-foggyline-helpdesk.xml file, under the
target attribute of the phpunit > logging > log element, we can see that the test report
is dumped into the coverage_dir/Foggyline_Helpdesk/test-reports/coverage folder relative
to the XML file.

If we open the dev/tests/unit/coverage_dir/Foggyline_Helpdesk/test-reports/coverage/ folder,
we should see a whole lot of files generated here, as shown in the following ss:

<ss>

Opening the index.html file in the brwoser should yield a result akin to a ss with
a legend of all relevant things we tested.

We can see the code coverage report showing 60% on lines and methods for our Model
folder and 0% for the rest. This is because we only wrote the test for the Ticket entity model
class, whereas the rest remain untested.

This chapter gave a full step-by-step guide to writing a simple yet functional
Magento module. Seemingly simple in terms of functionality, we can see that the module
code is significantly scattered across multiple PHP, XML and PHTML files.

With this simple module, we covered quite a lot of various Magento platform parts, from routes,
ACLs, controllers, blocks, XML layouts, grids, controller actions, models, resources, collections,
install scripts, interactions with session, e-mail templates, e-mail transport, and layout objects.

At the end we wrote a few simple unit tests for our models. Although the practice is to write
until tests for all of our PHP code, we opted for a shorter version or else we would need
more pages to cover everything.

The full module code is available here: https://github.com/ajzele/B05032-Foggyline_Helpdesk.

With this being the last chapter, let us look at a short overview of these things we learned
throughout the whole book. OUr journey started by grasping the Magento platform architechture,
where we gained significant insighti nto the tech stack behind it.

We then progressed to env management. Although it might seem like a wrong order of things,
we opted for this next step in order to quickly get us set for development. We then looked into
programming concepts and conventions, which served as a precursor to actual hands-on dev bits.

Details of entity persistence were shown through model, resource, collection classes, and indexers.
We further covered the importance and practical details of dependency injection and interception.
Backend and frontend-related dev was covered in their own two chapters, outlingin the most
common bits and pieces for making customization to our Magento platform.

We then dug into details of the web API, showing how to make authenticated API calls and even
define our own APIs. Along the way, we covered a few major function areas as well, such as customers,
reports, import export, cart and so on. The testing and QA took up a significant chunk as we briefly
covered all forms of available tests.

Finally, we used what we learned to build a fully functional moduel.

Although we have covered a significant path on our journey, this is merely a first step.
Given its massive code base, diverse tech stacks, and feature list, Magento is not an easy
platform to master. Hopefully, this book will give enough incentive to take steps into
profiling ourselves as true Magento experts.

