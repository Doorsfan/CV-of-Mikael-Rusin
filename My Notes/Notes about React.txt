If we wish to see if React is installed on a Linux system, we can write:

$ npm -v

To install the npm and run it:

$ npm install

$ npm start

If we wish to run the local version of the app, we can do as follows:

http://localhost:3000

To quit running a node server, we can do CTRl+C

To see the layout:

$ ls -ip

The folder we work from is public/:

$ ls -ip public

In the $ ls -ip public/js folder, the AP's JS is located.

An example of a startup code of a project in JS, React:

<html>
	<head>
		<meta charset="utf-8">
		<title>My Title</title>
		<link rel="stylesheet" href="./semantic/dist/semantic.css" />
		<link rel="stylesheet" href="./style.css" />
		<script src="vendor/babel-standalone.js"></script>
		<script src="vendor/react.js"></script>
		<script src="vendor/react-dom.js"</script>
	</head>
	<body>
		<div class="main ui text container">
			<h1 class="ui dividing centered header">Popular Products</h1>
			<div id="content"></div>
		</div>
		<script src="./js/seed.js"></script>
		<script src="./js/app.js"></script>
		<!-- Relevant part -->
		<script
			type="text/babel"
			data-plugins="transform-class-properties"
			src="./js/app-complete.js"
		></script>
	</body>
</html>

NOTE: This book uses Semantic UI layout for handling UI aspects, much akin how to BS handles stuff

React generally consists of components put together. They are self-contained and contained in one place. Meaning they are reusable.

To build components, at least in regards to this book, we'll do it in public/js/app.js:

class productList extends React.Component { //Every class inherits from the React.component superclass. It is imported in the <script src="vendor/react.js"></script>
	render() {
		return (
			<div className='ui unstackable items'>
				Hello, friend! This is a component.
			</div>
		);
	}
}


There are two ways we can create classes in React, either by explicit declaraton as we see above with inheritance from React.Component, or by calling the React.createClass:

const HelloWorld = React.createClass({
	render() { return(<p>This is what we build and then return to the React to handle</p>)}
})

React uses a Virtual DOM to represent the arguments sent to it.

Also, the JS used by React is JSX, which is a Extension of JS that allows for being parsed into vanilla JS but is written slightly different, returning HTML documents for the
React to integrate into the DOM.

The DOM is the Document Object Model, which is the hierarchy of all the HTML elements.

An illustration on the reason for usage of JSX:

React.createElement('div', {className: 'ui items'}, 
	'Hello, friend! I am a Element created by teh React createElement'
)

Which, in JSX is:

<div className='ui items'>
	Hello, Friend! I am a basic react component.
</div>

The difference becomes clearer in nested structures:

React.createElement('div', {className: 'ui items'},
	React.createElement('p', null, 'Hello Friend! This is a react component put into another component.')
)

In JSX:

<div className="ui items">
	<p>
		Hi friend. This is a react component!
	</p>
</div>

To access the Console in the Web app:

Command + Option + J on Mac

CTRL + Shift + L on Windows/Linux

To make sure that ES6 is converted to ES5 to account for backwards compability we use the Babel library to be able to transpile between them.
We can change the following in index.html:

<script src=".js/seed.js"></script>
<script
	type="text/babel"
	data-plugins="transform-class-properties"
	src="./js/app.js"
></script>

Note, we still have to call the React render method, as follows: //in the app.js:

class ProductList extends React.Component {
	render(){
		return (
			<div className='ui unstackable items'>
				Hello, friend! This is a React component. 
			</div>
		);
	}
}

ReactDOM.render(
	<ProductList />, //The what
	document.getElementById('content') //the where
);

The general syntax of rendering stuff from the ReactDOM.render call is ReactDOM.render(<what>, <where>)

To build the child component of the title saying of the screen, we can do as follows:

class Product extends React.Component {
	render() {
		return(
			<div>
				{//Stuff to do}
			</div>
		);
	}
}


ReactDom.render(
	//Do stuff
);

The complete setup of the product, is as follows:

class Product extends React.Component{ //Build the child component to include in the parent later
	render(){ //run the render
		return( //stuff to be returned to React to simulate in the DOM.
			<div className='item'> //JSX code that gets returned that we transpile to Es5/Es6 to be compatible with earlier stuff
				<div className='image'> //The divs and stuff in JSX
					<img src='images/products/image-aqua.png' />
				</div>
				<div className='middle aligned content'>
					<div className='description'>
						<a>Fort Knight</a>
						<p>Authentic shit, yo</a>
					</div>
					<div className='extra'> //class is a reserved JS name, so we use className which is later translated in the transpilation of babel
						<span>Submitted by: </span>
						<img
							className='ui avatar image'
							src='images/avatars/daniel.jpg'
						/>
					</div>
				</div>
			</div>
		);
	}
}

To then use the child component in the parent component, we do as follows:

class ProductList extends React.Component {
	render() {
		return (
			<div className='ui unstackable items'>
				<Product /> //Include the child setup of Product in the parent, which runs the stuff in the Virtual DOM by the React handler 
			</div>
		);
	}
}

NOTE: Both of the parent and the child, when it comes to a page, are in the same js file.

The problem with the above code is that it is not data driven, i.e it is static. It does not dynamically update with data. We have to change this, by accessing the
data-model.

The seed of our objects is in the public/js/seed.js:

const products = [
	{
		id: 1,
		title: 'Yellow Pail',
		description: 'On-demand sand castle construction expertise',
		url: '#',
		votes: generateVoteCount(),
		submitterAvatarURL: 'images/avatars/daniel.jpg',
		productImageURL: 'images/products/image-aqua.png',
	},
	....

We wish to modify the hierarchy so that it is:

Seed.js -> Product List -> Product/Product/Product etc.

To modify the way the data flows, we can use something akin to templating of the objects in the seeding, as follows:

in the public/js/app-3.js

class ProductList extends React.Component {
	render(){
		const product = Seed.products[0];
		return (
			<div className='ui unstackable items'>
				<Product
					id={product.id}
					title={product.title}
					description={product.description} //in JSX, {} delimeters means that it contains a JS expression
					url={product.url}
					votes={product.votes}
					submitterAvatarUrl={product.submitterAvatarUrl}
					productImageUrl={product.productImageUrl}
				/>
			</div>
		);
	}
}

NOTE: JSX attribute values must be delimeted by {} or ''

NOTE: use const and let, instead of var. var is function scope based, const is refering to constant and let is refering to declaration.
And let and const are block scoped, instead of function scoped

When we refactor the app-3.js parts into using the templates, we get dynamic values that are used by the seeding js, as follows:

class Product extends React.Component{
	render() {
		return (
			<div className='item'>
				<div className='image'>
					<img src={this.props.productImageUrl} />
				</div>
				<div className='middle aligned content'>
					<div className='header'>
						<a>
							<i className ='large caret up icon' />
						</a>
						{this.props.votes}
					</div>
					<div className='description'>
						<a href={this.props.url}>
							{this.props.title}
						</a>
						<p>
							{this.props.description}
						</p>
					</div>
					<div className='extra'>
						<span>Submitted by:</span>
						<img
							className='ui avatar image'
							src={this.props.submitterAvatarUrl}
						/>
					</div>
				</div>
			</div>
		);
	}
}

To render several products, we map the products of the array of products:

In public/js/app-4.js

class ProductList extends React.Component {
	render() {
		const productComponents = Seed.products.map((product) => (
			<Product
				key={'product-' + product.id} //This is specific to react, that it creates unique bindings that it ties to each product with relevant product ID
				id={product.id}
				title={product.title}
				description={product.description}
				url={product.url}
				votes={product.votes}
				submitterAvatarUrl={product.submitterAvatarUrl}
				productImageUrl={product.productImageUrl}

			/>
		));
	}
}

The above will cause a Array to be mapped of the products and then stored in JSX which then gets converted into JS by the babel transpiler.

our productsComponents array would look like as follows:

[
	<Product id={1} ... />
	etc.
]

in JS it would look like:

[
	React.createElement(Product, { id: 1, ...})
	etc.
]

The Array's map() function takes a function as an argument, and constructs an array from elements it finds - Being called once for each element

Now we just have to modify the render call in what it returns:

return (
	<div className='ui unstackable items'>
		{productComponents}
	</div>
);

In ES6, we have anonymous functions as well, called arrow functions, which do not require a explicit function declaration of doing stuff, where we can map stuff
without having to actually make a method for it, as follows:

Assume we have a constant:

const cities = [
	{ name: 'Cairo', pop: 100000},
	{ name: 'Lagos', pop: 800000}
];

If the arrow function consists of more than one line, we must include a return statement:

const formattedPopulations = cities.map((city) => {
	const popMM = (city.pop / 100000).toFixed(2);
	return popMM + ' million';
});
console.log(formattedPopulations);

//outputs ["7.76 Million", "8.03 Million"]

As forementioned, if onyl one line:

const formattedPopulations = cities.map((city) => (
	(city.pop / 100000).toFixed(2) + ' million'
));

Or if we wish to make it shorter:

const pops = cities.map(city => city.pop);
console.log(pops);
// [ 776400, 802900 ]


If we wish to sort the array, we can use sort() on it: //WARNING: using sort() mutates the array. Mutation can be errornous.

class ProductList extends React.Component {
	render() {
		const products = Seed.products.sort((a, b) => (
			b.votes - a.votes //if returned is less than 0, a comes first, since b has lower index. If is 0, they are equal. Otehrwise, b comes first.
		));

		const productComponents = products.map((product) => (
			<Product ...
		))
	}
}

NOTE: If sort() is omitted of it's optional argument, it simply runs comparison of index values based on unicode values
, if a function is supplied, it's return value is used to sort

In React, it supports one-way data flow. Which means that Child components cannot change parent component, because they do not own them. The parent owns all child components.

The reason we cannot change the this.props, is mostly because it's immutable. We need to propogate change from the top of the chain to let it go down.

We can propogate the event by allowing the child to communicate in function which is propogated down from the parent:

in public/js/app-6.js

class ProductList extends React.Component {
	handleProductUpVote(productId) {
		console.log(productId + ' was upvoted.');
	}

	render() {

	}

We have to pass down the prop in each product component as well:

in /js/app-6.js

	const ProductComponents = products.map((product) => (
		<Product
			key={'product-' + product.id}
			id={product.id}
			title={product.title}
			description={product.description}
			url={product.url}
			votes={product.votes}
			submitterAvatarUrl={product.submitterAvatarUrl}
			productImageUrl={product.productImageUrl}
			onVote={this.handleProductUpVote}
		/>
	));

We can now access this function in products by virtue of the function name:

inside of the product object:

handleUpVote() {
	this.props.onVote(this.props.id);
}

React supports mouse driven events such as clicks, integrated into itself:


render(){
	//Inside render for Product
	<div className='middle aligned content'>
		<div className='header'>
			<a onClick={this.handleUpVote}> //Access the handleUpVote function integrated on clicking to the link element
				<i className='large caret up icon' />
			</a>
			{this.props.votes}
		</div>
}


NOTE: For some special cases of react classes, such as render, a standard constructor has already been used, but when we have custom madeo nes, we have to make our own, 
to prevent default assignment of null value to this. Solution to this in the app-6.js:

class Product extends React.Component {
	constructor(props) {
		super(props); //References the parents constructor, which is the React.Component constructor
		//binds the this inside of THIS constructor

		//When we make custom methods in React, we must always bind the this, to make it understand what we are doing

		this.handleUpVote = this.handleUpVote.bind(this); //Bind the this for the custom method
	}
}

The anonymous function calls of => resolves the need for workarounds of different approaches in terms of handling what this we are accessing (instead of accessing global, we acces
the objects this instead.)

In React, objects are rendered due to props and state in a deterministic way. If we can acess the state, directly in the object, we can change it. Every time a state if changed,
it causes it to reflect in terms of what occurs in the Rendering via the React. Thus, we can put the state in the constructor, directly, as follows:

class ProductList extends React.Component {
	constructor(props) {
		super(props);

		this.state = { //Define the state to be the array
			products: [], //define products to be an empty array
		};
	}

	componentDidMount() {
		this.setState({ products: Seed.products }); //mount the components by virtue of accessing the Seeds products
		//Note: It is very important to use the setter, instead of outside. Due to the fact of bypassing hooks, if we try to circumvent the setter
	}
}


The next part, is that we modify the render to make it accomedate for the state set, instead of reading from the Seed JS:

render() {
	const products = this.state.products.sort((a, b) => (
		b.votes - a.votes
	));
}

Note, we should always initialize our state to be empty, to accomedate for asyncrhonous calls later on to fill up the state.


To keep the state imutable, to avoid mutation and unwanted changing of said state, we could keep it static and use the .concat() to create a new array with the proposed
value changes:

//NOte: The whole purpose of mapping to new arrays, cloning and doing all of this, is to avoid causing modifications to the original state so that the state is immutable,
//That way we assert that the only update to values is new values which have been modified in a intentional way.
//Seperation is a good way to prevent bugs in future builds, due to the fact of avoiding the unintenitonal change of the state or akin

The correct example of handling the state as a immutable source, to avoid mutation, is as follows:

	//inside productlist

	handleProductUpVote(productId) {
		const nextProducts = this.state.products.map((product) => { //First we use the map to return a new mappep array of the version, which we then call functions on
		//Note, that calling map on something, iterates one function call per object, that is how come we can compare productId and product.id
			if (product.id == productId) { //if the current product.id matches productId which we get from calling the handleUpVote
				return Object.assign({}, product, { //make a copy and overwrite the values of the votes in the object
					votes: product.votes + 1, //overwrite it by increase it by 1
				});
			} else {
				return product; //otherwise, just return the same product
			}
		});
		this.setState({ //finally, set the state through setState
			products: nextProducts, //set the value to modify products to reflect the value we got from operating on the map
		});
	}

The Object.Assign() call accepts other objects and transfers attributes unto said objects.

If We call it as we did, we find that we end up in a situation where we assign a empty object the values of the product and then modify the values of said object,
by modifying the values of the new object.

The last modification we have to make, is to update the this binding of our Component:

class ProductList extends React.Component {
	constructor(props) {
		super(props);

		this.state = {
			products: [],
		};

		this.handleProductUpVote = this.handleProductUpVote.bind(this);
	}

}

if we wish, we can use experiemntal functions of babel to refactor and improve certain things. an example, which is something that is most likely to stay, and is ratified
(ratify means upcoming in new versions), is using Property Initializers by virtue of arrow functions in the Constructor.

This allows for bypassing manual allocation of this bindings, and let's us drop the constructor part:

class Product extends React.Component {
	handleUpVote = () => (
		this.props.onVote(this.props.id)
	);

	render() {
		...
	}
}


And with property initializers, we don't need to use constructors in the initial state, as follows:

class ProductList extends React.Component {
	state = {
		products: [],
	};

	handleProductUpVote = (productId) => {
		const nextProducts = this.state.products.map((products) => {
			if (product.id === productId) {
				return Object.assign({}, product, {
					votes: product.votes + 1,
				});
			} else {
				return product;
			}
		});
		this.setState({
			products: nextProducts,
		});
	}
}

By virtue of using the arrow functions, we assert that the this has been bound properly to the respective attributes and we can surpass the need of using manual allocation of this and we can surpass having to use constructors manually. 

NOTE: The difference between a prop and a state, is that a prop is a immutable that is passed down to a child component. 

A state, is a private state that is a snapshot of what it's current state is.

The difference between stateless and stateful components, is as follows:

A stateless component: Only props, no state. Simple, and all logic revolves around the props they recieved. 

A stateful component: Both props and states. AKA state managers. They are in charge of client-server communication (XHR, web sockets, etc.) 

Note: Each Component has a set of Lifecycle methods, that means they are called at differing points of time related to the Component. 

if a licecycle method is called with will, it will be called before something happens, did causes it to be right after something happens

The lifecycle events are as follows:

Mounting: //occurs when DOM insertion occurs or component creation

constructor()

componentWillMount()

render()

componentDidMount()

Updating: //Called when component re-renders. Can be by change to state or prop:

componentWillRecieveProps()

shouldComponentUpdate()

componentWillupdate()

render()

componentDidUpdate()

Unmounting: //Called upon removal from DOM

componentWillUnmount()

To preview the app:

$ cd time_tracking_app //the file

$ npm install //install dependancies

$ npm start //start the server

$ ls -ip //prepare the App

//Note: Assets are the HTML stuff we use to render the page

//Note: JSON stands for JavaScript Object Notation , it enables serialization of JS objects and reading/writing it to text files

$ cd public //navigate to public
$ ls -ip //show all stuff in folder

//Note: the index.html is where we involve all the JS and the CSS

An example of the index.html where we are going to put in the code:

<html>
	<head>
		<meta char-set="utf-8">
		<title>Fok u</title>
		<link rel="stylesheet" href="./semantic/dist/semantic.css" />
		<link rel="stylesheet" href="styles.css" />
		<script src="vendor/babel-standalone.js"></script>
		<script src="vendor/react.js"></script>
		<script src="vendor/react-dom.js"></script>
		<script src="vendor/uuid.js"></script>
		<script srC="vendor/fetch.js"></script>
	</head>

	<body>
		<div id="main" class="main ui">
			<h1 class="ui dividing centered header">Timers</h1>
			<div id="content"></div> //Is where we will mount our React app
		</div>
		<script type="text/babel" src="./js/client.js"></script>
		<script type="text/bale" src="./js/helpers.js"></script>
		<script //import a specific JS, in our case, a custom one
			type="text/babel"
			data-plugins="transform-class-properties"
			src="./js/app.js"
		></script>
		<!-- Delete shit past this point -->
		<script //would import the entire thing
			type="text/babel"
			data-plugins="transform-class-properties"
			src="./js/app-complete.js"
		></script>
	</body>
</html>


Note: A component should only be responsible for one functionality per component.

The structure of this app is the same as before, except with TimerList and Timer components.

This app, further more, uses a + form widget.

The general hiearchy that we find after analyzing the app, is  :

TimersDashboard (parent)

ToggleableTimerForm (Right 1 child )

TimerForm (Right 1, has ToggleableTimerForm parent)

EditableTimerList( child of TimersDashboard)

EditableTimer(Child of EditableTimerList)

Timer and Timerform (Each a child of EditableTimer)

the TimersDashboard will communicate with a server to dynamically update it's values, by retrieving data.json from it and setting it to it's own state.

The 7 steps of building a react app, is as follows:

1. Break into components

2. Static version of app

3. determine what should be stateful

4. determine which component each piece of state should live

5. hard-coded initial states

6. Inverse data-flow //Communication through defining props and passing it down and causes interaction in terms of handling "up" communication

7. Connect it to a server

We'll begin by making a static version of it:

class TimersDashboard extends React.Component { //Declare the main component
	render() { //run the render
		return ( //return the stuff for React to simulate in the virtual DOM
			<div className='ui three column centered grid'> //Define the div
				<div className='column'> //Another div
					<EditableTimerList /> //Add component #1
					<ToggleableTimerForm //add component #2
						isOpen={true} //option for component of + sign
					/>
				</div>
			</div>
		);
	}
}

//Components

class EditableTimerList extends React.Component { //Declare child component for Parent component
	render() { //run the render
		return ( //return the stuff for React to simulate in the virtual DOM
			<div id='timers'> 	//divs id is timers
				<EditableTimer //Define the options for the edit form being NOT open
					title='Learn React'
					project='Web Domination'
					elapsed='80000000'
					runningSince={null}
					editFormOpen={false}
				/>
				<EditableTimer //Define options for when it is open
					title='Learn Extreme Ironing'
					project='World Domination'
					elapsed='10000'
					runningSince={null}
					editFormOpen={true}
				/>
			</div>
		);
	}
}


//We then make the EditableTimer 

class EditableTimer extends React.Component{
	render(){
		if (this.props.editFormOpen) { //If the editForm is open
			return ( //return for React to deal with in simulating DOM
				<TimerForm //pass down attributes to the TimerForm so it can modify thoose
					title={this.props.title}
					project={this.props.project}
				/>
			);
		} else {
			return ( //return for React to deal with in simulating DOM
				<Timer //pass down so we can modify them
					title={this.props.title}
					project={this.props.project}
					elapsed={this.props.elapsed}
					runningSince={this.props.runningSince}
				/>
			);
		}
	}
}


//We then build the TimerForm, which is one of the lowest subsets of Components

class TimerForm extends React.Component {
	render() {
		const submitText = this.props.title ? 'Update' : 'Create'; //Update if true, Create if false
		return (
			<div className='ui centered card'>
				<div className='content'>
					<div className='ui form'>
						<div className='field'>
							<label>Title</label>
							<input type='text' defaultValue={this.props.title} />
						</div>
						<div className='field'>
							<label>Project</label>
							<input type='text' defaultValue={this.props.project} />
						</div>
						<div className='ui two bottom attached buttons'>
							<button className='ui basic blue button'>
								{submitText}
							</button>
							<button className='ui basic red button'>
								Cancel
							</button>
						</div>
					</div>
				</div>
			</div>
		);
	}
}

//NOTE: when we assign attributes so that the default value is undefined in text context, it is left empty

//We create the Timer component

class Timer extends React.Component{
	render(){
		const elapsedString = helpers.renderElapsedString(this.props.elapsed); //use a helper function to render the elapsed time in HH:MM:SS
		return(
			<div className='ui centered card'>
				<div className='content'>
					<div className='header'>
						{this:props.title}
					</div>
					<div className='meta'>
						{this.props.project}
					</div>
					<div className='center aligned description'>
						<h2>
							{elapsedString}
						</h2>
					</div>
					<div className='extra content'>
						<span className='right floated edit icon'>
							<i className='edit icon' />
						</span>
						<span className='right floated trash icon'>
							<i className='trash icon'>
						</span>
					</div>
				</div>
				<div className='ui button attached blue basic button'>
					Start
				</div>
			</div>
		);
	}
}

Then, to render the App, we simply put this at the bottom:

ReactDOM.render(
	<TimerDashboard />
	document.getElementById('content')
);

We can follow a few criterias to define what should be stateful:

1. Is it passed in from a Parent via props? if so, probably is not a state //helps clear duplication

2. Does it change over time? If not, it probably is not a state. //Key criteria

3. can you compute it based on any other state or prop in your component? If so, not a state //Keep it simple

Going through the different things:

TimerDashboard: isOpen boolean //Data is defined here, changes over time and cannot be extrapulated

EditableTimerList: Timer props. // Defined here, changes over time, cannot be computed from other sources

EditableTimer: editFormOpen //Defined there, changes over time, cannot be computed from other sources

Now, to decide in what component each piece of state should live:

Identify every component that renders something based on said state

Find a common owner component

Either the common owner or higher, should own the state

If no place makes sense, make one for explicitly holding the state up in the hierarchy, above common owner component

The next step, is to hardcode the stuff in, before we make interaction with Servers:

An example of adding states to TimesDashboard:

class TimesDashboard extends React.Component{
	state = {
		timers: [
			{
				title: 'Practice Squat',
				project: 'Gym Chores',
				id: uuid.v4(), //Creates a unique ID string to assign to id
				elapsed: 5456099,
				runningSince: Date.now(),
			},
			{
				title: 'Bake Squash',
				project: 'Kitchen Chores',
				id: uuid.v4(),
				elapsed: 10000,
				runningSince: null,
			},
		],
	};

	render() {
		return (
			<div className='ui three column centered grid'>
				<div className='column'>
					<EditableTimerList
						timers={this.state.timers}
					/>
					<ToggleableTimerForm />
				</div>
			</div>
		);
	}
}

And an example of recieving props in EditableTimerList:

class EditableTimerList extends React.Component {
	render() {
		const timers = this.props.timers.map((timer) => ( //Run a map on all the timers 
			<EditableTimer
				key={timer.id} //map the values
				id={timer.id}
				title={timer.title}
				project={timer.project}
				elapsed={timer.elapsed}
				runningSince={timer.runningSince}
			/>
		));
		return ( //Return the setup of having implemented the timers
			<div id='timers'>
				{timers}
			</div>
		);
	}
}


Note: If a state updates, that element and all of it's children re-renders

And then we add states to EditableTimer:

class EditableTimer extends React.Component{
	state = {
		editFormOpen: false,
	};

	render() {
		if (this.state.editFormOpen) {
			return (
				<TimerForm
					id={this.props.id}
					title={this.props.title}
					project={this.props.project}
				/>
			);
		} else {
			return (
				<Timer
					id={this.props.id}
					title={this.props.title}
					project={this.props.project}
					elapsed={this.props.elapsed}
					runningSince={this.props.runningSince}
				/>
			);
		}
	}
}


We then create the ToggleableTimeform:

class ToggleableTimeform extends React.Component {
	state = {
		isOpen: false,
	};

	handleFormOpen = () => {
		this.setState({ isOpen: true });
	};

	render(){
		if (this.state.isOpen) {
			return {
				<TimerForm />
			};
		} else{
			return (
				<div className='ui basic content center aligned segment'>
					<button 
						className='ui basic button icon'
						onClick={this.handleFormOpen}
					>
						<i className='plus icon' />
					</button>
				</div>
			);
	}
}

//NOTE: as per usual, there is some indention error here, but cba to find it atm

Next, we add states, as we are entering territory of using forms, and in React, they are stateful:

When we define states that depend upon the this.props attributes, we must define them to be initialized inside the constructor.
Due to accounting for that we could be creating new timers, instead of already passing down working ones, we account for this
with a or statement in assigment:

class TimerForm extends React.Component{
	constructor(props) {
		super(props);

		this.state = { //Assignment of this.props accessing must be done in the constructor
			title: this.props.title || '', //we account for that it is either a existing attribute or undefined (if creating new), if it is undefined, we make the || satement
			project: this.props.project || '',
		};
	}
}


First off, we have to account for the fact of that we wish to make the data follow the state that is put and that it follows the computers state.
To account for this, we make assignment of the value directly, as per:

value={this.state.title}

Further more, to account for event handling, we implement the onChange event handler, to account for change in data:

<div className='field'>
	<label>Title</label>
	<input
		type='text'
		value={this.state.title} //Bind the value to initializaation of the actual prop
		onChange={this.handleTitleChange} //bind the on change event handler to account for changes in values
	/>
</div>
<div className='field'> //Each form that we have, has fields, and each field we account for by assigning respective name to div, handling label, handling input, binding value
	<label>Project</label> //and then handling on change events
	<input
		type='text'
		value={this.state.project}
		onChange={this.handleProjectChange}
	/>
</div>

And as for the handleProjectChange and handleTitleChange, they look as follows:

handleTitleChange = (e) => {
	this.setState({ title: e.target.value });
};

handleProjectChange = (e) => {
	this.setState({ project: e.target.value });
};

An example of a lifecycle of a form would be as follows:

1. timer with title

2. User toggles open the edit form for this timer, mounting TimerForm to the page

3. TimeForm initializes the state property title to the string "Mow the Lawn"

4. User modifies the input field, changing it to the value "Cut the Grass"


5. On every keystroke, React invokes the handleTitleChange. This causes the internal state to be changed.

The TimerForm form needs two event handlers.

One for when forms are submitted (creation or updating of a timer)

When the close button is pressed (closing the form)

TimerForm will have two functions passed down, to handle each event:

props.onFormSubmit() //When form is submitted

props.onFormClose() //When cancel is pressed.

These are to be implemented in the parents.

An example of adding the buttons with interactivity:

<div classname="ui two bottom attached buttons">
	<button
		className='u1 basic blue button'
		onClick={this.handleSubmit}
	>
		{submitText}
	</button>
	<button
		className='ui basic red button'
		onClick={this.props.onFormClose}
	>
		Cancel
	</button>
</div>

The handlesubmit function:

handleSubmit = () => {
	this.props.onFormSubmit({
		id: this.props.id,
		title: this.state.title,
		project: this.state.project,
	});
};

render() {
	....
}


In the TimerForm, we update the render to account for wether the object has been spawned or not:

render() {
	const submitText = this.props.id ? 'Update' : 'Create';
}

We then move up the hiearchy and start working on the higher up functions:

handleFormOpen = () => {
	this.setState({ isOpen: true });
};

handleFormClose = () => {
	this.setState({ isOpen: false });
};

handleFormSubmit = (timer) => {
	this.props.onFormSubmit(timer);
	this.setState({ isOpen: false });
};

render() {
	if (this.state.isOpen) {
		return (
			<TimerForm
				onFormSubmit={this.handleFormSubmit} //calls it's own handleFormSubmit function 
				onFormClose={this.handleFormClose} //Handle the closing of the form
			/>
		);
	} else{

	}
	
}


And now, we have reached the top of the hierarchy, that is where we will pass down stuff for the leaf functions:

handleCreateFormSubmit = (timer) => {
	this.createTimer(timer);
};

createTimer = (timer) => {
	const t = helpers.newTimer(timer); //Create a new Timer object
	this.setState({ //Define the setting of state
		timers: this.state.timers.concat(t),
	});
};

render(){
	return (
		<div className='ui three column centered grid'>
			<div className='column'>
				<EditableTimerList
					timers={this.state.timers}
				/>
				<ToggleableTimerForm
					onFormSubmit={this.handleCreateFormSubmit}
				/>
			</div>
		</div>
	);
}


NOTE: We seperate Create timer and handling the creation of form submit, due to keeping to single responsibility principle

We further more want to implement a edit button that allows changing to Timer:

{/* Inside Timer Render */}
<div className='extra content'>
	<span
		className='right float edit icon'
		onClick={this.props.onEditClick}
	>
		<i className='edit icon' />
	</span>
	<span className='right floated trash icon'>
		<i className='trash icon' />
	</span>
</div>

The functions of EditableTimer:

handleEditClick = () => {
	this.openForm();
};

handleFormClose = () => {
	this.closeForm();
};

handleSubmit = (timer) => {
	this.props.onFormSubmit(timer);
	this.closeForm();
};

closeForm = () => {
	this.setState({ editFormOpen: false });
};

openForm = () => {
	this.setState({ editFormOpen: true });
};

We then pass the event handlers down as props:

render() {
	if (this.state.editFormOpen) {
		return (
			<TimerForm
				id={this.props.id}
				title={this.props.title}
				project={this.props.project}
				onFormSubmit={this.handleSubmit}
				onFormClose={this.handleFormClose}
			/>
		);
	} else {
		return (
			<Timer
				id={this.props.id}
				title={this.props.title}
				project={this.props.project}
				elapsed={this.props.elapsed}
				runningSince={this.props.runningSince}
				onEditClick={this.handleEditClick}
			/>
		);
	}
}


We then move up a level and make a one-line addition to EditableTimerList to send the submit function from TimerDashboard to each EditableTimer

//inside the EditableTimerList

const timers = this.props.timers.map((timer)  => {
	<EditableTimer
		key={timer.id}
		id={timer.id}
		title={timer.title}
		project={timer.project}
		elapsed={timer.elapsed}
		runningSince={timer.runningSince}
		onFormSubmit={this.props.onFormSubmit}
	/>
});

Since EditableTimer does not need to do anything in this format, we just pass down functions

In the timersDashboard,we actually create the timers and traverse mapping:

handleEditFormSubmit = (attrs) => {
	this.updateTimer(attrs);
};

createTimer = (timer) => {
	const t = helpers.newTimer(timer);
	this.setState({
		timers: this.state.timers.concat(t),
	});
};

updateTimer = (attrs) => {
	this.setState({
		timers: this.state.timers.map((timer) => {
			if (timer.id === attrs.id) { //if its the one being updated
				return Object.assign({}, timer, { //Create a new object and return it with the props
					title: attrs.title,
					project: attrs.project,
				});
			} else { //Otherwise, just dump back the object
				return timer;
			}
		}),
	});
};

We then pass down as a prop inside render():

{/* inside TimerDashboard.render() */}
<EditableTimerList
	timers={this.state.timers}
	onFormSubmit={this.handleEditFormSubmit}
/>


We then define function handling for trashing:

class Timer extends React.Component{
	handleTrashClick = () => {
		this.props.onTrashClick(this.props.id);
	};

	render() {
		{/* Inside Timer.render() */}
		<div className='extra content'>
			<span
				className='right floated edit icon'
				onClick={this.props.onEditClick}
			>
				<i className='edit icon' />
			</span>
			<span
				className='right floated trash icon'>
				onClick={this.handleTrashClick}
			>
				<i className='trash icon' />
			</span>
		</div>
	}
}


in the EditableTimer we proxy the function:

} else {
	return(
		<Timer
			id={this.props.id}
			title={this.props.title}
			project={this.props.project}
			elapsed={this.props.elapsed}
			runningSince={this.props.runningSince}
			onEditClick={this.handleEditClick}
			onTrashClick={this.props.onTrashClick}
		/>
	);
}

As does EditableTimerList:

	//inside EditableTimerList.render()
	const timers = this.props.timers.map((timer) => (
		<EditableTimer
			key={timer.id}
			id={timer.id}
			title={timer.title}
			project={timer.title}
			elapsed={timer.elapsed}
			runningSince={timer.runningSince}
			onFormSubmit={this.props.onFormSubmit}
			onTrashClick={this.props.onTrashClick}
		/>
	));

The last step, is to define the delete function in the timersDashboard:

//inside the TimerDashboard
handleEditFormSubmit = (attrs) => {
	this.updateTimer(attrs);
};

handleTrashClick = (timerId) => {
	this.updateTimer(attrs);
};

We then run a filter to return an array with the timer object which has an id matching timer id removed:

//Inside TimersDashboard
deleteTimer = (timerId) => {
	this.setState({
		timers: this.state.timers.filter(t => t.id !== timerId),
	});
};

We then pass down the handleTrashClick as a prop:

{/inside TimerDashboard render() */}
<EditableTimerList
	timers={this.state.timers}
	onFormSubmit={this.handleEditFormSubmit}
	onTrashClick={this.handleTrashClick}
/>

NOTE: The filter call to Array's return a array that contains all the elements in a new array that managed to pass the test

The term of CRUD(Create, Update and Delete), is now in place. The next step is to fix functionality

The way we calculate the elapsed tiem is setting the time of startup and then subtracting current time with elapsed:

Date.now() - runningSince and add it to elapsed

to actually make the timer feel like it's constantly changing, we have to re-render the object all the time, with the forceUpdate() call:

The code using the forceUpdate() is as follows:

class Timer extends React.Component{
	componentDidMount(){
		this.forceUpdateInterval = setInterval(() => this.forceUpdate(), 50); //Sets the interval of forcing update to be every 50 ms
		//setInterval() returns a unique interval ID that we can use to stop that interval
	}

	componentWillUnmount(){
		clearInterval(this.forcedUpdateInterval); //Clears the interval upon unmounting, to account for no errors upon deletion of timers
	}

	handleTrashClick = () => { 	//Handler for trash click
		this.props.onTrashClick(this.props.id);
	};

	render() { //The render call to update info about timers
		const elapsedString = helpers.renderElapsedString(
			this.props.elapsed, this.props.runningSince
		);
		return (
			)
	}
}


We then add action event handlers to Buttons, that we treat as their own react components:

//inside timer

componentWillUnmount(){ //Event handler for when the component stops being mounted
	clearInterval(this.forcedUpdateInterval); //Whenever we dismount things, we assert that the element of the timer has been clear to steer clear from initialization errors
}

handleStartClick = () => {
	this.props.onStartClick(this.props.id);
};

handleStopClick = () => {
	this.props.onStopClick(this.props.id);
};

We then proceed by decclaring the TimerActionButton in the render call, which allows for interaction:

{/*At bottom of Timer render() */}
<TimerActionButton
	timerIsRunning={!!this.props.runningSince} //The !! runs a boolean not check on the not, meaning it returns false if runningSince is null
	onStartClick={this.handleStartClick}
	onStopClick={this.handleStopClick}
/>

We then go on to create the TimerActionButton:

class TimerActionButton extends React.Component{
	render(){
		if (this.props.timerIsRunning){
			return (
				<div
					className='ui bottom attached red basic button'
					onClick={this.props.onStopClick}
				>

					Stop
				</div>
			);
		} else {
			return (
				<div
					className='ui bottom attached green basic button'
					onClick={this.props.onStartClick})
				>
					Start
				</div>
			);
		}
	}
}


We then run the events through EditableTimer and EditableTimerList

//EditableTimer

} else {
	return (
		<Timer
			id={this.props.id}
			title={this.props.title}
			project={this.props.project}
			elapsed={this.props.elapsed}
			runningSince={this.props.runningSince}
			onEditClick={this.handleEditClick}
			onTrashClick={this.props.onTrashClick}
			onStartClick={this.props.onStartClick}
			onStopClick={this.props.onStopClick}
		/>
	);
}

//EditableTimerList

const Timers = this.props.timers.map((timer) => (
	<EditableTimer
		key={timer.id}
		id={timer.id}
		title={timer.title}
		project={timer.project}
		elapsed={timer.elapsed}
		runningSince={timer.runningSince}
		onFormSubmit={this.props.onFormSubmit}
		onTrashClick={this.props.onTrashClick}
		onStartClick={this.props.onStartClick}
		onStopClick={this.props.onStopClick}
	/>
));

We then define functions in the TimersDashboard. They should hunt through the state timers array using map, setting runningSince
appropiately when they find the matching timer:

//Inside the TimersDashboard

handleTrashClick = (timerId) => {
	this.deleteTimer(timerId);
};

handleStartClick = (timerId) => {
	this.startTimer(timerId);
};

handleStopClick = (timerId) => {
	this.stopTimer(timerId);
};

And then startTimer() and stopTimer():

deleteTimer = (timerId) => {
	this.setState({
		timers: this.state.timers.filter(t => t.id !== timerId),
	});
};

startTimer = (timerId) => {
	const now = Date.now();

	this.setState({
		timers: this.state.timers.map((timer) => {
			if (timer.id === timerId) {
				return Object.assign({}, timer, {
					runningSince: now,
				});
			} else{
				return timer;
			}

		}),
	});
};

stopTimer = (timerId) => {
	const now = Date.now();

	this.setState({
		timers: this.state.timers.map((timer) => { //map through all the states of the timers
			if (timer.id === timerId) { //if the id of the timer is the one we are looking for
				const lastElapsed = now - timer.runningSince; //set the elapsed time 
				return Object.assign({}, timer, { //return a new object that has been assigned attributes
					elapsed: timer.elapsed + lastElapsed,
					runningSince = null, //resets the timer, as the value will become undefined, by virtue of now - null
				});
			} else {
				return timer;
			}
		}),
	});
};


Then, we finally pass them down as props:

{/* inside TimerDashboard.render() */}
<EditableTimerList
	timers={this.state.timers}
	onFormSubmit={this.handleEditFormSubmit}
	onTrashClick={this.handleTrashClick}
	onStartClick={this.handleStartClick}
	onStopClick={this.handleStopClick}
/>

The steps we take for building react apps:

1. Break into Components

2. Build a static version

3. Determine what needs to be stateful

4. Determine in which component each piece of state should live

5. hard-coded initials

6. Add inverse data flow

7. add server communication

What follows, is the 7th step, of how to add server communication:

To be able to communicate towards servers, we use a external tool called Curl:

To supplement the code in this example with the provided node.js server, we add server.js to the root folder.

the server.js uses the data.json to reflect all data that has been stored and is going to be updated.

The dashboard and the server handle their states seperately, and individually.

But also, the two parts communicate, of course - Meaning that each time a state updates, we notify the server to actually have the other part be in sync with what is going on,
meaning that the data will be stored and handeled as per it should.

the server.js runs a GET request against the server and parses the JSON data related to the server, where of React only ever interacts with the endpoints of Reacts outlying endpoints.

the data.json is a JSON document, that keeps serialized data that can be interpeted by servers.

In the server.js , we can see stuff like:

fs.readFile(DATA_FILE, function(err, data) {
	const timers = JSON.parse(data);
});

to return all timers, we can run a GET request:

GET /api/timers

If we wish to send data, in form of JSON object with title, project and id attributes:

POST /api/timers

To set the start time of a timer by sending a timer object with id and start time:

POST /api/timers/start

To update a timer to stop on the current elapsed time of having been run:

POST /api/timers/stop //accepts a JSON body with a id and a stop timestamp.

To put times according to a specific time/project etc:

PUT /api/timers //Accepts a JSON body with id and title and/or project. Updates title and/or project to new attributes, if found

To delete some timer:

DELETE /api/timers //Accepts a JSON body with the attribute id.

We boot the server:

npm start

We can then visit the endpoints by /api/timers in our browser, and see the JSON request. (localhost:3000/api/timers in the browser field)

When it comes to the browser, to get data, we can do GET requests, if we wish to write data, we are forced to make POST, PUT, DELETE requests with curl

Example, running from command line:

curl -X GET localhost:3000/api/timers  //The X specifies what HTTP method to use.

The request would return something like:

[{"title":"Mow the lawn", "project":"House Chores","elapsed":5455099, "id":"0a479"\
cb-b06d-4cb1-883d-549a1e3bd66d7}]

To start one of the Timers by a PUT request, an example follows:

curl -X post \
-H 'Content-Type: application/json' \
-d '{"start":1455468632194, "id":"a73cidi9-f32d-4aff-b470-cea4e792406a"}' \
localhost:3000/api/timers/start

The -H flag is for the header of the request, which clarifies what kind of content the body the request has

The -d flag sets the body of our request. Inside single quotations, is the JSON data

The \ are just used for breaking lines, they are just htere for readability

If we want to have a tool for parsing and processing JSON on the command line, we can use the "jq" tool. We can pipe curl commands through it, as follows:

curl -X GET localhost: 3000/api/timers | jq '.'

We can do some powerful extractions using jq, as follows:

curl -X GET localhost: 3000/api/timers | jq '.[] | { id }' //Extract the id object from every object in an array

Since retrieving the data from servers is asynchronously, we have to use success methods and arrow functions as per shown:


//Passing `getTimers()` a success function
client.getTimers((serverTimers) => (
	//Do something with the array of timers, `serverTimers`
));


The serverTimers call is a success function that uses the Fetch API.

And the function we pass to getTimers, is a callback.

We initialize the components state with the timers property state set to a blank array. This allows for initial mounting and initial rendering, and then we can change the states by
making requests to the server and set the state:

class TimersDashboard extends React.Component {
	state = {
		timers = [], //Declare it's state to be an array that holds the values
	};

	componentDidMount() {
		this.loadTimersFromServer(); //Call loading the timers from server upon mounting
		setInterval(this.loadTimersFromServer, 5000); //Set the interval and load the timers from server
	}

	loadTimersFromServer = () => {
		client.getTimers((serverTimers) => ( //Aquire the timers from Servers
			this.setState({ timers: serverTimers }) //Set the state, by timers from teh server timers
		)
	);
};
}

A timeline of events follows:

1. Before initial render //Component state is initialize to a blank array

2. initial render //Calls render() on top level element 

3. Children rendered //Calls render() on sub-level elements

NOTE: When a element is passed to be an empty array and is called to be rendered, it leads to it becoming a empty div.

4. Once the rendering is done, it's written to the DOM.

5. mount invocation occurs, methods such as calls to server is performed, making asynch callback requests to get info

On invocation, re-render occurs after success resolution has been done on callback.

The interval setting of 5 seconds update, forces a hardcheck against the master state (Server) to update the info.
This means that in a several app or connection situation, all connections are forced to be in sync with the server in 5 seconds.

NOTE: The methods of using stuff for more instant messaging, we have to do something called Long Polling. Which will be covered later.

If we were to change the data.json, which would cause the propagation from the server to change, then the update would be in ~5 seconds.

In the client.js, we have the info about how the client is processing things and performing HTTP requests with the FETCH API:

function getTimers(success){
	return fetch('/api/timers', {
		headers: {
			Accept: 'application/json',
		},
	}).then(checkStatus) //Checks for error status and logs it, if present
	  .then(parseJSON) //Parses the JSON
	  .then(success); //in case of success
}

Before Fetch, people used XMLHttpRequests if it was natively supported, or they imported a ajax wrapper from jQuery, for instance.

In the client.getTimers(), we can see that fetch() accepts two arguments:

The path of the resource we wish to fetch

Object of request parameters

By default, Fetch runs GET requests, thus we are telling the fetch to run GET on /api/timers, with one argument:

Headers, where we include that we will only accept JSON files.

Basically, it's: check status -> Parse it -> pass it to success

The pipline consists of these stages:

Checkstatus //returns a fetch response object

parseJSON //invoked and given the response object

parseJSON //Returns an array of Timers in JS

success //invoked with said array

Basically the .then is promises of Ajax, allowing for pipelining of information and chain calling of methods.

The rest of the boilerplates pretty much contain similar code, differentiating only on the points of what iti s attempting to do. what follows is an example of something
that WRITES to the server, with POST requests:

//This sends a POST to the server:

function startTime(data) {
	return fetch('/api/timers/start', {
		method: 'post', //The method to use
		body: JSON.stringify(data), //the body, which is the HTTP request
		headers: {
			'Accept': 'application/json',
			'Content-type': 'application/json',

		},

	}).then(checkStatus);
}

The general code above will produce, for example:

start(
	{
		id: "bc5ea63b-9a21-4233-8a67-f4bca9d0421",
		start: 145584369113,
	}
);

Thus to send starts and stops, we can do as follows:

//inside TimersDashboard

startTimer = (timerId) => {
	const now = Date.now();

	this.setState({
		timers: this.state.timers.map((timer) => {
			if (timer.id === timerId) {
				return Object.assign({}, timer, {
					runningSince: now,
				});
			} else {
				return timer;
			}
		}),
	});

	client.startTimer(
		{ id: timerId, start: now }
	);
};

stopTimer = (timerId) => {
	const now = Date.now();

	this.setState({
		timers: this.state.timers.map((timer) => {
			if (timer.id === timerId) {
				const lastElapsed = now - timer.runningSince;
				return Object.assign({}, timer, {
					elapsed: timer.elapsed + lastElapsed,
					runningSince: null,
				});
			} else {
				return timer;
			}
		}),
	});

	client.stopTimer(
		{ id: timerId, stop: now }
	);
};

render() {
	
}

The above implementation updates the local call instead of doing server communication to access the state and change it.
It is called "Optimistic" approach, because we assume the call will be successful in terms of the server communication.

The other way we would do it, is the server communication way, as follows:

startTimer: function (timerId) {
	const now = Date.now();

	client.startTimer(
		{ id: timerId, start: now}
	).then(loadTimersFromServer);
},

Further more, when doing optimistic updating, we have to assert that the structure is the same as the one on the server, so that restrictions are applied properly.

We should also surface any error occurances to the client, such as timeouts and failures of server connections.

What follows, is a complete setup of creation, updating and deletion requests, to the server:

createTimer = (timer) => {
	const t = helpers.newTimer(timer);
	this.setState({
		timers: this.state.timers.concat(t),
	});

	client.createTimer(t);
};

updateTimer = (attrs) => {
	this.setState({
		timers: this.state.timers.map((timer) => {
			if (timer.id === attrs.id) {
				return Object.assign({}, timer, {
					title: attrs.title,
					project: attrs.project,
				});
			} else {
				return timer;
			}
		}),
	});

	client.updateTimer(attrs);
};

deleteTimer = (timerId) => {
	this.setState({
		timers: this.state.timers:filter(t => t.id !== timerId),
	});

	client.deleteTimer(
		{ id: timerId }
	);
};

startTimer = (timerId) => {
	
}


React uses a virtual DOM that consists of JS objects that represent the virtual DOM.

The reasons for not modifying DOM, are as follows:

Hard to keep track of different states and changes as they occur.

It can be slow, modifying the actual DOM costs a lot of resources to do.

Instead of changing the DOM piece by piece, React changes the entire DOM at once and re-renders it. The reason this is not slow for React, is that it does the following:

Efficient diffing algorithms in order to know what changed

Updates subtrees of the dom simultaneously

batch updates to the DOM

The Virtual DOM is not the Shadow DOM. The Shadow DOM, is the encapsulation of objects and integration of stuff like play buttons and stuff unto tags taht we simply mention, such as
<video></video>, which implements the playbuttons etc.

The virtual DOM is instead JS objects that represents a Virtual DOM.

The ReactElements that we create, stand responsible for actually implementing the DOM elements into the real DOM, from the virtual DOM.

To create a ReactElement that becomes the DOM elements in turn, can be done as follows:

var boldElement = React.createElement('b');

We then must render the element by virtue of mounting the root element and then appending the bold
text element:

var mountElement = document.getElementById('root');

or

var mountElement = document.querySelector('#root');

We can then tell React to render the element:

var boldElement = React.createElement('b');
var mountElement = document.querySelector("#root");

ReactDOM.render(boldElement, mountElement);

The ReactDOM.render accepts 3 arguments, the ReactElement, the props and the children of the element.
To implement text elements, we have to implement children for the ReactDOM.

This leads us to:

var mountElement = document.querySelector("#root");

var boldElement = React.createElement('b', null, "Text (as a string)");
ReactDOM.render(boldElement, mountElement);

The React DOM can also use a mode called native React, which is native to Mobile cellphones,
which changes up the rendering of the DOM to be according to native cellphones.

We can call the ReactDOM.render function several times, each time will just cause a mutation to the current DOM

We can also feed a third argument to the ReactDOM.render, which is a callback which activates when
the DOM has completed rendering:

ReactDOM.render(boldElement, mountElement, function() {
	//Some function that will be called upon completion of loading
});

We can also skip the process of manually writing react syntax,and instead go the route of calling
JSX to fix thoose calls for us:

var boldElement = <b>Text (as string)</b>; 

Another example of using the JSX to cause calls for us:

const element = <div>Hello world</div>;

An example of spawning HTML elements using React compared to that of doing HTML:

const htmlElement = <div>Hello world</div>;

const Message = React.createClass({
	render() {
		return (<div>{this.props.text}</div>)
	}
});

//Then use the react component to implement stuff into it:
const reactComponent = (<Message text='Hello World' />);

In order to use a JS expression inside of the components attribute, we can do as follows:

const warningLevel = 'debug';
const component = (<Alert
					color={warningLevel === 'debug' ? 'gray' : 'red'}
					log={true} />)


We can also make conditional child expressions:

const renderAdminMenu = function() {
	return (<MenuLink to="/users">User accounts</MenuLink>)
}

const userLevel = this.props.userLevel;
return (
	<ul>
		<li>Menu</li>
		{userLevel === 'admin' && renderAdminMenu()}
	</ul>
)

Or we can do it to compare wether a user is logged in or if one is not logged in:

const Menu = (<ul>{loggedInUser ? <UserMenu /> : <LoginLink />}</ul>)

In html we can simply denote that something is disabled:

<input name="Name" disabled />

Where as of in React, we must explicitly tell the status:

<input name="Name" disabled={true} />

//or use JS variables

<input name="Name" disabled={formDisabled} />

To make comments in jSX, we can do:

{/*
	A comment
*/}

In per normal JS, we would have to pass mapped values to a Component:

<Component msg={"Hello"} recipien={"World"} />

We could also use the ...props argument:

<Component {...props} />
//Same as
<Component msg={"Hello"} recipient={"World"} />

to use classes in JSX, we just use className:

<div className='box'></div>

To pass multiple classes in JSX, we can make an array and convert it to a string:

var cssNames = ['box', 'alert']
//And then use the array
(<div className={cssNames.join(' ')}></div>)

We can use the classNames package that takes arguments and assigns CSS class if that value exists:

const App = React.createClass({
	render: function() {
		const Klass = classnames({
			box: true, //Always apply
			alert: this.props.isAlert, //Case of prop
			severity: this.state.onHighAlert, //Case of state
			timed: false //never apply it
		});
		return (<div className={klass})
	}
})

In the same way as we cannot use class in JSX due to keyword in other contexts, we have to
circumvent the label tag names with declarations of htmlfor:

<label htmlFor='email'>Email</label>
<input name='email' type='email' />

To display entities, such as <,>, & etc. WE just put them in ltieral text areas.

To display dynamic data values, we need to encase them in {} notations.

Both emojis and other unicode characters, need to be encasef in {} to be displayed.

If we wish to display stuff in JSX that is not native to the HTML, we have to append the
data- tag:

<div className='box' data-dismissable={true} />
<span data-highlight={true} />

NOTE: The above requirement only applies to DOM elements, our own custom made elements can
have arbitrary values applies to them regardless

Examples:

<Message dismissable={true} />
<Note highlight={true} />

<div aria-hidden={true} />

Note: JSX is just syntax sugar to React components, which helps us to have convinience ways to write JS Objecs and React Syntax

An example:

var boldElement = <b>Text (as a string)</b>;

To create a ReactComponent, we generally have two ways that one is for React syntax, the other is for ES6:

//React

const App = React.createClass({
	render: function() {}
});

//ES6

class App extends React.Component {
	render() {}
}

NOTE: Every React.Component must have a render() call

An example of using the react() call to return a DOM element to render:

const Heading = React.createClass({
	render: function() {
		return (
			<h1>Hello</h1>
		)
	}
});

The react expects it to return a single child element.

If the value is false or null, it renders a empty element.

It then creates a <noscript /> tag, which removes it from the page

In React, we have props and state. Props is the attributes that are immutable that are passed down
to child elements.

State, is local bound data that is private to that instance. Whenever state is updated, the element
is re-rendered. State is mutable, however.

There is also context, which is a implicit props, that is passed through the entire tree.

An example of passing props down:

<div>
	<Header headerText="hello world!" />
</div>

Above, the headerText is the prop.

We could then access this data, by virtue of the this. referal, as follows:

const Header = React.createClass({
	render: function() {
		return (
			<h1>{this.props.headerText}</h1>
		)
	}
});

We can pretty much pass any elements down we want as props, as per primitives,
simple JS objects, atoms, functions etc.

NOTE: The props are immutable tho.

We can also define the type of each prop by the virtue of Prototypes.

using prototypes allows us to assert the typing of the said prop being passed down
and is written as follows:

const Component = React.createClass({
	protoTypes: {
		name: React.Prototypes.string,
		totalCount: React.Prototypes.number
	},
})

We can also make our own prototypes if we wish, but the general ones that we can assert with
the built in prototypes are as follows:


Prototypes are akin to constructors that enforce typing and documentation of a object.
They can generally look as follows:

const Component = React.createClass({
	prototypes:{
		//protoType defs go here
	},
	render: function() {}
});

To do it in Es6 style, we have to do slightly different:

class Component extends React.Component {
	render() {}
}
Component.protoTypes = {/* Definitions go here */}

The built in validatorsr of protoTypes is as follows:

string

number

boolean

function

object

shape

oneOf

instanceOf //can cause validation against instanciation, as follows:

const Component = React.createClass({
	protoTypes: {
		user: React.Prototypes.instanceOf(User)
	},
	//...
})

To then pass this prop, we could do as follows in JS:

const User = function(name) {
	this.name = name;
	return this;
};

const ar1 = new User('Ar1');

<Component user={ar1} />

Where as if we wish to assert it to be one of a specific range of types, we can use oneOf:

const Component = React.createClass({
	protoTypes: {
		level: React.Prototypes.oneOf(['debug', 'info', 'warning', 'error'])
	},
	//...
})

An example of running against several different kind of types:

const Component = React.createClass({
	protoTypes: {
		phoneNumber: React.Prototypes.oneOfType([
			React.Prototypes.number,
			React.Prototypes.string
		])
	},
	//...
})



array

arrayOf

node

element

any

required
The following scalar types:

string

number

boolean

And the complex types:

function

object

array

arrayOf //Expects a particular array of a specific type

node

element

We can also validate the shape of the input object. if we wish, we can define the shape of a React.Component by virtue of using the following constructor method:

const Component = React.createClass({
	prototypes: {
		user: React.Prototypes.shape({
			name: React.Prototypes.string,
			fiends: React.Prototypes.arrayOf(React.Prototypes.object),
			age: React.Prototypes.number
		})
	},
	//Code goes here
})

The above code defines the way a Object is expected to be asserted in it's typing and arguments etc.
This allows for custom creation of specific shaped objects.

To define a prop as a string, we could use the following:

const Component = React.createClass({
	protoTypes: {
		name: React.Prototypes.string
	},
})

If we call a string as a prop, we can do either:

<Component name={"Ar1"} />
<Component name="Ar1" />

To specify a number, we could do as follows:

const Component = React.createClass({
	protoTypes: {
		totalCount: React.PropTypes.number
	},
	//
})

To pass it in as a number, we must either do it as a JS variable or a plain {}'d number:

<Component totalCount={20} />
<Component totalCount={x} />

To declare bools:

const Component = React.createClass({
	protoTypes: {
		on: React.Prototypes.bool
	},
	//
})

To use the boool as JSX expression, we pass it as a JS value:

var isOn = true;

<Component isOn={true} />
<Component isOn={false} />
<Component on={isOn} />

an example of running a bool against showing content or not, is using a && operator inside the render():

javascript render(): function(){ return ( <div> {this.props.on && <p>This component is on</p>} </div>)}

If we wish to declare a prop to be a function, we could do as follows:

const Component = React.createClass({
	protoTypes: {
		onComplete: React.Prototypes.func
	},
	//...
})

To then pass the function as a prop:

const x = function(name) {};
const fn = value => alert("Value: " + value);

<Component onComplete={x} />
<Component onComplete={fn} />

To enforce a prop to be a object:

const Component = React.createClass({
	protoTypes: {
		user: React.Prototypes.object
	},
	//...
})

To send the object as a prop:

const user = {
	name: 'Ari'
}

<Component user={user} />
<Component user={{name : 'Anthony'}} />

if we wish to send in a array without type enforcement:

const Component = React.createClass({
	protoTypes: {
		authors: React.Prototypes.array
	},
	//...
})

Then sending said array:

const users = [
	{name: 'Ari'}
	{name: 'Anthony'}
];

<Component authors={[{name: 'Anthony'}]} />
<Component authors={users} />

To dictate what kind of array we are forcing in:

const Component = React.createClass({
	protoTypes: {
		authors: React.Prototypes.arrayOf(React.ProtoTypes.object)
	},
	//...
})

To then pass said array:

const users = [
	{name: 'Ari'}
	{name: 'Anthony'}
];

<Component authors={[{name: 'Anthony'}]} />
<Component authors={users} />

If we wish to pass anything of "arbitrary other" category, we can pass a node:

const Component = React.createClass({
	protoTypes: {
		icon: React.ProtoTypes.node
	},
	//...
})

And to pass said node:

const icon = <FontAwesomeIcon name="user" />

<Component icon={icon} />
<Component icon={"fa fa-cog"} />

If we wish, we can pass another React element as a prop, as well:

const Component = React.createClass({
	protoTypes: {
		customHeader: React.Prototypes.element
	},
	//...
})

If we wish, we can cause a re-using component environment, that allows for re-usage of Lists 
to hold elements, as for example:

const List = React.createClass({
	protoTypes: {
		listComponent: PropTypes.element,
		list: PropTypes.array
	},
	renderListItem: function(item, 1) {
		const Component = this.props.listComponent || "11";
		return React.createElement(Component, this.props, item)
	},
	render: function() {
		const list = this.props.list;
		return (
			<ul>
				{list.map(this.renderListItem)}
			</ul>
		)
	}
});

We can then use said list, with or without custom components if we wish:

const Item = React.createClass({
	render: function() {
		return (
			<div>{this.props.children}</div>
		)
	}
})

<List list={[1, 2, 3]} />
<List list={[1, 2, 3]} listComponent={item} />

We can also assert that a prop must be present to begin with, regardless of type:

const Component = React.createClass({
	propTypes: {
		mustBePresent: React.PropTypes.any
	},
})

React props have two kinds, one type that is required, the other that is optional.
What follows, is examples of using both kinds:

const Loading = React.createClass({
	protoTypes: {
		//optional props
		onStart: React.ProtoTypes.func,
		//required props
		onComplete: React.ProtoTypes.func.isRequired,
		name: React.PropTypes.string.isRequired
	},
	//...
})

When we create custom validators, we usually run with 3 arguments, and run validation against
a error object being raised.

An example follows:

const Component = React.createClass({
	protoTypes: {
		user: function(props, propName, componentName) {
			const user = props[propName],
			if (!user.isValid()) {
				return new Error('Invalid User');
			}
		}
	},
})

A popular tool for using commandline requests for HTTP, is cURL.

To perform a get request, we simply:

curl http://google.com

We can also mimic making a POST request with cURL as follows:

	curl -H 'Content-Type:application/graphql' -XPOST https://www.graphqlhub.com
/graphql?pretty=true -d '{ nn { topStories(limit: 2) {'title url }}}'

-H //states that we wish to pass a header. In this example, we pass the HTTP header content-type as
application/graphql

-XPOST //States that we wish to make a POST request

-d //States that the following is the POST Body. In this case, it's a GraphQL query that fetches
the top 2 posts from Hacker News.

We can also make copy URL requests from react in the Google DEV environment,
which if we paste into the URL will be a long string with a lot of "noise". But basically,
we could hypothetically condense a header request to as follows:

curl 'https://www.fullstackreact.com/assets/vendor/function.js'

An example of running default props on a component, is as follows:

const Counter = React.createClass({
	getDefaultProps: function() {
		return {
			initialValue: 1
		}
	},
	//...
});

We can then call, functionally the same:

<Counter />
<Counter initialValue={1} />

The default props gets called when defined and cached. if the props are not specified by the parent object,
they are set to this.props

as getDefaultProps() is created before any instance variables, we cannot use any instance variables
as per this.props in said method.

Additionaly, any objects returned by the getDefaultProps is shared amongst all instances,
not copied.

We can also define attributes to be according to the Global scope. use this sparingly, as it is far
from wise to use it. Few cases legitimately use it, such as the central Redux.

In order to tell React we want to pass context from a parent component to the rest of it's children,
we need to define two attributes in the parent class:

childContextTypes 

and

getChildContext

To retrieve the context in the child, we must define the context type in the child.

An example of a messaging app using this, follows:

const Messages= React.createClass({
	propTypes: {
		users: propTypes.array.isRequired,
		messages: PropTypes.array.isRequired
	},
	render: function(){
		return (
			<div>
				<ThreadList />
				<ChatWindow />
			</div>
		)
	}
});
const ThreadList = React.createClass({
	render: function() {
		//Do stuff
	}
});
const ChatWindow = React.createClass({
	render: function() {
		//..
	}
});

const ChatMessage = React.createClass({
	render: function() {
		//...
	}
});

Now, instead of defining the state to be global, we first set the context types to be the relevant one for the children:

const MessageApp = React.createClass({
	childContextTypes: {
		users: PropTypes.array
	},
	//...
});

Note: the childContextTypes does not populate the contextTypes, it merely defines it.

The second thing, we need to do, is define the getChildContext, which returns the state for the child to be in:

const MessageApp = React.createClass({
	childContextTypes: {
		users: PropTypes.array
	},
	getChildContext: function() {
		return {
			users: this.getUsers()
		}
	},
	//...
});

As per usual, since the state is now bound, and it can change, this will of course update the children and they will re-render.

With these two set in the parent Component, React will automatically pass down the attributes to the children, which will update them. But we still have to tell the Children what the context is:

const ThreadList = React.createClass({
	contextTypes: {
		users: PropTypes.array,
	},
	render: function(){
		//...
	}
});
const ChatWindow = React.createClass({
	contextTypes: {
		users: PropTypes.array,
	},
	render: function(){
		//...
	}
});
const ChatMessage = React.createClass({
	contextTypes: {
		users: PropTypes.array,

	},
});

Now we can access the parent elements nad get the users without having to manually pass em down.
The context is set to the this.conext object of the component with contextTypes defined.

For instance, ThreadList might look as follows:

const ThreadList = React.createClass({
	contextTypes: {
		users: ProtoTypes.array,
	},

	render: function(){
		return(
			<div>
				<ul>
					{this.context.users.map((u, idx) => (
						<UserListing onClick={this.props.onClick}
									key={idx}
									index={idx}
									user={u} />))}
				</ul>
			</div>
		)
	}
})

if contextTypes is defined on a component, then several of it's lifecycle methods will get passed an additional argument of nextContext

An example:

const ThreadList = React.createClass({
	contextTypes: {
		users: ProtoTypes.array,
	},

	componentWillRecieveProps(nextProps, nextContext) {
		//..
	},
	shouldComponentUpdate(nextProps, nextState, nextContext){
		//...
	},
	componentWillUpdate(nextProps, nextState, nextContext){
		//...
	},
	componentDidUpdate(prevProps, prevState, prevContext) {
		//...
	}
	//...
})

In a functional, stateless component, context will get passed as the second argument:

const ChatHeader = (props, context) => {
	const user = props.participants[0];
	return (
		<div>
			<img src={user.avatar} />
			<div className={styles.chatWith}>Chat with {user.username}</div>
		</div>
	)
}
ChatHeader.propTypes = {participants: PropTypes.array}
ChatHeader.contextTypes = {users: PropTypes.array}

NOTE: using global stuff is not very wise, and should be restricted to such as getting getting global vars (Such as logged in user etc.)

States refers to the idea of a components holds dynamic piece of data.

generally, this should be kept to a minimum, as each piece introduces further complexity and difficulty overall.

To set a state on a component, can be done as follows:

const Switch = React.createClass({
	getInitialState(){
		return {}; //The intial state, it is empty
	},

	render(){
		return <div><em>Template will be here</em></div>;
	}
});

To make it a bit more interactive and relevant, we can add values and interactions:

const CREDITCARD = 'Creditcard';
const BTC = 'Bitcoin';

const Switch = React.createClass({
	getInitialState() {
		return {
			payMethod: BTC
		};
	},

	render() {
		return (
			<div className="switch">
				<div className="choice">Creditcard</div>
				<div className="choice">Bitcoin</div>
				Pay with: {this.state.payMethod}
			</div>
		)
	}
});

To then add interactivity to the choices:

render() {
	return (
		<div className="switch">
			<div className="choice"
				onClick={this.select(CREDITCARD)} //Add this
				>Creditcard</div>
			<div className="choice"
				onClick={this.select(BTC)} //and this
				>BitCoin</div>
			Pay with: {this.state.payMethod}
		</div>
	)
}

Now, in the top part of the function, we add the event handling of the clicks:

const Switch = React.createClass({
	getInitialState(){
		return {
			payMethod: BTC
		};
	},

	select(choice) { //run select with the choice of the person
		return (evt) => { //return the function with event
			this.setState({ //Accessing the setting of this state
				payMethod: choice //put it to the relevant element selected
			})
		}
	},

	//etc.
});

NOTE: Since the call causes a update and updates to the actual DOM, this causes performance implications and should not be triggered in cascades to prevent performance issues.

We can refactor the code to only implement the render of selection once:

renderChoice(choice) {
	return (
		<div className="choice"
			onClick={this.selector(choice)}>
		{choice}
	</div>
	)
},

render() {
	return (
		<div className="switch">
			{this.renderChoice(CREDITCARD)}
			{this.renderChoice(BTC)}
			Pay with: {this.state.payMethod}
		</div>
	)
}

We then go on to add the active class from CSS to indicate active elements:

renderChoice(choice){
	//Create of set of cssClasses to apply
	let cssClasses = [];

	if (this.state.payMethod === choice) {
		cssClasses.push(styles.active); //Add active class
	}

	return (
		<div className="choice"
			onClick={this.select(choice)}
			className={cssClasses}>
			{choice}
		</div>
	)
},

NOTE:: Above syntax is unclear on indention due to book error

render() {
	return (
		<div className="switch">
			{this.renderChoice(CREDITCARD)}
			{this.renderChoice(BTC)}
			Pay with: {this.state.payMethod}
		</div>
	)
}

NOTE: What we did in the above example, which is not shown,i sthat we imported CSS encapsulation that allows us to use classes on objects and stuff.

Thus, the CSS things become accessible according to a object, akin to styles.active gives the active class of CSS 

When we set the state of objects, in React, we always expect there to be a initial state, and it is the only time we use props in the 
state of things:

const Component = React.createClass({
	getInitialState: function() {
		return {
			currentValue: 1,
			currentUser: {
				name: 'Ari'
			}
		}
	}
});

In the above example, the state is a JS object, but it could be anything, as long as it's returned:

const Component = React.createClass({
	getInitialState: function() {
		return 1;
	},
	//....
});

An example of setting the prop inside of a InitialState, but by calling it initialValue:

const Wrapper = React.createClass({
	render: function() {
		return (
			<div>
				<Counter initialValue={Date.now()} />
			</div>
		)
	}
});

Since we know by the code that the value will only be set to be intial and called once, we can define it as follows:

const Counter = React.createClass({
	getInitialState: function() {
		return {
			currentValue: this.props.initialValue
		}
	},
	//...
});

NOTE: The only info we should ever put into states, are things that cannot be computed and do not need to be synced across the app.

Also, we should keep states to a minimum and as small as possible, for sake of making fast conversions to JSON.

To this end, we can thus build apps with a single Stateful component composed of stateless components.

Stateless components, are components that do not need outside handling and can be called solely through the render() method.

as follows:

const Header = function(props) {
	return (<h1>{props.headerText}</h1>)
}

Note: Functional stateless components, as above, do not have this references.
In fact, they do not introduce even a React.Component, as it is Null.

The above does not allow for reference of the DOM or use refs.

And the less components we have, the less memory allocation and checking React has to handle.

NOTE: stateless functional components do not support lifecycle methods either.

We can redo the choice call to be a stateless component, as follows:

const Choice = function(props) {
	let cssClasses = [];

	if (props.active) { // <-- check props, not state
		cssClasses.push(styles.active);
	}

	return (
		<div className="choice">
		onClick={props.onClick}
			className={cssClasses}>
		{props.label} {/* Allow any label */}
		</div>
	)
}

This is a common pattern for react apps, to pull state components to isolate them. Which means that we pass down as much as we can through props.

By virtue of isolation, we cause decoupling, which means that Choice is a isolated thing that we can use anywhere for anything, so long as we pass the relevant
arguments (in our case, active, onClick and label)

This changes switch, to make it more modular and able to do more isolated things with it, as following showcases:

render() {
	return (
		<div className="switch">
			<Choice
				onClick={this.select(CREDITCARD)}
				active={this.state.payMethod === CREDITCARD}
				label="Pay with CreditCard" />

			<Choice
				onClick={this.select(BTC)}
				active={this.state.payMethod == BTC}
				label="Pay with Bitcoins" />

			Paying with: {this.state.payMethod}
		</div>
	)
}

By having made Choice a stateless component, we have been able to isolate it and treat it as reusable thing.

Beyond this, props inheritly allow us to communicate with children, by virtue of props.children, an example of this follows:

<Container>
	<Article headline="An interesting Article">
		Content Here
	</Article>
</Container>

If we wish to refer to the one child of the Container, we could do as follows:

const Container = React.createClass({
	render: function() {
		return (
			<div className="container">
				{this.props.children}
			</div>
		);
	}
});

The above code will produce a div with class notation container and then put the children in there.

If there are multiple children, we pass a list of all the elements down, otherwise we just pass a single element down.

To make it account for several different types, we can use propTypes definitions:

const Container = React.createClass({
	propTypes: {
		children: React.PropTypes.oneOfType([
			React.PropTypes.element,
			React.PropTypes.array
		])
	},
	render: function() {
		return (
			<div className="container">
				{this.props.children}
			</div>
		);

	}
});

From this point, we can either do the following things to handle children:

Put the child in a wrapper class, to assert that there's always only one

or

use the Children helper provided by React.

What follows, is an example of how we do to make wrappers and have it be one element:

const Container = React.createClass({
	propTypes: {
		children: React.PropTypes.element.isRequired //Enforce that it is a element type
	},
	render: function() {
		return (
			<div className="container">
				{this.props.children}
			</div>
		);
	}
});

The most common interaction of Children in React, is that of doing a forEach loop and mapping, as follows:

[1,2,3].forEach(function(n){
	console.log("The number is:" + n);
	return n; //Won't display
})
[1,2,3].map(function(n) {
	console.log("The number is:" + n);
	return n; //Will display
})

The main difference between map and forEach, is that while each iterate over respective elements one at a time and utilizing something on them,
forEach does not collect results, whilst map collects a single element or an array.

if we want to have a configurable wrapper class for the children of the class, we can do as follows:

const Container = React.createClass({
	propTypes: {
		component: React.PropTypes.element.isRequired,
		children: React.PropTypes.element.isRequired
	},
	renderChild: function(childData, index) {
		return React.createElement(
			this.props.component,
			{}, //The props of the child
			childData //The child's children
		);
	},
	render: function() {
		return (
			<div className="container">
				{React.children.map(
					this.props.children,
					this.renderChild)}
			</div>
		);
	}
});

the props.Children often passes back values that are unclear in their structure, and to combat this, we need to convert it to array:

const Container = React.createClass({
	propTypes: {
		component: React.PropTypes.element.isRequired,
		children: React.PropTypes.element.isRequired
	},
	render: function() {
		const arr = 
			React.Children.toArray(this.props.children);

		return (
			<div className="container">
				{arr.sort((a,b) => a.id < b.id; )} //Sort the elements of the array, in descending order
			</div>
		)
	}
});

To assert methods to a class in such a way that we can call them without instansiating objects in React, we could declare them as static, as follows:

const HomePage = React.createClass({
	statics: {
		getPageTitle: function() {
			return 'Home';
		}
	},
	render: function() {
		return (<div>Welcome home</div>)
	}
})

const AboutPage = React.createClass({
	statics: {
		getPageTitle: function() {
			return 'About';
		}
	},
	render: function() {
		return (<div>About us</div>)
	}
})

We can now call the getPageTitle() on either component class, without instansiation, due to the static status having rendered them in the pre-compilation stages. (? Unsure)

and as follows, the psuedo code for re-directing to other pages:

const currentUrl = window.location.pathname;
if (currentUrl == '/') {
	page = HomePage;
} else {
	page = AboutPage;
}
const title = page.getPageTitle();

Next, we are going to talk about forms. Forms are as we know them.

We direct ourselves to the dir:

$ cd forms

$ npm i //install

$ npm start

In this books example, they use budo, which is a dev server for rapid prototyping.

As per can come to be expected of forms and event hanlding, it is very similar in React to how we have come to know it otherwise:

render() {
	return (
		<div>
			<h1>What do you think of React?</h1>

			<button
				name="button-1"
				value="great"
				onClick={this.onGreatClick}
			>
				Great
			</button>

			<button
				name="button-2"
				value="amazing"
				onClick={this.onAmazingClick}
			>
				Amazing
			</button>
		</div>
	);
},

Of course, we have to define the event handlers as well:

onGreatClick(evt) {
	console.log("The user clicked button-1: great", evt);
},

onAmazingClick(evt) {
	console.log("The user clicked button-2: amazing", evt);
},

The object that gets provided for event handling in terms of clicking, in React, is a SyntheticMouseEvent, which is a cross-browser wrapper around the browser's native MouseEvent.
If we wish to access the native version, we just have to access it via the nativeEvent attribute of the evt object

NOTE: Event objects in React decay after callback, due to being pooled. To remove this feature, we have to call .persist() on the event object, which removes it from the pooling which removes nullification of the attributes of the object (which is done for performance reasons, mainly)

To Capture a event, we simply append Capture to afterwards of a event.

The events that exist in React, are as follows:

name	  events   			Event names 				Props

Clipboard  					//onCopy onCut onPaste 		DOMDataTransfer clipboardData

Composition 				//onCompositionEnd 			string data
							//onCompositionStart
							//onCompositionUpdate

Keyboard 					//onKeyDown 				boolean altKey
							//onKeyPress 				number charCode
							//onKeyUp 					boolean ctrlKey
														boolean getModifiedState(key)
														string key
														number keyCode
														string locale
														number location
														boolean metaKey
														boolean repeat
														boolean shiftkey
														number which

Focus 						onFocus, onBlur 			DOMEventTarget relatedTarget

Form 						onChange, onInput, onSubmit 

Mouse 						etc.

Selection

Touch

UI

Wheel

Media

Image

Animation

Transition

Since i could not be arsed to write all the details of these, as they are repeats of the ones in jQuery, i left them out.

An example of interaction with a button:

onButtonClick(evt){
	const btn = evt.target;
	console.log(`The user clicked ${btn.name}: ${btn.value}`);
},

With the above code, we can then just assign them to the relevant buttons and have them interact individually based on name and value

To access values in text forms in React, we have to use ref, otherwise stuff is as per normal:

render(){
	return (
		<div>
			<h1>Sign up Sheet</h1>

			<form onSubmit={this.form.onFormSubmit}>
				<input
					placeholder='Name'
					ref='name' /* Access data attribute of text field by virtue of ref */
				/>

				<input type="submit" />
			</form>
		</div>
	);
},

NOTE: the refs stands for referals, which means references.

The above code also supports pressinge nter for input with focus on the element

We can further more access ref values in event handlers:

onFormSubmit(evt){
	evt.preventDefault(); //Prevent the submit value
	console.log(this.refs.name.value); //Access the name through refs and access the value of the name
},

An example of holding track of all listed names, we keep a array as the state of the form and then
populate the array with new data upon re-render.

The initial state should be an empty array as follows:

getInitialState(){
	return { names: [] };
},

And the updated render method:

render() {
	return (
		<div>
			<h1>Sign up</h1>

			<form onSubmit={this.onFormSubmit}>
				<input
					placeHolder="Name"
					ref="name"
			/>

				<input type="submit"/>
			</form>

			<div>
				<h3>
				<ul>
					{ this.state.names.map((name, i) => <li key={i}>{name}</li>) }
					/* By mapping the values from the states array with a arrow function, we return
					each element in a li item by accessing the key value and referal of name */
					/*For this case, we can simply keep a referal of the key ID, but for more complex
					cases, we would have to assign ID to each name for sake of rendering, due to
					react wanting to have IDs for re-render calls and keeping track of stuff */
				</ul>
			</div>
		</div>

	);
},

And to make certain that state assignment occurs as should, we can see the following is a integration
that works:

onFormSubmit(evt) {
	const name = this.refs.name.value;

	const names = [...this.state.names, name ]; //Update the array of names by inserting all the state names and appending the new name unto the last part of the list 

	this.setState({ names: names }); //Set the state
	this.refs.name.value = ''; //Clear the value in the form
	evt.preventDefault(); //prevent Default from submission
},

The previous setup was a form of a uncontrolled form, which means that we did not let react
handle interaction of the values and we accessed the DOM directly instead of letting state do
the business. However, we can of course, do controlled forms, to which we let state handle the business.

The difference in the render call is thus not that great, apart from simply accessing this values from states instead:

render() {
	return(
		<div>
			<h1>Sign up</h1>

			<form onSubmit={this.form.onFormSubmit}>
				<input
					placeholder="Name"
					value={this.state.name} /* the difference being that instead of accessings refs to
					onChange={this.onNameChange} //manipulate values, we use states and props */
				/>

				<input type="submit" />
			</form>

			<div>
				<h3>Names</h3>
				<ul>
					{ this.state.names.map((name, i) => <li key={i}>{name}</li>)}
				</ul>
			</div>
		</div>
	);
},

We then go to define the initialState :

getInitialState() {
	return {
		name: '',
		names: [],
	};
},

And of course, we would have to set the state of name change as well, as follows:

onNameChange(evt) {
	this.setState({ name: evt.target.value });
},

And the last step, is to add the name to the list of previous names upon name change:

onFormSubmit(evt) {
	const names = {...this.state.names, this.state.name };
	this.setState({ names: names, name: ''});
	evt.preventDefault();
},

If we wanted to implement several form parts, we have to introduce the idea of polymorphism
that accounts for several inputs:

render() {
	return (
		<div>
			<h1>Sign up</h1>

			<form onSubmit={this.onFormSubmit}>
				<input
					placeholder="Name",
					name="name", //Name prop is for the sake of polymorphism later
					value={this.state.fields.name} //Access fields instead of root
					onChange={this.onInputChange}
				/>

				<input
					placeholder="Email"
					name="email" //The name prop is for the sake of polymorphism later
					value={this.state.fields.email} //Access fields instead of root
					onChange={this.onInputChange}
				/>

				<input type="submit"/>
			</form>

			<div>
				<h3>People</h3>
				<ul>
					{ this.state.people.map(({ name, email }, 1) => 
						<li key={i}>{name} ({ email })</li>
					) }
				</ul>
			</div>
		</div>
	);
},

To account for the polymorphism that we wish to achieve, we also have to change the event handlers:

onInputChange(evt) {
	const fields = this.state.fields; //Access the fields
	fields[evt.target.name] = evt.target.value; //account for event targeting both in name and value
	//to cause polymorphism
	//the evt.target.name is the name of the attribute and the target.value is the value
	this.setState({ fields }); //set the state according to the fields
},

We then also update the forms Submit event handling:

onFormSubmit(evt) {
	const people = [
		...this.state.people,
		this.state.fields,
	];
	this.setState({ people, fields: {} }); //update the list and clear all fields by returning a empty
	//object
	evt.preventDefault();
},

With this approach, all we need to update is the render() method.

If we wanted to add a field for say, phonenumbers, all we would have to do is add the details for it
in line to the other values

If we wish to add validation to our app, it generally consists of a few steps as follows:

1. A place to store validation errors

2. change the render()

3. Add a new validate() that takes fields object as an argument and returns a fieldErrors object

4. onFormSubmit() will call the new validate() method to get the fieldErrors object, and if
there are errors it will add them to the state (So they can be shown in render()) and return early
without adding the "Person" to the list, state.people

First, the initialstate:

getInitialState(){
	return {
		fields: {},
		fieldErrors: {},
		people: [],
	};
},

Then we update the Render() method:

render() {
	return (
		<div>
			<h1>Sign up</h1>

			<form onSubmit={this.onFormSubmit}>

				<input
					placeholder="Name"
					name="name"
					value={this.state.fields.name}
					onChange={this.onInputChange}
				/>

				<span style={{ color: "red" }}>{this.state.fieldErrors.name}</span>

				<br />

				<input
					placeholder="Email"
					name="email"
					value={this.state.fields.email}
					onChange={this.onInputChange}
				/>

				//Where the errors will be shown, if they occur
				<span style={{ color: "red" }}>{ this.state.fieldErrors.email }</span>

				<br />

				<input type="submit" />
			</form>

			<div>
				<h3>People</h3>
				<ul>
					{ this.state.people.map(({ name, email }, i) => 
						<li key={i}>{name} ({ email })</li>
					) }
				</ul>
			</div>
		</div>
	);
},

And then we have the validate() method:

validate(person){
	const errors = {};
	if (!person.name) errors.name = "Name Required";
	if (!person.email) errors.email = "Email Required";
	if (person.email && !isEmail(person.email)) errors email = "Invalid Email";
	return errors;
},

By virtue of checking against ! we account for if the value is empty or not,
and we further more handle validation by virtue of a function call to validate the 
relevant values:

onFormSubmit(evt) {
	const people = [...this.state.people ];
	const person = this.state.fields;

	const fieldErrors = this.validate(person);
	this.setState({ fieldErrors }); //map the state to be the fieldErrors, if there were no errors,
	//we would get a empty object, otherwise, it will return a error object with keys assigned to each
	//index of respective errors
	evt.preventDefault();

	if (Object.keys(fieldErrors).length) return; //If there were any errors, return

	people.push(person);
	this.setState({ people, fields: {} });
},

The above causes validation after buttons has been pushed, but we may want to learn
on how to do stuff on the level of updating in realtime, which we will see soon.

To do this, we put in implementation of running validations for each respective field on their own,
whilst the parent form is only responsible for handling form level errors.

This would allow for realtime validation and freeing the parent of having to validate for children.

To fullfill the jobs at hand, we need the following:

placeholder: Will be passed straight through to the input child element. Similar to a label,
this tells the user what data to the Field expects

name: We need this for the event handler to decide where to store input data and validation errors

value: this is how our parent form can initialize the Field with a value, or it can use this
to update the Field with a new value. 

validate: A function that returns validation errors (if any) when run

onChange: event handler to be run when the field changes. 

What follows are the illustrations of the changes that we need to do:

propTypes: {
	placeholder: PropTypes.string,
	name: PropTypes.string.isRequired,
	value: PropTypes.string,
	validate: PropTypes.func,
	onChange: PropTypes.func.isRequired,
},

And we declare the initialState:

getInitialState(){
	return {
		value: this.props.value,
		error: false,
	};
},

And we further more have to allow the parent to change the value of props, to which we need to
implement a lifecycle method as follows:

componentWillRecieveProps(update) {
	this.setState({ value: update.value });
},

And then, the render method:

render() {
	return (
		<div>
			<input 
				placeholder={this.props.placeholder}
				value={this.state.value}
				onChange={this.onChange}
			/>
			<span style={{ color: "red" }}>{ this.state.error }</span>
		</div>
	);
},

And then, handling onChange event handling:

onChange (evt) {
	const name = this.props.name; //the name
	const value = evt.target.value; //get the value
	const error = this.props.validate ? this.props.validate(value) : false; //Did we run into any errors

	this.setState({value : error}); //set the state

	this.props.onChange({name, value, error}); //passes the info to the actual Form
}

The updated render() looks as follows:

render(){
	return (
		<div>
			<h1>Sign up sheet</h1>

			<form onSubmit={this.onFormSubmit}>

				<Field
					placeholder="Name"
					name="name"
					value={this.state.fields.name}
					onChange={this.onInputChange}
					validate={(val) => (val ? false : "Name required")} //Run validation, if pass, return false, no error occured, otherwise, return error of name required
					the above validation will trigger upon empty names or empty emails
				/>

				<br />

				<Field
					placeholder="Email"
					name="email"
					value={this.state.fields.email}
					onChange={this.onInputChange}
					validate={(val) => (isEmail(val) ? false : "Invalid email")} //See above
					//runs validation on forming of E-mail structure
				/>

				<br />

				<input type="submit" disabled={this.validate()} /> //Button disables if
				//validation does not pass through
			</form>

			<div>
				<h3>People</h3>
				<ul>
					{ this.state.people.map(({ name, email }, i) =>
						<li key={i}>{name} ({email})</li>
					) }
				</ul>
			</div>
		</div>
	);
},

And of course, we have to update the onInputChange:

onInputChange({ name, value, error }){
	const fields = this.state.fields;
	const fieldErrors = this.state.fieldErrors;

	fields[name] = value; //This time, we allow fields to access name instead
	fieldErrors[name] = error; //same here

	this.setState({ fields, fieldErrors });
},

The main difference we do, is that to access the onInputChange, we instead call:

this.props.onChange({name, value, error})

Which means that we access the properties of the objects instead of through just props

At this point our submit and validate looks as follows:

onFormSubmit(evt){
	const people = this.state.people;
	const person = this.state.fields;

	evt.preventDefault();

	if (this.validate()) return;

	people.push(person);
	this.setState({ people, fields: {} });
},

And the validate:

validate(){ //If it returns false, then we have a error
	const person = this.state.fields;
	const fieldErrors = this.state.fieldErrors;
	const errMessages = Object.keys(fieldErrors).filter((k) => fieldErrors[k]) //Access the keys of field
	//errors and filter them out where we have the relevant errors

	if (!person.name) return true; //If person.name is not defined or 0 chars
	if (!person.email) return true; //If person.email is not defined or 0 chars
	if (errMessages.length) return true; //If there are any error messages

	return false;
},


When it comes to remote data, i.e ajax loading, we are going to basically need three props to begin with, for three specific menus that asynch load data one after another upon selections and loading specific ranges:

propTypes: {
	department: PropTypes.string,
	course: PropTypes.string,
	onChange: PropTypes.func.isRequired,
},

NOTE: A convention of displayable data that is just for display is started with _ , such as _loading.

We begin by setting a number of designated collection states where we will refer things to, and we have one for presentational state : I.e if it's loading or not:

getInitialState(){
	return {
		department: null,
		course: null,
		courses: null,
		_loading: false,
	};
},

We then define a asynch promise method that updates states of the parents:

componentWillReceiveProps(update){
	this.setState({
		department: update.department,
		course: update.course,
	});
},

Since the graphical component is a bit more complicated, we have to do function calls instead that allows us to present the data as is relevant:

render() {
	return (
		<div>
			{ this.renderDepartmentSelect() } //Returns what department has been selected
			<br />
			{ this.renderCourseSelect() }
		</div>
	);
},

As we will see in the definition of the onSelectDepartment, we will see that it provides a bit 
of utility to what is chosen and how it displays the data:

onSelectDepartment(evt) { //Handling of selection of the department
	const department = evt.target.value; //Department is the chosen one
	const course = null; //Course becomes null, unselected
	this.setState({ department, course }); //set the state to be department and course
	this.props.onChange({ name: "department", value: department }); //activate the on change to assign prop values
	this.props.onChange({ name: "course", value: course }); //activate the on change to assign
	prop values

	if (department) this.fetch(department); //If a department was chosen, we fetch it
	//we implement the fetch later
},

And of course, the fetch method:

fetch(department) {
	this.setState({ _loading: true, courses: [] });
	apiClient(department).then((courses) => {
		this.setState({ _loading: false, courses: courses });
	});
},

Based on the different choises, we get different root elements returned, such as picking the first one
gets us the department things whilst the second get us Courses.

The main difference between the two, is that the selection of courses is dynamically populated
which means that keys must be provided to each prop.

onSelectCourse(evt) {
	const course = evt.target.value;
	this.setState({ course });
	this.props.onChange({ name: "course", value: course });
},

Next is the updated render():

render() {
	return (
		<div>
			<h1>Sign up</h1>

			<form onSubmit={this.onFormSubmit}>

			<Field
				placeholder="Name"
				name="name"
				value={this.state.fields.name}
				onChange={this.onInputChange}
				validate={(val) => (val ? false : "Name Required")}

			/>

			<br />

			<Field
				placeholder="email"
				name="name"
				value={this.state.fields.email}
				onChange={this.onInputChange}
				validate={(val) => (isEmail(val) ? false : "Invalid Email")}
			/>

			<br />

			<CourseSelect
				department={this.state.fields.department}
				course={this.state.fields.course}
				onChange={this.onInputChange}
			/>

			<br />

			<input type="submit" disabled={this.validate()} />
		</form>

		<div>
			<h2>People</h2>
			<ul>
				{ this.state.people.map(({ name, email, department, course }, i) => 
					<li key={i}>{[ name, email, department, course ].join(' - ')}</li>
				) }
			</ul>
		</div>
	</div>
);

NOTE: The above example has indention error due to somewhere in the example indention went wrong

And we then of course, have to modify the validate():

validate() {
	const person = this.state.fields;
	const fieldErrors = this.state.fieldErrors;
	const errMessages = Object.keys(fieldErrors).filter((k) => fieldErrors[k]);

	if (!person.name) return true;
	if (!person.email) return true;
	if (!person.course) return true;
	if (!person.department) return true;
	if (errMessages.length) return true;

	return false;
},

After we have the data, wich returns to us in JS objects, we can then decied on how to form them
and use them. Such as serializing them to JSON objects, encode them into a URL or a search query or how to configure UI.

To implement async persistance, which is the idea of the data having been written to the app to persist after having read them in - We can generally do as follows:

1. Modify getInitialState() to keep track of persistance status. Basically, we'll want to know if the app
is currently loading, is currently saving, or encountered an error during either operation

2. Make request using our API client to get any previously persisted data and load it into our state.

3. Update our onFormSubmit() event handler to trigger a save

4. Change our render() method so that the "submit" button both reflects current save status and prevents
the user from performing an unwanted action like a double-save.

We begin by modifying the getInitialState():

getInitialState: function() {
	return {
		fields: {},
		fieldErrors: {},
		people: [],
		_loading: false,
		_saveStatus: 'READY',
	};
},

The _ prefix is also a designation of a private attribute, this means that the status of these things are not needed for others to know, be that children or parents.

Generally, we will have 4 status tags for _saveStatus: "READY", "SAVING", "SUCCESS" and "ERROR".

Of course, if we have READY or SAVING as status, we do not wish to allwo for submital to make saving available again.

What follows is a illustration of the loading process:

componentWillMount(){
	this.setState({ _loading: true });
	apiClient.loadPeople().then((people) => {
		this.setState({ _loading: false, people: people });
	});
},

the apiClient object is just a thin wrapper object to make network requests

In addition to the previous interaction, we now also add the part of persistance, for which allows
saving of objects.

onFormSubmit(evt) {
	const person = this.state.fields;

	evt.preventDefault();

	if (this.validate()) return;

	const people = [...this.state.people, person ]; //The previous people and the new person

	this.setState({ _saveStatus: 'SAVING' });
	apiClient.savePeople(people) //Save the people to a persisting state
		.then(() => { //a callback promise, if saving succeeded
			this.setState({ //Set the state
				people: people, //Declaring props
				fields: {}, //props
				_saveStatus: 'SUCCESS', //assign private status done
			});
		})
		.catch((err) => { //Catch the error and run a arrow function against the error, if saving failed
			console.error(err); //Just log the error and keep the rest
			this.setState({ _saveStatus: "ERROR" });
		});
},

NOTE: POssibly indention error somewhere here due to uneven code above.

We then update the render() method to account for the state of saving, loading etc.

render(){
	if (this.state._loading) {
		return <img alt="loading" src="/img/loading.gif" />
	}

	return {
		<div>
			<h1>Sign up sheet</h1>

			<form onSubmit={this.onFormSubmit}>

				<Field
					placeholder="Name"
					name="name"
					value={this.state.fields.name}
					onChange={this.onInputChange}
					validate={(val) => (val ? false : "Name required")}
				/>

				<br />

				<Field
					placeholder="Email"
					name="email"
					value={this.state.fields.email}
					onChange={this.onInputChange}
					validate={(val) => (isEmail(val) ? false : "invalid email")}
				/>

				<br />

				<CourseSelect
					department={this.state.fields.department}
					course={this.state.fields.course}
					onChange={this.onInputChange}
				/>

				<br />

				{{
					SAVING: <input value="Saving..." type="submit" disabled />
					SUCCESS: <input value="Saved!" type="submit" disabled />
					ERROR: <input
						value="Save failed - retry?"
						type="submit"
						disabled={this.validate()}
					/>,
					READY: <input
						value="Submit"
						type="submit"
						disabled={this.validate()}
					/>,
				}[this.state_saveStatus]}
			</form>

			<div>
				<h3>People</h3>
				<ul>
					{ this.state.people.map(({ name, email, department, course }, i) =>
						<li key={i}>{[ name, email, department, course].join(' - ')}</li>
					)}
				</ul>
			</div>
		</div>
	);
},

Now, we have to update the saved button to say ready after submission:

onInputChange({ name, value, error }){
	const fields = this.state.fields;
	const fieldErrors = this.state.fieldErrors;

	fields[name] = value;
	fieldErrors[name] = error;

	this.setState({ fields, fieldErrors, _saveStatus: 'READY'});
},

The next stage in The process, is to learn something called Redux, which allows for 
integration into larger apps. We will also cover Flux.

//NOTE: The Jump occurs from page 243, goes to 463. Return to 243 when we have gone over Flux and
Redux

The reason FLUX came to be, was that state propagation from the top of the hierarchy was becoming cumbersome in larger integrated systems where they ran into the problem of that they had to propogate too much in one function and let that trickle down.

Thus, they invented FLUX. The previous one to FLUX was MVC, (Model View Controller).

MVC is a design pattern that utilizes the View Logic in the Controller. After the controller instructs the model to display itself, the model updates and re-renders.

The FLUX design pattern is akin to a one way data pipeline. It has the following parts:

Action -> Dispatcher -> Store -> View (View then loops to action)

View dispatches what actions are occuring. The store recieves these, and determines what states to change.
After states update, they are pushed to the View.

FLUX allows for splitting up of state to smaller pieces that allows modification on each seperate piece.

The benefits go deeper, as FLUX also allows us to compute data such as amount of time passed since propogation of data - and then allows us to set the respective data to the part, at a later notice.

FLUX is a design pattern, and one of the libraries of FLUX, is Redux.

Redux is very simple, and aims to be that. It's key features are:

All app data is in a single data structure called State, which is held in Store.

The app reads state from said store, the state is never mutated directly outside of said Store,
the views emit actions that describe what occured, and a new state is then created from the old state and the propogated action by virtue of a function called the Reducer.

Since Redux is a implementation of Flux, Redux applies many concepts that apply to FLUX as well. Also, Reduxx is not a STRICT Implementation of Flux.

We begin by navigating to redux:

$ cd redux/counter

To run the code, we will use babel-oli:

$ ./node_modules/.bin/babel-node app.js

To install dependancies, we go to the app in redux/counter and run npm to install it:

$ npm install

The state in this case, will begin as 0, and a increment or decrement will be a result of our actions.

To create a new state, we call the reducer with the state and the action:

state = reducer(state, action);

Example:

Store: increment action (state 5) -> render() -> (state 6)

We start by constructing the reducer, to which we later on navigate up to the store and see what it looks like - It is there that the state is going to be maintained.

NOTE: States do not inheritly have to be just numbers.

Actions in Redux are objects. Each action has a attribute called a type property.

Our increment and decrement actions will look something like this:

{
	type: 'INCREMENT',
}

or

{
	type: 'DECREMENT',
}

We begin by defining the reducer function:

function reducer(state, action){
	if (action.type === 'Increment'){
		return state + 1;
	} else {
		return state;
	}
}

Showcasing of differing events:

const incrementAction = { type: 'INCREMENT' };

console.log(reducer(0, incrementAction)); // -> 1
console.log(reducer(1, incrementAction)); // -> 2
console.log(reudcer(5, incrementAction)); // -> 6

const unknownAction = { type: 'UNKNOWN' };

console.log(reducer(5, unknownAction)); // -> 5
console.log(reducer(8, unknownAction)); // -> 8

To support decrement, we just implement it into the reducer:

function reducer(state, action){
	if (action.type === 'INCREMENT') {
		return state + 1;
	} else if (action.type === 'DECREMENT'){
		return state - 1;
	} else{
		return state;
	}
}

To try it:

const decrementAction = { type: 'DECREMENT' };

console.log(reducer(10, decrementAction)); //-> 9
etc.

We can further more relate a value to each action, as per action.value and provide it in the reducer
for the respective action:

//The action:

{
	type: 'INCREMENT',
	amount: 7,
}

function reducer(state, action){
	if (action.type === "INCREMENT"){
		return state + action.amount;
	} else if (action.type === "DECREMENT"){
		return state - action.amount;
	} else{
		return state;
	}
}

A full example of running increment and decrement:

const incrementAction = {
	type: 'INCREMENT',
	amount: 5,
};

console.log(reducer(0, incrementAction)); // -> 5
console.log(reducer(1, incrementAction)); // -> 6

const decrementAction = {
	type: 'DECREMENT',
	amount: 11,
};

console.log(reducer(100, decrementAction)); // -> 80

We can create stores by the virtue of the createStore() in the Redux library.

The store consists of a hierarchy as follows:

action/State -> render() -> next state

Currently, our store provides two functions (we will write our own later on):

dispatch: The method we will use to send the store actions

getState: The method we will use to read the current value of state

We can then look at the full createStore() method:

function createStore(reducer){
	let state = 0; //Initialize the state to be 0 upon creation

	const getState = () => (state); //Get the state's current state

	const dispatch = (action) => { //dispatch an action to set the state through a reducer
		state = reducer(state, action);
	};

	return { //return the state and the dispatched action
		getState,
		dispatch,
	};
}


To call a dispatch to store, we can do as follows:

store.dispatch({ type: 'INCREMENT', amount: 7 });

NOTE: The dispatch does not return a state, we do not expect to have a resolution at a set point of time or any promise of resolution at all.

The return of the createStory uses the ES6 enhanced literal syntax, which is that we can forgo the assignmento f attributes with the <value> : <value>, to which we instead just write <value>,:

{
	getState,
	dispatch,
}

This is the same as.

{
	getState: getState,
	dispatch: dispatch,
}

The pattern which  the reducer uses is called a factory pattern, and the state is private to the said object being processed.

This means that the state of the object lives on through function calls.

An example of hanling the factory pattern is as follows:

function createAdder(){
	let value = 0;

	const add = (amount) => (value = value + amount);
	const getValue = () => (value);

	return {
		add,
		getValue,
	}
}

The way we use this, is as follows:

const adder = createAdder(); //Create the adder object

adder.add(1); //add 1
adder.getValue(); //print it out

NOTE: These functions such as the createAdder, which is put in the reducer which uses the factory method, is private. Which means that we can only call them inside of the reducer, not outside.

This stops unwanted mutation of the values and unwanted calls.

Thus, instead of using the reducer, we define it in the store and then call dispatches to the said object in the store:

const state = createStore(reducer);

const incrementAction = {
	type: 'INCREMENT',
	amount: 3,
};

store.dispatch(incrementAction); //Call a dispatch on the increment of the object
console.log(store.getState()); // The state is now 3, due to the dispatch having been created
store.dispatch(incrementAction);
console.log(store.getState()); //Since the reducer already exists in the store then we are incrementing the value and the value becomes 6.

const decrementAction = {
	type: 'DECREMENT'm,
	amount: 4,
};

store.dispatch(decrementAction);
console.log(store.getState()); //The state becomes 2, since it persists through function calls and the decrement has been called which is 4 in the decremential value

To run the app, we can run it with the babel:

$ ./node_modules/.bin/babel-node app.js


The last concept of redux that we have yet to explore, is the fact of that functions must be pure functions.

We can further more get access to notifications of updates to the states by virtue of something called subscriptions.

We can also split larger reducers into smaller reducers and them combine them into bigger ones later on.

And further more, we need to cover how to organize our redux app.

The next step we are goign to do, is to write a chat app!

We begin by doing the directions to dirs:

$ cd ../chat_simple

$ npm install

run the -ls i to see the content in the folder:

$ ls -i

Access the public file in these listings:

$ ls -i public/

To run the app and  then witness it:

$ npm run server

And then we access the said web server by virtue of localhost:3000

The difference of the state in this app is the fact of it is not going to be a number. Instead it is going to be a message Object, which has a single attribute: Message.

An example of the state value:

{
	messages: [
		'here is message one',
		'here goes message two lol',
	],
}

For the time being the structure is simplified in such a way that we are simply using strings instead of using objects, which simplifies the approach and allows us to not have IDs, instead we use indexes:

The two attributes we will have to messages, is ADD_MESSAGE and DELETE_MESSAGE:

{
	type: 'ADD_MESSAGE',
	message: 'Whatever message is, it goes here, lol',
}

//The delete message

{
	type: 'DELETE_MESSAGE',
	index: 2, //Index of whatever message is being removed here
}

We then begin building the reducer(), and we initialize the state to be 0 to begin with.

function createStore(reducer) {
	let state = 0;
	... //Stuff follows
}


To account for the fact that we need to have an array to be the initializing State, then we have to spawn an array and pass it in as a argument in as a second argument of the store:

//The state declaration of the messages:

{
	messages = [];
}

//The store

function createStore(reducer, initialState){
	let state = initialState;
	//Stuff follows
}

We then begin writing the ADD_MESSAGE function inside of the store:

function reducer(state, action){
	if (action.type == 'ADD_MESSAGE'){
		return {
			messages: state.messages.concat(action.message),
		};
	} else {
		return state;
	}
}

What we would be tempted to do now, is to define the ADD_MESSAGE to actually push to the array of messages, but this would contradict the mantra of that each function must be pure. And since it returns a modified state of a object and it affects the real world around it in a real world, then we must handle it in a different way - Which means that we have to treat the data inside to be immutable.

Thus, to solve this, we create a new state and return a new state:

return {
	messages: state.messages.concat(action.message),
};

We then go to apply these principles to the messaging app:

const intialState = { messages: [] };

const store = createStore(reducer, initialState);

We then add dispatches and we run messages:

const addMessageAction1 = {
	type: 'ADD_MESSAGE',
	message: 'THE GOOSE HAS LANDED, TANGO, OVER',
};

store.dispatch(addMessageAction1);
const stateV1 = store.getState();

const addMessageAction2 = {
	type: 'ADD_MESSAGE',
	message: 'NOOOOOOO, CHARLIES IN THE TREES',
};

store.dispatch(addMessageAction2);

const stateV2 = store.getState();

console.log('State v1');
console.log(stateV1);

etc.

Running it with label, gives:

./node_modules/.bin/babel-node public/app.js

So what occured, is we dispatched the object and then we assigned the new data to the returned object.

Now, following the mantra of which we want, we have to use array slicing where we return a new array with the indexing leveled at what we wanted to change and delete:

function reducer(state, action){
	if (action.type === 'ADD_MESSAGE') {
		return {
			messages: state.messages.concat(action.message),
		};

	} else if (action.type === 'DELETE-MESSAGE') {
		return {
			messages: [
				...state.messages.slice(0, action.index), //These two parts makes so that we just slice out the part that is relevant. Which means that we have deleted the message from the array that we specified that we wanted gone.
				...state.messages.slice(
					action.index + 1, state.messages.length
				),
			],
		};
	} else {
		return state;
	}
}

The ... operator in ES6, is called the spread operator, which acts as per expanding the array and merging it to the parent array, as an example follows:

const a = [ 1, 2, 3];
const b = [ 4, 5, 6];
const c = [...a, ...b, 7, 8, 9]; //Becomes an array of 1,2,3,4,5,6,7,8,9

The difference between making the call with [a,b,7,8,9] and using the ... notation, is that ... merges, where as of the simple call of pure letters, will lead to a tuple instead of a actual merged array


An example of the deletion in process:

const AddMessageAction = {
	type: 'DELETE_MESSAGE',
	index: 0,
};

store.dispatch(deleteMessageAction);
const stateV2 = store.getState();

console.log("State V2");
console.log("stateV3");

We then run the file with babel:

./node_modules/.bin/babel-node public/app.js

To fix the subscriber system we have to account for whenever a change happens. To fix this, we assign listeners in the store, which allows us to notify when changes occur:

function createStore(reducer, initialState){ //Run a reducer and run the initialState
	let state = initialState;
	const listeners = [];

	const subscribe = (listener) => ( //Push the listener unto the list upon subscription
		listeners.push(listener)
	);

	const getState = () => (state); //Get the state 

	const dispatch = (action) => { //When a action is run, do a dispatch
		state = reducer(state, action); //run a reducer on the state and the action
		listeners.forEach(1 => 1()); // For each that has a state of 1, which means that
		//a action has been fired, we fire a function to run on them, which has no arguments, thus it's just tracking of dispatch of the event to begin with
	};

	return {
		subscribe, //Upon being called, we return the subscribe status
		getState, //the state
		dispatch, //And the dispatch
	};
}

To try it out, we would do the following:

const store = createStore(reducer, initialState);

We then run the listener:

const listener = () => {
	console.log(store.getState())
};

We then subscribe:

store.subscribe(listener);

And as the final part, we commit the dispatches:

const addMessageAction1 = {
	type: 'ADD_MESSAGE',
	message: 'How do you read?',
};
store.dispatch(addMessageAction1);

const addMessageAction2 = {
	type: 'ADD_MESSAGE',
	message: 'CHARLIES IN THE TREEEEEEEES',
};
store.dispatch(addMessageAction2);

const deleteMessageAction = {
	type: 'DELETE_MESSAGE',
	index: 0,
};
store.dispatch(deleteMessageAction);

every time a dispatch is made here, the listener is called.

Now, we have that Redux runs the state handling, not React. Which means that the top level components will call store.getState() to get their states, instead of calling this.state

For instace:

class App extends React.component {
	render() {
		const messages = store.getState().messages;
		...
	}
};

To then handle subscription in react, involves the idea of running subscribe and then
tying it to a forceUpdate():

class App extends React.Component{
	componentDidMount(){ //Whenever a component mounts, we run a subscription on it,
	//and force a update
		store.subscribe(() => this.forceUpdate());
	}
};

Lower level components will send dispatches to the store upon relevant actions being fired:

class Messages extends React.Component {
	handleDeleteClick = () => {
		store.dispatch({
			type: 'DELETE_MESSAGE',
			index: this.props.index,
		});
	};
	//... Code goes here
};

Upon every dispatch, it forces React to re-render, and we have that the getState is re-get from the store.

NOTE: WE could break the componentional structure down even more to have messages be one part and the message list one part, but the messsages are so simple that atm it is not needed.

The top class we have, is App, which will handle the subscription and communication with the store:

class App extends React.Component{
	componentDidMount(){
		store.subscribe(() => this.forceUpdate());
	}

	//And then we run the render on the view
	render(){
		const messages = store.getState().messages;

		return (
			<div className="ui segment">
				<MessageView messages={messages} />
				<MessageInput />
			</div>
		);
	}
}
	//The above code now provides for a one way pipeline that goes from the top downwards.
	//But what if we want to have two way communication with ability to
	//have MessageInput add messages and MessageView to delete messages.

We then go to define the message adding function handling:

class MessageInput extends React.Component {
	handleSubmit = () => {
		store.dispatch({
			type: 'ADD_MESSAGE',
			message: this.refs.messageInput.value,
		});
		this.refs.messageInput.value = '';
	};

	//And we then define the render method:

	render(){
		return (
			<div className="ui input">
				<input
					ref="messageInput"
					type="text"
				>
				</input>
				<button
					onClick={this.handleSubmit}
					className="ui primary button"
					type="submit"
				>
					Submit
				</button>
			</div>
		);
	}

}

NOTE: We could have skipped the onClick and instead run a dispatch() call in a wrapper of a arrow function:

	key={index}
	onClick={() => (
		store.dispatch({
			type: 'DELETE_MESSAGE',
			index: index,
		})
	)}
>
	{messages}

And thus, the MessageInput in it's full glory:

classMessageInput extends React.Component {
	handleSubmit = () => {
		store.dispatch({
			type: 'ADD_MESSAGE',
			message: this.refs.messageInput.value,
		});
		this.refs.messageInput.value = '';
	};

	render(){
		return(
			<div className="ui input">
				<input
					ref='messageInput'
					type='text'
				>
				</input>
				<button
					onClick={this.handleSubmit}
					className='ui primary button'
					type='submit'
				>
					Submit
				</button>
			</div>
		);
	}
}


And further more, we wish to handle the deletion of mouse clicking on messages to delete them:

class MessageView extends React.Component {
	handleClick = (index) => {
		store.dispatch({
			type: 'DELETE_MESSAGE',
			index: index,
		});
	};

	render(){
		const messages = this.props.messages.map((messages, index) => (
			<div
				className='comment'
				key={index}
				onClick={() => this.handleClick(index)}
			>

			{messages}
		</div>

		));
		return (
			<div className='ui comments'>
				{messages}
			</div>
		);
	}
}

The last piece, is that we call the DOM to render stuff:

ReactDOM.render(
	<App />,
	document.getElementById('content')
);

Next we just run the server with $ npm run server

The more complicated our structure grows, the more relevant redux becomes, due to:

1. All of the data is in a central data structure

2. Data changes are also centralized

3. The actions that views emit are decoupled from the state mutations that occur

4. One-way data flow makes it easy to trace how changes flow through the system

We then begin preperations for creating the intermediate step of the app:

$ cd redux/chat_intermediate

if you run ls -i public/ , we will see the files

We then simply run the npm install and npm server:

$ npm install

$ npm run server

The shipped version of the Redux createStore() is the same as the one we have defined, except for some subtle differences.

To bring our chat app to be more realistic, as in time of sending and Id of sending, we need to add attributes as per follows:

{
	messages: [
		//An example message
		//messages are now objects 
		{
			text: 'ALPHA TANGO MANGO',
			timestamp: '1461974250213', //Run with Date.now() to get Epoch time
			id: 'QdaQ8285-4178',
		},
		//....
	]
}

Now, we will modify the reducer, for the add message handling so that we access attributes in a different matter:

function reducer(state, section){
	if (action.type === 'ADD_MESSAGE'){
		const newMessage = {
			text: action.text,
			timestamp: Date.now(),
			id: uuid.v4(), //Secure way of rendering unique IDs
		};
		return {
			messages: state.messages.concat(newMessage),
		};
	} else if (action.type === 'DELETE_MESSAGE'){
		const index = state.messages.findIndex(
			(m) => m.id === action.id
		);
		return {
			messages: [
				...state.messages.slice(0, index),
				...state.messages.slice(
					index + 1, state.messages.length
				),
			],
		};
	}
}

What we do now in the delete message is that we grab two chunks and isolate the part of which is we want to delete

to then update the react components, we do dispatches:

class MessageInput extends React.Component{
	handleSubmit = () => {
		store.dispatch({
			type: 'ADD_MESSAGE',
			text: this.refs.messageInput.value,
		});
		this.refs.messageInput.value = '';
	};
}

And then we handle the dispatch for deleting messages:

class MessageView extends React.Component {
	handleClick = (id) => {
		store.dispatch({
			type: 'DELETE_MESSAGE',
			id: id,
		});
	};

	render(){
		const messages = this.props.messages.map((message, index) => (
			<div
				className="comment"
				key={index}
				onClick={() => this.handleClick(message.id)} //Use id

				<div className='text'> {/*Wrap message in div */}
					{message.text}
					<span className='metadata'>0{message.timestamp}</span>
				</div>
			</div>
		));
	}
}

Now, to make the app tied to the real world, where we connect stuff, we have to introduce the concept of threads. Threads in this context means simply a owner of said conversation you are having with other respective user.

Every conversation belongs to a Thread.

We then have to reconstruct our building of the system:

{
	threads: [
		{
			id: 'd7Q02357-4703',
			title: 'Buss Aldrin',,
			messages: [
				{
					id: 'e55Q6e6b-Q7cc',
					text: 'Twelve minutes to ignition',
					timestamp: 1462122684882,
				},
				//Other messages with Buss Aldrin
			]
		},
		//Other threads with other users
	],
}

For the sake of simplicity, we will initialize State to be a specified value
that is hardcoded:

const initialState = {
	threads: [
		{
			id: '1-fca2',
			title: 'Buss Aldrin',
			messages: [
				{
					text: 'Twelve minutes to ignition',
					timestamp: Date.now(),
					id: uuid.v4(),
				},
			],
		},
		{
			id: '2-be91',
			title: 'Michael Collins',
			messages: [],
		},
	],
};

We have to further more modify one small thing, which is what thread to display:

const initialState = {
	activeThreadId: 'i-fca2',
	threads: [
		//stuff...
	]
}

We begin by modifying the App component to assert that our app supports the new threads structure:

class App extends React.component {
	componentDidMount() {
		store.subscribe(() => this.forceUpdate()); //if the component mounts,
		//subscribe and force it to update
	}

	render() { //Render the stuff
		const state = store.getState(); //The state
		const activeThreadId = state.activeThreadId; //the active Thread
		const threads = state.threads; //the threads
		const activeThread = threads.find((t) => t.id === activeThreadId); //Find the active thread

		return ( //return a div wrapped around the active Thread
			<div className='ui segment'>
				<Thread thread={activeThread} />
			</div>
		);
	}
}

We then turn out gaze upon the MessageView and convert it into thread, which will allow us to integrated thread interaction in the handling of things:

class Thread extends React.Component {
	render() {
		const messages = this.props.thread.messages.map((message, index) => ( //etc.))
	}

	//we hold off on the updating of MessageInput for now
}

Albeit the current version is:

return (
	<div className='ui center aligned basic segment'>
		<div className='ui comments'>
			{messages}
		</div>
		<MessageInput />
	</div>
);

We then go on to create the tabs integration of threads:

const tabs = threads.map(t => (
	{
		title: t.title,
		active: t.id === activeThreadId,
	}
));

We then add the App component's markup, passing them down as props:

return (
	<div className='ui segment'>
		<ThreadTabs tabs={tabs} />
		<Thread thread={activeThread} />
	</div>
);

We then go to define the class for the tabs:

class ThreadTabs extends React.Component {
	render() {
		const tabs = this.props.tabs.map((tab, index) => (
			<div
				key={index}
				className={tab.active ? 'active item' : 'item'}
			>
				{tab.title}
			</div>
		));
		return (
			<div className='ui top attached tabular menu'>
				{tabs}
			</div>
		);
	}
}

Since we now added the idea of threads, we integrate it into the action handlers:

{
	type: 'ADD_MESSAGE',
	text: 'Looking Good',
	threadId: '1-fcs2', //or whichever thread is relevant
}

We then go to modify the reducer to reflect handling of threads:

const newMessage = {
	text: action.text,
	timestamp: Date.now(),
	id: uuid.v4(),
};
const threadIndex = state.threads.findIndex(
	(t) => t.id === action.threadId
);

And to keep the function pure, we are not allowed to mutate state. Thus, we take the old thread and mutate it with the new thread:

const oldThread = state.threads[threadIndex];
const newThread = {
	...oldThread,
	messages: oldThread.messages.concat(newMessage);
};

Note: We could have achieved the same effect by virtue of object assignment:

Object.assign({}, oldThread, {
	messages: oldThread.messages.concat(newMessage),
});

NOte: the ...<object> notation is just "include the earlier attributes of object"

To showcase the way we would then handle of creating the new format of the thread object, is the fact of keeping it pure combined with the idea of using the spread operator (...), as follows:

return {
	...state,
	threads: [
		...state.threads.slice(0, threadIndex),
		newThread,
		...state.threads.slice(
			threadIndex + 1, state.threads.length
		),
	],
};

Thus, the end result of adding new messages with thread support is as follows:

if (action.type === 'ADD_MESSAGE'){
	concat newMessage = {
		text: action.text,
		timestamp: Date.now(),
		id: uuid.v4(),
	};
	const threadIndex = state.threads.findIndex(
		(t) => t.id === action.threadId
	);

	const oldThread = state.threads[threadIndex];
	const newThread = {
		...oldThread,
		messages: oldThread.messages.concat(newMessage),
	};

	return {
		...state,
		threads: [
			...state.threads.slice(0, threadIndex),
			newThread,
			...state.threads.slice(
				threadIndex + 1, state.threads.length
			),
		],
	};
}

We  then just have to update the remaining things to also refer to the thread based infrastructure:

return (
	<div className="ui center aligned basic segment">
		<div className="ui comments">
			{messages}
		</div>
		<MessageInput threadId={this.props.thread.id} />
	</div>
);

And the last thing to update, the MessageInput:

class MessageInput extends React.Component {
	handleSubmit = () => {
		store.dispatch({
			type: 'ADD_MESSAGE',
			text: this.refs.messageInput.value,
			threadId: this.props.threadId,
		});
		this.refs.messageInput.value = '';
	};
}

And following the normal logic of not interfering with the actual state set, we instead
create a new version and return it, as follows:

} else if (action.type === 'DELETE_MESSAGE'){
	const threadIndex = state.threads.findIndex(
		(t) => t.messages.find((m) => (
			m.id === action.id
		))
	);
	const oldThread = state.threads[threadIndex];
}

And according to that of the older versions of code, we now do the same thing:

const messageIndex = oldThread.messages.findIndex(
	(m) => m.id === action.id
);
const messages = [
	...oldThread.messages.slice(0, messageIndex),
	...oldThread.messages.slice(
		messageIndex + 1, oldThread.messages.length
	),
];

We then prepare the new thread:

const newThread = {
	...oldThread,
	messages: messages,
};

And then to handle the return part:

return {
	...state,
	threads: [
		...state.threads.slice(0, threadIndex),
		newThread,
		...state.threads.slice(
			threadIndex + 1, state.threads.length
		),
	],
};

And thus, we end up with the complete version of things:

} else if (action.type === 'DELETE_MESSAGE') {
	const threadIndex = state.threads.findIndex(
		(t) => t.messages.find((m) => (
			m.id === action.id 
		))
	);
	const oldThread = state.threads[threadIndex];
	const messageIndex = oldThread.messages.findIndex(
		(m) => m.id === action.id
	);

	const messages = [
		...oldThread.messages.slice(0, messageIndex),
		...oldThread.messages.slice(
			messageIndex + 1, oldThread.messages.length
		),
	];
	const newThread = {
		...oldThread,
		messages: messages,
	};

	return {
		...state,
		threads: [
			...state.threads.slice(0, threadIndex),
			newThread,
			...state.threads.slice(
				threadIndex + 1, state.threads.length
			),
		],
	};
}

We then go to define the dispatch of changing the active thread id:

{
	type: 'OPEN_THREAD',
	id: '2-be91',
}

And we have to modify the reducer:

} else if (action.type === 'OPEN_THREAD') {
	return {
		...state,
		activeThreadId: action.id,
	};
}

To allow dispatching we need to know the id of the thread dispatching. We add this to the app:

const tabs = threads.map(t => (
	{
		title: t.title,
		active: t.id === activeThreadId,
		id: t.id,
	}
));

Next we handle the action event handler:

class ThreadTabs extends React.Component {
	handleClick = (id) => {
		store.dispatch({
			type: 'OPEN_THREAD',
			id: id,
		});
	};
}

We then map the event handlers to the respective tabs:

const tabs = this.props.tabs.map((tabs, index) => (
	<div
		key={index}
		className={tab.active ? 'active item' : 'item'}
		onClick={() => this.handleClick(tab.id)}
	>
	//etc.
	)


While all of this is great and all, we also might want to wish to break down the reducer to easen up the logic, avoid duplication and a number of other issues.

Thus, we break apart the reducer by making subreducers, smaller reducers that get called with interactions:

function reducer(state, action){
	return {
		activeThreadId: activeThreadIdReducer(state.activeThreadId, action),
		threads: threadsReducer(state.threads, action),
	};
}

The above code delegates what thread to handle what. This means that we are breaking down the composition of the reducer to smaller states to handle individual things.

To get a better idea, here is the activeThreadId reducer:

function activeThreadReducer(state, action){
	if (action.type === 'OPEN_THREAD'){
		return action.id;
	} else {
		return state;
	}
}

The above code will simply handle reduction of active threads, so if its a open thread, it will return the state - and if its that we wish to open a thread, we return the id of the action.

Having applied all of the recurring logic to the threads, pruning relevant ones and re-assigning to keep state handling pure, we get the following result:

function threadsReducer(state,action){
	if (action.type === 'ADD_MESSAGE'){
		const newMessage = {
			text: action.text,
			timestamp: Date,now(), //timestamp
			id: uuid.v4(), //Id
		};
		const threadIndex = state.findIndex( //index of thread
			(t) => t.id === action.threadId
		);

		const oldThread = state[threadIndex]; //find the old thread
		const newThread = {
			...oldThread,
			messages: oldThread.messages.concat(newMessage),
		};

		return [
			...state.slice(0, threadIndex),
			newThread,
			...state.slice(
				threadIndex +1, state.length
			),
		];

	} else if(action.type === 'DELETE_MESSAGE'){
		const threadIndex = state.findIndex(
			(t) = t.messages.find((m) => (
				m.id === action.id //Ifwe are running to delete a message,
				find the index of the thread, find it in messages and assign it
			))
		);
	};

	const oldThread = state[threadIndex];
	const messageIndex = oldThread.messages.findIndex(
		(m) => m.id === action.id //find the index of the message based on the id
	);

	const messages = [
		...oldThread.messages.slice(0, messageIndex),
		...oldThread.messages.slice( //messages is the oldThreads messages -the deleted one
			messageIndex + 1, oldThread.message.length
		),
	];

	const newThread = {
		...oldThread,
		messages: messages, //Concat the new thread from old thread msgs + messages
	};

	return [
		...state.slice(0, threadIndex),
		newThread,
		...state.slice(
			threadIndex + 1, state.length //Return the new thread that has sliced out the deleted message
		),
	];
	} else {
		return state; //If the state is unmodified, return it
	}
}

NOTE: ABove indention is wrong somewhere, cba to fix, general gist is the same

With the above code, we still have some repetition delegated between the two threads. Which means that wecan further break it down into delegations in terms of accessing a sub reducer which handles message reducing (1 of the 2 reducers working on identical states)

We begin with re-defining threadsreducer that is responsible for the subclass of messageReducer() as follows:

function threadsReducer(state, action){
	if (action.type === 'ADD_MESSAGE'){
		const threadIndex = state.findIndex(
			(t) => t.id === action.threadId
		);
		const oldThread = state[threadIndex];
		const newThread = {
			...oldThread,
			messages: messagesReducer(oldThread.messages, action),
		};
	}
}

We have moved the responsibility of adding messages to the messageReducer which allows us to break up the component parting which means we can seperate state handling and simply assign calls to the hierarchy as follows:

function messagesReducer(state, action){
	if (action.type === 'ADD_MESSAGE'){
		const newMessage = {
			text: action.text,
			timestamp: Date.now(),
			id: uuid.v4(),
		};
		return state.concat(newMessage);
	} else {
		return state;
	}
}

And we of course seperate the delete_message in the same way:

} else if (action.type === 'DELETE_MESSAGE'){
	const threadIndex = state.findIndex(
		(t) => t.messages.find((m) => (
			m.id === action.id
		))
	);
	const oldThread = state[threadIndex];
	const newThread = {
		...oldThread,
		messages: messageReducer(oldThread.messages, action),
	};
}

The result here is the fact of that we have functions that are almost similar, the only differential is how they identify the findIndexes. Which we can consequently break out and deal with seperately:

function findThreadIndex(threads, action){
	switch (action.type) {
		case 'ADD_MESSAGE': {
			return threads.findIndex(
				(t) => t.id === action.threadId
			);
		}
		case 'DELETE_MESSAGE': {
			return threads.findIndex(
				(t) => t.messages((m) => (
					m.id === action.id
				))
			);
		}
	}
}

And as for the threadReducer, we also do switch cases, but it looks slightly different in handling of threads:

function threadsReducer(state,action){
	switch(action.type) {
		case: 'ADD_MESSAGE': //NOTE: having no body for a case followed by another case is pretty much just the equivilant
		of running a or statement against two different states.
		case: 'DELETE_MESSAGE': {
			const threadIndex = findThreadIndex(state, action);

			const oldThread = state[threadIndex];

			const newThread= {
				...oldThread,
				messages: messagesReducer(oldThread.messages, action),
			};

			return [
				...state.slice(0, threadIndex),
				newThread,
				...state.slce(threadIndex + 1, state.length
				),
			];
		}

		default {
			return state;
		}
	}
}

Next up is bringing the state initialization closer to the rest of our state dealings, which means that we have to use a trick of running the state as being undefined to differentiate it upon initialization from the other things and modify it before it fires.

This is a clever trick due to the fact of that we can run the check against the undefined which will only be at one point of time - when it fires the default initiliazer due to the fact of not having passed a initialState to it:

const store = Redux.createStore(reducer); //Omit the initializer which causes a default initializer to fire with undefined, which we can use in our favor.

The initialize as is, looks as follows:

//inside the createStore() call
dispatch({ type: '00redux/INIT' });

return {
	dispatch,
	subscribe,
	getState,
}


To run the reducer with no state initialized, we run it with a empty object:

function reducer(state = {}, action) {
	//code goes here
}

As for ES6 and default arguments, it works so that if we do not provide the argument, it will default to being undefined. BUt we can of course designate it to be undefined as well if we wish, as follows:

function divide(a, b){
	const divisor = typeof b === 'undefined' ? 1 : b; //Can be written as giving the b argument a default value of 1 in the argument list
}

omitting an argument that does not have a standardized value, will simply provide it as undefined.

We then set the activeThreadIdReducer to be the relevant state of the first thread that we have and then run the action:

function activeThreadIdReducer(state = 'i-fca2', action) {
	// Code
}

And then we go to fix the initialState of the threadsReducer() :

function threadsReducer(state = [
	{
		id: 'i-fca2',
		title: 'Buss Aldrin',
		messages: messagesReducer(undefined, {}),
	},
	{
		id: '2-beQ1',
		title: 'Michael Collins',
		messages: messagesReducer(undefined, {}),
	},
], action) {
	//etc.
}

NOTE: If we were not initializing threadsReducer with two states already, we would assign it to default to a empty object:

function threadsReducer(state = [], action){
	//Code
}

We could now remove the old version of messagesReducer states :

function messagesReducer(state = [], action){
	//Code
}

And we could also have just set the initial state in the declaration of the object to begin with in the threadsReducer:

{
	id: '2-beQ1',
	title: 'Michael Collins',
	messages: messagesReducer(
		undefined, { type: '00redux/INIT' }
	),
},

We can further more modify our reducer to combine reducers to merge designation of different functions:

const reducer = Redux.combineReducers({
	activeThreadId: activeThreadIdReducer,
	threads: threadsReducer,
});

NOTE: A common way of handling reducers, is the fact of wrapping them:

const reducer = Redux.combineReducers({
	activeThreadId,
	threads,
});


At this point, we have our actions, our reducer and our streamlined form component. All we gotta do, is connect them together.

First, we create a store and to be able to launch asynch stuff, we apply the Middleware with the thunkMiddleware module from redux.

const store = createStore(reducer, applyMiddleware(thunkMiddleware));

We will use react-redux's Connect method that will allow us to tie these together. However, we first, we must map the states:

function mapStateToProps(state){
	return {
		isLoading: state.isLoading,
		fields: state.person,
		people: state.people,
		saveStatus: state.saveStatus,
	};
}

We then go to map the stating of the save people action to be on submitting:

function mapDispatchToProps(dispatch){
	return {
		onSubmit: (people) => {
			dispatch(savePeople(people));
		},
	};
}

We then use the connect method to give an optimized ReduxForm component:

const ReduxForm = connect(mapStateToProps, mapDispatchToProps)(Form);

We then write the two remaining parts, which is handling of the mounting of the component and the loading of the rendering of states:

componentWillMount(){
	store.dispatch(fetchPeople());
},

And as for the render, we use a helper component called Provider, to make the relevant things to be children of all the relevant components:

render(){
	return (
		<Provider store={store}>
			<ReduxForm />
		</Provider>
	);
},

Beyond this, there is of course standardized form modules that allow us to use already completed things to be able to handle forms, as we will see in the coming chapter:

formsy-react //A module that strikes between reusability and flexibility

react-input-enhancements //Allows for mode advanced customization on a abstract level, as this module as of the writing, is not ready for production yet. Allows for masking, autocomplete, dropdown etc.

tcomb-form //To be used with tomb models, centers around Domain Driven Design, which allows for autocompletion of markup etc. useful if you use tomb models and you wish to autocomplete stuff

winterfell //Allows for sketching out entire forms, css, fields, types, reqs etc. in a entire JSOn object.

react-redux-form //Allows for a collection of action creators and reducer creators.

To load ES6 stuff, we can just use babel to transpile stuff:

<script src='vendor/babel-standalone.js'></script>

<script type='text/babel' src='./client.js'></script>

modules are basically like a limited interface blackbox that provides functionality 

We can think of React components as Modules.

The general pattern of React components is to accept a prop and run a render() call with said input.

In ES6, we can use something called Bundles. Bundles are a way to pile up ES6 and have it work seemlessly in our Environment.
They provide toolkitss and toolchains for us to use. However, they add complexity and the startup of them is a pain.

Thus, the React create-react-app bundle was made.

To create a React create-react-app, we can simple do as follows:

$ create-react-app my-app-name

This will create a black box, that will allow us to use it without knowing the details.

to install the thing, we can do as follows:

npm -i -g create-react-app00.5.0 //defines a version number for the app to be created for create-react-app

We then go to modify the stuff:

$ cd webpack

$ ls -ip //Call it to view contents

We then run up the app in a folder called heart-webpack:

$ create-react-app heart-webpack

$ cd heart-webpack

And we then go to lock in the same version as is per this book, we can do this as follows:

npm install --save-dev --save-exact react-scripts00.6.1 //locks in the 0.6.1 version

We then look and what we made:

$ ls -ip

If we were to go to public/index.html, we would find that the script tags are omitted, since it loads no external JS
dependancies.

We then see in the package.json that we have a lining up of packages, dependancies and stuff:

{
	"name": "heart-webpack",
	"version": "0.1.0",
	"private": true,
	"devDependencies": {
		"react-scripts": "0.7.0"
	},
	"dependencies": { //The Dependancies that we run with instead of the JS imports
		"react": "15.4.1",
		"react-dom": "15.4.1"
	},
	"scripts": {
		"start": "react-scripts start",
		"build": "react-scripts-build",
		"test": "react-scripts test --env=jsdom",
		"eject": "react-scripts eject"
	}
}

The create-react-app is just a boilerplate that generates a setup for us to use, whilst the actual work is done in the
react-scripts package, specified in package.json , which is the engine

By virtue of including the above, we allow for inclusion of npm package managing, which means that we can put in modules that we need to have.

The four scripts in the JSON object, is as follows:

start //Boots the Webpack development HTTP server. Handles requests from out web browser

build //For in production, creates a optimized, static bundle of all of our assets.

test //Executes the app's test suite, if present

eject //Moves innards of the react-scripts into our project dir. Enables abandonment of config the react-scripts provided,
tweaking the config to your liking.

We can specify which packages are nessecary in the package.json, and we can use the eject, if we wish to move away from the blackbox approach, which we might do when we get into later parts of developing.

The general structure, mgiht be as follows:

//inside of src/:

$ ls -ip src
App.css
App.js
App.test.js
index.css
index.js
logo.svg

Inside of the App.js of the src/:

import React, { Component } from 'react';
import logo from './logo.svg';
import './App.css';

class App extends Component {
	render() {
		return (
			<div className="App">
				<div className="App-header">
					<img src={logo} className="App-logo" alt="logo" />
					<h2>Welcome to react</h2>
				</div>
				<p className="App-intro">
					To get started, edit <code>src/App.js</code> and save to reload
				</p>
			</div>
		);
	}
}

export default App;

What we do, is that we import all dependancies, be they React Components or otherwise, and we then export
the App.

The entire app is three dedicated files: component itself, CSS and dedicated Test file.

The component that is written to the DOm, is the index.js:

import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import './index.css';

ReactDOM.render(
	<App />, //is a JSX component that underlying has element of calling React
	document.getElementById('root')
);

An example of exporting and then importing variables:

export const sayHi = () => (console.log("Hi!"));
export const sayBye = () => (console.log("Bye!"));

And then importing them:

import { sayHi, sayBye } from './greetings';

Which we can simply call on:

sayHi();

or

sayBye();

We can also just export them all in one chunk:

export { sayHi, sayBye };

We can also assign imports to be part of a nameSpace, which acts as a psuedo class and accesses the bound stuff to said thing:

import * as Greetings from '/.greetings'; //Imports all the functions of greetings.js

The default export is when you export the entire object in one go:

const Greetings = { sayHi, sayBye };

export default Greetings;

can be imported with:

import Greetings from '/.greetings';

Greetings.sayHi(); // Hi
Greetings.sayBye(); // Bye

If we want an entire class:

import ReactDOM from 'react-dom';

ReactDOM.render(
	//Stuff
);

To import a specific method:

import { render } from 'render-dom';

render(
	//something
);

To achieve the flexibility, we can do as follows:

export const render = (component, target) => {
	//stuff
};

const ReactDOM = {
	render,
	//other functions
};

export default ReactDOM;

To view the sourcecode of pages, we can access things with:

view-source:http://localhost:3000/ in the browser field

Upon booting the app with the webpack, we will see that dependancies are inserted at the bottom of the Index.html to allow it to know what we are using.

The bundle is constructed on the fly and loads all dependancies based on connecting to the server. Said dependancies, in our case, is React and all of the relevant JS that we have written for the said app.

The Webpack has used babel to transpile all of the info that we needed and that we wish to provide to the index.html, which it uses to then send the info to the server.

The modules, are encapsulated in functions as follows:

function(module, exports, __webpack_require__){
	//The transpiled App.js code goes here
}

Where as of for other implementations such as logos and shit:

var logo = __webpack_reqiuire__(/*! ./logo.svg */ 250); //This inline comment is mostly there for debug purposes of the babel transpiler. 

Webpacks  treats everything in it's way as Modules, and allocates them to be dirs on the Server, with relative pathing to be on the server.

If we console log the variable of which we have the required variable with a id, we can find out the dir placing of the file.

Such as follows:

var _logo = __webpack_require__(250);
console.log(_logo);

The reason for it bundling everything up in the bundle.js is maximizing performance.

the Webpack allows for something called hot reloading, which means that we can replace stuff by virtue of just assignment. However, this is only stable for CSS.

if we edit the CSS elements of classes in the window, they will update on the fly.

The hot reloading works as per a client code that keeps a web socket open against the server and calls for a patch upon modification which modifies the elements in the Server.

The client simply removes the old style tags and inserts new ones into the DOM.

Beyond this, we have the autoload, as well, which does the same thing as hotswapping, really, which the Webpack handles.

To create a production build, we shut down the current server and run a build, to later be able to put it on asset hosts.

npm run build

We then go that dir

$ cd build
$ ls -lp

A big difference as well, is that of not including new line characters in a production build, because it takes unessecary space to include in a production build.

NOTE: Webpack version assets are versions of the Js file that updates upon modification of the file and forces the client browser to load the latest version.

When it comes to production lineup, we can optimize effectivity by virtue of processes called minifying, uglifying and source mapping.
They strip all unessecary characters and put them unto one line, followed by one line with a dir of the location.

uglification is just to make the code ugly, while keeping interaction , perverting others from understanding the codebase.

The uglified and the minified files come along with source maps, that end in .map , that allows for mapping out the stuff and making the originals back to what they were.

To eject a project, we run npm run eject from the heart-webpack

NOTE: There is no way to back out of a eject command, and we should keep a copy of relevant dirs for ejecting.

In the root dirs, server.js is for the server and client/ is for the React app.

The respective maps and files are filled with relativily well documented code, so if we wanted to knos tuff we could just look ati t.

There is also two json package files, one for handling the API servers and the second for being the React app.

In the .babelrc, we find the babel lib with plugins.

We add this in the app.js:

<script
	type="text/babel"
	data-plugins="transform-class-properties"
	src="./js/app.js"
></script>

We then include babel in the package.json:

"babel-plugin-transform-class-properties": "6.22.0",

We then install dependancies for server and client:

$ npm i && cd client && npm i && cd ..

We then run the server from the top level dir:

$ npm start

The app in the example consists of 3 parts, 3 components, the Parent table and 2 other tables.

The server in the example provides a single API endpoint which accepts one argument, which is q. Which defines what we are searching for. if we run the server, we can access the searching as follows:

$ npm run server

$ curl localhost:3001/api/food?q=hash+browns

//Will give a long listing of food items

The client module, which is located in client/src/Client.js, exports one object with one method, search() - It looks as follows:

function search(query, cb) {
	return fetch(`http://localhost:3001/api/food?q=${query}`, {
		accept: 'application/json',
	}).then(checkStatus)
	  .then(parseJSON)
	  .then(cb);
}

Thus, we end up with two servers. One on 3001 with the API server, and one on 3000 with the Webpack development server

we have a concurrency utility that allows us to run things concurrently, to which allows us to boot up the two servers concurrently:

concurrently "command1" "command2"

If we were doing just mac or linux:

concurrently "npm run server" "cd client && npm start"

Since we will add a piece of client code to the package.json, we will end up with a command that looks as follows:

$ npm run server

$ npm run client

And we then end up with:

$ concurrently "npm run server" "npm run client"

We then add the start and client commands to the package.json:

"scripts": {
	"start": "concurrently \"npm run server\" \"npm run client\"",
	"server": "babel-node start-server.js",
	"client": "babel-node start-client.js"
},

For the start, we have to execute both commands with escape chars, due to being in a JSON file.

The problem we run in doing concurrency requests, is cross realm requests. Which we need to use a proxy for.

Thus, we make requests to the localhost:3000 and then have Webpack use a proxy to request to our API server.

This way, we interact with just the localhost:3000, which then proxies to the API server.

We begin by modifying the place of making requests to 3001 in Client.js:

function search(query, cb){
	return fetch(`/api/food?q=${query}`, { //Remove the base url request, making requests to localhost:3000 instead
		accept: 'application.json',
	}).then(checkStatus)
}

And we then add the proxy attribute to the client/package.json:

"proxy": "http://localhost:3001/", //Run a proxy to 3001 instead

The proxy API request is run if the URL is not recognized or if the request is not loading static assets like HTML, CSS or JS.

There are two main gains of Webpacks:

Optimization and Tooling

The optimizations of Webpacks is both Code splitting (Which splits code and only loads relevant stuff for the relevant page),
and it further more causes optimization due to the factor of that we provide a few bundle.js files instead of serving tons of small files.

Webpacks also allows for toolsets, such as auto-linting the JS code, hot-load and auto-load.

The reasons for using Webpacks, is also integrated platforms for testing, etc. - But mainly, the main differential becommes circumstancial.
If the circumstance is that we have to roll in a lot of features into a already existing setup, then we do not want to roll in Webpacks, then we just do
React and babel. But for large scales and relevant situations, then we can do Webpacks and React.

First, we will run a test suite without any external testing utilities:

$ cd testing/basics

$ ls -iap //Run the ls on the relevant package map
.babelrc
Modash.js
Modash.test.js
complete/
package.json

We will be running the babel-node to run our test suite from the command-line. babel-node is included in
this folder's package.json. We run a npm install on it:

$ npm install

However, we need a test library to run tests, so let us write a small utility test library:

We begin to write a small script handling lib in the Modash.js:

truncate(string, length) //Truncates anything past length to be ...

Example:

const s = 'All code and no tests makes jack a dull reference';
Modash.truncate(s, 10); //Expected result is all text up until the 10th letter

const s = "hi";
Modash.capitalize(s); //Returns capitalized letters

const s = "stared_at_floor";
Modash.camelCase(s); //returns staredAtFloor

We then write our three functions in the Modash.js and then export them:

function truncate(string, length){
	if (string.length > length){
		return string.slice(0, length) + '...';
	} else {
		return string;
	}
}

function capitalize(string){
	return(
		string.charAt(0).toUpperCase() + string.slice(1).toLowerCase()
	);
}

function camelCase(string){
	const words = string.split(/[\s|\-|]+/); //Split at all relevant delimeters
	return [ //Return all of the arguments joined together by joining them upon space
		words[0].toLowerCase(), //lowerCase the first letter
		...words.slice(1).map((w) => capitalize(w)), //slice the words at 1, map every other word to be capitalized
	].join(''); //join the array
}

We then create a object that encapsulates our methods:

const Modash = {
	truncate,
	capitalize,
	camelCase,
};

And then we export it with a default export:

export default Modash;

We then use Babel to import/export, we begin by opening our package.json in testing/basics/

"babel-plugin-add-module-exports": "0.2.1",

We then head to the basics/.babelrc to declare it to be part of the plugins:

{
	"plugins": ["transform-class-properties"]
}

The above will apply to the local Node server running, but won't work for real browser pruposes, as that requires mode tooling:

at the Modash.test.js we import our library:

import Modash from './Modash';

As follows, this is our test suite for asserting that truncate works:

const string = 'there was one catch, FOK U';
const actual = Modash.truncate(string, 19);
const expected = 'There was one catch..'; //this is not the real expected value, since i wrote something else as the start string, i just cba modifying it

if (actual !== expected){
	console.log(
		`[FAIL] Expected\`truncate()\` to return '${expected}', got '${actual}'`
		);
} else {
	console.log('[PASS] `truncate()`.');
}

The next one, we have to have a helper function called assertEqual to make sure that we do not run into an issue with code duplication:

import Modash from './Modash';

function assertEqual(description, actual, expected){
	if (actual === expected){
		console.log(`[PASS] ${description}`);
	} else {
		console.log(`[FAIL] ${description}`);
		console.log(`\tactual: '${actual}'`); //The \t is just a tab
		console.log(`\texpected: '${$expected}'`);
	}
}

We then just re-write the first test and re-use the variables:

let actual;
let expected;
let string;

string = 'there was one catch, FOK U';
actual = Modash.truncate(string, 19);
expected = 'FOK U ** 2';

assertEqual('`truncate()`: truncate a string', actual, expected);

We can further modify the assertEqual to just return a string as is, if it was too short:

actual = Modash.truncate(string, string.length);
expected = string;

assertEqual('`truncate()`: no-ops if <= length', actual, expected); //Returns string as is, if it less in length or equal in length

Now we just write the assertion for capitalization:

actual = Modash.capitalize(string);
expected = 'THERE WAS ONE JOB, MOTHERFUCKERRRRRRRRRRRRRRRRRRR';

assertEqual('`capitalize()`: capitalizes the string', actual, expected);

We then run two versions, one with spaces and one with underlinings:

string = 'customer responded at';
actual = Modash.camelCase(string);
expected = 'customerRespondedAt';

assertEqual('`camelCase()`: string with spaces', actual, expected);


And for underscores:

string = 'customer_responded_at';
actual = Modash.camelCase(string);
expected = 'customerRespondedAt';

assertEqual('`camelCase()`: string with underscores', actual, expected);

to then try it out:

./node_modules/.bin/babel-node Modash.test.js

JS also has a variety of libs that have a bunch of features. They usually complete the same thing, but in different approaches, and some are as follows:

Mocha, Jasmine, QUnit, Chai and Tape.

These test libraries generally are three parts:

The test runner. //Runs the tests in console, returns results etc.

A domain-specific language for organizing tests. //Helps with build up and teardown after test runs

an assertion library //allows assertions for otherwise complex tasks

The one we will discuss here, is jest. Jest uses Jasmine's assertion lib.

Generally jest files are named by the extensions .test.js or .spec.js

In Jest (and by extension Jasmine), uses expect(x).toBe(y) //if x is y, it passes.

toBe basically is ===

If we wish to compare different objects, we use toEqual().

Thus, toBe is for boolean or numerical assertions, whilst toEqual is for everything else.

Thus, an example of running assertions in Jasmine:

describe('my test suite', () => {
	it('`true` should be `true`', () => {
		expect(true).toBe(true);
	});

	it('`false` should be `false`', () => {
		expect(false).toBe(false);
	});
});

In jasmine, all asserted code must be encaped by describe();

An assertion is the expect calls, and a spec is the it blocks.

in our package.json we define the test:

"scripts": {
	"test": "jest"
},

So, let's try using the Modash with the Jasmine code:

import Modash from './Modash';

describe('Modash', () => {
	it('`truncate()`: truncates a string', () => { //Run the function name with a description and then run a arrow function on it
		const string = 'MOTHERFOCKER';
		expect( //Expect the results of the following action 
			Modash.truncate(string, 1) //The action
		).toEqual('FAKKA U'); //to result 
	});
});


As for the other truncate Spec, what do we do with that? Well, since it covers two cases of assertions, we wrap em in the same describe:

describe('Modash', () => {
	describe('`truncate()`', () => {
		const string = 'There was one catch. FOK U';

		it('truncates a string', () => {
			expect(
				Modash.truncate(string, 19)
			).toEqual('there was ONE MOTHERFUCKER');
		});

		it('no-ops if <= length', () => { //Runs with no-ops as arg if the length is equal to or less than it was, otherwise, run the truncate
			expect(
				Modash.truncate(string, string.length)
			).toEqual(string);
		});
	});
});

We then wrap the rest of the two methods in their own describe block:

describe('Modash', () => {
	describe('`truncate()`', () => {
		//truncate stuff
	});
	describe('`capitalize()`', () => {
		//Capitalize stuff
	});
	describe('`camelCase()`', () => {
		//camelcase stuff
	});
});

Then we define the two other specs:

describe('capitalize()', () => {
	it('capitalizes first letter, lowercases rest', () => {
		const string = 'There was ONE MOTHERFUCKING CATCH';
		expect(
			Modash.capitalize(string)
		).toEqual(
			'THERE WAS ONE FUCKING CATCH, ONEEEEEEEEEEEEEEEEEEEEEEEEEEEEE'
		);
	});
});

And the camelcase:

describe('camelCase()', () => {
	it('camelizes string with spaces', () => {
		const string = 'customer responds at';
		expect(
			Modash.camelCase(string)
		).toEqual('customerRespondedAt');
	});

	it('camelizes string with undersocres', () => {
		const string = 'customer_responds_at';
		expect(
			Modash.camelCase(string)
		).toEqual('customerRespondsAt');
	});
});

There are two kinds of tests we can run, integration tests and unit tests:

Integration test is with several modules, where for example React would be a App test, because we have all the components to test.

If we were to interact with an API server as well, we'd have a end-to-end test, where we interact between server and the program.

There are a few ways to run end-to-end tests, such as Selenium to programatically load your app in a browser and automatically navigate your app's interface. You could 
click on buttons, fills out forms, asserting what the page looks like after these interactions.

or we could make assertions on the datastores over on the server.

in this book, we will only be talking about unit testing, which means that we will test modules in isolation.

For React components, we run two kinds of assertions:

1. Given a set of inputs (state & props), assert what a component should output (render)

2. given a user action, assert how the component behaves. The component might make a state update or call a prop-function passed to it by a parent

Now, we could use the DOM's API to interact with DOM elements and load in a headless one, into our suite.

What we can do to test things, is use a Shallow rendering, where we only access the first layer (i.e no children), and do not write to teh actual DOM, running asserts on the virtual DOM only.

A lib that wraps around a useful low-level API, called ReactTestUtils, is Enzyme, which helps for Component tests of React.

Thus, to shallow render a object, instead of calling ReactDOM.render(),we call Enzyme.shallow():

const wrapper = Enzyme.shallow(
	<App />
);

the Enzyme.shallow() returns a EnzymeWrapper object, nested inside of our object is our shallow-rendered component in it's virtual DOM representation.

It gives us a bunch of useful methods to traverse and doing assertions against the components virtual DOM.

The advantages of shallow rendering is Speed and allowing testing in isolated circumstances.

We'll begin by setting up Enzyme:

$ cd ../react-basics

$ npm i

$ ls -ip /look at the dir

$ ls -ip src/ /look at src

in the app.js we see that the app has two state props:

class App extends React.Component {
	state = {
		items: [],
		item: '',
	};
}

Inside of the render(), the app runs over items to render them all in a table:

<tbody>
	{
		this.state.items.map((item, idx) => (
			<tr
				key={idx}
			>
				<td>{item}</td>
			</tr>
		))
	}
</tbody>

The controlled input is standard, contained in a form:

<form className='ui form'
	onSubmit={this.addItem}
>
<div className='field'>
	<input
		className='prompt'
		type='text'
		placeholder='Add item...'
		value={this.state.item}
		onChange={this.onItemChange}
	/>

And the interaction, ofc:

onItemChange = (e) => {
	this.setState({
		item: e.target.value,
	});
};

And the addItem:

addItem = (e) => {
	e.preventDefault();

	this.setState({
		items: this.state.items.concat({
			this.state.item
		}),
		item: '',
	});
};

And the button:

<button
	className='ui button'
	type='submit'
	disabled={submitDisabled}
>
	Add item
</button>

The submitDisabled is a attribute defined in the render and is related to state:

render(){
	const submitDisabled = !this.state.item;
	return(
}

To run a test, we simply do $ npm test

If we wish to find all of the relevant things, we simply go to ./node_-modules/react-scripts/package.json //find all the dependancies and stuff

Jest, can be run in watch mode, which keeps it running after a test and re-runs test on any change detected.

And we simply add the depdancy of enzyme in the packages.json :

"enzyme" : "2.4.1",

enzyme wraps ReactTestUtils, so it gets included.

We then go to use the shallow call from enzyme in the app.test.js:

import React from 'react';
import { shallow } from 'enzyme';

describe('App', () => {
	//Assertion will go here
});

We then read in a table header with items:

describe('App', () => {
	it('should have `th` "Items"', () => {
		//Assertions go here
	});

	//Rest of stuff goes here
});

Thus, we then apply the wrapper of Enzyme and check to see that it contains the table header as expected:

it ('should have `th` "Items"', () => {
	const wrapper = shallow(
		<App />
	);

	expect(
		wrapper.contains(<th>Items</th>)
	).toBe(true);
});

The reason we import React is the fact that the th again renders in DOM elements, it just covers it up in JSX syntax.

We then go to assert that a button and a field is present:

if('should have a `button` element', () => {
	const wrapper = shallow(
		<App />
	);

	expect(
		wrapper.containsMatchingElement(
			<button>Add item</button>
		)
	).toBe(true);
});

And one for the input field:

it ('should have an `input` element', () => {
	const wrapper = shallow(
		<App />
	);
	expect(
		wrapper.containsMatchingElement(
			<input />
		)
	).toBe(true);
});

Now, to assert that the button is disabled, we have to first find it and then call the assertion:

it('`button` should be disabled', () => {
	const wrapper = shallow(
		<App /> //make a wrapper of the App and search through the shallow copy of the DOM
	);

	const button = wrapper.find('button').first(); //find the first button
	expect(
		button.props().disabled //Expect it to have it's property disabled to be true
	).toBe(true);
});

NOTE: the .find method in Enzyme can support several different classes of types, such as CSS or React etc.

Now, there is a command called beforeEach() that allows for running a check before every it block in testing environments. Thus, we can do as follows, to assert that a fresh wrapper of the enzyme is applied every time:

describe('App', () => {
beforeEach(() => {
	const wrapper = shallow(
		<App />
	);
})

it('should have the `th` "items"', () => {
	expect(
		wrapper.contains(<th>Items</th>)
	).toBe(true);
});

it('should have a `button` element', () => {
	expect(
		wrapper.containsMatchingElement(
			<button>Add item</button>
		)
	).toBe(true);
});

it('should have an `input` element', () => {
	expect(
		wrapper.containsMatchingElement(
			<input />
		)
	).toBe(true);
});

it('`button` should be disabled', () => {
	const button = wrapper.find('button').first();
	expect(
		button.props().disabled
	).toBe(true);
});

Now, we are going to simulate stuff on changes. WHich means that we will test against changes of values. We are also going to keep one inner describe and one outer describe:

describe('App', () => {
	//The asseritons we've written so far

	describe('the user population the input', () => {
		beforeEach(() => {
			//Setup context
		})
	});
});

And the inner describe, as is above, we define to act on changes of values:

describe('the user populates the input', () => {
	const item = 'Vancouver';

	beforeEach(() => {
		const input = wrapper.find('input').first();
		input.simulate('change', {
			target: { value: item }
		})
	});

	it('should update the state property `item`', () => {
		expect(
			wrapper.state().item
		).toEqual(item);
	});

	it('should enable `button`', () => {
		const button = wrapper.find('button').first();
		expect(
			button.props().disabled
		).toBe(false);
	});
});

The above code gets the state and asserts that the button is disabled.

For the next part, we build the structure of asserting how to test the input field:

describe('App', () => {
	// Initial state assertions

	describe('the user populates the input', () => {
		//Populated field assertions

		describe('and then clears the input', () => {
			//ASsert the button is disabled again
		});
	});
});

And in the respective fields, we put the simulations of events: //The first being under the describe('The user populates the input')

it('should enable `button`', () => {
	const button = wrapper.find('button').find();
	expect(
		button.props().disabled
	).toBe(false);
});

describe('and then clears the input', () => {
	beforeEach(() => {
		const input = wrapper.find('input').first();
		input.simulate('change', { //Simulate that the input changes
			target: { value: ' ' }
		})
	});
		it('should disable `button`', () => {
			const button = wrapper.find('button').first();
			expect(
				button.props().disabled
			).toBe(true);
		});
	});
});

We then go to define the assertion of simulating form submissions:

describe('App', () => {
	//initial state assertions

	describe('the user populates the input', () => {
		//Populated field assertions

		describe('and then clears the input', () => {
			//Assert that the button is disabled again
		});

		describe('and then submits the form', () => {
			//upcoming assertions
		});
	});
});

We go to define the blocks that will become the assertion, albeit the order and placing is unclear:

addItem = (e) => {
	e.preventDefault();

	this.setState({
		items: this.state.items.concat(
			this.state.item
		),
		item: '',
	});
};

We then assert that the item is in place:

describe('and then submits the form', () => {
	beforeEach(() => {
		const form = wrapper.find('form').first();
		form.simulate('submit', {
			preventDefault: () => {},
		});
	});

	it('should add the item to the state', () => {
		expect(
			wrapper.state().items
		).toContain(item); //Runs against an array to assert
	});

	it ('should render the item in the table', () => {
		expect(
			wrapper.containsMatchingElement( //is stronger than contains, due to contains breaking if a class is added for instance
				<td>{item}</td>
			)
		).toBe(true);
	});

	it('should clear the input field', () => {
		const input = wrapper.find('input').first();
		expect(
			input.props().value
		).toEqual('');
	});

	it('should disable `button`', () => {
		const button = wrapper.find('button').first();
		expect(
			button.props().disabled
		).toBe(true);
	});

	describe('and then submits the form', () => {
		beforeEach(() => {
			const form = wrapper.find('form').first();
			forms.simulate('submit', { //Assign the submit to be prevent default on the submit calling
				preventDefault: () => {},
			});
		});
	});	
});

NOTE: The reason we perform a find, is that because we pick the elements of new re-renderings, if we were to define them at the top in the beginning we'd reference the old objects still laying about there.

For the next part, we begin by installing packages for both server and client:

$ npm i && cd client && npm i && cd ..

$ npm start 

We go to the cd of client:

$ cd client

$ ls -ip tests/

The search field in the app, prompts a GET requests to the API Server. The request would look as follows:

GET localhost:3001/api/food?q=truffle

The array returned, is a JSON object of stuff.

The FoodSearch app, has three states:

foods //An empty array that we will the foods into

showRemoveIcon //the boolean for showing the X next to the search field

searchValue //is the state tied to the controlled input

we begin by importing and declaring how many items will be shown at a time:

import React from 'react';
import Client from './Client';

const MATCHING_ITEM_LIMIT = 25;

class FoodSearch extends React.Component {
	state = {
		foods: [],
		showRemoveIcon: false,
		searchValue: '',
	};
}


The input element for the searching is as follows:

<input
	className='prompt'
	type='text'
	placeholder='Search for food'
	value={this.state.searchValue}
	onChange={this.onSearchChange}
/>

We then look at the event handling of seeing the onSearchChange:

onSearchChange = (e) => {
	const value = e.target.value;

	this.setState({
		searchValue: value,
	});

	if (value === ''){
		this.setState({
			foods: [],
			showRemoveIcon: false,
		});
	} else{
		this.setState({
			showRemoveIcon: true,
		});

		Client.search(value, (foods) => {
			this.setState({
				foods: foods.slice(0, MATCHING_ITEM_LIMIT),
			});
		});
	}
};

The client uses the Fetch API to get the items and the invoke a callback on the array recieved.

We define the icon by virtue of a ternary operator:

this.state.showRemoveIcon ? (
	<i
		className='remove icon'
		onClick={this.onRemoveIconClick}
	/>
) : ''


And we define the handling of onRemoveIconClick:

onRemoveIconClick = () => {
	this.setState({
		foods: [],
		showRemoveIcon: false,
		searchValue: '',
	});
};

We then go to put in the stuff of the body:

<tbody>
{
	this.state.foods.map((food, idx) => (
		<tr
			key={idx}
			onClick={() => this.props.onFoodClick(food)}
		>

			<td>{food.description}</td>
			<td className='right aligned'>
				{food.kcal}
			</td>
			<td className='right aligned'>
				{food.protein_g}
			</td>
			<td className='right aligned'>
				{food.fat_g}
			</td>
			<td className='right aligned'>
				{food.carbonhydrate_g}
			</td>
		</tr>
	))
}
</tbody>

The purpose of unit tests for this, is to simply define what we get back : a full food object.

The test suite, is as follows:

import { shallow } from 'enzyme';
import React from 'react';
import FoodSearch from '../src/FoodSearch';

describe('FoodSearch', () => {
	//Initial states

	describe('user populates search field', () => {
		beforeEach(() => {
			//simulate user typing brocc in input
		});

		//The specs

		describe('and API returning results', () => {
			beforeEach(() => {
				//Simulate the API returning results
			});

			//The specs

			describe('then user clicks food item', () => {
				beforeEach(() => {
					//Simulate user clicking food item
				});

				//specs
			});

			describe('then user types more', () => {
				beforeEach(() => {
					//Simulate user typing 'x'
				});

				describe('and API returns no results', () => {
					beforeEach(() => {
						//SImulate the API returning no results
					});

					//Specs
				});
			});
		});
	});
});

We begin with the initial state declaration of things:

//just under describe('FoodSearch'):

let wrapper;

beforeEach(() => {
	wrapper = shallow(
		<FoodSearch />
	);
});

We begin by asserting that the remove icon is not in the DOM:

it('should not display the remove icon', () => {
	expect(
		wrapper.find('.remove.icon').length //since the shallow returned enzyme object can be 0, we check against that
	).toBe(0);
});

We could also have done it in a different way:

it('should not display the remove icon', () => {
	expect(
		wrapper.containsAnyMatchingElements(
			<i className='remove icon' />
		)
	).toBe(false);
});

The next part, is that we check that there are not tr elements in the tbody:

it('should display zero rows', () => {
	expect(
		wrapper.find('tbody tr').length
	).toEqual(0);
});

A problem with test suties is that we have to strike a balance between how correct we are and how much we wish to be right about that.

There is only one interaction the use can have with the FoodSearch component after it loads:
entering a value into the search field. When this happens, there are two further possibilities:

1. The search matches food in the database and the API returns a list of those foods

2. The search does not match any food in the database and the API returns an empty array

Now, we go to simulate the behaviour of searching stuff in the DB, as follows:

.describe('user populates search field', () => {
	const value = 'brocc';

	beforeEach(() => {
		const input = wrapper.find('input').first();
		input.simulate('change', {
			target: { value : value },
		});
	});

	//next, we assert that searchValue has been updated in state to match the new value

	it('should update state property `searchValue`', () => {
		expect(
			wrapper.state().searchValue
		).toEqual(value);
	});

	//We assert that the Remove icon is there in the DOM
	it('should display the remove icon', () => {
		expect(
			wrapper.find('.remove.icon').length
		).toBe(1);
	});
})

Now, we wish to get to the point of asserting the API. However, doing this is bad practice for sake of actually calling the real API. And further more, it would be cubersome to involve the Server API. We could actually let Node.JS or other Libs etc. allow for making a fake HTTP request to see that the server API works as intended.

However, what we are going to, is mock it with Jest:

const Client = {
	search: () => {},
};

We could inject this false client into the search system, that will run it and call empty functions on attempts.

However, we could populate the Client objecta nd then inject it, which causes to see if the desired effect has taken place:

const Client = {
	search: (_, cb) => { //The _ is just a empty "we do not care" argument
		const result = [
			{
				description: 'Hummus',
				kcal: '166',
				protein_g: '8',
				fat_g: '10',
				carbonhydrate_g: '14',
			},
		];
		cb(result); //The cb is a callback
	},
};


Now, assume we wanted to have dynamic reacting ot this function and dynamic values. We then, can use Jest to put in Mocks:

const myMockFunction = jest.fn(); //A empty function that returns undefined

The cool thing about jest.fn(); , tho, is that it allows tons of dynamic things, such as tracking down how many times it was called, what it was called with, etc.

All of these things can be accessed by virtue of the <variable name>.mock.<attribute>, where attirbute can be length, how many times it was called, with what etc.

Thus, we COULD make a mock like this:

const Client = {
	search: jest.fn(),
};


But, we can let Jest take care of that for us, as follows:

jest.mock('../src/Client');

The above will take the entire client and make a mockup of all the things that it needs - a dummy version, basically.

If we define our jest mock of the client at the top after Imports, we can simulate the changes of things and witness that it uses the Jest mockup:

beforeEach(() => {
	const input = wrapper.find('input').first();
	input.simulate('change', {
		target: { value: value },
	});
});

We could then go on to run assertions against remove icons and what not, etc.

Now, if we were to run console fencing on these things (inside of call, outside, afterwards etc.), we'd find that it calls a total of 3 times. Due to each releated it block, but it causes it to be in a "Non-pristine state", due to earlier calls. Thus, to account for this, we clear the mock after each run:

describe('FoodSearch', () => {
	let wrapper;

	beforeEach(() => {
		wrapper = shallow(
			<FoodSearch />
		);
	});

	afterEach(() => {
		Client.search.mockClear();
	});

	it('should not display the remove icon', () => {
		//etc..
	});
});

We then make the assertion of what we would expect to return from making the API call:

it('should call `Client.search() with `value`', () => {
	const invocationArgs = Client.search.mock.calls[0];
	expect(
		invocationArgs[0]
	).toEqual(value);
});

describe('And API returns results', () => {
	//Etc..
});

And we then go to write a assertion of followups for the API returning results, as follows:

describe('FoodSearch', () => {
	//...

	describe('user populates search field', () => {
		//...

		describe('and API returns results', () => {
			beforeEach(() => {
				//Simulate the APIr eturning results
			});

			//...
		});

		describe('then user types more', () => {
			//Stuff..
		});
	});
});

NOTE: In the following code, we will mimick asynch code. Asynch code in shallow copies do not have the standard re-rendering hooks. Thus we need to call them manually:

it('should call `Client.search() with `value`', () => {
	const invocationArgs = Client.search.mock.calls[0];
	expect(
		invocationArgs[0]
	).toEqual(value);
});

describe('and API returns results', () => {
	const foods = [
		{
			//JSON objects that fakes queries
		},
		{
			//Same
		},
	];

	beforeEach(() => {
		const invocationArgs = Client.search.mock.calls[0]; //the first call is the args we called
		const cb = invocationArgs[1]; //the callback is the first arg
		cd(foods); //Cause a callback on the foods
		wrapper.update(); //Call manually because shallow copies does not copy hooking of rendering functions in Asynch context
	});
})

note: if simulate() is not viable, we can call setState() instead, which causes automatic update() after invoked.

We then go on to define the assertions:

it('should set the state property `foods`', () => {
	expect(
		wrapper.state().foods
	).toEqual(foods);
});

it('should display two rows', () => {
	expect(
		wrapper.find('tbody tr').length
	).toEqual(2);
});

And we then assert that our things have been printed out:

it('should render the description of first food', () => {
	expect(
		wrapper.html() //Access the html of the wrapper
	).toContain(foods[0], description); //See that it contains the description
});

it('should render the description of second food', () => {
	expect(
		wrapper.html() //Access the html of the wrapper
	).toContain(foods[1].description); //See that it contains the description
});

describe('then user clicks food item', () => {
	
})


In the body, we define the Clicking of food items to add them to our total list, as follows:

<tbody>
	{
		this.state.foods.map((food, idx) => (
			<tr
				key={idx}
				onClick={() => this.props.onFoodClick(food)}
			>
		))
	}

We then go to write the mockup:

describe('FoodSearch', () =>{
	let wrapper;
	const onFoodClick = jest.fn();

	beforeEach(() => {
		wrapper = shallow(
			<FoodSearch
				onFoodClick={onFoodClick}
			/>
		);
	});

	//Then clear the mock after each iteration
	afterEach(() => {
		Client.search.mockClear();
		onFoodClick.mockClear();
	});

	//We then go to write the describe assertions

	describe('FoodSearch', () => {
		//...

		describe('user populates search field', () => {
			//...

			describe('and API returns results', () => {
				
				it('should render the description of second food', () => {
					expect(
						wrapper.html()
					).toContain(foods[1].description);
				});



				describe('then user clicks food items', () =>{
					beforeEach(() => {
						const foodRow = wrapper.find('tbody tr').first();
						foodRow.simulate('click');
					});

					it('should call prop `onFoodClick` with `food`', () => {
						const food = foods[0];
						expect(
							onFoodClick.mock.calls[0]
						).toEqual([ food ]);
					});

					//Specs
				});

				
			});

			describe('then user types more', () => {

				const value = 'broccx';

				beforeEach(() => {
					const input = wrapper.find('input').first();
					input.simulate('change', {
						target: { value: value },
					});
				});

				describe('and API returns no results', () => {
					beforeEach(() => {
						const secondInvocationArgs = Client.search.mock.calls[1];
						const cb = secondInvocationArgs[1];
						cb([]); //callback with a empty array
						wrapper.update();
					});
				});

				it('should set the state property `foods`', () => {
					expect(
						wrapper.state().foods
					).toEqual([]);
				});
			});
		});
	});
});


NOTE: There are plenty of things we can do with Jest, such as grabbing instances of React components, interacting with times, set the state of underlying components etc. etc.

The purpose of a router is to modify the location of the App and determine what React component to render at a given location

Thus, to modify the location and redirect, we use React Router, with two components: Link and Redirect.

For determening what to render, we use two other components: Match and Miss.

The general skeleton of the App with routing is as follows:

class App extends React.Component{
	const Atlnatic = () => (
		<div>
			<h2>Atlantic ocean</h2>
			<p>
				Some shit
			</p>
		</div>
	);

	const Pacific = () => (
		<div>
			<h2>Pacific Ocean</h2>
			<p>
				some other shit
			</p>
		</div>
	);

	}
	render(){
		return(
			<div
				className='ui text container'
			>

				<h2 className='ui dividing header'>
					Which body of water?
				</h2>

				<ul>
					<li>
						<a href='/atlantic'>
							<code>/atlantic</code>
						</a>
					</li>
				</ul>

				<hr />

				<Match pattern='/atlantic' component={Atlantic}/>
				<Match pattern='/pacific' component={Pacific}/>
			</div>
		);

	}
}


The match setup is meant to be so that it runs checks against if it's matching the pattern or not,
if it matches the pattern, it returns the respective thing.

Thus, we define the interaction at the top:

import React from 'react';

const Match = ({ pattern, component: Component }) => { //Destructuring syntax to withdraw the info from the object
	const pathname = window.location.pathname;
	if(pathname.match(pattern)){
		return (
			<Component />
		);
	} else {
		return null;
	}
};

//The above goes above App

If we wish, we can assign syntax to variables within arguments that are objects or arrays, with destructuring syntax:

const TreeRow = ({ species, region, imageURL }) => (
	<tr>
		<td>{species}</td>
		<td>{Region}</td>
		<td>{imageURL}</td>
	</tr>
);

Is equivilant to:

const TreeRow = (props) => {
	const species = props.species;
	const region = props.region;
	const imageURL = props.imageURL;
	return (
		<tr>
			<td>{species}</td>
			<td>{region}</td>
			<td>{imageURL}</td>
		</tr>
	);
};

We then go to write the variable of the pathname and run a matcher on it:

const pathname = window.location.pathname;

if (pathname.match(pattern)){
	return (
		<Component />
	); 
} else {
	return null;
}

In JS, we have access to a History API which allows us to see history, push to states of history etc.

What we will do here, is define it in the beginning and then use it to overwrite the need of communicating with the server on apge load.

We begin by making the history object:

import React from 'react';

import createdHistory from 'history/createBrowserHistory';

const history = createHistory();

const Match = ({ pattern, component: Component }) => {
	
}

What follows, is then how we make the links relate to route to the specified action, which is to disregard the normal fetching against the API server:

render(){
	return (
		<div
			className='ui text container'
		>
			<h2 className='ui dividing header'>
				Which body of water?
			</h2>

			<ul>
				<li>
					<Link to='/atlnatic'>
						<code>/atlnatic</code>
					</Link>
				</li>
				<li>
					<Link to='/pacific'>
						<code>/pacific</code>
					</Link>
				</li>
			</ul>
			<hr />

			<Match pattern='/atlantic' component={Atlantic} />
			<Match pattern='/pacific' component={Pacific} />
		</div>

	);
}


We then go to define the Link interaction before the App:

const Link = ({ to, children }) => (
	<a
		onClick={(e) => {
			e.preventDefault(); //prevent requests to the server API
			history.push(to); //push the elements of history unto the to element
		}}
		href={to} //assign the href to be this, which causes a reference to the Stack of history elements
	>

		{children} //Apply them to all of the children
	</a> //Close the link tag
);

class App extends React.Component {
	//etc.
}

Now, if we were to save this as is, the Website would not update because it has not been forced to re-render. Which we will do by virtue of running a listener from history on the window:

class App extends React.Component{
	componentDidMount() { //run a listener on the mounting of the component
		history.listen(() => this.forceUpdate()); //listen to the changing of history,
		//if a change occurs, run a forceUpdate() on the DOM, causing re-render
	}

	render(){

	}
}

What we do next is that we move the Router to be a component that is above App to forgoe the usage of having a stateful place of plaing it. Thus we can put it above, and have it enclose everything and handle the different events such as Route and Miss (Miss being the time that it does not actually hit a url that is relevant)

First, we encase the app in the router:

const App = () => (
	<Router>
		<div
			className='ui text container'
		>
		//content
			<Match pattern='/atlantic' component={Atlantic} />
			<Match pattern='/pacific' component={Pacific} />
		</div>
	</Router>
);

And we then go to define the actual router:

class Router extends React.Component {
	static childContextTypes = { //Assign the context for the children of this component, identical to this, technically
		history: React.PropTypes.object,
		location: React.PropTypes.object,
	};

	constructor(props){
		super(props);

		this.history = createHistory(); //Upon instanciation, assign a history stack to this object
		this.history.listen(() => this.forceUpdate()); //assign a listener and run it to force update on changes
	}

	getChildContext(){ //Return the window.location (the url we are at) and  the history of the object
		return {
			history: this.history,
			location: window.location,
		};
	}

	render(){ //render the children
		return this.props.children;
	}
}


Now that we have the relevant props that we can pass down to the Match object, we define the Match object to handle the props, as follows:

const Match = ({ pattern, component: Component }, { location }) => { //assign a pattern and a component against the pattern, and run against the location

	const pathname = location.pathname;
	if (pathname.match(pattern)){ //If the pathname matches the pattern, we return the respective component
		return (
			<Component />
		);
	} else { //otherwise, do not re-render 
		return null;
	}
};

Match.contextTypes = { //The context is assigned to a Object
	location: React.PropTypes.object,
};

We then go to update the Link element:

const Link = ({ to, children }, { history }) => (
	<a //Assign a elements to have a onclick where we prevent default and push the element to the history
		onClick={(e) => {
			e.preventDefault();
			history.push(e);
		}}
		href={to} //assign the href to be bound to said object
	>
		{children} //The children is the things we put to the end
	</a> //End of link
);

Link.contextType = {
	history: React.PropTypes.object; //the context of the link is the history of the Object
};

class Router extends React.Component {
	
}


Now that we have the link component defined, we go on to the Redirect component which will handle the redirection.
We define this above the Router class:

class Redirect extends React.Component {
	static contextTypes = {
		history: React.PropTypes.object,
	}

	componentDidMount(){ //Every time the component mounts, update history and push it 
		const history = this.context.history;
		const to = this.props.to;
		history.push(to);
	}

	render(){
		return null;
	}
}

class Router extends React.Component {
	//etc.
}

For the third component that we redirect to, we just apply pattern matching against a new object, in the App:

<Match pattern='/black-sea' component={BlackSeas} />

//etc.

We then implement the BlackSea, last after App:

class BlackSea extends React.Component {
	constructor(props){
		super(props);

		this.state = {
			counter: 3, //The delay is 3 seconds at start
		};
	}

	componentDidMount() {
		setInterval(() => (
			this.setState({ counter: this.state.counter - 1 })
		), 1000); //Decrease the state by 1 every 1 second
	}
}


Secondly, we handle the redirect logic:

render(){
	return (
		<div>
			<h3>Black Sea</h3>
			<p>Nothing to sea [sic] here ...</p>
			<p>Redirecting in {this.state.counter}...</p>
			{
				(this.state.counter < 1) ? ( //Run a ternary against the counter, if it's less than 1, redirect, otherwise, don't
					<Redirect to='/' />
				) : null
			}
		</div>
	);
}

We then import the router from React, that handles history, which overwrites the one we wrote, as we imported one instead

We also import all the things we need from the Router from React:

import React from 'react';

import Router from 'react-router/BrowserRouter';
import Match from 'react-router/Match';
import Link from 'react-router/Link';
import Redirect from 'react-router/Redirect';

Since we imported the Match, we now have far more properties to it, which we will showcase that we can do different things with:

<Match pattern='/atlantic' component={Atlantic} />
<Match pattern='/atlantic/ocean' render= {() => (
	<div>
		<h3>Atlantic Ocean - Again!</h3>
		<p>
			The atlnatic ocean covers approx FOK U
		</p>
	</div>
)} />
<Match pattern='/pacific' component={Pacific} />
<Match pattern='/black-sea' component={BlackSea} />

NOTE: THE current way the matcher runs, if we run a match against a deeper referal to such as /x/y, then it would load x and then stack y on top of that, due to that it hits both.

NOTE: The matcher currently matches against ^ (start of), thus, it will not trigger on things that may include but does not start with relevant things

Now, if we wish to have a more precise search result, we could define a pintpoint location to refer to what we are looking for:

<Match exactly pattern='/' render={() => (
	<h3>
		MODDAFOKKA!
	</h3>)} />

NOTE: The above is a modified syntax, if a prop is listed but not assigned, it's default value is true, but we could go one step further and say that exactly is true:

<Match exactly={true} pattern='/' render={() => (
	//Stuff..
)}

The last part that we need, is the Miss component, that renders if no match is found:

import Miss from 'react-router/Miss';

We then put in the miss object after the match call:

<Match exactly pattern='/' render={() => (
	<h3>
		Welcome! FOK U
	</h3>
)} />

<Miss render={({ location }) => ( //in case of a miss, this attempts to render the location which is empty
	<div className='ui inverted red segment'>
		<h3>
			YOU WOOOOOOOT, DERE'S NO DAMN <code>{location.pathname}</code>
		</h3>
	</div>
)} />

//etc.

NOTE: Since the Match call has a process of returning wether a match was found or not, it means that we do not need to define the Miss ourselves, as that would be a rather complicated issue to solve.

The difference in the upcoming app is that the upcoming one is a remote calling app communicating with the spotify server. Which means that the display of stuff is done local and calling to the API server is local, but the API server calls to the Spotify servers that is remote.

We begin by directing to the dirs and then moving around there:

$ cd routing/music

$ ls -ip
//listing of stuff

inside the client is the relevant react-app:

$ ls -ip client
//listing of stuff

We then go to call the dependancies to install with npm and then direct to start up the server:

$ npm i
$ cd client
$ npm i
$ cd ..

$ npm start //Will concurrently boot the servers at the top level

The server's API in this case provides us with a hardcoded token that bypasses login and password, because it has a hardcoded token that it provides to the server:

POST /api/login

To demonstrate how we would get this, we could simply make a post request to the server with curl and then authenticate using the false token:

$ curl -X POST http://localhost:3001/api/login
{
	"success": true,
	"token": "<token lol>"
}


The token is saved in the storage and is removed upon logging out, which means that a new login must occur after logging out

If we wish, we can write to and retrieve values from localStorage, as follows:

localStorage.setItem('gas', 'pop'); //To save gas to be bound to pop

localStorage.getItem('gas'); //Gives pop

NOTE: Saving info in the local storage is a thing that is VERY ILL advised without knowing the security limiations, due to the fact of that we cannot assert safe transfers, we cannot assert that they are immune to cross-site scripting attacks etc.

Thus, we need to know a lot about it, before we choose to store sensitive data - but we should look to using JSON Web Tokens (JWT's) or cookies or both, for saving sensitive data.

NOTE: If we wish to dynamically assign values, we can use data-value in our JS which binds values to stuff upon input

To make GET queries against the server, we structure them up with queries along with the GET request, as follows:

GET/api/albums?ids=<id1>,<id2>


//NOTE: To assert a callback, we could run typeof callback == "function"

It expects the token as well, so we end up with the full syntax being:

/api/albums?ids=<id1>,<id2>&token=<token>

An example of querying the /api/albums endpoint with curl is as follows:

$ curl -X GET \
"http://localhost:3001/api/albums"\
"?id=<etc>"\
"&token=D6W6QPRgCoDKgHZGJmRUNA"

Strings or commands can be split over several lines, and curl is part of Bash.

NOTE: We should not have spaces between the elements.

Next up, we go into client/src/components, where we will find index.js, where we begin with imports:

//same as before

import App from './components-complete/App';

And in the index.js, we wrap the App in the Router class:

ReactDOM.render(
	<Router>
		<App />
	</Router>
	document.getElementById('root')
);

This is a common pattern for React Router apps

Taking a look at App.js we would find the following:

import React from 'react';

import TopBar from './TopBar';
import AlbumContainer from './AlbumContainer';

import '../styles/App.css';

const App () => (
	<div className='ui grid'>	
		<TopBar />
		<div className='space row' />
		<div className='row'>
			<AlbumContainer />
		</div>
	</div>
);

export default App;

We then import stuff into the AlbumsContainer.js:

import React, { Component } from 'react';

import Album from './Album';
import { client } from '../Client';

const ALBUM_IDS = [
'Some shit',
'id 2',
'etc.'];


the AlbumsContainer is a stateful component that has two components: fetched (status of fetched), albums (An array of all the album objects)

//AlbumsContainer

class AlbumsContainer extends Component {
	constructor(props){
		super(props);

		this.state = {
			fetched: false,
			albums: [],
		};

		this.getAlbums = this.getAlbums.bind(this); //bind the this to this.getAlbums so that we have context of AlbumsContainer
	}
}


NOTE: When we have components that are not part of the standard API within React (didMount, render etc.), we have to manually bind the this, otherwise it won't understand the context of the different components.

To populate the albums, we do a call upon mounting:

componentDidMount(){
	this.getAlbums();
}

by using the Fetch API, we involve it in the getAlbums():

getAlbums(){
	client.setToken('D6W6QPRgCoDKgHZGJmRUNA');
	client.getAlbums(ALBUM_IDS)
		.then((albums) => (
			this.setState({
				fetched: true,
				albums: albums,
			})
		));
}

NOTE: By virtue of cheating, we declare a hardcoded token which we use for login and logout:

export const API_TOKEN = '<stuff>';

Finally, we run the render to implement the stuff:

render(){
	if (!this.state.fetched){
		return (
			<div className="ui active centered inline loader" />
		);
	} else {
		return (
			<div className='ui two column divided grid'>
				<div
					className='ui six wide column'
					style={{ maxWidth: 250 }})
				>
					{/* VerticalMenu will go here */}
				</div>
				<div className='ui ten wide column'>
					{
						this.state.albums.map((a) => (
							<div
								className='row'
								key={a.id}
							>
								<Album album={a} />
							</div>
						))
					}
				</div>
			</div>
		);
	}
}

We begin by only rendering albums when we visit a certain section:

const App = () => (
	<div className='ui grid'>
		<TopBar />
		<div className='spacer row' />
		<div className='row'>
			<Match pattern='/albums' component={AlbumContainer} />
		</div>
	</div>
);

Now, we go to define the structure of the side menu bar:

import React from 'react';

import '../styles/VerticalMenu.css';

const VerticalMenu = ({ albums }) => (
	<div className='ui secondary vertical menu'>
		<div className='header item'>
			Albums
		</div>
		{/* render album menu here */}
	</div>
);

export default VerticalMenu;

We then go to import what we need and build the verticalmenu with links referal IDs:

import React from 'react';

import Link from 'react-router/Link';

import '../styles/VerticalMenu.css';

We then map the values to each thing:

const VerticalMenu = ({ albums }) => (
	<div className='ui secondary vertical menu'>
		<div className='header item'>
			Albums
		</div>
		{
			albums.map((album) => (
				<Link
					to={`/albums/${album.id}`}
					className=`item`
					key={album.id}
				>
					{album.name}
				</Link>
			))
		}
	</div>
);


We then go to define so that we render the side menu and a sidebar menu:

//add to imports
import Album from './Album';
import VerticalMenu from './VerticalMenu';
import { client } from '../Client';

//Then, inside of the render method:

render(){
	if (!this.state.fetched){
		return (
			<div className='ui active centered inline loader' />
		);
	} else {
		return (
			<div className='ui two column divided grid'>
				<div
					className='ui six wide column'
					style={{ maxWidth: 250 }}
				>
					<VerticalMenu
						albums={this.state.albums}
					/>
				</div>
				<div className='ui ten wide colum'>
			)
	}
}

We then go to apply the changes in the AlbumContainer:

import React, { Component } from 'react';

import Match from 'react-router/Match';

We then render the sidemenu of albums:

<div className='ui ten wide column'>
	<Match
		pattern='/albums/:albumId' //The pattern we search again
		render={({ params }) => { //run render with the parameterers of the album
			const album = this.state.albums.find(
				(a) => a.id === params.albumId //Change the state of albums to be a match of the pattern run against a.id with with the params
			);
			return (
				<Album //Return a album object
					album={album}
				/>
			);
		}}
	/>
</div>


Next up, we will learn how to propogate pathnames as props. What will be showcased here, is the Close button:

<div className='six wide column'>
	<p>
		{
			`By ${album.artist.name}
			- ${album.year}
			- ${album.tracks.length} songs`
		}
	</p>
	<div
		className='ui left floated large button'
	>
		Close
	</div>

Now, we could route this to a earlier path and "close" the window there of:

<Link
	to='/album'
	className='ui left floated large button'
/>
	Close
</Link>

The problem, is that it's easy to break. And not very flexible. So, we pass down paths as props, instead.

The current matcher is down to the pattern of album/:

<Match pattern='/albums' component={AlbumsContainer} />

The match, sets the props on the target component:

pattern: (string) the portion of the pattern matched

pathname: (string) the portion of pathname matched

isExact: (bool) wether or not the match is exact (v. partial)

location: The location matched

params: The values parsed from the pathname corresponding by name to the dynamic segments of the pattern

The one we have of interest, is the pathname. Inside of AlbumsContainer, this.props.pathname will be /albums

We can update the Match inside AlbumsContainer that wraps Album. Before, the pattern prop was /albums/:albumId, we thus, can replace the
root of the path (/albums) with the variable of this.props.pathname:

<div className='ui ten wide column'>
	<Match
		pattern={`${this.props.pathname}/:albumId`}
		render={({ params })} => {
			const album = this.state.albums.find(
				(a) => a.id === params.albumId
			);
			return (
			)
		}

By having changed the pattern of which we match again, we allow for dynamic location of pathing.
Albeit, we wish to keep that the "closing" reroutes to the same as before:

			return (
				<Album
					album={album}
					albumsPathname={this.props.pathname}
				/>
			);

Then inside of Album, we extract the albumPathname from the props object:

const Album = ({ album, albumsPathname }) => (
)

Now, we replace the Div with link:

<div className='six wide column'>
	<p>	
		{
			`By ${album.artist.name}
			- ${album.year}
			- ${album.tracks.length} songs`
		}
	</p>
	<Link
		to={albumsPathname}
		className='ui left floated large button'
	>
		Close
	</Link>

And with these changes in place, we can go back to the VerticalMenu on the side to update it to accept the pathname props:

<div
	className='ui six wide column'
	style={{ maxWidth: 250 }}
>
	<VerticalMenu
		albums={this.state.album}
		albumsPathname={this.props.pathname}
	/>
</div>

And finally, the verticalmenu itself:

const VerticalMenu = ({ albums, albumsPathName }) => (
	<div className='ui secondary vertical menu'>
		<div className='header item'>
			Albums
		</div>
		{
			albums.map((albums) => (
				<Link
					to={`${albumsPathname}/${album.id}`}
					className='item'
					key={album.id}
				>
					{album.name}
				</Link>
			))
		}
	</div>
);

By isolating the number of places where we specify pathnames, we make it more flexible for routing later on.

If we wish to fetch more specific attributes, we could do as follows:

albums.map((album) => {
	const to = `${albumsPathname}/${album.id}`;
	const active = window.location.pathname === to; //A boolean, if it's true, or not
	<Link
		to={to} //Run the link to be relative to the pathname and id
		className={active ? 'active item' : 'item'} //if the classname is active, set it to active item, otherwise item
		key={album.id}
	>
		{album.name}
	</Link>
})

Our final version of the vertical side menu, as of total, is as follows:

const VerticalMenu = ({ albums, albumsPathname }) => (
	<div className='ui secondary vertical menu'>
		<div className='header item'>
			Albums
		</div>
		{
			albums.map((album) => (
				<Link
					to={`${albumsPathname}/${album.id}`}
					key={album.id}
				>
				{
					({ onClick, href, isActive }) => (
						<a
							className={isActive ? 'active item' : 'item'}
							onClick={onClick}
							href={href}
						>
							{album.name}
						</a>
					)
				}
				</Link>
			))
		}
	</div>
);

In the background, React actually converts a elements to clickable elements.
Thus, the following:

const Link = ({ to, children }) => (
	<a
		onClick={(e) => { //Assigning a function to a element derefers it from reloading the page
			e.preventDefault(); //prevent the default, which is to re-render and re-direct
			history.push(to); //make it push to history instead
		}}
		href={to} //assign the href to be the to element
	>
		{children} //Display the children
	</a>
);


Thus, the usage:

<Link to='home'>
	Go home
</Link>

is identical to:

<Link to='/home'>
{
	({ onClick, href }) => (
		<a
			onClick={onClick}
			href={href}
		>
			Go home
		</a>
	)
}
</Link>

Further more, since links are basically react components, we can abstract to build general purpose link blocks and place them around as we please and use them as we please.

Now, to cause redirects on the / argument, we could do as follows:

import Match from 'react-router/Match';
import Redirect from 'react-router/Redirect';

//We then run a exact match against the /

	<div className='row'>
		<Match pattern='/albums' component={AlbumsContainer} /> 

		<Match exactly pattern='/' render={() => ( //Exactly causes explicit matching against its pattern
			<Redirect
				to='albums'
			/>
		)} />
	</div>


Now, our app so far, has used a mimicked and faked token for authentication, which can be redesigned as follows:

Our design to fake the token was, before:

getAlbums(){
	client.setToken(<stuff>)
	client.getAlbums(ALBUM_IDS)
}


But, we are going to use the client() library which supports the structure of giving us authentication, storing tokens and interacting with APIs:

login(){
	return fetch('/api/login', { //Return the results of fetching with the login API
		method: 'post',
		headers: { //run a POST request with this header object, containing a accept that is for a application/JSON
			accept: 'application/json',
		},
	}).then(this.checkStatus) //Check the status
	  .then(this.parseJson) //parse the JSON to check for the wanted 201 status
	  .then((json) => this.setToken(json.token)); //Set the token
}

The token is kept in local storage with no expiration date, which means that they only log out when they designate to do so:

setToken(token) {
	this.token = token;

	if (this.useLocalStorage) {
		localStorage.setItem(LOCAL_STORAGE_KEY, token);
	}
}

The logout, in turn, looks like this:

logout(){
	this.removeToken();
}

//Which implements removeToken()

removeToken(){
	this.token = null;

	if (this.useLocalStorage){
		localStorage.removeItem(LOCAL_STORAGE_KEY);
	}
}

Then, we go to define the setup of rendering the loading menu for login and to see if redirection is nessecary:

class Login extends Component {
	constructor(props){ //Initiate stuff
		super(props);

		this.state = {
			loginInProgress: false,
			shouldRedirect: false,
		};

	this.performLogin = this.performLogin.bind(this);
}

performLogin(){
	this.setState({ loginInProgress: true }); //Set the loginprocess to true
	client.login().then(() => ( //Then set redirect state to true
		this.setState({ shouldRedirect: true })
	));
}
}


Then, we run the relevant calls in the render():

render() {
	if (this.state.shouldRedirect) {
		return (
			<Redirect to='/albums' />
		);
	} else {
		return (
			<div className='ui one column centered grid'>
				<div className='ten wide column'>
					<div
						className='ui raised very padded text container segment'
						style={{ textAlign: 'center' }}
					>
						<h2 className='ui green header'>
							Notify
						</h2>
						{
							this.state.loginProgress ? (
								<div className='ui active centered inline loader' />
							) : (
								<div
									className='ui large green submit button'
									onClick={this.performLogin}
								>
									Login
								</div>
							)
						}
					</div>
				</div>
			</div>
		);
	}
}


Now, we go to populate the Logout component:

import React, { Component } from 'react';

import Redirect from 'react-router/Redirect';

//Then we fill the logout component

class Logout extends Component {
	constructor(props){
		super(props);

		client.logout();
	}

	render(){
		return (
			<Redirect
				to='/login'
			/>
		);
	}
}

Now, in the App.js, we add the components:

//Top of App.js

import TopBar from './TopBar';
import AlbumsContainer from './AlbumsContainer';
import Login from './Login';
import Logout from './Logout';

//And we then go to call on the components as well, in the app.js:

	<div className='row'
		<Match pattern='/albums' component={AlbumsContainer} />

		<Match pattern='/login' component={Login} />
		<Match pattern='/logout' component={Logout} />

		<Match exactly pattern='/' render={() => (
			<Redirect
				to='/albums'
			/>
		)} />
	</div>


//Remove the setToken from getAlbums

And in the Topbar, we define the login/logout buttons:

<div className='right menu'>
	{
		client.isLoggedIn() ? (
			<Link className='ui item' to='/logout'>
				Logout
			</Link>
		) : (
			<Link className='ui item' to='/login'>
				Login
			</Link>
		)
	}
</div>

Now, what if we wanted a routing element for the part of where we try to access parts of the page where we are not logged in, but must be?
Well, we wish to redirect then. And now, even if we are at a point of where we could just write:

render() {
	if(!client.isLoggedIn()){
		return (
			<Redirect to='/login' />
		);
	}
}

Now, if we wish to do this, we need to do something that is called a higher-order component. A wrapping parent, that encapsulates the children, so to speak.

We begin by importing this, into our App.js:

import TopBar from './TopBar';
import MatchWhenLoggedIn from './MatchWhenLoggedIn';
import AlbumsContainer from './AlbumsContainer';
import Login from './Login';
import Logout from './Logout';

We then go to implement that the only path required to logged in for, is in /albums:

<div className='row'>
	<MatchWhenLoggedIn pattern='/albums' component={AlbumsContainer} />
	<Match pattern='/login' component={login} />
	<Match pattern='/logout' component={logout} />


In terms of using a higher ordered prop to wrap another, we can illustrate that calling Match directly, would be the same as follows:

const MatchWhenLoggedIn = (props) => (
	<Match {...props} />
);

Ultimately, what we wish to do, is something akin to this psuedo code structure:

const MatchWhenLoggedIn = (props) => (
	<Match {...props} render={(props => (
		client.isLoggedIn() ? (
			//Render the component
		) : (
			//Render the redirect
		)
	)}
);

Inside of the render function, we wish to switch off of client.isLoggedIn(), this boolean defines if we should render the component
given to us, or perform a redirect

const MatchWhenLoggedIn = ({ component: Component, ...rest }) => ( //pass in the Component and the rest of the args to matchedwhenloggedin
	<Match {...rest} render{(props) => ( //Pass the rest of the arguments to match to render, with the props given
		client.isLoggedIn() ? ( //if clienti s logged in, pass down the component with props
			<Component {...props}
		) : (
			<Redirect to={{ //otherwise, redirect to the login
				pathname: '/login',
			}} />
		)
	)}
);

Now, we wish to also implement that once rerouted to Login due to attempting to access a place without logging in, we want to route the user back to doing
that specific place again - thus, we could do as follows:

//in the MatchedWhenLoggedIn js:

	<Redirect to=({
		pathname: '/login',
		state: { from : props.location },
	}) />


Then, in the login.js, we set up the routing:

redirectPath() {
	const locationState = this.props.location.state; //set the locationState to be the props location state
	const pathname = (
		locationState && locationState.from && locationState.from.pathname //Bind the values to the pathanme if they exist
	);

	return pathname || '/albums'; //if pathname exists, return that, otherwise, default to albums
}

render() {
	
}


We must also bind the state and this of performLogin and redirectPath:

constructor(props) {
	super(props);

	this.state = {
		loginInProgress: false,
		shouldRedirect: false,
	};

	this.performLogin = this.performLogin.bind(this);
	this.redirectPath = this.redirectPath.bind(this);
}

And now we can check against the evaluation of if it should redirect:

if (this.state.shouldRedirect) {
	return (
		<Redirect to={this.redirectPath()} />
	)
}


//The following part may be repetition, but do it anyway:

Having looked at the other stuff, we now conclude that we have 4 components of our React app. But we would like to break it down further, having some components
only becoming Presentation components, compared to that of the Container Components.

Presentation Components only uses presentation values, meaning that it never interacts with the store, it just accepts values to render, such as HTML markup.

And if the presentation component has behaviour, it's defined by the Container Component.

An example of a full component (both render and interaction), is ThreadTabs, for instance:

class ThreadTabs extends React.Component {
	handleClick = (id) => {
		store.dispatch({
			type: 'OPEN_THREAD',
			id: id,

		});
	};

	render() {
		const tabs = this.props.tabs.map((tab, index) => (
			<div
				key={index}
				className={tab.active ? 'active item' : 'item'}
				onClick={() => this.handleClick(tab.id)}
			>

				{tab.title}
			</div>
		));

		return (
			<div className='ui top attached tabular menu'>
				{tabs}
			</div>
		);
	}
}

We go to redefine the tabs a Presentation Component instead of being interactive, as we let the reactivity be left to the others:

const Tabs = (props) => ( //Since they are stateless components, we don't extends React.components upon this class, as it's not needed
	<div className='ui top attached tabular menu'>
		{
			props.tabs.map((tab, index) => (
				<div
					key={index}
					className={tabs.active ? 'active item' : 'item'}
					onClick={() => props.onClick(tab.id)}
				>
					{tab.title}
				</div>
			))
		}
	</div>
);

We have now broken down the Tabs into a representative Tabs state.

And now, we will see the one managing the tabs:

class ThreadTabs extends React.Component {
	render() {
		return (
			<Tabs //Define the tabs
				tabs={this.props.tabs} //give them the props
				onClick={(id) => ( //if they click, dispatch from the specified tab with relevant Id
					store.dispatch({ //Dispatch to the store
						type: 'OPEN_THREAD', //open a thread
						id: id, //assign the id
					})
				)}
			/>
		);
	}
}

The problem here, is the fact that it indirectly accesses attributes, instead of dispatching through the store. We can fix this, by virtue of 
changing the declaration to subscribe to force the update upon mounting of the component:

class ThreadTabs extends React.Component {
	componentDidMount() { //force threadTabs to subscribe to the store and update this object, meaning ThreadTabs retrieves AND dispatches 
		store.subscribe(() => this.forceUpdate());
	}

	//Then in the render, we update states locally by virtue of assigning states and mapping them:

	const state = store.getState();

	const tabs = state.threads.map(t => (
		{
			title: t.title,
			active: t.id === state.activeThreadId,
			id: t.id,
		}
	));

	//Which means, that now we do not need to read from props at all, we can just pass it through the tabs part we just made

	return (
		<Tabs
			tabs={tabs}
			onClick={(id) => (
				store.dispatch({
					type: 'OPEN_THREAD',
					id: id,
				})
			)}
		/>
	);
}

This division, causes one component to be a container component that handles all interactivity, whilst the other handles markup and presentation.

The Component combos, in full:

const Tabs = (props) => (
	<div className='ui top attached tabular menu'>
		{
			props.tabs.map((tab, index) => (
				<div
					key={index}
					className={tab.active ? 'active item' : 'item'}
					onClick={() => props.onClick(tab.id)}
				>
					{tab.title}
				</div>
			))
		}
	</div>
);

class ThreadTabs extends React.Component {
	componentDidMount(){
		store.subscribe(() => this.forceUpdate());
	}

	render() {
		const state = store.getState();

		const tabs = state.threads.map(t => (
			{
				title: t.title,
				active: t.id === state.activeThreadId,
				id: t.id,
			}
		));

		return (
			<Tabs
				tabs={tabs}
				onClick={(id) => (
					store.dispatch({
						type: 'OPEN_THREAD',
						id: id,
					})
				)}
			</div>
		);
	}
}

Now, the next step is to refactor how the message hierarchy is, which we can write as follows:

Messagelist and TextFieldSubmit -> Thread -> ThreadDisplay -> Redux Store

We begin by seperating interaction and markup, in the TextFieldSubmit:

const TextFieldSubmit = (props) => {
	let input;

	return (
		<div className='ui input'>
			<input
				ref={node => input = node} //Assign a reference to the node, which allows us to interact with the value, later on
				type='text'
			>
			</input>
			<buton
				onClick={() => { //interact with the node, retrieve the values and assign them on interaction
					props.onSubmit(input, value);
					input.value = '';
				}}
				className='ui primary button'
				type='submit'
			>
				Submit
			</button>
		</div>
	);
};

It is now a stateless component that expects one prop, the onSubmit prop.

We then go to remove the MessageInput Component, because we have ThreadDisplay be the container for TextFieldSubmit

And the MessagesList, is just a markup component, with no state:

const MessageList = (props) => (
	<div className='ui comments'>
		{
			props.messages.map((m, index) => (
				<div
					className='comment'
					key={index}
					onClick={() => props.onClick(m.id)}

					<div className='text'>
						{m.text}
						<span className='metadata'>@{m.timestamp}</span>
					</div>
				</div>
			))
		}
	</div>
);

The differences is that we now use m for messages, we map over props.messages, onClick is set to be props.onClick

Right now, our hiearchy is as follows:

MessageList and TextFieldSubmit, both of which are representional

They are under Thread, another representional component. ThreadDisplay then renders the Thread.

the ThreadDisplay will pass three props:

thread //The thread itself

onMessageClick //upon clicking the message

onMessageSubmit //The text field submit handler

We then go to define Thread:

const Thread = (props) => (
	<div className='ui center aligned basic segment'>
		<MessageList
			messages={props.thread.messages}
			onClick={props.onMessageClick}
		/>
		<TextFieldSubmit
			onSubmit={props.onMessageSubmit}
		/>
	</div>
);


The ThreadDisplay, which will be our container COmponent, the one to interact with the store, is as follows:

class ThreadDisplay extends React.Component {
	componentDidMount() {
		store.subscribe(() => this.forceUpdate());
	}

	//Then, in the render, we go to set the states through store and find the active thread

	render() {
		const state = store.getState();
		const activeThreadId = state.activeThreadId;
		const activeThread = state.threads.find(
			t => t.id === activeThreadId
		);

		//We then return the Thread object and run dispatches against the store in the Thread object returned
		return (
			<Thread
				thread={activeThread}
				onMessageClick={(id) => ( //on click, run a dispatch of removing message
					store.dispatch({
						type: 'DELETE_MESSAGE',
						id: id,
					})
				)}
				onMessageSubmit={(text) => ( //On submittal
					store.dispatch({ //run a dispatch to add the message in teh activeThread
						type: 'ADD_MESSAGE',
						text: text,
						threadId: activeThreadId,
					})
				)}
			/>
		);
	}
}


Due to having added the communication in our container components, we can make App stateless and run no communication in it, as follows:

const App = () => (
	<div className='ui segment'>
		//`Thread` changed to `ThreadDisplay` below
		<ThreadTabs />
		<ThreadDisplay />
	</div>
);

given this structure, we can re-use the display components whilst the Container elements can still have some reduction implemented on them.

react-redux allows for a feature called connect(), which means that we can change the setup to be so that Provider encapsulates all of the COmponents,
providing context to all others, meaning we have that the lower components will access them through context, meaning we don't have to have teh Store in the 
same file structure.

note: You generally should not use context. It's akin to Global.

To allow the context based idea, we have to wrap App in a Provider component:

ReactDOM.render(
	<ReactRedux.Provider store={store}>
		<App />
	</ReactRedux.Provider>,
	document.getElementById('content')
);

The store is now avaialble in context, for all child components in the structure.

Now, we go to write a function that interacts and maps states to props, upon interaction, as follows:

const mapStateToTabsProps = (state) => {
	const tabs = state.threads.map(t => ( //map the states of the threads
		{
			title: t.title, //assign title
			active: t.id === state.activeThreadId, //assign the active id
			id: t.id, //assign the default id
		}

	));

	return {
		tabs, //sincei t's called tabs and the one we are assigning to is also called tabs, we can just forgo any other words in returning it
	};
};

We then also go to map the Dispatches to Tabs props:

const mapDispatchToTabsProps = (dispatch) => (
	{
		onClick: (id) => ( //on click, run a dispatch to store
			dispatch({
				type: 'OPEN_THREAD',
				id: id,
			})
		),
	}
);

We then go to connect both the mapping of States and matching of dispatches, to the ThreadTabs:

const ThreadTabs = ReactRedux.connect(
	mapStateToTabsProps,
	mapDispatchToTabsProps
)(Tabs); //Map the two sub components unto the representational component, which causes a Container component to be created

The next one we will define with connect, is ThreadDisplay:

We re-write it to handle the onMessageclick and run a dispatch:

const mapDispatchToThreadProps = (dispatch) => (
	{
		onMessageClick: (id) => (
			dispatch({
				type: 'DELETE_MESSAGE',
				id: id,
			})
		),
		dispatch: dispatch, //assign the dispatch
	}
);

To connect the store with one point, we simply merge the third attribute, into the others, with a third funciton call to connect(), where it uses the two previously
stated states:

connect(
	mapStateToProps(state, [ownProps]),
	mapDispatchToProps(dispatch, [ownProps]),
	mergeProps(stateProps, dispatchProps, [ownProps])
)

Now, to further merge the threads, we merge the props:

const mergeThreadProps = (stateProps, dispatchProps) => (
	{
		...stateProps,
		...dispatchProps,
		onMessageSubmit: (text) => (
			dispatchProps.dispatch({
				type: 'ADD_MESSAGE',
				text: text,
				threadId: stateProps.thread.id,
			})
		),
	}
);

Meaning that the completed connect statement we end up with, is as follows:

const ThreadDisplay = ReactRedux.connect(
	mapStateToThreadProps,
	mapDispatchToThreadProps,
	mergeThreadProps
)(Thread);

A popular pattern to handling action objects, is to make a general action generator and then call upon it, what follows is an example:

function deleteMessage(id) {
	return {
		type: 'DELETE_MESSAGE',
		id: id,
	};
}

We could then just dispatch the action:

dispatch(deleteMessage(id));

We then go to re-define our action generators:

function addMessage(text, threadId) {
	return{
		type: 'ADD_MESSAGE',
		text: text,
		threadId: threadId,
	};
}

function openThread(id){
	return {
		type: 'OPEN_THREAD',
		id: id,
	};
}

And we then carry on to handle the mapping of dispatched Tabs:

const mapDispatchToTabsProps = (dispatch) => (
	{
		onClick: (id) => (
			dispatch(openThread(id))
		),
	}
);

//Then we go to dispatch thread props:

const mapDispatchToThreadProps = (dispatch) => (
	{
		onMessageClick: (id) => (
			dispatch(deleteMessage(id))
		),
		dispatch: dispatch,
	}
);

//And lastly, the mergeThreadProps

const mergeThreadProps = (stateProps, dispatchProps) => (
	{
		...stateProps,
		...dispatchProps,
		onMessageSubmit: (text) => (
			dispatchProps.dispatch(
				addMessage(text, stateProps.thread.id)
			)
		),
	}
);

The benefit of having action generators, is that we have a single localized place where our actions are dispatched and handeled

The next step, is Asynch integration. The Asynch, can for instance, use something called Thunk. Thunk allows for having dispatches run a function which make network requests and dispatch an action when the request finishes.

When it comes to asynch actions, we are gonna have to dig a bit into Redux and how it handles ASynch structure.

asynch has two big moments of time that matters: The moment you send the action, and the moment you recieve an answer.

Generally, for any API request, you can do one of three actions:

An action informing the reducers that the request has begun //can handle this by toggling the isFetching flag in the state

An action informing the reducers that the request finished successfully. //Merge the data into state and reset the isFetching

An action informing the reducers that the request failed. //Reset the isFetching. Some reducers may store the error message so the UI can display it

Now, we could define a status for them, or we could assign a distinct type for them:

//a status

{ type: 'FETCH_POSTS' }
{ type: 'FETCH_POSTS', status: 'error', error: 'Oops' }
{ type: 'FETCH_POSTS', status: 'success', response: {...} }

//Seperate types

{ type: 'FETCH_POSTS_REQUEST' }
{ type: 'FETCH_POSTS_FAILURE', error: 'Oops' }
{ type: 'FETCH_POSTS_SUCCESS', response: { ... } }

Now, we go to define some normal Synch tasks:

export const SELECT_SUBREDDIT = 'SELECT_SUBREDDIT'

export function selectSubreddit(subreddit) {
	return {
		type: SELECT_SUBREDDIT,
		subreddit
	}
}

//One for refresh button as well

export const INVALIDATE_SUBREDDIT = 'INVALIDATE_SUBREDDIT'

export function invalidateSubreddit(subreddit){
	return {
		type: INVALIDATE_SUBREDDIT,
		subreddit
	}
}

//Next we define one which is needed for server fetching

export const REQUEST_POSTS = 'REQUEST_POSTS'

function requestPosts(subReddit){
	return {
		type: REQUEST_POSTS,
		subreddit
	}
}

//And the final one, when network requests come, we dispatch RECIEVE_POSTS

export const RECIEVE_POSTS = 'RECIEVE_POSTS'

function recievePosts(subreddit, json) {
	return {
		type: RECIEVE_POSTS,
		subreddit,
		posts: json.data.children.map(child => child.data), //map the data
		recievedAt: Date.now()
	}
}

A real world example, would also dispatch an action on request failure. We won't showcase that here, tho

Now, to showcase how a real async example, might look like:

{
	selectedSubreddit: 'frontend',
	postsBySubreddit: {
		frontend: {
			isFetching: true,
			didInvalidate: false,
			items: []
		},

		reactjs: {
			isFetching: false,
			didInvalidate: false,
			lastUpdated: 981238509830589,
			items: [
				{
					id: 42,
					title: 'Some shit'
				},
				{
					id: 500,
					title: 'Some other shit'
				}
			]
		}
	}
}

Every piece of the Subreddit is stored seperately, to allow caching for each piece. 

beyond this, we save if it's fetching, if it invalidated and the items following.

In a real App, we would have store pagination states like fetchedPageCount and nextPageUrl


If we have nested types, we would refer to them a bit differently:

{
	selectedSubreddit: 'frontend',
	entities: {
		users: {
			2: {
				id: 2,
				name: 'Andrew'
			}
		},
		posts: {
			42: {
				id: 42,
				title: 'SOME SHIT',
				author: 2
			},
			100: {
				id: 100,
				title: 'Some osther shit',
				author: 2
			}
		}
	},
	postsBySubreddit: {
		frontend: {
			isFetching: true,
			didInvalidate: false,
			items: []
		},
		reactjs: {
			isFetching: false,
			didInvalidate: false,
			lastUpdated: 2910841209841,
			items: [ 42, 100 ]
		}
	}
}

Also, we might consider running normalizr, which noramlzies the JSON data into a more "digestable" format.

Next, we go to write the reducers:

import { combineReducers } from 'redux'
import {
	SELECT_SUBREDDIT, INVALIDATE_SUBREDDIT,
	REQUEST_POSTS, RECIEVE_POSTS
} from '../actions'

function selectedSubreddit(state = 'reactjs', action) {
	switch (action_type){
		case SELECT_SUBREDDIT:
			return action.subreddit
		default:
			return state
	}
}

function posts(state = {
	isFetching: false,
	didInvalidate: false
	items: []
}, action) {
	switch (action.type) {
		case INVALIDATE_SUBREDDIT: //the subreddit got invalidated
			return Object.assign({}, state, { //return a new object with the state having been re-assigned as invalidated
				didInvalidate: true
			})
		case REQUEST_POSTS:
			return Object.assign({}, state, {
				isFetching: true,
				didInvalidate: false
			})
		case RECIEVE_POSTS:
			return Object.assign({}, state, {
				isFetching: false,
				didInvalidate: false,
				items: action.posts,
				lastUpdated: action.recievedAt
			})
		default:
			return state
	}
}

function postsBySubreddit(state = {}, action){
	switch (action.type) {
		case INVALIDATE_SUBREDDIT:
		CASE RECIEVE_POSTS:
		CASE REQUEST_POSTS:
			return Object.assign({}, state, { //This part, is a special case of more terse syntax, which is equal to:
				[action.subreddit]: posts(state[action.subreddit], action)
			})

			//let nextState = {}
			//nextState[action.subreddit] = posts(state[action.subreddit], action)
			//return Object.assign({}, state, nextState)
		default:
			return state
	}
}

const rootReducer = combineReducers({
	postsBySubreddit,
	selectedSubReddit
})

export default rootReducer

Now, to implement stuff with Async, we have to introduce redux-thunk middleware, which allows for returning functions instead of action objects.

The function can dispatch actions such as the synch ones before, and the offset of the redux-thunk is that we can use Asynch API calls.

What follows, is when we define our actions in actions.js and we make them async:

import fetch from 'isomorphic-fetch'

export const REQUEST_POSTS = 'REQUEST_POSTS'
function requestPosts(subreddit){
	return {
		type: REQUEST_POSTS,
		subreddit
	}
}

export const RECIEVE_POSTS = 'RECIEVE_POSTS'
function recievePosts(subreddit, json){
	return {
		type: RECIEVE_POSTS,
		subreddit,
		posts: json.data.children.map(child => child.data),
		recievedAt: Date.now()
	}
}

//Next, we define the thunk action creator
//We can use it like any other action creator: store.dispatch(fetchPosts('reactjs'))

export function fetchPosts(subreddit){
	
	//return a function that we run a dispatch on

	return function (dispatch) {

		//first dispatch has the state changed to tell that API call is starting
		dispatch(requestPosts(subreddit))

		//The result, is what we run dispatches on, thus, we can for instance retrieve a promise, if we wish:

		return fetch(`https://www.reddit.com/r/${subreddit}.json`)
			.then(response => response.json())
			.then(json =>
				//Run another dispatch. to update the app state with the results of teh API call

				dispatch(recievePosts(subreddit, json))
		)
	}
}

NOTE: the fetch API is not supported by all, thus, we need to import it from isomorphic-fetch, and we need to assure that the babel polyfill is in as well

import 'babel-polyfill' //before any code

import fetch from 'isomorphic-fetch' //the fetch API, more precisely it runs whatwg-fetch polyfill on the client and node-fetch on the server,
//meaning no API calls need to be changed in between

Now, to include the redux thunk middleware in the dispatch mechanism, we use the applymiddleware(), as shown below:

//in index.js

import thunkMiddleware from 'redux-thunk'
import createLogger from 'redux-logger'
import { createStore, applyMiddleware } from 'redux'
import { selectSubreddit, fetchPosts } from './actions'
import rootReducer from './reducers'

const loggerMiddleware = createLogger()

const createStore(
	rootReducer,
	applyMiddleware(
		thunkMiddleware,
		loggerMiddleware
	)
)

store.dispatch(selectSubreddit('reactjs'))
store.dispatch(fetchPosts('reactjs')).then(() => 
	console.log(store.getState())
)

The cool thing about thunks, is that they can dispatch results of each other:

//in the actions.js

import fetch from 'isomoprhic-fetch'

export const REQUEST_POSTS = 'REQUEST_POSTS'
function requestPosts(subreddit){
	return {
		type: REQUEST_POSTS,
		subreddit
	}
}

export const RECIEVE_POSTS = 'RECIEVE_POSTS'
function recievePosts(subreddit, json) {
	return {
		type: RECIEVE_POSTS,
		subreddit,
		posts: json.data.children.map(child => child.data),
		recievedAt: Date.now()
	}
}

function fetchPosts(subreddit) {
	return dispatch => { //run a dispatch on a dispatch
		dispatch(requestPosts(subreddit)) //request the posts
		return fetch(`https://www.reddit.com/r/${subreddit}.json`) //fetch the json from the subreddit
			.then(response => response.json()) //Then respond with json
			.then(json => dispatch(recievePosts(subreddit, json))) //then dispatch on the dispatch 
	}
}

function shouldFetchPosts(state, subreddit) {
	const posts = state.postsBySubreddit[subreddit]
	if(!posts){ //if the state is false or is undefined
		return true
	} else if(posts.isFetching){ //if the posts is fetching
		return false
	} else { //if it's true, assign that it should invalidate
		return posts.didInvalidate
	}
}

export function fetchPostsIfNeeded(subreddit){
	//The function gets getState, so we can define interaciton

	return (dispatch, getState) => {
		if(shouldFetchPosts(getState(), subreddit)) {
			//Dispatch a thunk from the thunk
			return dispatch(fetchPosts(subreddit))
		} else {
			//There is nothing to wait for, return a resovled promise
			return Promise.resolve()
		}
	}
}

//And in the index.js, we handle the resolve:

store.dispatch(fetchPostsIfNeeded('reactjs')).then(() => 
	console.log(store.getState())
)

NOTE: We could use this structure of dispatches and async calls to fetch everything we need before the call to render stuff even happens, meaning we would have
everything before we even rendered the server

NOTE: This is not the only way that we could orchestrate asynch actions in Redux

We could:

use redux-promise or redux-promise-middleware to dispatch Promises instead of functions

use redux-observable to dispatch Observables

use redux-saga to buld more complex asynch actions

use redux-pack middleware to dispatch promise-based asynch actions

write our own middleware to describe calls to our API

Now, we can use JSON or HTTP APIs to make requests to servers. But we can use GraphQL as well, if we wish. Which is a Graphical Query Language, which works much akin to HTTP requests, except there is only one endpoint in the server API that handles all of the GraphQL requests.

We can make a server request to others by virtue of a curl request as follows:

$ curl -H 'Content-Type:application/graphql' -XPOST https://www.graphqlhub.com/g\raphql?pretty=true -d '{ hn { topStories(limit: 2) { title url } } }'
{
	"data": {
		"hn": {
			"topStories": [
				{
					"title": "Bank of Japan is an estimated top 10 holder in 90% of the Nikkei 225", "url": "http://www.bloomberg.com/news/articles/2016-04-24/the-tokyo-wh\
						ale-is-quietly-buying-up-huge-stakes-in-japan-inc"
						},
						{
							"title": "Dropbox as a Git Server",
							"url": "http://www.antishathalye.com/2016/04/25/dropbox-as-a-true-git-server/"
						}
					]
				}
			}
		}


We first set the header to be Content-type of application/graphql, which is the -H declaration

The next part is the POST, where we ask for a readable format, instead of JSNO, by assigning that the pretty variable is true

the -d is the body part of the POST request

What comes, is a showcasing of how to write one in a expanded format and one as a one-liner:

//one-liner
{ hn { topStories(limit: 2) { title url } } }

//expanded

{
	hn {
		topStories(limit: 2){
			title
			url
		}
	}
}

the GraphQL system inheritly will always return the data explicitly requested. And it understands types implicitly

Now, you might wonder why you'd use GraphQL instead of REST, for instance.

It allows for better unit testing, integration testing and mocking it on the server. And we can assert that server GraphQL changes don't break GraphQL in the client code.

It also helps performance, due to skipping over-fetching (mostly against mobiles, due to mobiles being sensitive on speed and sizes)

Also, the tooling and documentation from GraphQL is far better. The type system is yields, is also very good.

also, the declarative nature of GraphQL makes for an easier time, regarding glue code around APIs and tracking lifecycles of requests.

The gains of GraphQL over REST, is that REST runs into endpoint-creep, and the tooling for development is not as strongly supported as for GraphQL.
You might use Swagger, curl and wget, or other documentation formats, but the issue becomes that the popular API's don't have much in common on that point.

Beyond this, for server handling, GraphQL beats SQL in security. Albeit, Sql is good for DB's, if run in the Frontend, it could cause issues with Security in the DBs in the long run.

Beyond this, GraphQL allows for high privitization and restriction of access on specific things.

Beyond this, we have Relay, which connects the GraphQL server and React components, allowing for automatic retrieval of Data from the servers.

It can be used as follows:

class Item extends React.Component {
	render() {
		let item = this.props.item;

		return (
			<div>
				<h1><a href={item.url}>{item.title}</a></h1>
				<h2>{item.score} - {item.by.id}</h2>
				<hr />
			</div>
		);
	}
};

Item = Relay.createContainer(Item, {
	fragments: {
		item: () => Relay.QL`
			fragment on HackerNewsItem {
				id
				title,
				score,
				url
				by {
					id
				}
			}
		`
	},
});

There are other approaches to integrating GraphQL and React as well, such as Apollo, by the creators of Meteor.

You can use GraphQL in other places as well where you'd use traditional API calls, such as Angular or Backbone

There are two sides to GraphQL, Client side and Server side.

GraphQL is a language of it's own, and can be used in a IDE called GraphiQL - Whilst you can use GraphQL with anything that uses HTTP requests (Such as curl), if we wish to have
more intrecate interaction and handling of servers, its easier with GraphiQL

an example of aquiring say the top two stories from hackernews and stuff of the author, we could do as follows:

{
	hn{
		topStories(limit: 2){
			title //request attribute is title
			url //The requested attribute is url
			by { //The response from the server will follow this structure as well, by dividing the content with a by section
				id //adds another field to the result, with id, which is the requested attribute here
			}
		}
	}
}


In GraphQl, the entire thing we send, is a document. The document, can have one more or operations. So far, we have done query operations, but we can also do mutation
operations.

Query is read-only and is retrieval. Mutation is write and then retrieve some data.

If we have only one query, and we omit any starting notation, it defaults to being a query.

To write a query in a formal matter, we must type out the query part:

query getTopTwoStories {
	hn {
		topStories(limit: 2){
			title
			url
		}
	}
}

If we have multiple queries, we must give unique names. Normally, we are intended to use one query per document. The only reason multiple ones are allowed, is for advanced performance optimization.

A operation is composed of selections, which are generally fields. Each field represents a piece of data, which can be irreducable type (scalar)(smallest), or a complex which is
made of more scalar and more complex types.

String is a scalar type, and when it comes to making queries, we must specify the query to the point of where we have only scalars, as queries must end in scalar types.

The scalar types, are: String, Int, Float, Boolean and ID (reduced to String)

We can compose them to complex types: Objects, Interfaces, Unions, Enums and Lists.

Fields can take arguments. These can be optional. They are denoted, in our example, by the (limit: 2)

GraphQL also has type enforcement (if a String is expected, it will only accept String, etc)

The arguments can also be objects with attributes.

A collection of fields, is called a Schema. Tools like GraphiQL can download the entire schema, use it for auto-complete and other functionality.

Unions, in GraphQL, is a new type that is a list of other types. An example of how this might be in reality, is as follows:

union SearchResult = Photo | Person //SearchResult can be either a Photo or a Person

type Person {
	name: String
	age: Int
}

type Photo {
	height: Int
	width: Int
}

type searchQuery{
	firstSearchResult: SearchResult //becomes a union, due to either Person or Photo
}

In GraphQL, we also have something called Fragments, which allows us to handle multi-cased scenarios:

{
	firstSearchResult {
		... on Person { //If we get a person type, return name
			name 
		}
		... on Photo { //If we get a Photo type, return height
			height
		}
	}
}

A no named fragment, is a inline fragment. There are also, named fragments, which follow assignment:

{
	firstSearchResult{
		... searchPerson
		... searchPhoto
	}
}

fragment searchPerson on Person { //Can now use searchPerson on other parts just as a variable to execute query
	name //Retrieves name after having defined the searchPerson to be a fragment which can be re-used elsewhere
}

fragment searchPhoto on Photo {
	height
}

An example of implementing interfaces in GraphQL:

interface Searchable {
	searchResultPreview: String
}

type Person implements Searchable {
	searchResultPreview: String
	name: String
	age: Int
}

type Photo implements Searchable {
	searchResultPreview: String
	height: Int
	width: Int
}

type SearchQuery {
	firstSearchResult: Searchable //Will guarantee to return a object of the type Searchable
}

The reason it's called GraphQL, is because it generally is in the mathematical sense.

We like to reason that every object is a Node, and that the link between each is a edge. 

Generally, GraphQL bases itself on the model of which is requried by Relay. ideally, the candidate for GraphQL is close to a mathematical graph.
However, we can, express other things in it, such as Data stores, nodes, SQL databses etc.

An example of a graph like structure, is as follows:

{
	viewer {
		id
		name
		likes {
			edges {
				cursor
				node {
					id 
					name
				}
			}
		}
	}
}
node(id: "123123"){
	id
	name
}

The patterns following, are required by Relay.

When you query a Graph, you must begin with a Node. You are either querying against fields of the node directly or what connections it has.

A simple node interface owuld be:

interface Node {
	id: ID
}

GraphQL enforces unique IDs on things, globally. Meaning no two distinct objects can have the same ID. Further, beyond this, if we were to instead
design with REST, it would look akin to something like accessing the url of:

/$nouns/:id. 

The reason for having unqiue IDs, is that we have a top-level field that lets us query arbitrary nodes by ID:

{
	node(id: "the_id"){
		id
	}
}

A common pattern to handle the issue of unique IDs per table, is to assign a type before the ID and run something akin to the following psuedo code:

const findNode = (id) => {
	const [ prefix, dbId ] = id.split(":");
	if (prefix === "users") {
		return database.usersTable.find(dbId);
	}
	else if( ... ){
		//Do stuff
	}
};

const getUser = (id) => {
	let user = database.usersTable.find(id);
	user.id = `user:${user.id}`;
	return user;
};

Since the approach of a mesaging APp might be self centric, our viewer would come to look like something akin to:

{
	viewer{
		id
		messages {
			participants {
				id
				name
			}
			unreadCount
		}
		channels {
			name
			unreadCount
		}
	}
}

If we didn't have the top level viewer, we'd be forced to either make 2 server calls (get current user and get messages for current user) or make top-level messages and channels fields that implicitly return the data for the current user.

Having a viewer top level field also helps strengthen authorization. (Isolation of what person can see what)

Normally, when we query for larger pieces of info, we use something called pagination. Imagine slicing of arrays, with given indexes.

However, GraphQL, centers around live updated data, which means that it bases itself on running cursor pagination, which means it assign a cursor to the current
set of data and then queries for the set of 10 next data from current position of cursor.

An example of a GraphQL enpoind that supports cursor, is as follows:

{
	hn2{
		nodeFromHnId(id: "dhouston", isUserId:true){ //Grab teh first node
			... on HackerNewsV2User {
				submitted(first: 2){ //Then grab the first 2 nodes from submitted
				//Every GraphQL connection has 2 fields, pageInfo and Edges
					pageInfo { //General info about the page and relevant attributes there of
						hasNextPage
						hasPreviousPage
						startCursor
						endCursor
					}
					edges { //A field that is a list of actual nodes with actual attributes for each node
						cursor //Every entry contains the cursor for respective item
						node { //And the respective Node
							id
							... on HackerNewsV2Comment {
								text
							}
						}
					}
				}
			}
		}
	}
}


NOTE: in some systems, having id be part of cursor, can be appropiate. (if identifiers are atomically incrementing ints)

But we could just make the cursor a timestamp, offset or both. 

Let's pretend this is the data retrieved:

{
	"nodeFromHnId": {
		"submitted": {
			"pageInfo": {
				"hasNextPage": true,
				"hasPreviousPage": false,
				"startCursor": "<stuff>",
				"endCursor": "<stuff>"
			},
			"edges": [
				{
					"cursor": "same as for startCursor",
					"node": {
						"id": "some id",
						"text": "it's not going anywhere :)<p>(actually, FOK U) <a href\="https://www.dropbox.com/jobs\" rel=\"nofollow\">https://www.dropbox.\
com/jobs</a> :))"
					}
				},
				{
					"cursor": "same as for endCursor",
					"node":{
						"id": "some shit",
						"text": "HI"
					}
				}
			]
		}
	}
}


With the pattern observed, we can use this for the front end making queries:

{
	h2{
		nodeFromHnId(id:"dhouston", isUserId:true){
			... on HackerNewsV2User {
				submitted(first: 2, after: "<some id>") { //The other arguments on connections are before and after, accepting cursors, first and last, which accepts ints
					pageInfo { //By virtue of specifying the after argument, means it will fetch the specified data, which uses the end cursor
						hasNextPage
						hasPreviousPage
						startCursor
						endCursor
					}
					edges {
						cursor
						node {
							id
							... on HackerNewsV2Comment{
								text
							}
						}
					}
				}
			}
		}
	}
}

Now, to write data to the server with GraphQL, we can use mutators, as ofllows: //Mutators use POST/PUT/DELETE HTTP requests.

mutation {
	keyValue_setValue(input: { //This is the mutation field, takes an input value of what id and value to set
		clientMutationId: "browser", id: "this-is-a-key", value: "this is a value"
	}) { //But we also define what data is returned from the mutation
		item {
			value
			id
		}
	}
}

The return of this request, would be something akin to:

{
	"data": {
		"keyValue_setValue": {
			"item": {
				"value": "some value",
				"id": "someKey"
			}
		}
	}
}

In REST; we'd get only the data of the request regardless. The advantage, of GraphQL, is that we can define what we wish to return after having made updates etc.
Which means that we forgoe the need of possibily needing to run many requests to the Client, using the GraphQL instead

The third form of operation for GraphQL, that is being worked on, is Subscriptions, which is to allow for live update upon servers pushing a valid thing to subscribe to.

An example, would be as follows:

input StoryLikeSubscribeInput {
	storyId: string
	clientSubscriptionId: string
}

subscription StoryLikeSubscription($input: StoryLikeSubscribeInput){
	storyLikeSubscribe(input: $input) {
		story {
			likers { count }
			likeSentence { text }
		}
	}
}

Basically, it subscribes to an ID and gives it's own id to accoutn for what is subscribing

The mechanisms, can vary from Websockets, MQTT, Server-Sent events or others.

MQTT //This is when you run a connection on a footprint and run the message through a Broker that interpets the message to the reciever. MQTT defines a few methods of operation,
//Connect, Disconnect, Subscribe, UnSubscribe, Publish all of which are selfexplanetory, except for Publish, that returns immedeatly to the App thread after passing the 
//request to the MQTT Client

Server-Sent is standardized in HTML5 

Websockets is when you run a HTTP request against it and allows for two way communication. if the user runs a Proxy, it attempts to setup a Persistent tunnel.

In psuedo-code, the process looks like:

var clientSubscriptionId = generateSubscriptionId();
//The "channel" could be Websockets, MQTT, etc.
connectToRealtimeChannel(clientSubscriptionId, (newData) => {});
//Send the GraphQL requests to tell the server to start sending updates
sendGraphQLSubscription(clientSubscriptionId);

GraphQL overall allows a finite list, where as of Meteor allows subscription to all data by default.
To engineer that, however, is very difficult, especially at scale.

we could use anything with GraphQL, such as Ajax from jQuery or raw XmlHTTPRequests, but we are going to use Fetch from Es2015, with React.

To run the fetch in JS, we could do as follows:

var query = ' { graphQLHub } ';
var options = {
	method: 'POST',
	body: query,
	headers: {
		'content-type': 'application/graphql'
	}
};

fetch('https://graphqlhub.com/graphql', options).then((red)=> {
	return res.json();
}).then((data) => {
	console.log(JSON.stringify(data, null, 2));
});

This should be familiar, we define the header to be graphql and then append the query to the body

Our output should look as:

{
	"data": {
		"graphQLHub": "Use GraphQLHub to explore bla bla bla"
	}
}

The reason we have the Viewer pattern, is for defining what node is current.

Now, to integrate GraphQL into React, we use something called Relay. the reason for this, is because it automates a lot of hte processes that we would face otherwise, such as:

caching, cache-busting and batching.

There are other alternatives, to Relay, such as Apollo. Apollo works akin to GraphQL in colocating the views and what not, but uses Redux under the hood to store GraphQL
cache and data.

An example of a Apollo component:

class AboutGraphQLHub extends React.Component {
	render() {
		return <div>{ this.props.about.graphQLHub }</div>;
	}
}

const mapQueriesToProps = () => {
	return {
		about : {
			query: '{ graphQLHub }'
		}
	};
};

const ConnectedAboutGraphQLHub = connect({
	mapQueriesToProps
})(AboutGraphQLHub);

By virtue of building upon Redux, we can more easily integrate it into an existing Redux store like any other middleware or reducer:

import ApolloClient from 'apollo-client';
import { createStore, combineReducers, applyMiddleware } from 'redux';

const client = new ApolloClient();

const store = createStore(
	combineReducers({
		apollo: client.reducer(),
		//Run other reducers here
	}),
	applyMiddleware(client.middleware())
);

Next up, is writing a GraphQL server.

GraphQL servers are integrated into other languages as well, such as Ruby, Python, Scala. And we are going to use Node for the sake of that Facebook often targets Node.

On Windows, we need to isntall the sqlite3 package, which requries windows-build-tools:

npm install --global --production windows-build-tools

Next, we must make sure that Python is in our Path.

Python comes with a script to add itself to the path:

$env:UserProfile\.windows-build-tools\pytthon27\scripts\win-add2path.py

We are going to create a Express HTTP server, add endpoints for the GraphQL requests, construct a GraphQL Schema, write the glue-code that resolves the fields of GraphQL data,
and support GraphiQL so we can debug and iterate quickly

Express is a minimalistic framework of NodeJS

We then go to begin the setup of the server:

$ mkrdir graphql-server
$ cd ./graphql-server
$ npm init
$ touch index.js server.js
//hit enter a lot
$ npm install babel-register@6.3.13 babel-preset-es2015@6.3.13 express@4.13.3 --save --save-exact
$ echo '{"presets": ["es2015"] }' > .babelrc

We install all dependancies, including babel to transpile the NodeJS to the preset of es2015, we then go to open index.js:

require('babel-register');

require('./server');

This will ensure that every other import or require we do, will go through the transpiler

We then run a quick debug:

console.log({ starting: true });

And then we run the server:

$ node index.js
//will give { starting: true }

We begin by adding some HTTP and configuring the server:

import express from 'express';

const app = express(); //Start a server instance of express

app.use('/graphql', (req, res) => { //Send some data to the app, req stands for request and res for response. Meaning how it handles GET and POST. Currently they handle both the //same way
	res.send({ data: true });
});

app.listen(3000, () => { //listen on outgoing port 3000
	console.log({ running: true });
});

To try this out, we begin by starting the server and then run cURL requests against it:

$ node index.js
{ starting: true }
{ running: true }

//Then run cURL requests
$ curl -XPOST http://localhost:3000/graphql
{"data":true}
$ curl -XGET http://localhost:3000/graphql
{"date":true}

If we wish to have tools that automatically update the server upon edits, we can install a Setup tool like Nodemon that will automatically reboot the server upon changes.

We can install it with:

npm install -g nodemon && nodemon index.js

Nodemon is a wrapper class that replaces the Node wrapper class, scannign any changes done in the Folder active for the Server

First, we need to isntall the GraphQL dependancies to the server:

$ npm install graphql@0.6.0 express-graphql@0.5.3 --save --save-exact

The GraphQl library itself, exposes APIs that lets us construct our schemas, exposes a API for resolving raw GraphQL document strings. It can be used anywhere.

But when it comes to Express, it is designed for just express.

The express-graphql package, is just made for ensuring HTTP requests are formatted properly for GraphQL (such as dealing with the content-type header)

After we create the express instance, we add the following code:

const app = express();

import graphqlHTTP from 'express-graphql';
import { GraphQLSchema, GraphQLObjectType, GraphQLString } from 'graphql';

const RootQuery = new GraphQLObjectType({ //Create a new GraphQLObjectType as the RootQuery, basically creating a new class
	name: 'RootQuery',
	description: 'The root query', //The description
	fields: { //the fields
		viewer: { //can be accessed with a viewer query -d '{ viewer }'
			type: GraphQLString, //The type is a String
			resolve() { //resolve the request
				return 'viewer!'; //return a string
			}
		}
	}
});

const Schema = new GraphQLSchema({
	query: RootQuery
});

app.use('/graphql', graphqlHTTP({ schema: Schema }));

We then go to start up the node js server:

node index.js

//And then run cURL requests:

$ curl -XPOST -H 'content-type:application/graphql' http://localhost:3000/graphql -d '{ viewer }' 

//This should output: {"data": {"viewer": "viewer!"}}

If we wish to define a fragment upon this type, we'd have to define the ... on RootQuery as our query. If we changed name to be anythign else, we'd have to 
change our fragment to reflect that change, even if the JS variable is something else.

We also gave our object a type and a method to resolve it.

Schemas accepts two types, as discussed previously, mutations and queries. Schemas act as the top level component of the GraphQL integration, meaning we cannot resolve things without the support of a Schema to call resolve methods from, to resolve the objects.

NOTE: Generally, the root level of anything, is refered to as root, which means base, ground-level, highest level of instance of admin of said thing etc.

We then hook up our schema to Express:

app.use('/graphql', graphqlHTTP({ schema: Schema }));

Thus, instead of having to use a manual handler function, we let the graphqlHTTP call make one and pass it to the internal handlers of graphql

If we wish to integrate GraphiQL into this, we could simply add this to the resolving of the app call:

app.use('/graphql', graphqlHTTP({ schema: Schema, graphiql: true }));

If we then restart our server and direct to:

http://localhost:3000/graphql, we will get the graphiQL setup

We get a description of our queries, of our setup and the stuff added to it.

NOTE: We can integrate GraphiQL to other languages as well, if we wish, or other JS Frameworks.

The GraphiQL populates it's things in the boot up cycle, by virtue of running introspection, meaning it derivates from a higher instance of it's own.
If we were to call this query to the GraphQL:

{
	__schema {
		queryType {
			name
			fields {
				name
				type {
					name
				}
			}
		}
	}
} 

We'd get something like this, back:

{
	"data": {
		"__schema": {
			"queryType": {
				"name": "RootQuery",
				"fields": [
					{
						"name": "viewer",
						"type": {
							"name": "String"
						}
					}
				]
			}
		}
	}
}

Which is the JSON description of our servers Schema. It's how GraphiQL populates it's things in the Bootup cycle.

Next up, we are going to run some mutations against the Server, which means we need to perform more imports:

import { GraphQLSchema, GraphQLObjectType, GraphQLString, GraphQLNonNull, GraphQLID } from 'graphql';

The GraphQlNonNull is a null checker against field arguments, GraphQLID is the JS analog to the Scalar ID type (A String compound type for identification)

Now, we are going to run the mutations:

let inMemoryStore = {}; //The live-memory state storage of our objects, if browser is rebooted, this is cleaned
const RootMutation = new GraphQLObjectType({
	name: 'RootMutation', //The name 
	description: 'The root mutation', //The description
	fields: { //The fields we allow for
		setNode: { //Set up Node to have these attributes
			type: GraphQLString, //The type we run against
			args: {
				id: {
					type: new GraphQLNonNull(GraphQLID) //The type must be a non Null
				},
				value: {
					type: new GraphQLNonNull(GraphQLString), //The value must be a non null
				}
			},
			resolve(source, args){ //The resolve, run against source and the field args
				inMemoryStore[args.key] = args.value; //assign the index of the key to be related to the value
				return inMemoryStore[args.key]; //return the value by accessing it with the key
			}
		}
	}
});

We then go to add the schema:

const Schema = new GraphQLSchema({
	query: RootQuery,
	mutation: RootMutation,
});

For sake of keeping things coherent, we add a Node field to our earlier object as well:

fields: {
	viewer: {
		type: GraphQLString,
		resolve(){
			return 'viewer!';
		}
	},
	node: {
		type: GraphQLString,
		args: {
			id: {
				type: new GraphQLNonNull(GraphQLID)
			}
		},
		resolve(source, args){
			return inMemoryStore[args.key];
		}
	}
}

We can then restart the server and run a mutation against it:

mutation {
	setNode(id: "id", value: "a value!")
}

We'd get the expected value returned:

{
	"data": {
		"node": "a value!"
	}
}

To confirm that the mutation work, we could just run a query with the id:

query{
	node(id: "id")
}


Most products data lives in Datastores as Postgres or MySQL.

Now, we are going to make a setup for a small FB clone, having a DB, authentication of authorization of clearance level, etc.

we are going to use Node-ql and sqlite3 for the DB interactions.

WE begin by setting up the DB:

$ npm install sqlite@0.0.4 sqlite3@3.1.3 --save --save-exact
$ mkdir src //make a source dir
$ touch src/tables.js src/database.js src/seedData.js

We begin by defining our tables, in table.js:

import sql from 'sql';

sql.setDialect('sqlite');

export const users = sql.define({
	name: 'users',
	columns: [{
		name: 'id',
		dataType: 'INTEGER',
		primaryKey: true
	}, {
		name: 'name',
		dataType: 'text'
	}, {
		name: 'about',
		dataType: 'text'
	}]
});

export const usersFriends = sql.define({
	name: 'users_friends',
	columns: [{
		name: 'user_id_a',
		dataType: 'int',
	},{
		name: 'user_id_b',
		dataType: 'int',
	},{
		name: 'level',
		dataType: 'text'
	}]
});

export const posts = sql.define({
	name: 'posts',
	columns: [{
		name: 'id',
		dataType: 'INTEGER',
		primaryKey: true
	}, {
		name: 'user_id',
		dataType: 'int'
	}, {
		name: 'body',
		dataType: 'text'
	}, {
		name: 'level',
		dataType: 'text'
	},{
		name: 'created_at',
		dataType: 'datetime'
	}]
});

We have now simply defines a few objects that we export, that we will be using shortly.

in addition to this book, some data.json file was given to us. The data is just some random data, we could make our own, but we are going to import the data into the DB,
thus, we go into database.js:

import sqlite3 from 'sqlite3';

import * as table from './tables'; //import the tables

export const db = new sqlite3.Database('./db.sqlite'); //Define the DB and export it

export const getSql = (query) => { //run a callback against the query provided
	return new Promise((resolve, reject) => { //create a Promise and run it with a resolve or reject
		console.log(query, text);
		console.log(query, values);
		db.all(query.text, query.values, (err, rows) => { //run the query text and values against all of the contents of the DB
			if (err) { //fi there is a error, reject it
				reject(err);
			} else { //otherwise, reoslve the resolve it and provide the rows from the result
				resolve(rows);
			}
		});
	});
}


We then open the seedData.js and create the DB and populate it:

import * as data from './data'; //iimport the data
import * as tables from './tables'; //import the tables
import * as database from './database'; //import the database

const sequencePromises = function (promises) { //A sequence of promises
	return promises.reduce((promise, promiseFunction) => { //return a reduction of the rpomises, havint reduced the result of promise run through promise function,
		//which returns the promise, and then runs the promiseFunction()
		return promise.then(() => {
			return promiseFunction();
		});
	}, Promise.resolve()); //resolve hte promise
};

const createDatabase = () => {
	let promises = [tables.users, tables.usersFriends, tables.posts].map((table) =\ //Define the promise to be mapping the values from the DB from tables
	{
		return () => database.getSql(table.create().toQuery()); //Run the getSql function after having made the trable and made it to a query
	});

	return sequencePromises(promises); //Run the promise sequence on the retrieved values from the DB tables
};

Since the node-sql is node objects created and exported, we have to run toQuery() on them to convert them to queries that we can handle.
Due to the fact of that the promises variable is created by the node-sql.

We then go to populate the data, into the tables we created, all the lines in this file, follows each other:

const insertData = () => {
	let { users, posts, usersFriends } = data; //assign the objects to be the data imported

	let queries = [ //let the list of queries be these converted queries
		tables.users.insert(users).toQuery(),
		tables.users.insert(posts).toQuery(),
		tables.usersFriends.insert(usersFriends).toQuery(),
	];

	let promises = queries.map((query) => { //let the promises be what we get from running a map of querying tthe promises and running a SQL query to the DB
		return () => database.getSql(query);
	});
	return sequencePromises(promises); //return the sequencing of running the promises run against the DB
};


We then bind them together, using toQuery and execute them using getSQL:

createDatabase().then(() => {
	return insertData();
}).then(() => {
	console.log({ done: true });
});

Now, wej ust have to populate the db from commandline:

$ node -e 'require("babel-register"); require("./src/seedData'); //The js we just wrote

Now, to explore this SQLite DB, we could use tons of things, such as DBeaver or anything akin.

To get some data from the DB, on a more primtiive level, we can jsut run commands against it on the command line:

$ sqlite3 ./db.sqlite "select count(*) from users"

Now, for the next step, is handling the data retrieved from the DB @ the GraphQLServer, which means that we have to begin thinking about how
our viewer will be. our viewer will be "the current user", and it needs to keep in mind of pagination. Anyhow, the general structure:

{
	viewer {
		friends {
			# connection fields for Users
		}
		

		posts {
			# connection fields for Posts
		}

		newsfeed {
			# connection fields for Posts
		}
	}
}

All of our objects should be nodes on a Graph and the data in the newsFeed has to be authorization aware.

We should support for queries that fetch arbitrary nodes using a top-level node (:id) field like:

{
	node(id: "123"){
		... on User {
			fiends {
				# friends
			}
		}

		... on Post {
			author {
				posts {
					#Connection fields
				}
			}

			body
		}
	}
}


Generally, the GraphQL convention is to fetch everything from the same top level ID, which is the reason for having unique ID values in GraphQL. To assert what that fetch is.

We then begin by creating a Js that holds our types:

types.js

$ touch src/types.js

We begin by creating our Node type. Remember, it has to have a strictly unique ID globallyt accessible:

import {
	GraphQLInterfaceType,
	GraphQLObjectType,
	GraphQLID,
	GraphQLString,
	GraphQLNonNull,
	GraphQLList,
} from 'graphql';

import * as tables from './tables';

export const NodeInterface = new GraphQLInterfaceType({ //Export the Node Interface
	name: 'Node', //give it a name
	fields: { //The fields
		id: { //just an id with no resolve, interfaces define their own things in their own way, defaults cannot be provided
			type: new GraphQLNonNull(GraphQLID)
		}
	}
})

The above code however, must also implement a resolveType function, cause we need to specify what type of a node is being returned, so that GraphQL can run fragmentaiton
on them (the ... on Users, for instance)

//Just continue the code above

const resolveId  = (source) => {
	return tables.dbIdToNode(source.id, source.__tableName);
};

export const NodeInterface = new GraphQLInterfaceType({
	name: 'Node',
	fields: {
		id: {
			type: new GraphQLNonNull(GraphQLID)
		}
	},
	resolveType: (source) => { //take raw data from the DB, in our case this will be straight form the DB
		if (source.__tableName === tables.users.getName()) { //The source is not a part of the DB tables yet, it gets injected later
			return UserType; //if the source tablename is equal to the users, return that it's a user we are returning
		}
		return PostType; //Otherwise, it's a post
	}
});

export const PostType = new GraphQLObjectType({
	name: 'Post',
	interfaces: [ NodeInterface ],
	fields: {
		id: {
			type: new GraphQLNonNull(GraphQLID),
			resolve: resolveId //If they do not exist, run a resolve to check against if their ground type exists, we will import this from another file
		},
		createdAt: {
			type: new GraphQLNonNull(GraphQLString),
		},
		body: {
			type: new GraphQLNonNull(GraphQLString)
		}
	}

})

We have to go to the tables.js to find where we will put in the exported functions:

export const dbIdToNodeId = (dbId, tableName) => {
	return `${tableName}:${dbId}`;
};

export const splitNodeId = (nodeId) => { //Since row colission can occur, we write a handling function for that
	const [tableName, dbId] = nodeId.split(':');
	return { tableName, dbId };
};

We then head to server.js to import some of the types we just made and change the rootQuery to only have the new node field:

// in server.js
import {
	NodeInterface,
	UserType,
	PostType
} from './src/types';

import * as loaders from './src/loaders'; 

const RootQuery = new GraphQLObjectType({
	name: 'RootQuery',
	description: 'The root query',
	fields: {
		node: {
			type: NodeInterface,
			args: {
				id: {
					type: new GraphQLNonNull(GraphQLID)
				}
			},
			resolve(source, args){
				return loaders.getNodeById(args.id); //return the resolved promise 
			}
		}
	}
});

The loaders.js that we import, is a script that exposes the APIs to load stuff from the source, we do not wish to have source accessing code on the Server or on the top-level schema code:

//in loaders.js

import * as database from './database';
import * as tables from './tables';

export const getNodeById = (nodeId) => {
	const { tableName, dbId } = tables.splitNodeId(nodeId); //get the id of the DB by accessing nodeID, a unique ID to signify the table we are after, not a specific row

	const table = tables[tableName];
	const query = table //Formulate the query
		.select(table.star()) //Select everything 
		.where(table.id.equals(dbId)) //Where table.id is equal to dbId
		.limit(1) //limit to one
		.toQuery(); //turn it into a query

	return database.getSql(query).then((rows) => { //run the query against the DB, then resolve it
		if (rows[0]){ //if the first element exists
			rows[0].__tableName = tableName; //let the metadata tableName be equal to the tableName we got from splitting the NodeId
		}
		return rows[0]; //return the table
	});
};

NOTE: Some things do not provide support for promises, but we can convert callbacks to promises.

The last step, is that we gotta make a list of all possible types in our schema, so that GraphQL can know a list of types that implements any interfaces.

const Schema = new GraphQLSchema({
	types: [UserType, PostType],
	query: RootQuery,
	mutation: RootMutation,
});

We can then run GraphiQL commands, against the server, if we wish:

//open the GraphiQL at localhost:3000/graphql

{
	node(id:"users:4"){
		id,
		... on User {
			name
		}
	}
}

We should see the data returned as:

{
	"data": {
		"node": {
			"id": "users:4",
			"name": "Roger"
		}
	}
}

Now, we would want a list of User types returned, but first, we must do babysteps, letsb egin with returning a list of IDs. We begin by editing the types.js to support User types:

	about: {
		type: new GraphQLNonNull(GraphQLString)
	},
	friends: {
		type: new GraphQLList(GraphQLID),
		resolve(source) { //Upon resolution
			return loaders.getFriendIdsForUser(source).then((rows) => { //get ids of friends for the user, resolve it afterwards
				return rows.map((row) => { //map the rows to be the resolved promise of the dbIdToNodeId, where we get the id of the nodes
					return tables.dbIdToNodeId(row.user_id_b, row.__tableName);
				});
			})
		}
	}

We add an imports to account for the need of the external classes from loaders:

import * as tables from './tables';
import * as loaders from './loaders';

And we then go to edit the loader.js, so that we can get the getFriendIdsForUser:

export const getFriendIdsForUser = (userSource) => {
	const table = tables.usersFriends;
	const query = table
		.select(table.users_id_b)
		.where(table.user_id_a.equals(userSource.id))
		.toQuery();

	return database.getSql(query).then((rows) => {
		rows.forEach((row) => {
			row.__tableName = tables.users.getName();
		});
		return rows;
	});
};

We can then just run the GraphQL queries with the new code:

{
	node(id:"users:4"){
		id
		... on User {
			name
			friends
		}
	}
}

Which will give us:

{
	"data": {
		"node": {
			"id": "users:4",
			"name": "Roger",
			"friends": [
				"users:1",
				"users:3",
				"users:2"
			]
		}
	}
}

Now, making queries in this capacity, is taxing. We need some optimization for it.

The GraphQL passes, in addition to the rest, two more variables to resolve : context and info. info contains an AST (Abstract Syntax Tree), which is the syntax tree
We will use context later for authentication and authorization

In the server.js, we do a simple traversal of the AST and look for User fragments on the node field's selection set, and determine if the fragment accesses the friends field.
if it does, then we run a new loader, else, we fall back to the original loader.

//in server.js

node: {
	type: NodeInterface,
	args: {
		id: {
			type: new GraphQLNonNull(GraphQLID) //assign a non-null ID
		}
	},
	resolve(source, args, context, info) { //Change the resolve
		let includeFriends = false; //declare boolean if inclusion of friends

		const selectionFragments = info.fieldASTs[0].selectionSet.selections; //Find the selections from the selection set from the fields of the AST in info
		const userSelections = selectionFragments.filter((selection) => { //access selections from selectionFragments, where it filetered out the selections
			return selection.kind === 'InlineFragment' && selection.typeCondition.name.value === 'User'; //return it if the selection.kind is inline fragment, and the value of
			//The selection is a User
		})

		UserSelections.forEach((selection) => { //loop through the selections
			selection.selectionSet.selections.forEach((innerSelection) => { //loop through the selections for the inner loops
				if (innerSelection.name.value === 'friends'){ //if the value is friends
					includeFriends = true; //include them
				}
			});
		});

		if (includeFriends){ //if we should include friends
			return loaders.getUserByNodeWithFriends(args.id); //run loaders against that
		}
		else{
			return loaders.getNodeById(args.id); //Otherwise, run original loader
		}
	}
}

Now, we shall take a look at the getUserNodeWithFriends function():

export const getUsersNodeWithFriends = (nodeId) => {
	const { tableNames, dbId } = tables.splitNodeId(nodeId);

	const query = tables.users //Grab user and all of it's friends, meaning we do not make a second roundabout to the DB
		.select(tables.usersFriends.user_id_b, tables.users.star())
		.from(
			tables.users.leftJoin(tables.usersFriends)
			.on(tables.usersFriends.user_id_a.equals(tables.users.id))
		)
		.where(tables.users.id.equals(dbId))
		.toQuery();


	return database.getSql(query).then((rows) => {
		if (!rows[0]) { //if it does not exist
			return undefined; 
		}

		const __friends = rows.map((row) => { //__ is designation of "private" in JS, it's not really private
			return {
				user_id_b: row.user_id_b,
				__tableName: tables.users.getName()
			}
		});

		const source = {
			id: rows[0].id,
			name: rows[0].name,
			about: rows[0].about,
			__tableName: tableName,
			__friends: __friends
		};

		return source;
	});
};

And we then access the stuff in types.js:

friends: {
	type: new GraphQLList(GraphQLID),
	resolve(source){ //upon resolution
		if (source.__friends){ //if source.__friends exists
			return source.__friends.map((row) => { //return a mapped array of rows from the DB
				return tables.dbIdToNodeId(row.user_id_b, row.__tableName);
			});
		}

		//otherwise, return the friendsIdsforUsers and then return the mapped results of rows in the DB of user_id_b against tableName
		return loaders.getFriendIdsForUser(source).then((rows) => {
			return rows.map((row) => {
				return tables.dbIdToNodeId(row.user_id_b, row.__tableName);
			});
		})
	}
}


The main point, is that many arguments can be passed, to bypass the normal flow of recursive calls, to shortcircuit the flow and assert that we have what we wanted from teh search to ebgin with.

Other applications might do warm up of a cache in the background, but here we just glob the SQL Queries.

Since the app is about to change a lot, and we are about to implement the idiomatic connection of GraphQL, we remove the optimized resolve, first:

//Remove this, in teh meantime
resolve(source, args, context, info){
	return loaders.getNodeById(args.id);
}

Next up, we change the type returned by friends field to a list of User. We already have a loader for arbitrary Node ids, so we just gotta write the following code:

export const UserType = new GraphQLObjectType({
	name: 'User', //A user object
	interfaces: [ NodeInterface ], //Implements the NodeInterface
	// This is now a function
	fields: () => { //The fields is the results of said things
		return { //return the object
			id: {  //the id of the object
				type: new GraphQLNonNull(GraphQLID), //It's ID is a GraphQLID
				resolve: resolveId //to resolve the ID, run resolveId
			},
			name: { type: new GraphQLNonNull(GraphQLString) }, //the name
			about: { type: new GraphQLNonNull(GraphQLString) }, //the about
			friends: { //The friends, is a list
				type: new GraphQLList(UserType), //a GraphQLList of UserType
				resolve(source){ //Resolve the source
					return loaders.getFriendsIdsForUser(source).then((rows) => { //return the loaders of getting friends ids for User on source, then
						const promises = rows.map((row) => { //make promises to be a mapping of that row
							const friendNodeId = tables.dbIdToNodeId(row.user_id_b, row.__tab1\ //where we read from the DB, where we get the dbIdToNodeId on the users ID
eName); 																						//against the users name
							return loaders.getNodeById(friendNodeId); //return the Node by accessing the Id
						});
						return Promise.all(promises); //Return the promises, having resolved all of them
					})
				}
			}
		};
	}
});

NOTE: Due to how JS hoisting works, we have to declare a field to be a function, to be able to use a field of itself

If we now restart the server, and run the query against the server, we'd find the following:

//The request

{
	node(id: "users: 4"){
		... on User {
			friends {
				id
				about
				name
			}
		}
	}
}

//Will return

{
	"data": {
		"node": {

		
			"friends": [
				{
					"id": "Users:1",
					"about": "Sports!",
					"name": "FOK U"
				},
				etc.
			]
		}
	}
}

The next step, is to write Connections, which will allow for lists that we treat like chunks, related.

The goal is to be able to write queries to the following structure, with cursors in mind, which are more resillient to real-time change:

{
	node(id:"users:1"){
		... on User{
			posts(first: 1){
				pageInfo {
					hasNextPage
					hasPreviousPage
					startCursor
					endCursor
				}
				edges {
					cursor
					node {
						id 
						body
					}
				}
			}
		}
	}
}

Instead of returning a list of PostType, the posts field will return a PostConnection type.

We begin by defining the PageInfo, PostEdge and PostConnection types in our types.js, along with importing some more stuff:

import {
	GraphQLInterfaceType,
	GraphQLObjectType,
	GraphQLID,
	GraphQLString,
	GraphQLNonNull,
	GraphQLList,
	GraphQLBoolean,
	GraphQLInt,
}	from 'graphql';

const PageInfoType = new GraphQLObjectType({
	name: 'PageInfo',
	fields: {
		hasNextPage: {
			type: new GraphQLNonNull(GraphQLBoolean)
		},
		hasPreviousPage: {
			type: new GraphQLNonNull(GraphQLBoolean)
		},
		startCursor: {
			type: GraphQLString,
		},
		endCursor: {
			type: GraphQLString,
		}
	}
});

const PostEdgeType = new GraphQLObjectType({
	name: 'PostEdge',
	fields: () => {
		return {
			cursor: {
				type: new GraphQLNonNull(GraphQLString)
			},
			node: {
				type: new GraphQLNonNull(PostType)
			}
		}
	}
});

const PostConnectionType = new GraphQLObjectType({
	name: 'PostConnection',
	fields: {
		pageInfo: {
			type: new GraphQLNonNull(PageInfoType)
		},
		edges: {
			type: new GraphQLList(PostEdgeType)
		}
	}
})

//The above is mostly type declarations, with no inherit resolve, which means that connections can be resolved in different means, so far we haven ot elected to resolve them in any matter.

And then, we go to hook up our UserType to the New Types we created and actually create the Posts fields:

		}
	},
	posts: {
		type: PostsConnectionType,
		args: {
			after: {
				type: GraphQLString
			},
			first: {
				type: GraphQLInt
			},
		},
		resolve(source, args){
			return loaders.getPostIdsForUser(source, args).then(({ rows, pageInfo }) => {
				const promises = rows.map((row) => {
					const postNodeId = tables.dbIdToNodeId(row.id, row.__tableName);
					return loaders.getNodeById(postNodeId).then((node) =>, {
						const edge = {
							node,
							cursor: row.__cursor,
						};
						return edge;
					});
				});

				return Promise.all(promises).then((edges) => { //Returns a PostConnectionType with edges keys and pageInfo,
					return {
						edges,
						pageInfo
					}
				});
			})
		}
	}
});



NOTE: There is optimization to be had in terms of the JS and the DB. The slicing and returning on level of the Relay, is kind of complicated, thus, we will only suffice to briefly use after and first.

The order of which the algorithm runs, is as follows:

EdgesToReturn(allEdges, before, after, first, last) :
	1. Let edges be the result of calling ApplyCursorToEdges(allEdges, before, after)
	2. If first is set:
		1. If first is less than 0:
			1. Throw an error
		2. If edges has length greater than first:
			1. Slice edges to be of length first by removing edges from the end of edges
		3.if last is set:
			1.if last is less than 0:
				Throw an error
			2. If Edges has length greater than last:
				Slice edges to be of length last by removing edges from the start of edges.
		4. Return edges.

ApplyCursorToEdges(allEdges, before, after):
	1. Initialize edges to be allEdges
	2. If after is set:
		1. Let afterEdge be the edge in Edges whose cursor is equal to the after argument
		2. if afterEdge exists:
			1. Remove all elements of edges before and including afterEdge
	3.If before is set:
		1.Let beforeEdge be the edge in edges whose cursor is equal to the before argument
		2.If beforeEdge exists
			1. Remove all elements of edges after and including beforeEdge
	4. Return edges

We begin by defining a new function, parsing the arguments:

export const getPostIdsForUser = (userSource, args) => {
	let { after, first } = args;
	if (!first){ //If we did not supply a argument for first, return two posts
		first = 2;
	}
}

//We then build the SQL queries:

const table = table.posts;
let query = table
	.select(table.id, table.created_at) //From what
	.where(table.user_id.equals(userSource.id)) //the where check 
	.order(table.created_at.asc) //order it by created at order, ascending
	.limit(first + 1); //Cheap way to assert if there is more than what the user requested

//We then account for a after cursor:

if (after) {
	//parse cursor
	const [id, created_at] = after.split(':');
	query = query
		.where(table.created_at.gt(after))
		.where(table.id.gt(id));

Most likely, our cursors consists of dates and ids, sometimes we have autoincremeneted IDs, but that's more rare with bigger scales.

We then go to continue the queries:

return database.getSql((query.toQuery())).then((allRows) => {
	const rows = allRows.slice(0, first); //We slice due to requesting more than 1 row

	rows.forEach((row) => { //Assign attributes to each row to allow for joins later on
		row.__tableName = tables.posts.getName(); //Give them a name
		row.__cursor = row.id + ':' + row.created_at; //And a relevant cursor with a id and time of creation


	});

	//we then work with the returned data

	const hasNextPage = allRows.length > first; //SAve if we have more than 1 page
	const hasPreviousPage = false; //We always assign to it being false, since we do not support before and last

	const pageInfo = {
		hasNextPage: hasNextPage,
		hasPreviousPage: hasPreviousPage,
	};

	if(rows.length > 0){
		pageInfo.startCursor = rows[0].__cursor;
		pageInfo.endCursor = rows[rows.length - 1].__cursor;
	}
})
}


Now, assuming the sytnax is correct, we can make queries as follows:

{
	node(id:"users:1") {
		... on User {
			posts(first: 1){
				pageInfo {
					hasNextPage
					hasPreviousPage
					startCursor
					endCursor
				}
				edges{
					cursor
					node{
						id
						body
					}
				}
			}
		}
	}
}


The expected info from the first post, would be something along the lines of:

{
	"data": {
		"node": {
			"posts": {
				"pageInfo": {
					"hasNextPage": true,
					"hasPreviousPage": false,
					"startCursor": "1:2016-04-01",
					"endCursor": "1:2016-04-01"
				},
				"edges:" [
					{
						"cursor": "1:2016-04-01",
						"node": {
							"id": "posts:1",
							"body": "The team really played well! FOK U!"
						}
					}
				]
			}
		}
	}
}


Since it has the NextPage true, we could run a request for the next page as well:

{
	node(id:"users:1"){
		... on User{
			posts(first: 1, after:"1:2016-04-01"){
				pageInfo {
					hasNextPage
					hasPreviousPage
					startCursor
					endCursor
				}
				edges{
					cursor
					node{
						id
						body
					}
				}
			}
		}
	}
}


Which would give:

{
	"data":{
		"node":{
			"posts":{
				"pageInfo":{
					"hasNextPage": false,
					"hasPreviousPage": false,
					"startCursor": "2:2016-04-02",
					"endCursor": "2:2016-04-02"
				},
				"edges": [
					{
						"cursor": "2:2016-04-02",
						"node":{
							"id": "posts:2",
							"body": "HONESTLY, FOK UUUUUUUUUUUUUUUUUUUUUUUUU"
						}
					}
				]
			}
		}
	}
}

Now, on to Authentication. In our case, we are going to do a very simple HTTP authentication, which, is very simple. there is plenty of other, such as JSON tokens, cookies, OAuth etc.

We begin by installing the basic-auth-connect package:

$ npm i basic-auth-connect@1.0.0 --save --save-exact

Then just import it in the server.js:

import basicAuth from 'basic-auth-connect';

And before the call to graphqlHTTP with app.use(), we call basic auth:

app.use(basicAuth(function(user, pass){
	return user === 'harry' && pass === 'mypassword1'; //just provide the correct password as mockup
}));


Let us try authenticating aginst the server now, after reboot:

$ curl -XPOST -H 'content-type:application/graphql' http://localhost:3000/graphql -d '{ node(id:"users:4") { id } }'
//Gives unauthorized

$ curl -XPOST -H 'content-type:application/graphql' --user 1:mypassword1 http://localhost:3000/graphql -d '{ node(id:"users:4") { id }'
//Will give: {"data": {"node": {"id":"users:4"}}}

Generally, the authentication is seperated from the GraphQL itself.

Now, to account for the view of authorization of levels and permissions, we add the authorization to the app.use() call:

app.use('/graphql', graphqlHTTP((req) => {
	const context = 'users:' + req.user;
	return { schema: Schema, graphiql: true, context: context, pretty: true };
}));

This will returna different object with different contexts each time, whilst also being readable due to pretty

To now add teh viewer field, we just change the rootQuery:

const RootQuery = new GraphQLObjectType({
	name: 'RootQuery',
	description: 'The root query',
	fields: {
		viewer: {
			type: NodeInterface,
			resolve(source, args, context){
				return loaders.getNodeById(context);
			}
		},
	}
})

If we reboot, we should now be able to access our view:

$ curl -XPOST -H 'content-type:application/graphql' --user 1:mypassword1 http://\
localhost:3000/graphql -d '{ viewer { id } }'
{
	"data": {
		"viewer": {
			"id": "users: 1"
		}
	}
}

Now, not only can viewer see all the relevant things and run authentication against things, but now, all levels of resolve() can see each other, regardless of depth in the hierarchy, due to being described as a graph

We should not let the actual Schema handle it, instead we let the loaders handle that. Thus, we just pass context:

resolve(source, args, context){
	return loaders.getPostIdsForUser(source, args, context).then(({ rows, pageInfo}) => {})
}

Inside of the getPostsForIdForuser, we load the levels of relevance:

let query = table
	.select(table.id, table.created_at, table.level) //Selects
	.where(table.user_id.equals(userSource.id)) //joins
	.order(table.created_at.asc) //Order them ascendingly
	.limit(first + 10); //Limit to the first 10 + the first

We then also run queries to query all relevance levels:

return Promimse.all([
	database.getSql(query.toQuery()),
	getFriendshipLevels(context)
]).then(([ allRows, friendshipLevels ]) => {
	allRows = allRows.filter((row) => {
		return canAccessLevel(friendshipLevels[userSource.id], row.level);
	});
	const rows = allRows.slice(0, first);
})

NOTE: A potentional bug is reading length against the fact of truncated rows due to visibility, which means we compensate in reading with overshooting by 10

We still have two methods to define, canAccessLevel and friendshipLevels. Let us begin with friendshipLevels:

const getFriendshipLevels = (nodeId) => {
	const { dbId } = tables.splitNodeId(nodeId); //split the nodeId

	const table = tables.usersFriends; //assign a table
	let query = table //query teh table
		.select(table.star()) //Select * from the table where
		.where(table.user_id_a.equals(dbId)); //user_id_a === dbId

	return database.getSql(query.toQuery()).then((rows) => { //run queries against the DB, convert them to queries, then call a function with rows
		const levelMap = {}; //assign Levelmap as empty array
		rows.forEach((row) => { //iterate through rows
			levelMap[row.user_id_b] = row.level; //map the values
		});

		return levelMap; //return the map, which is now a object
	});
};

Since our accesslevels are linear, we can just make an array and compare indexes:

const canAccessLevel = (viewerLevel, contentLevel) => { //pass in viewerlevel and content level
	const levels = ['public', 'acquintance', 'friend', 'top']; //The levels
	const viewerLevelIndex = levels.indexOf(viewerLevel); //our viewer level
	const contentLevelIndex = levels.indexOf(contentLevel); //the target level

	return viewerLevelIndex >= contentLevelIndex; //Return if it's true that we have access or not
};

now, if we ran this query, we'd get no answer:

{
	node(id:"users:2"){
		... on User{
			posts {
				edges {
					node {
						id
						... on Post{
							body
						}
					}
				}
			}
		}
	}
}


Will given othing, because we are not friends with user two. If we were to login as user 5 instead, we'd get a response:

{
	"data":{
		"node":{
			"posts":{
				"edges": [
				{
					"node": {
						"id": "posts:3",
						"body": "Some shit"
					}
				}
			]
		}
	}
}
}

//NOTE: Some shitty indention error again

Now, next up, is running mutations, which is for creation and updating, in our server.js:

import { GraphQLSchema, GraphQLObjectType, GraphQLString, GraphQLNonNull, GraphQLID, GraphQLEnumType } from 'graphql';

const LevelEnum = new GraphQLEnumType({
	name: 'PrivacyLevel',
	values: {
		PUBLIC: {
			value: 'public'
		},
		ACQUITANCE: {
			value: 'acquitance'
		},
		FRIEND: {
			value: 'friend'
		},
		TOP {
			value: 'top'
		}
	}
});

const RootMutation = new GraphQLObjectType({
	name: 'RootMutation',
	description: 'The root mutation',
	fields: {
		createPost: {
			type: PostType,
			args: {
				body: {
					type: new GraphQLNonNull(GraphQLString)
				},
				level: {
					new GraphQLNonNull(LevelEnum),
				}
			},
			resolve(source, args, context){ //after a post is made, we have to deligate it to createPost
				return loaders.createPost(args.body, args.level, context).then((nodeId) \
=> {
					return loaders.getNodeById(nodeId);
				});
			}
		}
	}
});

NOTE: Enums in GraphQL are ALL_CAPS


//The createPost loader:

export const createPost = {body, level, context} => { //Run a function call with the object
	const { dbId } = tables.splitNodeId(context); //split the node id by context and assign it
	const created_at = new Date().toISOString().split('T')[0]; //assign when it occured
	const posts = [{ body, level, created_at, user_id: dbId }]; //assign the posts to be a array with the object

	let query = tables.posts.insert(posts).toQuery(); //query the posts after inserting them and retrieve values afterwards
	return database.getSql(query).then(() => { //run a query against the DB
		return database.getSql({ text: 'SELECT last_insert_rowid() AS id FROM posts'}); //get the ids from teh DB
	}).then((ids) => {
		return tables.dbIdToNodeId(ids[0].id, tables.posts.getName()); //get the names 
	});
};

If we open up GraphiQL, we can run the mutation:

mutation {
	createPost(body:"First post!", level:PUBLIC){
		id
		body
	}
}

Relay can also delegate to get files, which can be done as follows:

getFiles(): ?FileMap

//Type of the FileMap object
type FileMap = {[key: string]: File};

An example of using it:

class AttachDocumentMutation extends Relay.Mutation{
	getFiles(){
		return{
			file: this.props.file,
		};
	}
}

class FileUploader extends React.Component{
	handleSubmit(){
		var fileToAttach = this.refs.fileInput.files.item(0);
		Relay.Store.commitUpdate(
			new AttachDocumentMutation({file: fileToAttach})
		);
	}
}

beyond this, there is a library that makes easier use for Relay, tho, which is the GraphQL-Relay-JS lib, which we will showcase:

$ npm install graphql-relay@0.4.1 --save --save-exact

With this lib, we can simply import the connections:

import {
	connectionDefinitions
} from 'graphql-relay';

We then delete all existing connection types, and write this instead:

const resolveId = (source) => {
	return tables.dbIdToNodeId(source.id, source.__tableName);
};

export const UserType = new GraphQLObjectType({
	name: 'User',
	etc..
})

At the bottom, we simply add:

const { connectionType: PostsConnectionType } = connectionDefinitions({ nodeType : PostType });

This would generate all the types we made for hand.

GraphQL-Relay also has functions for simplifying how node types are structured and working with Relay compatible mutations.
Relay itself, actually puts constraints on Mutations, which we will see later.

None of the GraphQL server things here, are specific to GraphQL-JS or JS. Which means any language can use the GraphQL server structure in tandem with Relay.

Then, there is optimization, and the problem of the N+1 queries. Which is when we have to call iterative calls in terms of queries, and thus, we would like to batch similarly typed data to be Batched and increase perforamcne there of.

There is a library, called DataLoader, that allows for loading batches of Data, which is independant of React or GraphQL. you use it to create loaders, which are objects that
automatically batch fetching of similar data.

For example:

const UserLoader = new DataLoader((userIds) => {
	const query = table
		.select(table.star())
		.where(table.id.in(userIds))
		.toQuery();

	return database.getSql(query.toQuery());
});

//Elsewhere, to load a single user:

function resolveUser(userId){
	return UserLoader.load(userId);
}

In our code, we have many calls to fetching by getNodeById, where we could just batch them all together:

$ npm install dataloader@1.2.0 --save --save-exact

We begin with the idea of making one data loader for each table:

//loaders.js

import * as database.from './database';
import * as tables from './tables';

import DataLoader from 'dataloader';

const createNodeLoader = (table) => {
	return new DataLoader((ids) => {
		const query = table
			.select(table.star())
			.where(table.id.in(ids))
			.toQuery();

		return database.getSql(query).then((rows) => {
			rows.forEach((row) => {
				row.__tableName = table.getName();
			});
			return rows;
		});
	});
};

The createNodeLoader is a factory function which returns new instances of DataLoader

We make a query from the SELECT * FROM $TABLE WHERE ID IN($IDS), which allows for multiple nodes per query

We then make a constant of the factories we need:

const nodeLoaders = {
	users: createNodeLoader(tables.users),
	posts: createNodeLoader(tables.posts),
	usersFriends: createNodeLoader(tables.usersFriends),
};

We then change the getNodeById to use the factories:

export const getNodeById = (nodeId) => {
	const { tableName, dbId } = tables.splitNodeId(nodeId);
	return nodeLoaders[tableName].load(dbId);
};

To then make the query:

{
	user3: node(id:"users:3"){
		id
	}
	user4: node(id:"users:4"){
		id
	}
}

//we'd get:

$ node index.js
{ starting: true }
{ running: true }
SELECT "users".* FROM "users" WHERE ("users"."id" IN ($1, $2))
['3', '4']

Note, the loader can act as a cache as well, if we wish.

We should keep optimization to the level of loading and data service points, so everyone can enjoy the benefits.

There is plenty of stuff in regards to GraphQL, like Apollo Server (for Node), Graffiti-Mongoose (Node and MongoDB), Reindex and Graphcool for hosting GraphQL servers

GraphQL (Ruby), Graphene (Python), Sangria (scala)

Next up, is Relay:

Relay is the glue between a GraphQL server and React components.

Relay is good for the following concerns:

Fetching data, fetch failure handling, query dependancies and relationships between data, data consistent across the app, keeping devs away from breaking each others COmponents,
How to write app specific functionality

In relay, the GraphQL queries are co-located to the Component. 

Relay helps us declare the data it needs to operate, manages how and when we fetch data, aggregates queries, gives clear patterns for navigating relations between objects and mutating them

This also means that Relay can handle discarding duplication of aggregated requests. (I.e, if it finds duplications i total, it removes the redundancy)

The server in this example, is run with graffiti-mongoose. if we use MongoDB and mongoose, then grafitti-mongoose is great. It takes our mongoose models and generates a GraphQL Relay compatible server in tandem to thoose, automatically.

The app we will make, is a simple book store, with 3 pages, with routing.

We begin by running the install on server and client:

$ npm install && cd client && npm install && cd ..

$ npm run server //first tab

$ npm run client //second tab

$ npm start //both

We can find the server at http://localhost:3001 and client app at http://localhost:3000

The complete schema of the setup, is as follows:

-- bookstore
	|-- Readme.md
	|-- client
	|	|-- config 					//Client config
	| 	| 	|-- babelRelayPlugin.js 		//custom babel plugin
	|	|	|-- webpack.config.dev.js 		//webpack configs
	| 	|	 -- webpack.config.prod.js
	| 	| 
	| 	|-- package.json
	|	|-- public
	| 	| 	|-- images/
	| 	| 	 -- index.html
	| 	|--scripts
	|	|	| -- build.js
	| 	|	| -- start.js
	| 	| 	  -- test.js
	| 	| -- src
	| 		| -- components 		//our components
	|		|	| -- App.js
	|		|	| -- AuthorPage.js
	|		|	| -- BookItem.js
	|		| 	| -- BookPage.js
	| 		| 	| -- FancyBook.js
	| 		|  	  -- TopBar.js
	| 		| -- data   			//graphQL metaData
	|		|	|-- schema.graphql
	| 		| 	 -- schema.json
	| 		|-- index.js
	| 		|-- mutations 
	| 		|	 -- UpdateBookMutation.js
	| 		|-- Routes.js
	| 		|-- steps/ 			//intermediate files
	| 		|-- styles 		//css
	|-- model.js
	| -- package.json
	| -- schema.js 				//graphQL schema on server
	| -- server.js 				//the server
	| -- start-client.js
	| -- start-server.js
	 	-- tools
	 		-- 	update-schema.js 			//helper in generating the schemas


Relay is a JS lib that runs on the client side

We connect our Relay to our React Components and then fetch the data.

The server must adhere to the Relay protocol, and Relay acts as the Database backbone to load all states, get info, etc.

Relay can take two query objects and delegate each seperately. It also has it's own store.

However, since Relay holds a central storage, it makes it incompatible with other similar things, such as Redux. Because they do the same thing.

The conventions that the GraphQL server must adhere to, on a high level:

1. A way to fetch any object by ID (regardless of type)

2. A way to traverse relationships between objects (connections) with pagination

3. A structure around changing data with mutations

We begin by fetching ID of authors from the already done Server structure, where we wish to load a list of ID specified authors to implement into teh URL (www.someshit.com/hello/author123)

query {
	authors {
		id
		name
	}
}


We can now query a specific author:

query{
	author(id: "WJRAJRIAWRJirj<someshit>"){
		id
		name
	}
}

The response:

{
	"data": {
		"author": {
			"id": "<some shit>",
			"name": "Anthony MOFOKKA"
		}
	}
}

However, the Relay specification says we need to access nodes by Id, regarldess of type. Which means, we have to do stuff like:

query {
	node(id: "Some shit"){
		id
	}
}

//The response

{
	"data": {
		"node": {
			"id": <some shit>
		}
	}
}

If we wish to query the specific author, we have to access it with fragments. meaning we CANNOT:

query {
	node(id:"<some shit>"){
		id
		name
	}
}

^^ NO NO. Will fail due to generic access to node, have to specify through ... fragment access on Class:

query {
	node(id: "<some shit>"){
		id
		... on Author {
			name
		}
	}
}

//The response

{
	"data":{
		"node": {
			"id": <some shit>
			"name": <fok u>
		}
	}
}

Relay uses the node interface for re-fetching objects.

The two relations that Relay defines, much akin to DBs, is connections and edges.

Connections: What the relationship is and pagination of data

edge : wraps a cursor as well as the node model specified data

An example of making a query of a author and all his books:

query {
	author(id: <some shit>){
		id 
		name
		books {
			count
			edges{
				node {
					id
					name
				}
			}
		}
	}
}

The type books does not return an array of books. it accepts arguments, such as first and last and returns a AuthorBooksConnection

Since Relay was made to handle a huge number, we have pagination in terms of first and last.

The AuthorBooksConnection ahs trhee relevant attributes:

pageInfo //the cursor with page info

edges //the list of AuthorBookEdge

count

a AuthorBookEdge has:

a node and a cursor

Node is a type of book, which we can use Cursor to traverse

Note: Everything in a graph, is node and edges.

Relay stands for the connection, such as first and last, returning edges, GraphQL stands for fetching from teh DB and the server.

An example of running a mutation query:

mutation {
	updateAuthor(input: {
		id: <some shit>
		bio: "some shit"
	}) {
		changedAuthor {
			id
			name
			bio
		}
	}
}

The response would be an object with the updated bio

We can use similar paradigms such as CRUD from REST (Create, Read, Update, Delete)

Which in our case would be createAuthor, updateAuthor, deleteAuthor

What follows, is an example of a minimal function Relay code:

import React from 'react';
import ReactDOM from 'react-dom';
improt Relay from 'react-relay';

import '/../semmantic/dist/semmantic.css';
import '/styles/index.css';

//define the server url
const graphQLUrl = 'http://localhost:3001/graphql';

//Config Relay with a network layer
Relay.injectNetworklayer(
	new Relay.DefaultNetworkLayer(graphQLUrl)
);

//Config top level query that we will make
class AppQueries extends Relay Route {
	static routeName = 'AppQueries';
	static queries = {
		viewer = () => Relay.QL`
			query {
				viewer
			}
		`,
	};
}

//A basic component that renders the list of authors
class App extends React.Component {
	render() {
		return (
			<div>
				<h1>Authors list</h1>
				<ul>
					{this.props.viewer.authors.edges.map(edge => 
						<li key={edge.node.id}>{edge.node.name}</li>
					)}
				</ul>
			</div>
		);
	}
}

//A relay container that specifies the fragment to be used in our query above 
const AppContainer = Relay.createContainer(App, {
	fragments: {
		viewer: () => Relay.QL`
			fragment on Viewer {
				authors(first: 100){
					edges {
						node {
							id
							name
						}
					}
				}
			}
		`,
	},
});

ReactDOM.render(
	<Relay.Renderer
		environment={Relay.Store}
		Container={AppContainer}
		queryConfig={new AppQueries()}
	/>,
	document.getElementById('root')
);

The above code fetches the data of a list and renders it. It's decalrative, which means we just declare stuff and Relay popuylates it for us.

Next up, is the AuthorPage component in it's minimal format:

class AuthorPage extends React.Component {
	render() { //The render call
		const { author } = this.props;

		return (
			<div>
				<img src={author.avatarUrl} />
				<h1>{author.name}</h1>
				<p>
					//How many books we are getting
					{author.books.count}
					{author.books.count > 1 ? 'Books' : 'Book'}
				</p>
				<p>{author.bio}</p>
			</div>
		);
	}
}

export default Relay.createContainer(AuthorPage, { //Creates a Relay container with a query of Relay to populate the fragments on Author
	fragments: {
		author: () => Relay.QL`
		fragment on Author {
			name
			avatarUrl
			bio
			books{
				count
			}
		}`,
	},
});


When we make queries:

fragments: {
	author: () => Relay.QL `
	fragment on Author {
		name
		avatarUrl
		bio
		books {
			count
		}
	}`,
},

Now, we could do typos, but the good news is, we have a babel-relay-plugin for that, which we can access by converting our objects into JSON and then exporting it to run against the server comparator at compile-time.

First, we need to write something that exports our Schema as json, it follows:

import fs from 'fs'; //import fs
import path from path; //get our path
import { graphql } from 'graphql'; //get the whole graphql
import { introspectionQuery, printSchema } from 'graphql/utilities'; //import stuff from graphql
import schema from '../schema'; //get the schema from the prev dir with schema folder

//Save JSON of full schema introspection for the babel relay plugin to use
const generateJSONSchema = async () => { //run a async call
	var result = await (graphql(schema, introspectionQuery)); //await the query to finish
	if (result.errors){ //If there were errors in the result
		console.error( //log the error
			'ERROR introspecting schema: ',
			JSON.stringify(result.errors, null, 2)
		);
	} else { //otherwise
		fs.writeFileSync( //write the file synchronization
			path.join(__dirname, '../client/src/data/schema.json'), //join the paths
			JSON.stringify(result, null, 2) //stringify the result
		);
	}
	

	//Save the user readable type system shorthand of schema
	fs.writeFileSync( //write the file syncrhonization
		path.join(__dirname, '../client/src/data/schema.graphql'), //join the paths with the destination dir
		printSchema(schema) //print the schema
	);
};


generateJSONSchema().then(() => {
	console.log("Saved to client/src/data/schema.{json,graphql}");
})

Note: Exporting the JSOn can be done with any GraphQL, we must not run Relay for that

The introspectionQuery that we are running on this, is a query that asks GraphQL info about what Queries it supports.

We write two files, one machine-readable schema.json file (for client) and one human-readable schema.graphql file

A sample from the schema.graphql file:

type Author implements Node {
	name: String
	avatarUrl: String
	bio: String
	createdAt: Date
	books(after: String, first: Int, before: String, last: Int): AuthorBooksConnection
	_id: ID

	#The Id of a object
	id: ID!
}

#A connection to al ist of items
type AuthorBooksConnection{
	#information to aid in pagination
	pageInfo: PageInfo!

	#A list of edges
	edges: [AuthorBooksEdge]
	count: Float
}

if we were in root dir, we could generate the schema by:

npm run generateSchema

If we change the schema, we have to regenerate it, with the above code

NOTE: Some webpacks caches your schemas when run. (Such as the default that is generated when you eject from generate-react-app), it caches commpiled scripts.
Which means it caches the schemas as well.

To always have a up to date schema, we must run the following:

rm -rf client/node_modules/.cache/react-scripts/

Failure to do this, will re-run the old schema

The next step, is to config our Babel-relay-plugin:

$ npm install babel-relay-plugin

Then tell the babel-relay-plugin about our schema.json:

in client/cojnfig/babelRelayPlugin.js

var getBabelRelayPlugin = require('babel-relay-plugin'); //require the plugin
var schema = require('../src/data/schema.json'); //require the schema

module.exports = getBabelRelayPlugin(schema.data, { ///Export the module
	debug: true, //run debug
	suppressWarnings: false, //do not surpress warnings
	enforceSchema: true //enforce schema
});

We then also modify the client's package.json:

"babel": {
	"presets": [
		"react-app"
	],
	"plugins": [
		"./config/babelRelayPlugin"
	]
},

NOTE: If we config babel via a .babelrc or some other way, the core idea is that we add our custom babelRelayPlugin script to the list of plugins

Next up, we are going to include Routing! Except, we are doing it by react-router with react-router-relay.

The problem, is that react-router uses 2.8, not 4, which we covered earlier.

We can, however, if we want, manually circumvent this and integrate Relay into React Router v4. This will not be covered here.

to install react-router-relay middleware, we'll config Relay, Config our Router, and then use the middleware.

What follows, is the code for this:

import React from 'react';
import ReactDOM from 'react-dom';
import createHistory from 'history/lib/createHasHistory';
import Relay from 'react-relay';
import applyRouterMiddleWare from 'react-router/lib/applyRouterMiddleware';
import Router from 'react-router/lib/Router';
import useRouterHistory from 'react-router/lib/useRouterHistory';
import useRelay from 'react-router-relay';

import routes from './routes';

import '../semantic/dist/semantic.css';
import './styles/index.css';

//Customize this based on url
const GraphQLUrl = 'http://localhost:3001:graphql';

//Configure the relay with a Networklayer
Relay.injectNetworkLayer(
	new Relay.DefaultNetworkLayer(graphQLUrl) //Inject the network layer 
);

const history = useRouterHistory(createHashHistory)({ queryKey: false }); //We are going to use hash-based history, thus create hash based History

ReactDOM.render(
	<Router
		history={history}
		routes={routes}
		render={applyRouterMiddleware(useRelay)} //Apply the Middleware
		environment={Relay.Store}
	/>,
	document.getElementById('root')
);


import Relay from 'react-relay';
import React from 'react';
import indexRoute from 'react-router/lib/IndexRoute';
import Route from 'react-router/lib/Route';

import App from './components/App';
import AuthorPage from './components/AuthorPage';

const AuthorQueries = {
	author: () => Relay.QL`
	query {
		author(id: $authorId)
	}`,
};

export default (
	<Route
		path='/'
		component={App}
	>
		<Route
			path='/authors/:authorId'
			component={AuthorPage}
			queries={AuthorQueries}
		/>
	</Route>
);

We then go further and build the hiearchy:

import React, { Component } from 'react';
import { withRouter } from 'react-router';

import TopBar from './TopBar';
import '../styles/App.css';

class App extends React.Component{
	render(){
		return (
			<div className='ui grid'>
				<TopBar />
				<div className='ui grid container'>
					{ React.cloneElement(this.props.children) } //Wrap around any of the children
				</div>
			</div>
		);
	}
}

export default withRouter(App); //wrap the App with the helper withRouter function taht gives us the Relay functions

Whilst we could make the App into a Relay Container, the App does not need the Relay data.,

We have built our stuff so that the Query we run against the side, is whatever comes after author,so that it forms out:


const AuthorQueries = {
	author: () => Relay.QL`
	query {
		author(id: $authorId)
	}`,
};

<Route
	path='/'authors/:authorId'
	component={AuthorPage}
	queries={AuthorQueries}
/>


We then go to create the minial code for AuthorPage:

export default Relay.createContainer(AuthorPage, {
	fragments: {
		author: () => Relay.QL`
		fragment on Author{
			name
			avatarUrl
			bio
			books {
				count
			}
		}`,
	},
});

There are two constraints for makign queries against something:

the fragment must be against the same object as being called, such as fragment on Author must match the Query Key name of Author

The second, is that we must put fragment on, on the relevant elemment, meaning we can only get it for example on Author, since it ends on an author

The output of running a query against Authors by id and name, we'd get the following:

query Routes($id_0:ID!){
	author(id:$id_0){
		id,
		...F0
	}
}
fragment F0 on Author {
	name,
	avatarUrl,
	bio,
	books{
		count
	},
	id
}

the Query against Routes, is the query from AuthorQueries, whilst the f0 is the Author query

We then go to change the markup of AuthorPage:

class AuthorPage extends React.Component {
	render(){
		const { author } = this.props;

		return (
			<div className='authorPage bookPage sixteen wide column'>
				<div className='spacer row' />
					<div className='ui divided items'>
						<div className='item'>
							<div className='ui'>
								<img src={author.avatarUrl}
									alt={author.name}
									className='ui medium rounded bordered image'
								/>
							</div>
							<div className='content'>
								<div className='header authorName'>
									<h1>{ author.name }</h1>
									<div className='extra'>
										<div className='ui label'>
											{ author.books.count }
											{ author.books.count > 1 ? 'Books' : 'Book' }
										</div>
									</div>
								</div>
								<div className='description'>
									<p> { author.bio } </p>
								</div>
							</div>
						</div>
					</div>
				</div>
			</div>
		);
	}
}

We now go to build the Books selection part, where we begin with Route:

The Bookspage will be our default, so we user IndexRoute helper to define this route:

	<IndexRoute
		component={BooksPage}
		queries={ViewerQueries}
	/>

Next, we go to define the Viewer, which is the current user. Normally we'd see it accept some form of token for autherization, but we ksip that here:

const ViewerQueries = {
	viewer: () => Relay.QL`query { viewer }`,
};

This page, holds two Relay containers: BooksPage and aBookItem. Let's take a look at BooksPage:

export default Relay.createContainer(BooksPage, {
	initialVariables: {
		count: 100, //initialize the count to 100
	},
	fragments: {
		viewer: () => Relay.QL`
		fragment on Viewer {
			books(first: $count){ //ask for the first 100 books
				count
				edges {
					node {
						slug
						${BookItem.getFragment('book')} //compose a fragment by getting a fragment of book
					}
				}
			}
		}
		`,
	},
});

To set teh value, we can simply use setVariables:

this.props.relay.setVariables({count: 2});

If no default value is defined, we get a uncaught error. We must, however, update our GraphQL schema if an argument/field/type was recently added.

IMPORTANT: to use a Childs relay component, we need to embed the Child's fragment in the parent query with getFragment().

Which, for instance, means that to access the books, we ahve to include the BookItem fragments of book to display books

Carrying on, what follows, is the BooksPage render():

class BooksPage extends React.Component {
	render(){
		const books = this.props.viewer.books.edges.map(this.renderbook);

		return(
			<div className='sixteen wide column'>
				<h1>JS books</h1>
				<div className='ui grid centered'>
					{ books }
				</div>
			</div>
		);
	}

	renderBook(bookEdge){
		return(
			<Link
				to={`/books/${bookEdge.node.slug}`}
				key={bookEdge.node.slug}
				className='five wide column book'
			>
				<BookItem
					book={bookEdge.node}
				/>
			</Link>
		);
	}
}


The above methods contain a wrapper that puts a Object with the iteratable book with pages to be rendered into the render call,
in renderBook. We render each bookpage, like this.

We also assign a link to the book and then populate it with the pages.

Further more, let's take a look at the Relay query for the book:

export default Relay.createContainer(BookItem,{
	fragments: {
		book: () => Relay.QL`
		fragment on Book{
			name
			slug
			tagline
			coverUrl
			pages
			description
			authors{
				count
			}
		}
		`,
	},
});

We simply query the Book for all of the relevant things, including the slug. I suspect that the slug is akin to the node node, but i am not certain
Gotta check that up unless the book explains it

And of course, the React component for the BookItem:

class BookItem extends React.Component{
	render() {
		return(
			<div className='bookItem'>
				<FancyBook book={this.props.book} //pass the props for later on 3d effects rendered in CSS

				<div className='bookMeta'> //The meta name, author count, name, tagline, description
					<div className='authors'>
						{ this.props.book.authors.count }
						{ this.props.book.authors.count > 1 ? 'Authors' : 'Author' }
					</div>
					<h2>{ this.props.book.name }</h2>
					<div className='tagline'>{ this.props.book.tagline }</div>
					<div className='description'>{ this.props.book.description }</div>
				</div>
			</div>
		);
	}
}

A rule of Thumb for Relay, is to run a relay component with it's fragment counterpart, and this allows us to allocate fragments
of child classes to parent classes where they belong, without actually passing an entire component of the thing

If we were to get a warning akin to the following: warning, js: 96 Warning: RelayContainer: component <bla> was rendered with variables
that differ from the variables used to fetch fragment <bla>. Which means that we have not included the fragment for the child properly in the parent query

Beyond this, we have data masking, which blocks out Fields of components that we did not explicitly load, to explicitly have access to a Component we have to explicitly query for it's Slug, lest we don't get it along with us.

The idea behind Masking is that we wish to seperate components and isolate them with their whole own, so that coupling does not occur and does not create dependancies in the code that would make it bug or break later on

NOTE: Masking goes both ways, which means that we can both not access them in children or in parents, unless explicitly called for.

Right now, the AuthorPage.js just includes the count, we are gonna have to include more things to direct links and keep a check of the relevant info for the book in regards to the author, as follows:

export default Relay.createContainer(AuthorPage, {
	fragments: {
		author: () => Relay.QL`
		fragments on Author{
			_id
			name
			avatarUrl
			bio
			books(first: 100){
				count
				edges {
					node{
						slug
						${BookItem.getFragment('book')}
					}
				}
			}
		}`,
	},
});

Now that we have the book, we are going to render them:

class AuthorPage extends React.Component {
	renderBook(bookEdge){
		return(
			<Link
				to={`/books/${bookEdge.node.slug}`}
				key={bookEdge.node.slug}
				className='five wide column book'
			>
				<BookItem
					book={bookEdge.node}
				/>
			</Link>
		);
	}

	render() {
		const author = this.props.author;
		const books = this.props.author.books.edges.map(this.renderBook); //The books are the edges mapped and rendered

		return(
			{/* TRUNCATEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEED */}

				<div className='sixten wide column'>
					<h1>{ author.name }&rsquo;s Books</h1>
					<div className='ui grid centered'>
						{ books }
					</div>
				</div>
			{/* FOK U */}
	);
}


Next up, is for allowing mutation. We will begin by modifying the structure of the BookPage:

export default Relay.createContainer(BookPage, {
	fragments: {
		book: () => Relay.QL`
		fragment on Book {
			id
			name
			tagline
			coverUrl
			description
			page
			authors(first: 100){
				edges{
					node{
						_id
						name
						avatarUrl
						bio
					}
				}
			}
		}`,
	},
});

The render call of the same js, BookPagereads

render(){
	const { book } = this.props;
	const authors = book.authors.edges.map(this.renderAuthor);
	return {
		<div className='bookPage sixteen wide column'>
			<div className='spacer row' />

				<div className='ui grid row'>
					<div className='six wide column'>
						<FancyBook book={book} />
					</div>

					<div className='ten wide column'>
						<div className='content ui form'>
							<h2>
								<RIEInput
									value={book.name}
									propName={'name'}
									change={this.handleBookChange}
								/>
							</h2>

							<div className='tagline hr'>
								<RIEInput
									value={book.tagline}
									propName={'tagline'}
									change={this.handleBookChange}
								/>
							</div>

							<div className='description'>
								<p>
									<RIETextArea
										value={book.description}
										propName={'description'}
										change={this.handleBookChange}
									/>
								</p>
							</div>
						</div>

						<div className='ten wide column authorSection'>
							<h2 className='hr'>Authors</h2>
							<div className='ui three column grid link cards'>
								{authors}
							</div>
						</div>
					</div>
				</div>
			</div>
		);
	}

And we then must define the handleBookChange as well:

handleBookChange(newState){
	console.log('bookChanged', newState, this.props.book);
}

NOTE: The RIEK is just a arbitrary form library.

Next up, is mutating things. Mutations in Relay work as follows:

1. Define a mutation object

2. Create an instance of said object, passing config vars 

3.Send it to Relay using Relay.Store.commitUpdate

There are 5 types of mutations in Relay:

FIELDS_CHANGE

NODE_DELETE

RANGE_ADD

RANGE_DELETE

REQUIRED_CHILDREN

Since we have a existing object, we are running a FIELDS_CHANGE

We begin by creating a subclass of Relay.Mutation and follow the following 6 steps:

1. What GraphQL Functions are we using for this mutation?

2. What variables will be used as the input to this mutation?

3. What fields does this mutation depend on in order to run properly?

4. What fields could change as a result of this mutation?

5. If everything works, what is expected to change?

6. How should Relay handle the actual response that comes back from the server?

We specify each of these things by defining a function for each one.

In the UpdateBookMutation.js, we begin by defining the UpdateBookMutation:

export default class UpdateBookMutation extends Relay.Mutation {
	getMutation(){
		return Relay.QL`mutation { updateBook }`;
	}

We define that we will use the updateBook mutation

The variables that we pass on to updateBookInput will come from function getVariables:

getVariables(){
	return {
		id: this.props.id,
		name: this.props.name,
		tagline: this.props.tagline,
		description: this.props.description,
	};
}

We then aquire fragments of the thing we wish to update:

static fragments = {
	book: () => Relay.QL`
		fragments on Book {
			id
			name
			tagline
			description
		}
	`,
}

Then, to see if the relevant values have changed, we make a "fat query", that retrieves all of the values that we thought might have changed it.

	getFatQuery(){
		return Relay.QL`
			fragment on updateBookPayload{
				changedBook
			}
		`;
	}
}

We then also run the idea of running against having a OptimisticResponse(){}, which is, as it sounds, a response of what might have changed:

getOptimisticResponse(){
	const { book, id, name, tagline, description } = this.props;

	const newBook = Object.assign({}, book, { id, name, tagline, description });

	const optimisticResponse = {
		changedBook: newBook,
	};
	console.log('optimisticResponse', optimisticResponse);
	return optimisticResponse;
}

The above converges two objects into one, making them into one that look like it the one we were to update,
meaning we can return it and apply it without making any network call. Meaning we have made a clever fooling of the user.

If the consistency trade-off is worth it, it increases responsiveness feel of your APp.

We also, tho, have to prepare Relay for the actual return of the updated Object, as follows:

getConfigs(){
	return [ {
		type: 'FIELDS_CHANGE',
		fieldIDs: {
			changedBook: this.props.id,
		},
	} ];
}

Here is the BookPage query that we're adding in the mutation's fragments:

 fragments: {
 	book: () => Relay.QL`
 	fragment on Book {
 		id
 		name
 		tagline
 		coverUrl
 		description
 		pages
 		authors(first: 100){
 			edges{
 				node{
 					_id
 					name
 					avatarUrl
 					bio
 				}
 			}
 		}
 		${UpdateBookMutation.getFragment('book')}
 	}`,
 },

 If we get the following error:

 Warning: RelayMutation: Expected prop 'book' supplied to 'UpdateBookMutation' to be data fetched by Relay. This is likely an error unless you are
 purposely passing in mock data that conforms to the shape of this mutation's fragment

 We then define the actual mutation:

handleBookChange(newState){
	console.log('bookChanged', newState, this.props.book); //print out the new state of the book being cvhanged
	const book = Object.assign({}, this.props.book, newState); //Make a book object
	Relay.Store.commmitUpdate( //Commit the update against the Relay store
		new UpdateBookMutation({ //Create the mtuation object
			id: book.id, //props for the thing
			name: book.name,
			tagline: book.tagline,
			description: book.description,
			book: this.props.book,
		})
	);
}

Next up, is React Native, which is React for iPhones and Androids, Where we take the components and map them to the iOS's UIView or Android's android view (akin to Normal React, just passing to UIView or Androids android view instead) (NOTE: It's React for building Android/iPhone apps, not web apps)

We begin by bootstrapping our app:

npm install --global react-native-cli

To secure that it is installed, we run a test:

which react-native

To create a new React-Native project:

react-native init <name> (in this case, we run with Playground)

In React Native, the system is rendered in Layers, instead of URLs. And we route to these Layers, as follows:

export const Routes = (
	<Router history={hashHistory}>
		<Router path='/' component={Main}>
			<IndexRoute component={Home} />
			<Route
				path='players/:playerOne?'
				component={PromptContainer}
			/>
			<Route
				path='battle'
				component={ConfirmBattleContainer}
			/>
			<Route
				path='results'
				component={ResultsContainer}
			/>
		</Route>
	</Router>
);

Basically, the routes are as per Stacks. They technically use pop and push, push being navigating to a view, pop being moving away

For every nesting of navigating to views, the stack increases in size by one, since it functions like an array of Views.

In React Native, we also run with animations of transitions between scenes, meaning we have one of three, usually:

Right to Left

Left to Right

Bottom to Top

Generally we do on iOS:

from the right if in the same hierachy

from bottom if modal and other hierachy

left to right when pushing view

pop right to left when after leaving a previous route

Android is more about elevation change.

In React Native, we run with a navigator, to route. it is, however, just a React component.

It accepts two props:

configureScene() //Responsible for what transition type to make

and

renderScene() //Responsible for rendering

Both are called, when routes are changed.

Generally, our App might look like:

export default class App extends Component{
	configureScene(route){
		//Handle config scene
	}

	renderScene(route, navigator){
		//handle rendering
	}
	render(){
		return(
			<Navigator
				renderScene={this.renderScene} //what ui or component to render and transition into a new scene
				configureScene={this.configureScene}
			/>
		);
	}
}

renderScene might look as follows:

renderScene(route){
	if (route.home === true){
		return <HomeContainer />
	} else if (route.notifications === true){
		return <NotificationsContainer />
	} else {
		return <FooterTabsContainer />
	}
}

The way that we navigate, is actually by a stack object, called navigator.

And we pass it down as a prop:

renderScene(route, navigator){
	if (route.home === true){
		return <HomeContainer navigator={navigator} />
	} else if (route.notifications === true) {
		return <NotificationsContainer navigator={navigator} />
	} else {
		return <FooterTabsContainer navigator={navigator} />
	}
}

Now all the containers have the navigator available, meaning they can push things based on interaction:

handleToNotifications(){
	this.props.navigator.push({
		notifications: true, //Notifies to render the NotificationsContainer next
	});
}

We then update the configureScene(route){
	if (route.home === true){
		//Transition to HomeContainer
	} else if (route.notifications === true) {
		//Transitioning to NotificationsContainer
	} else {
		// Showing FooterTabsContainer
	}
}

In here, we then define what kind of a transition we wish to have, to which we have 10:

Navigator.SceneConfigs.PushFromRight(default)
Navigator.SceneConfigs.FloatFromRight
Navigator.SceneConfigs.FloatFromLeft
Navigator.SceneConfigs.FloatFromBottom
Navigator.SceneConfigs.FloatFromBottomAndroid
Navigator.SceneConfigs.FadeAndroid
Navigator.SceneConfigs.HorizontalSwipeJump
Navigator.SceneConfigs.HorizontalSwipeJumpFromRight
Navigator.SceneConfigs.VerticalUpSwipeJump
Navigator.SceneConfigs.VerticalDownSwipeJump

An example of running every transition to be FloatFromRight, only choosing FloatFromBottom for notifications:

	configureScene(route){
		if (route.notifications === true) {
			return Navigator.SceneConfigs.FloatFromBottom;
		}

		return Navigator.SceneConfigs.FloatFromRight;
	}

	renderScene(route, navigator){
		if (route.home === true){
			return <HomeContainer navigator={navigator} />
		} else if (route.notifications === true) {
			return <NotificationsContainer navigator={navigator} />
		} else {
			return <FooterTabsContainer navigator={navigator} />
		}
	}

	render(){
		return(
			<Navigator
				renderScene={this.renderScene}
				configureScene={this.configureScene}
			/>
		);
	}

To define what platform we are on, we can import Platform and use that:

import { Platform } from 'react-native';

The Platform object has a attribute called OS, which has a string that shows which platform the app is currently using. For ios, the string is 'ios', android is 'android':

In the same js as index.js:

//re-write it

configureScene(route){
	if (route.notifications === true){
		if (Platform.OS === 'android'){
			return Navigator.SceneConfigs.FloatFromBottomAndroid;
		} else {
			return Navigator.SceneConfigs.FloatFromBottom;
		}
	}

	return Navigator.SceneConfigs.FloatFromRight;
}

renderScene(route, navigator){
	if (route.home === true){
		return <HomeContainer navigator={navigator} />
	} else if (route.notifications === true){
		return <NotificationsContainer navigator={navigator} />
	} else {
		return <FooterTabsContainer navigator={navigator} />
	}
}

render(){
	return (
		<Navigator
			renderScene={this.renderScene}
			configureScene={this.configureScene}
		/>
	);
}

The difference between Native and Web is that the components differ, slightly. However, we can create our own.

The ones we have (we can get more), are, however:

<View /> //navigates to UIView, akin to <div /> on the web

<Text /> //Text must be wrapped in this, so, <Text>some shit</Text>

<Image /> //images, any, really

<TextInput /> //Text input, accepts onChangeText() as prop, updates on input change

Then come the touch handlers:

<TouchableHighlight /> //decreases opacity of component, will allow underlaying color to shine through

<TouchableOpacity /> //decreases opacity, but does not display an underlay color

<TouchableWithoutFeedback /> //invokes when pressed, but gives no feedback on said interaction, use Sparingly to avoid confusion

<ActivityIndicator /> //Default loading indicator. Works on different platforms due to being JS. Styles after platform.

<WebView /> //Allows to display some Web Content

<ScrollView /> //allows scrollable view. Not very performant, keep to <ListView />

<ListView /> //performance-focused option for rendering long lists of data. Unlike <ScrollView />, <ListView /> only renders current Elements on the screen.

A showcasing of differences between <ListView /> and <ScrollView />, follows:

//Web version of twitterish

import React, { PropTypes } from 'react';

Feed.propTypes = {
	tweets: PropTypes.arrayOf(PropTypes.shape({
		name: PropTypes.string.isRequired,
		user_id: PropTypes.string.isRequired,
		avatar: PropTypes.string.isRequired,
		text: PropTypes.string.isRequired,
		numberOfFavorites: PropTypes.number.isRequired,
		numberOfRetweets: PropTypes.number.isRequired,
	})).isRequired,
};

function Feed ({ tweets }) {
	return (
		<div>
			{tweets.map((tweet) => (
				<div>
					<div>
						<img alt="tweet" src={tweet.avatar} />
						<span>{tweet.name}</span>
					</div>
					<p>{tweet.text}</p>
					<div>
						<div>Favs: {tweet.numberOfFavorites}</div>
						<div>RTs: {tweet.numberOfRetweets}</div>
					</div>
				</div>
			)
			)}
		</div>
	);
}

Just a stateless functional component here that displays some UI elements for each tweet.

Now, for the ScrollView version:

import React, { PropTypes } from 'react';
import { View, Text, ScrollView, Image } from 'react-native';

Feed.propTypes = {
	tweets: PropTypes.arrayOf(PropTypes.shape({
		name: PropTypes.string.isRequired,
		user_id: PropTypes.string.isRequired,
		avatar: PropTypes.string.isRequired,
		text: PropTypes.string.isRequired,
		numberOfFavorites: PropTypes.number.isRequired,
		numberOfRetweets: PropTypes.number.isRequired,
	})).isRequired,
};

function Feed ({ tweets }){
	return(
		<ScrollView>
			{tweets.map((tweet) => (
				<View>
					<View>
						<Img src={tweet.avatar} />
						<Text>{tweet.name}</Text>
					</View>
					<Text>{tweet.text}</Text>
					<View>
						<Text>Favs: {tweet.numberOfFavorites}</Text>
						<Text>RTs: {tweet.numberOfRetweets}</Text>
					</View>
				</View>
			)
			)}
		</ScrollView>
	);
}

The difference is tiny, it's justb asically containers that are different

Now, to use the ListView, we use the following code:

import React, { PropTypes, Component } from 'react';
import { View, Text, ScrollView, Image, ListView } from 'react-native';

class Feed extends Component {
	static props = {
		tweets: PropTypes.arrayOf(PropTypes.shape({
			name: PropTypes.string.isRequired,
			user_id: PropTypes.string.isRequired,
			avatar: PropTypes.string.isRequired,
			text: PropTypes.string.isRequired,
			numberOfFavorites: PropTypes.number.isRequired,
			numberOfRetweets: PropTypes.number.isRequired,
		})).isRequired,
	}

	constructor(props){
		super(props);

		this.ds = new ListView.DataSource({
			rowHasChanged: (r1, r2) => r1 !== r2, //Automatically assign that a rowHasChanged if r1 does not equal to r2, meaning it forces a re-render on only changed items.
		});

		this.state = {
			dataSource: this.ds.cloneWithRows(this.props.tweets), //clonse the datasource with rows
		};
	}

	componentWillRecieveProps(nextProps){
		if(nextProps.tweets !== this.props.tweets){
			this.setState({
				dataSource: this.ds.cloneWithRows(nextProps.tweets), //dataSource must be updated to keep track of relevant data in dataSource
			});
		}
	}

	renderRow = ({ tweet }) => {
		return(
			<View>
				<View>
					<Image src={tweet.avatar} />
					<Text>{tweet.name}</Text>
				</View>
				<Text>{tweet.text}</Text>
				<View>
					<Text>Favs: {tweet.numberOfFavorites}</Text>
					<Text>RTs: {tweet.numberOfRetweets}</Text>
				</View>
			</View>
		);
	}
	render(){
		return (
			<ListView
				renderRow={this.renderRow}
				dataSource={this.state.dataSource}
			/>
		);
	}
}

Since it's a listview with live data, we keep a state to track it, as well as keep a listen for the updating through shouldComponentUpdate() lifecycle hook.

Two vital things for a ListView, is:

ListView.DataSource instance

and

renderRow() function defined

NOTE: The reason we run the clone, is due to dataSource containing immutables to begin with.

ListView also defines 3 other functions:

renderSeperator()

renderHeader()

renderFooter()

if we wish to render a element without a border, we can do so with renderSeperator, as it won't add one to the last element:

	renderSeperator = (sectionId, rowId) => { //Returns a seperator object to be rendered
		return (
			<View key={rowId} style={styles.seperator} />
		);
	}

	render(){
		return(
			<ListView
				renderRow={this.renderRow}
				dataSource={this.state.dataSource}
				renderSeperator={this.renderSeperator}
			/>
		);
	}

if we want a header, we can go with renderHeader():

renderHeader = () => <SearchBar />

render(){
	return(
		<ListView
			renderRow={this.renderRow}
			dataSource={this.state.dataSource}
			renderHeader={this.renderHeader}
		/>
	);
}

And to add a footer:

renderFooter = () => <ShowMoreTweets />

render(){
	return(
		<ListView
			renderRow={this.renderRow}
			dataSource={this.state.dataSource}
			renderFooter={this.renderFooter}
		/>
	);
}

Styling in React native is done in JS, meaning we have to run with the fact of designating CSS objects for styling:

<View style={{ backgroundColor: 'green', padding: 10 }}>
	<Text style={{ color: 'blue', fontSize: 25 }}>
		Hello World
	</Text>
</View>

We can also compile different styles on top of each other:

const ContainerComponent = () => {
	const getBackgroundColor = () => {
		return { backgroundColor: 'red' }; 
	};

	return (
		<View style={[ getBackgroundColor(), { padding: 10 } ]}>
			<Text style={{ color: 'blue', fontSize: 25 }}>
				Hello World
			</Text>
		</View>
	);
};

If we want more props for a component, we can use the helper class called StyleSheet.

The StyleSheet object has a method called create() that accepts a object that contains the list of our styles.

We can thus use the style that create() returns, instead of doing raw styles. An example follows:

const styles = StyleSheet.create({ //By defining a styles object, we can access the attributes later to apply them to different elements
	container: {
		padding: 10,
	},
	containerText: {
		color: 'blue',
		fontSize: 20,
	},
});

class ExampleComponent extends Component {
	getBackgroundColor(){
		return {
			backgroundColor: 'yellow'
		};
	}

	render() {
		return(
			<View style={[
				this.getBackgroundColor(),
				styles.container
			]}>
				<Text style={styles.containerText}>
					Hello World
				</Text>
			</View>
		);
	}
}

StyleSheet also gives us some performance gains in comparison to applying an object directly.

Another great technology for handling CSS, is Flexbox. Which allows us to define the parent element to be a Flexbox, that accounts for something to be
very flexible and allows dynamic displaying of boxes. Which means that we can get away without having to do floats and positions of elements, we just 
have to declare the parent element to be responsible as in being a flexbox container.

Flexbox is built on two axises, The main axis (up and down), and Cross Axis (left and right)

Main axis is up to down, Cross axis is left to right

The rest of flexbox, is alignments, positions, stretch, spread, shrink, center and wrap child elements along main and cross axises.

We can change the default flex-direction of properties to specify them, it accepts one of two:

column

row

If we define the prop to be row, the cross axis switches to be from left to right, to top to down and column inverts as well

We can then further define the props to align, by virtue of the justifyContent prop, it accepts 1 of 5 values:

flex-start

center

flex-end

space-around

space-between

We begin by making example code of structure layout:

import React, { Component } from 'react';
import { StyleSheet, Text, View } from 'react-native';

export class FlexboxExamples extends Component{
	render(){
		return(
			<View style={ styles.container }>
				<View style={ styles.box } />
				<View style={ styles.box } />
				<View style={ stlyes.box } />
			</View>
		);
	}

	const styles = StyleSheet.create({
		container: {
			flex: 1,
		},
		box: {
			height: 50,
			width: 50,
			backgroundColor: '#e76e93',
			margin: 10,
		},
	});

	export default FlexboxExamples;
}

if we wish to align the downwards on a line, we can do flex-start:

container: {
	flex: 1;
	justifyContent: 'flex-start';
}

if we were to set it to center, we would have the elements align against the center, and flex-end would have htem line up with the end part.

We could also set it to be space-between, which puts a even space between each.

We could also set it to space-around, which puts a margin around them

If we change the flexDirection to row, we would have row lineup, as expected.

To align the items in question, we can use alignItems to one of the following:

flex-start //Alligns to start of flexbox

center //center of

flex-end //End

stretch //Stretches over entire box, if width is not specified

Note: The position is always relative to the flexbox they are in.

If we wish to modify the "amount of times the size of a element" comparedly to other, just assign the flex to be the multiplier, 1 is the natural size,
2 is double the size etc.

0 means to just use the specified width and height.

To align a specific element outside of the normal ordering, we could just add alignSelf to the component object:

<View style={[ styles.box, { alignSelf: 'flex-end' } ]} />

The two kinds of props in React native can be summed up to defaults and excluded props.

Defaults are applied to everyone, excluded props are props that exist in CSS/Flexbox that don't exist in React Native's implementation.

The default ones:

box-sizing: border-box; //elements specified height and width are not affected by paddding or margin
position: relative; 

display: flex;
flex-direction: column; //Defaults to column
align-items: stretch; //default align is stretch
flex-shrink: 0;
align-content: flex-start;

border: 0 solid black;
margin: 0;
padding: 0;
min-width: 0;


The rest of CSS applies as per normal.

In react native, we just fetch for HTTP requests, fetch uses promises, btw

To deal with asynch fetches, we could run callbacks (a method that returns upon completion):

function getCurrentTime(callback){
	//Get the time from an API 
	return setTimeout(function(){
		var currentTime = new Date();
		callback(currentTime); //make a callback after 2 seconds 
	}, 2000);
}
getCurrentTime(function(currentTime){
	//do something
});

An example of running a promise in react native:

function getCurrentTime(onSuccess, onFail){
	return new Promise((resolve, reject) => { //Return a promise object
		setTimeout(function(){ //Set a timeout ot see if we resolved it or not
			var didSucceed = Math.random() >= 0.5;
			didSucceed ? resolve(new Date()) : reject('error');
		}, 2000);
	})
}
getCurrentTime() //Perform the call to the promise
	.then(currentTime => getCurrentTime()) //assign currenTime
	.then(currentTime => { //log out that currentTime is something
		console.log("some shit");
		return true;
	})
	.catch(err => console.log("dakka" + err)) //otherwise, catch the error

An example of modifying the getCurrentTime call:

getCurrentTime()
	.then(currenTime => getCurrentTime())
	.then(currentTime => {
		return 'it is now: ' + currentTime;
	})

	//this will log "it is now: " and the time
	.then(currentTimeMessage => console.log(currentTimeMessage))
	.catch(err => console.log('There was an error:' + err))


A promise only has three states:

pending

fulfilled(resolved)

rejected(error)

A function can only be resolved or rejected once.

An example of a promise that triggers a resolve if completed:

var promise = new Promise(function(resolve, reject){
	resolve(true);
})
promise.then(bool => console.log('Bool is true'))

An example of fetching users from a gitHub with a fetch that accepts a URL and returns a promise, when resolved, has the response:

const baseUrl = 'https://api.github.com';

export const getGithubUsers = ({ offset }) => {
	return fetch(`${baseUrl}/users?since=${offset}`)
			.then(response => response.json())
			.catch(console.warn);
};

If we wanted to run some gists on the Github, we could include that as well: //a gist is a code snipped with git revision control

export const makeGist = (
	activity,
	{ description = '', isPublic = true } = {} //make the gist public, can be hidden
	) => fetch(`${baseUrl}/gists`, { //run the object into fetch, call it activity and assign it to be a object
		method: 'POST', //run it with POST
		body: JSON.stringify({ //stringify the body with JSON
			files: { //the files inside
				'activity.json':{ //assign the acitivty
					content: JSON.stringify(activity), //The content of the activity is the content JSON stringified
				},
			},
			description, //The description
			public: isPublic, //If it is public
		}),
	})
	.then(response => response.json()); //then proses the response to JSON()


We can debug in Native, with CMD + D or CTRL + D on a PC, for iOS, CMD + M  or CTRL + M on a PC, for Android

This will allow us to debug the JS remotely, through Chrome.

